import {
  InputText_default,
  Resize_default,
  RouteEvents_default,
  SetProperties_default,
  SetValue_default,
  StopPropagationTouchEvents_default
} from "./chunk-L3QQAAB7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/phaser3-rex-plugins/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/phaser3-rex-plugins/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE2(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE2(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/phaser3-rex-plugins/templates/ui/ObjectFactory.js
var ObjectFactory = class _ObjectFactory {
  constructor(scene) {
    this.scene = scene;
    scene.events.once("destroy", this.destroy, this);
  }
  destroy() {
    this.scene = null;
  }
  static register(type, callback) {
    _ObjectFactory.prototype[type] = callback;
  }
};
var ObjectFactory_default = ObjectFactory;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/texture/SetGetFrameNameCallback.js
var SetGetFrameNameCallback = function(callback) {
  if (callback === void 0) {
    callback = DefaultGetFrameNameCallback;
  }
  this.getFrameNameCallback = callback;
  return this;
};
var DefaultGetFrameNameCallback = function(colIndex, rowIndex, baseFrameName) {
  if (baseFrameName === "__BASE") {
    return `${colIndex},${rowIndex}`;
  } else {
    return `${baseFrameName}:${colIndex},${rowIndex}`;
  }
};
var SetGetFrameNameCallback_default = SetGetFrameNameCallback;

// node_modules/phaser3-rex-plugins/plugins/utils/object/DeepClone.js
function DeepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => DeepClone(item));
  }
  if (obj instanceof Date) {
    return new Date(obj);
  }
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }
  if (Object.getPrototypeOf(obj) !== Object.prototype) {
    return obj;
  }
  const clonedObj = {};
  for (let key2 in obj) {
    if (obj.hasOwnProperty(key2)) {
      clonedObj[key2] = DeepClone(obj[key2]);
    }
  }
  return clonedObj;
}
var DeepClone_default = DeepClone;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/texture/SetBaseTexture.js
var SetBaseTexture = function(key2, baseFrameName, columns, rows) {
  if (Array.isArray(baseFrameName)) {
    rows = columns;
    columns = baseFrameName;
    baseFrameName = void 0;
  }
  if (baseFrameName == null) {
    baseFrameName = "__BASE";
  }
  if (typeof columns === "number" && arguments.length >= 6) {
    columns = [arguments[2], void 0, arguments[3]];
    rows = [arguments[4], void 0, arguments[5]];
  } else if (columns === void 0 && rows === void 0 && this.columns.data !== void 0 && this.rows.data !== void 0) {
    columns = this.columns.data;
    rows = this.rows.data;
  } else {
    columns = DeepClone_default(columns);
    rows = DeepClone_default(rows);
  }
  this.textureKey = key2;
  this.baseFrameName = baseFrameName;
  this.columns.data = columns;
  this.columns.count = columns ? columns.length : 0;
  this.columns.stretch = 0;
  this.columns.minWidth = 0;
  this.columns.scale = 1;
  this.rows.data = rows;
  this.rows.count = rows ? rows.length : 0;
  this.rows.stretch = 0;
  this.rows.minHeight = 0;
  this.rows.scale = 1;
  var texture = this.scene.sys.textures.get(key2);
  if (!texture) {
    this.clear();
    return this;
  }
  if (!columns || !rows) {
    this.clear();
    return this;
  }
  var baseFrame = texture.get(baseFrameName);
  var remainderTextureWidth = baseFrame.width;
  var unknownColumnWidthCount = 0;
  for (var i = 0, cnt = columns.length; i < cnt; i++) {
    if (columns[i] === void 0) {
      unknownColumnWidthCount++;
    } else if (typeof columns[i] === "number") {
      remainderTextureWidth -= columns[i];
    } else {
      remainderTextureWidth -= columns[i].width;
    }
  }
  var unknownColumnWidth = unknownColumnWidthCount > 0 ? remainderTextureWidth / unknownColumnWidthCount : 0;
  var remainderTextureHeight = baseFrame.height;
  var unknownRowHeightCount = 0;
  for (var i = 0, cnt = rows.length; i < cnt; i++) {
    if (rows[i] === void 0) {
      unknownRowHeightCount++;
    } else if (typeof rows[i] === "number") {
      remainderTextureHeight -= rows[i];
    } else {
      remainderTextureHeight -= rows[i].width;
    }
  }
  var unknownRowHeight = unknownRowHeightCount ? remainderTextureHeight / unknownRowHeightCount : 0;
  var row, col, rowHeight, colWidth, frameName;
  var offsetX = 0, offsetY = 0;
  for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
    if (rows[j] === void 0) {
      rows[j] = unknownRowHeight;
    }
    if (typeof rows[j] === "number") {
      rows[j] = {
        height: rows[j],
        stretch: j % 2
      };
    }
    row = rows[j];
    rowHeight = row.height;
    this.rows.stretch += row.stretch | 0;
    this.rows.minHeight += row.stretch > 0 ? 0 : rowHeight;
    offsetX = 0;
    for (var i = 0, icnt = columns.length; i < icnt; i++) {
      if (columns[i] === void 0) {
        columns[i] = unknownColumnWidth;
      }
      if (typeof columns[i] === "number") {
        columns[i] = {
          width: columns[i],
          stretch: i % 2
        };
      }
      col = columns[i];
      colWidth = col.width;
      if (j === 0) {
        this.columns.stretch += col.stretch | 0;
        this.columns.minWidth += col.stretch > 0 ? 0 : colWidth;
      }
      if (colWidth >= 1 && rowHeight >= 1) {
        frameName = this.getFrameNameCallback(i, j, baseFrameName);
        var frameNameType = typeof frameName;
        if (frameNameType === "string" || frameNameType === "number") {
          texture.add(
            frameName,
            0,
            offsetX + baseFrame.cutX,
            offsetY + baseFrame.cutY,
            colWidth,
            rowHeight
          );
        }
      } else {
      }
      offsetX += colWidth;
    }
    offsetY += rowHeight;
  }
  this.updateTexture();
  return this;
};
var SetBaseTexture_default = SetBaseTexture;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/texture/UpdateTexture.js
var UpdateTexture = function() {
  this.clear();
  if (this.textureKey === void 0) {
    return this;
  }
  var texture = this.scene.sys.textures.get(this.textureKey);
  if (!texture) {
    return this;
  }
  var minWidth = this.columns.minWidth * this.maxFixedPartScaleX;
  var minHeight = this.rows.minHeight * this.maxFixedPartScaleY;
  var stretchWidth = this.width - minWidth;
  var stretchHeight = this.height - minHeight;
  var fixedPartScaleX = stretchWidth >= 0 ? this.maxFixedPartScaleX : this.width / minWidth;
  var fixedPartScaleY = stretchHeight >= 0 ? this.maxFixedPartScaleY : this.height / minHeight;
  if (this.preserveRatio) {
    var minScale = Math.min(fixedPartScaleX, fixedPartScaleY);
    if (fixedPartScaleX > minScale) {
      var compensationWidth = (fixedPartScaleX - minScale) * minWidth;
      if (stretchWidth >= 0) {
        stretchWidth += compensationWidth;
      } else {
        stretchWidth = compensationWidth;
      }
      fixedPartScaleX = minScale;
    }
    if (fixedPartScaleY > minScale) {
      var compensationHeight = (fixedPartScaleY - minScale) * minHeight;
      if (stretchHeight >= 0) {
        stretchHeight += compensationHeight;
      } else {
        stretchHeight = compensationHeight;
      }
      fixedPartScaleY = minScale;
    }
  }
  this.columns.scale = fixedPartScaleX;
  this.rows.scale = fixedPartScaleY;
  var proportionWidth;
  if (stretchWidth > 0) {
    proportionWidth = this.columns.stretch > 0 ? stretchWidth / this.columns.stretch : 0;
  } else {
    proportionWidth = 0;
  }
  var proportionHeight;
  if (stretchHeight > 0) {
    proportionHeight = this.rows.stretch > 0 ? stretchHeight / this.rows.stretch : 0;
  } else {
    proportionHeight = 0;
  }
  var frameName, col, row, colWidth, rowHeight;
  var offsetX = 0, offsetY = 0;
  var imageType;
  this._beginDraw();
  for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
    row = this.rows.data[j];
    rowHeight = row.stretch === 0 ? row.height * fixedPartScaleY : proportionHeight * row.stretch;
    offsetX = 0;
    for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
      col = this.columns.data[i];
      colWidth = col.stretch === 0 ? col.width * fixedPartScaleX : proportionWidth * col.stretch;
      frameName = this.getFrameNameCallback(i, j, this.baseFrameName);
      if (texture.has(frameName) && colWidth > 0 && rowHeight > 0) {
        if (row.stretch === 0 && col.stretch === 0) {
          imageType = 0;
        } else {
          if (this.getStretchMode(i, j) === 0) {
            imageType = 0;
          } else {
            imageType = 1;
          }
        }
        if (imageType === 0) {
          this._drawImage(
            this.textureKey,
            frameName,
            offsetX,
            offsetY,
            colWidth,
            rowHeight
          );
        } else {
          this._drawTileSprite(
            this.textureKey,
            frameName,
            offsetX,
            offsetY,
            colWidth,
            rowHeight
          );
        }
      }
      offsetX += colWidth;
    }
    offsetY += rowHeight;
  }
  this._endDraw();
};
var UpdateTexture_default = UpdateTexture;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/texture/SetStretchMode.js
var IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
var GetValue = Phaser.Utils.Objects.GetValue;
var SetStretchMode = function(mode) {
  if (IsPlainObject(mode)) {
    this.stretchMode.edge = parseMode(GetValue(mode, "edge", 0));
    this.stretchMode.internal = parseMode(GetValue(mode, "internal", 0));
  } else {
    mode = parseMode(mode);
    this.stretchMode.edge = mode;
    this.stretchMode.internal = mode;
  }
  return this;
};
var parseMode = function(mode) {
  if (typeof mode === "string") {
    mode = EXTENDMODE[mode];
  }
  return mode;
};
var EXTENDMODE = {
  scale: 0,
  repeat: 1
};
var SetStretchMode_default = SetStretchMode;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/utils/IsEdge.js
var IsEdge = function(colIndex, rowIndex) {
  return colIndex === 0 || colIndex === this.columns.count - 1 || rowIndex === 0 || rowIndex === this.rows.count - 1;
};
var IsEdge_default = IsEdge;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/texture/GetStretchMode.js
var GetStretchMode = function(colIndex, rowIndex) {
  return IsEdge_default.call(this, colIndex, rowIndex) ? this.stretchMode.edge : this.stretchMode.internal;
};
var GetStretchMode_default = GetStretchMode;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/texture/SetPreserveRatio.js
var SetPreserveRatio = function(enable) {
  if (enable == void 0) {
    enable = true;
  }
  this.preserveRatio = enable;
  return this;
};
var SetPreserveRatio_default = SetPreserveRatio;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/texture/SetMaxFixedPartScale.js
var SetMaxFixedPartScale = function(scaleX, scaleY) {
  if (scaleY === void 0) {
    scaleY = scaleX;
  }
  this.maxFixedPartScaleX = scaleX;
  this.maxFixedPartScaleY = scaleY;
  return this;
};
var SetMaxFixedPartScale_default = SetMaxFixedPartScale;

// node_modules/phaser3-rex-plugins/plugins/utils/object/NOOP.js
var NOOP = function() {
};
var NOOP_default = NOOP;

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/Methods.js
var Methods_default = {
  _beginDraw: NOOP_default,
  _drawImage: NOOP_default,
  _drawTileSprite: NOOP_default,
  _endDraw: NOOP_default,
  setGetFrameNameCallback: SetGetFrameNameCallback_default,
  setBaseTexture: SetBaseTexture_default,
  updateTexture: UpdateTexture_default,
  setStretchMode: SetStretchMode_default,
  getStretchMode: GetStretchMode_default,
  setPreserveRatio: SetPreserveRatio_default,
  setMaxFixedPartScale: SetMaxFixedPartScale_default
};

// node_modules/phaser3-rex-plugins/plugins/utils/ninepatch/NinePatch.js
var IsPlainObject2 = Phaser.Utils.Objects.IsPlainObject;
var GetValue2 = Phaser.Utils.Objects.GetValue;
var NinePatchBase = function(GOClass, type) {
  class NinePatch3 extends GOClass {
    constructor(scene, x, y, width, height, key2, baseFrame, columns, rows, config) {
      if (IsPlainObject2(x)) {
        config = x;
        x = GetValue2(config, "x", 0);
        y = GetValue2(config, "y", 0);
        width = GetValue2(config, "width", 1);
        height = GetValue2(config, "height", 1);
        key2 = GetValue2(config, "key", void 0);
        baseFrame = GetValue2(config, "baseFrame", void 0);
        columns = GetValue2(config, "columns", void 0);
        rows = GetValue2(config, "rows", void 0);
      } else if (IsPlainObject2(width)) {
        config = width;
        width = GetValue2(config, "width", 1);
        height = GetValue2(config, "height", 1);
        key2 = GetValue2(config, "key", void 0);
        baseFrame = GetValue2(config, "baseFrame", void 0);
        columns = GetValue2(config, "columns", void 0);
        rows = GetValue2(config, "rows", void 0);
      } else if (IsPlainObject2(key2)) {
        config = key2;
        key2 = GetValue2(config, "key", void 0);
        baseFrame = GetValue2(config, "baseFrame", void 0);
        columns = GetValue2(config, "columns", void 0);
        rows = GetValue2(config, "rows", void 0);
      } else if (IsPlainObject2(baseFrame)) {
        config = baseFrame;
        baseFrame = GetValue2(config, "baseFrame", void 0);
        columns = GetValue2(config, "columns", void 0);
        rows = GetValue2(config, "rows", void 0);
      } else if (Array.isArray(baseFrame)) {
        config = rows;
        rows = columns;
        columns = baseFrame;
        baseFrame = GetValue2(config, "baseFrame", void 0);
      } else if (IsPlainObject2(columns)) {
        config = columns;
        columns = GetValue2(config, "columns", void 0);
        rows = GetValue2(config, "rows", void 0);
      }
      if (baseFrame === void 0) {
        baseFrame = GetValue2(config, "frame", void 0);
      }
      if (columns === void 0) {
        var leftWidth = GetValue2(config, "leftWidth", void 0);
        var rightWidth = GetValue2(config, "rightWidth", void 0);
        if (leftWidth !== void 0 && rightWidth !== void 0) {
          columns = [leftWidth, void 0, rightWidth];
        }
      }
      if (rows === void 0) {
        var topHeight = GetValue2(config, "topHeight", void 0);
        var bottomHeight = GetValue2(config, "bottomHeight", void 0);
        if (topHeight !== void 0 && bottomHeight !== void 0) {
          rows = [topHeight, void 0, bottomHeight];
        }
      }
      super(scene);
      this.type = type;
      this.setPosition(x, y).setSize(width, height).setOrigin(0.5, 0.5);
      this.columns = {};
      this.rows = {};
      this.stretchMode = {};
      this._tileSprite = void 0;
      this._image = void 0;
      this.setGetFrameNameCallback(GetValue2(config, "getFrameNameCallback", void 0));
      this.setStretchMode(GetValue2(config, "stretchMode", 0));
      this.setPreserveRatio(GetValue2(config, "preserveRatio", true));
      var maxFixedPartScale = GetValue2(config, "maxFixedPartScale", 1);
      var maxFixedPartScaleX = GetValue2(config, "maxFixedPartScaleX", maxFixedPartScale);
      var maxFixedPartScaleY = GetValue2(config, "maxFixedPartScaleY", void 0);
      this.setMaxFixedPartScale(maxFixedPartScaleX, maxFixedPartScaleY);
      this.setBaseTexture(key2, baseFrame, columns, rows);
    }
    get minWidth() {
      return this.columns.minWidth;
    }
    get minHeight() {
      return this.rows.minHeight;
    }
    get fixedPartScaleX() {
      return this.columns.scale;
    }
    get fixedPartScaleY() {
      return this.rows.scale;
    }
    resize(width, height) {
      if (this.width === width && this.height === height) {
        return this;
      }
      if (super.resize) {
        super.resize(width, height);
      } else {
        super.setSize(width, height);
      }
      this.updateTexture();
      return this;
    }
    get leftWidth() {
      return this.columns.data[0];
    }
    get rightWidth() {
      return this.columns.data[this.columns.count - 1];
    }
    get topHeight() {
      return this.rows.data[0];
    }
    get bottomHeight() {
      return this.rows.data[this.rows.count - 1];
    }
  }
  Object.assign(
    NinePatch3.prototype,
    Methods_default
  );
  return NinePatch3;
};
var NinePatch_default = NinePatchBase;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsGame.js
var GameClass = Phaser.Game;
var IsGame = function(object) {
  return object instanceof GameClass;
};
var IsGame_default = IsGame;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsSceneObject.js
var SceneClass = Phaser.Scene;
var IsSceneObject = function(object) {
  return object instanceof SceneClass;
};
var IsSceneObject_default = IsSceneObject;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetGame.js
var GetGame = function(object) {
  if (object == null || typeof object !== "object") {
    return null;
  } else if (IsGame_default(object)) {
    return object;
  } else if (IsGame_default(object.game)) {
    return object.game;
  } else if (IsSceneObject_default(object)) {
    return object.sys.game;
  } else if (IsSceneObject_default(object.scene)) {
    return object.scene.sys.game;
  }
};
var GetGame_default = GetGame;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/rendertexture/utils/GetStampGameObject.js
var GameObjectClasses = Phaser.GameObjects;
var GameObjects = void 0;
var GetStampGameObject = function(gameObject2, className) {
  if (!GameObjects) {
    GameObjects = {};
    GetGame_default(gameObject2).events.once("destroy", function() {
      for (var name2 in GameObjects) {
        GameObjects[name2].destroy();
      }
      GameObjects = void 0;
    });
  }
  if (!GameObjects.hasOwnProperty(className)) {
    var scene = GetGame_default(gameObject2).scene.systemScene;
    var gameObject2 = new GameObjectClasses[className](scene);
    gameObject2.setOrigin(0);
    GameObjects[className] = gameObject2;
  }
  return GameObjects[className];
};
var GetStampGameObject_default = GetStampGameObject;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/rendertexture/utils/DrawImage.js
var DrawImage = function(key2, frame, x, y, width, height) {
  var gameObject2 = GetStampGameObject_default(this, "Image").setTexture(key2, frame).setDisplaySize(width, height);
  this.draw(gameObject2, x, y);
};
var DrawImage_default = DrawImage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/rendertexture/utils/DrawTileSprite.js
var DrawTileSprite = function(key2, frame, x, y, width, height) {
  var gameObject2 = GetStampGameObject_default(this, "TileSprite").setTexture(key2, frame).setSize(width, height);
  this.draw(gameObject2, x, y);
};
var DrawTileSprite_default = DrawTileSprite;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/rendertexture/ninepatch/NinePatch.js
var RenderTexture = Phaser.GameObjects.RenderTexture;
var NinePatch = class extends NinePatch_default(RenderTexture, "rexNinePatch") {
};
var Methods = {
  _drawImage: DrawImage_default,
  _drawTileSprite: DrawTileSprite_default
};
Object.assign(
  NinePatch.prototype,
  Methods
);
var NinePatch_default2 = NinePatch;

// node_modules/phaser3-rex-plugins/plugins/ninepatch.js
var ninepatch_default = NinePatch_default2;

// node_modules/phaser3-rex-plugins/templates/ui/ninepatch/NinePatch.js
var NinePatch_default3 = ninepatch_default;

// node_modules/phaser3-rex-plugins/templates/ui/ninepatch/Factory.js
ObjectFactory_default.register("ninePatch", function(x, y, width, height, key2, columns, rows, config) {
  var gameObject2 = new NinePatch_default3(this.scene, x, y, width, height, key2, columns, rows, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.NinePatch", NinePatch_default3);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/render/WebGLRenderer.js
var GetCalcMatrix = Phaser.GameObjects.GetCalcMatrix;
var WebGLRenderer = function(renderer, src, camera, parentMatrix3) {
  var bobs = src.getRenderList();
  if (bobs.length === 0) {
    return;
  }
  camera.addToRenderList(src);
  var pipeline = renderer.pipelines.set(src.pipeline);
  var texture = src.frame.glTexture;
  var textureUnit = pipeline.setGameObject(src);
  var roundPixels = camera.roundPixels;
  var result = GetCalcMatrix(src, camera, parentMatrix3);
  var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
  var dx = src._displayOriginX;
  var dy = src._displayOriginY;
  var alpha = camera.alpha * src.alpha;
  renderer.pipelines.preBatch(src);
  for (var i = 0, cnt = bobs.length; i < cnt; i++) {
    bobs[i].webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels);
  }
  renderer.pipelines.postBatch(src);
};
var WebGLRenderer_default = WebGLRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/render/CanvasRenderer.js
var SetTransform = Phaser.Renderer.Canvas.SetTransform;
var CanvasRenderer = function(renderer, src, camera, parentMatrix3) {
  var ctx = renderer.currentContext;
  var bobs = src.getRenderList();
  if (bobs.length === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix3)) {
    return;
  }
  camera.addToRenderList(src);
  var roundPixels = camera.roundPixels;
  var dx = -src._displayOriginX, dy = -src._displayOriginY;
  ctx.translate(dx, dy);
  for (var i = 0, cnt = bobs.length; i < cnt; i++) {
    bobs[i].canvasRender(ctx, dx, dy, roundPixels);
  }
  ctx.restore();
};
var CanvasRenderer_default = CanvasRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/render/Render.js
var Render_default = {
  renderWebGL: WebGLRenderer_default,
  renderCanvas: CanvasRenderer_default
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/SetTexture.js
var SetTexture = function(key2, frame) {
  this.texture = this.scene.sys.textures.get(key2);
  this.frame = this.texture.get(frame);
  return this;
};
var SetTexture_default = SetTexture;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/Resize.js
var Resize = function(width, height) {
  if (this.width === width && this.height === height) {
    return this;
  }
  this.width = width;
  this.height = height;
  this.updateDisplayOrigin();
  var input = this.input;
  if (input && !input.customHitArea) {
    input.hitArea.width = width;
    input.hitArea.height = height;
  }
  return this;
};
var Resize_default2 = Resize;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/AddChild.js
var AddChild = function(bob) {
  this.lastAppendedChildren.length = 0;
  if (Array.isArray(bob)) {
    this.children.add(bob);
    this.lastAppendedChildren.push(...bob);
  } else {
    this.children.add(bob);
    this.lastAppendedChildren.push(bob);
  }
  return this;
};
var AddChild_default = AddChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/RemoveChild.js
var RemoveItem = Phaser.Utils.Array.Remove;
var RemoveChild = function(bob) {
  if (this.poolManager) {
    this.poolManager.free(bob);
  }
  RemoveItem(this.children.list, bob);
  this.lastAppendedChildren.length = 0;
  this.dirty = true;
  return this;
};
var RemoveChild_default = RemoveChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/RemoveChildren.js
var RemoveChildren = function() {
  if (this.poolManager) {
    this.poolManager.freeMultiple(this.children.list);
  }
  this.children.list.length = 0;
  this.lastAppendedChildren.length = 0;
  this.dirty = true;
  return this;
};
var RemoveChildren_default = RemoveChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/GetLastAppendedChildren.js
var GetLastAppendedChildren = function() {
  return this.lastAppendedChildren;
};
var GetLastAppendedChildren_default = GetLastAppendedChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/GetChildren.js
var GetChildren = function() {
  return this.children.list;
};
var GetChildren_default = GetChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/TintMethods.js
var TintMethods_default = {
  setTint(tint) {
    this.tint = tint;
    this.tintFill = false;
    return this;
  },
  setTintFill(tint) {
    this.tint = tint;
    this.tintFill = true;
    return this;
  },
  clearTint() {
    this.setTint(16777215);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/methods/Methods.js
var methods = {
  setTexture: SetTexture_default,
  resize: Resize_default2,
  setSize: Resize_default2,
  addChild: AddChild_default,
  removeChild: RemoveChild_default,
  removeChildren: RemoveChildren_default,
  clear: RemoveChildren_default,
  getLastAppendedChildren: GetLastAppendedChildren_default,
  getChildren: GetChildren_default
};
Object.assign(
  methods,
  TintMethods_default
);
var Methods_default2 = methods;

// node_modules/phaser3-rex-plugins/plugins/utils/struct/Stack.js
var Stack = class {
  constructor() {
    this.items = [];
  }
  destroy() {
    this.clear();
    this.items = void 0;
  }
  pop() {
    return this.items.length > 0 ? this.items.pop() : null;
  }
  push(l) {
    this.items.push(l);
    return this;
  }
  pushMultiple(arr) {
    this.items.push.apply(this.items, arr);
    arr.length = 0;
    return this;
  }
  clear() {
    this.items.length = 0;
    return this;
  }
};
var Stack_default = Stack;

// node_modules/phaser3-rex-plugins/plugins/pool.js
var pool_default = Stack_default;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/poolmanager/PoolManager.js
var GetValue3 = Phaser.Utils.Objects.GetValue;
var Pools = {};
var PoolManager = class {
  constructor(config) {
    this.pools = GetValue3(config, "pools", Pools);
  }
  destroy() {
    this.pools = void 0;
  }
  free(bob) {
    if (!this.pools) {
      return this;
    }
    var bobType = bob.type;
    if (!this.pools.hasOwnProperty(bobType)) {
      this.pools[bobType] = new pool_default();
    }
    this.pools[bobType].push(bob);
    bob.onFree();
    return this;
  }
  freeMultiple(bobs) {
    if (!this.pools) {
      return this;
    }
    for (var i = 0, cnt = bobs.length; i < cnt; i++) {
      this.free(bobs[i]);
    }
    return this;
  }
  allocate(bobType) {
    if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
      return null;
    }
    return this.pools[bobType].pop();
  }
};
var PoolManager_default = PoolManager;

// node_modules/phaser3-rex-plugins/plugins/utils/system/CheckP3Version.js
var MinVersion = 60;
var IsChecked = false;
var CheckP3Version = function(minVersion) {
  if (IsChecked) {
    return;
  }
  if (minVersion === void 0) {
    minVersion = MinVersion;
  }
  var version = Phaser.VERSION.split(".");
  var mainVersion = parseInt(version[0]);
  if (mainVersion === 3) {
    var currentVersion = parseInt(version[1]);
    if (currentVersion < minVersion) {
      console.error(`Minimum supported version : ${mainVersion}.${currentVersion}`);
    }
  } else {
    console.error(`Can't supported version : ${mainVersion}`);
  }
  IsChecked = true;
};
var CheckP3Version_default = CheckP3Version;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/BlitterBase.js
CheckP3Version_default();
var GameObject = Phaser.GameObjects.GameObject;
var IsPlainObject3 = Phaser.Utils.Objects.IsPlainObject;
var GetValue4 = Phaser.Utils.Objects.GetValue;
var List = Phaser.Structs.List;
var StableSort = Phaser.Utils.Array.StableSort;
var Blitter = class extends GameObject {
  constructor(scene, x, y, texture, frame, config) {
    if (IsPlainObject3(x)) {
      config = x;
      x = GetValue4(config, "x", 0);
      y = GetValue4(config, "y", 0);
      texture = GetValue4(config, "texture");
      frame = GetValue4(config, "frame");
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    super(scene, "rexBlitter");
    this.children = new List();
    this.renderList = [];
    this.displayListDirty = false;
    this.lastAppendedChildren = [];
    var reuseBob = GetValue4(config, "reuseBob", true);
    this.poolManager = reuseBob ? new PoolManager_default(config) : void 0;
    this.setTexture(texture, frame);
    this.setPosition(x, y);
    this.setOrigin(0, 0);
    this.clearTint();
    this.initPipeline();
    this.initPostPipeline();
  }
  preDestroy() {
    this.removeChildren();
    this.children.destroy();
    this.renderList.length = 0;
    if (this.poolManager) {
      this.poolManager.destroy();
    }
  }
  getRenderList() {
    if (this.displayListDirty) {
      this.renderList.length = 0;
      var needDepthSort = false;
      var children = this.children.list;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (ChildCanRender(child)) {
          this.renderList.push(child);
          if (!needDepthSort) {
            needDepthSort = child.depth !== 0;
          }
        }
      }
      if (needDepthSort) {
        StableSort(this.renderList, SortByDepth);
      }
      this.displayListDirty = false;
    }
    return this.renderList;
  }
};
var ChildCanRender = function(child) {
  return child.active && child.visible && child.alpha > 0;
};
var SortByDepth = function(childA, childB) {
  return childA._depth - childB._depth;
};
var Components2 = Phaser.GameObjects.Components;
Phaser.Class.mixin(
  Blitter,
  [
    Components2.Alpha,
    Components2.BlendMode,
    Components2.ComputedSize,
    Components2.Depth,
    Components2.GetBounds,
    Components2.Mask,
    Components2.Origin,
    Components2.Pipeline,
    Components2.PostPipeline,
    Components2.ScrollFactor,
    Components2.Transform,
    Components2.Visible,
    Render_default,
    Methods_default2
  ]
);
var BlitterBase_default = Blitter;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/bob/Types.js
var ImageTypeName = "image";

// node_modules/phaser3-rex-plugins/plugins/utils/object/GetValue.js
var GetValue5 = function(source, key2, defaultValue) {
  if (!source || typeof source === "number") {
    return defaultValue;
  }
  if (typeof key2 === "string") {
    if (source.hasOwnProperty(key2)) {
      return source[key2];
    }
    if (key2.indexOf(".") !== -1) {
      key2 = key2.split(".");
    } else {
      return defaultValue;
    }
  }
  var keys = key2;
  var parent = source;
  var value = defaultValue;
  for (var i = 0; i < keys.length; i++) {
    key2 = keys[i];
    if (parent.hasOwnProperty(key2)) {
      value = parent[key2];
      parent = value;
    } else {
      value = defaultValue;
      break;
    }
  }
  return value;
};
var GetValue_default = GetValue5;

// node_modules/phaser3-rex-plugins/plugins/utils/object/Clear.js
var Clear2 = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    obj.length = 0;
  } else {
    for (var key2 in obj) {
      delete obj[key2];
    }
  }
  return obj;
};
var Clear_default = Clear2;

// node_modules/phaser3-rex-plugins/plugins/utils/data/DataMethods.js
var DataMethods_default = {
  enableData() {
    if (this.data === void 0) {
      this.data = {};
    }
    return this;
  },
  setData(key2, value) {
    this.enableData();
    if (arguments.length === 1) {
      var data = key2;
      for (key2 in data) {
        this.data[key2] = data[key2];
      }
    } else {
      this.data[key2] = value;
    }
    return this;
  },
  getData(key2, defaultValue) {
    this.enableData();
    return key2 === void 0 ? this.data : GetValue_default(this.data, key2, defaultValue);
  },
  incData(key2, inc, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = 0;
    }
    this.enableData();
    this.setData(key2, this.getData(key2, defaultValue) + inc);
    return this;
  },
  mulData(key2, mul, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = 0;
    }
    this.enableData();
    this.setData(key2, this.getData(key2, defaultValue) * mul);
    return this;
  },
  clearData() {
    if (this.data) {
      Clear_default(this.data);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/bob/Base.js
var Base = class {
  constructor(parent, type) {
    this.type = type;
    this.data = void 0;
    this.setParent(parent).reset().setActive();
  }
  destroy() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
  }
  setParent(parent) {
    this.parent = parent;
    return this;
  }
  // get scene() {
  //     if (this.parent) {
  //         return this.parent.scene;
  //     } else {
  //         return null;
  //     }
  // }
  setDisplayListDirty(displayListDirty) {
    if (displayListDirty && this.parent) {
      this.parent.displayListDirty = true;
    }
    return this;
  }
  get active() {
    return this._active;
  }
  set active(value) {
    this.setDisplayListDirty(this._active != value);
    this._active = value;
  }
  setActive(active) {
    if (active === void 0) {
      active = true;
    }
    this.active = active;
    return this;
  }
  modifyPorperties(o) {
    return this;
  }
  // Override
  reset() {
    this.clearData();
  }
  // Override
  onFree() {
    this.reset().setActive(false).setParent();
  }
};
Object.assign(
  Base.prototype,
  DataMethods_default
);
var Base_default = Base;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/bob/RenderBase.js
var DegToRad = Phaser.Math.DegToRad;
var RadToDeg = Phaser.Math.RadToDeg;
var GetValue6 = Phaser.Utils.Objects.GetValue;
var RenderBase = class extends Base_default {
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this.setDisplayListDirty(this._visible != value);
    this._visible = value;
  }
  setVisible(visible) {
    if (visible === void 0) {
      visible = true;
    }
    this.visible = visible;
    return this;
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(value) {
    this.setDisplayListDirty(!!this._alpha !== !!value);
    this._alpha = value;
  }
  setAlpha(alpha) {
    this.alpha = alpha;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setRotation(rotation) {
    this.rotation = rotation;
    return this;
  }
  get angle() {
    return RadToDeg(this.rotation);
  }
  set angle(value) {
    this.rotation = DegToRad(value);
  }
  setAngle(angle) {
    this.angle = angle;
    return this;
  }
  setScaleX(scaleX) {
    this.scaleX = scaleX;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  setWidth(width, keepAspectRatio) {
    if (keepAspectRatio === void 0) {
      keepAspectRatio = false;
    }
    this.width = width;
    if (keepAspectRatio) {
      this.scaleY = this.scaleX;
    }
    return this;
  }
  setScaleY(scaleY) {
    this.scaleY = scaleY;
    return this;
  }
  setScale(scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    return this;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
  setHeight(height, keepAspectRatio) {
    if (keepAspectRatio === void 0) {
      keepAspectRatio = false;
    }
    this.height = height;
    if (keepAspectRatio) {
      this.scaleX = this.scaleY;
    }
    return this;
  }
  setScale(scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    return this;
  }
  get displayWidth() {
    return this._width * this.scaleX;
  }
  set displayWidth(value) {
    this.scaleX = value / this._width;
  }
  setDisplayWidth(width, keepAspectRatio) {
    if (keepAspectRatio === void 0) {
      keepAspectRatio = false;
    }
    this.displayWidth = width;
    if (keepAspectRatio) {
      this.scaleY = this.scaleX;
    }
    return this;
  }
  get displayHeight() {
    return this._height * this.scaleY;
  }
  set displayHeight(value) {
    this.scaleY = value / this._height;
  }
  setDisplayHeight(height, keepAspectRatio) {
    if (keepAspectRatio === void 0) {
      keepAspectRatio = false;
    }
    this.displayHeight = height;
    if (keepAspectRatio) {
      this.scaleX = this.scaleY;
    }
    return this;
  }
  setOriginX(originX) {
    this.originX = originX;
    this._displayOriginX = this.width * originX;
    return this;
  }
  setOriginY(originY) {
    this.originY = originY;
    this._displayOriginY = this.height * originY;
    return this;
  }
  setOrigin(originX, originY) {
    if (originY === void 0) {
      originY = originX;
    }
    this.setOriginX(originX).setOriginY(originY);
    return this;
  }
  get depth() {
    return this._depth;
  }
  set depth(value) {
    this.setDisplayListDirty(this._depth != value);
    this._depth = value;
  }
  setDepth(depth) {
    if (depth === void 0) {
      depth = 0;
    }
    this.depth = depth;
    return this;
  }
  modifyPorperties(o) {
    if (!o) {
      return this;
    }
    if (o.hasOwnProperty("x")) {
      this.setX(o.x);
    }
    if (o.hasOwnProperty("y")) {
      this.setY(o.y);
    }
    if (o.hasOwnProperty("rotation")) {
      this.setRotation(o.rotation);
    } else if (o.hasOwnProperty("angle")) {
      this.setAngle(o.angle);
    }
    if (o.hasOwnProperty("alpha")) {
      this.setAlpha(o.alpha);
    }
    var width = GetValue6(o, "width", void 0);
    var height = GetValue6(o, "height", void 0);
    var scale = GetValue6(o, "scale", void 0);
    var scaleX = GetValue6(o, "scaleX", scale);
    var scaleY = GetValue6(o, "scaleY", scale);
    if (width !== void 0) {
      if (height === void 0 && scaleY === void 0) {
        this.setWidth(width, true);
      } else {
        this.setWidth(width);
      }
    } else if (scaleX !== void 0) {
      this.setScaleX(scaleX);
    } else if (o.hasOwnProperty("displayWidth")) {
      this.setDisplayWidth(o.displayWidth);
    }
    if (height !== void 0) {
      if (width === void 0 && scaleX === void 0) {
        this.setHeight(height, true);
      } else {
        this.setHeight(height);
      }
    } else if (scaleY !== void 0) {
      this.setScaleY(scaleY);
    } else if (o.hasOwnProperty("displayHeight")) {
      this.setDisplayHeight(o.displayHeight);
    }
    var origin = GetValue6(o, "origin", void 0);
    if (origin !== void 0) {
      this.setOrigin(origin);
    } else {
      if (o.hasOwnProperty("originX")) {
        this.setOriginX(o.originX);
      }
      if (o.hasOwnProperty("originY")) {
        this.setOriginY(o.originY);
      }
    }
    if (o.hasOwnProperty("depth")) {
      this.setDepth(o.depth);
    }
    return this;
  }
  reset() {
    super.reset();
    this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setOrigin(0).setDepth(0);
    return this;
  }
  // Override
  webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {
  }
  // Override
  canvasRender(ctx, dx, dy, roundPixels) {
  }
};
var RenderBase_default = RenderBase;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/bob/image/WebglRender.js
var TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;
var GetTint = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
var FrameMatrix = new TransformMatrix();
var WebglRender = function(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {
  var frame = this.frame;
  if (!frame) {
    return;
  }
  var width = this._width, height = this._height;
  var displayOriginX = width * this.originX, displayOriginY = height * this.originY;
  var x = this.x - dx, y = this.y - dy;
  var u0, v0, u1, v1;
  var frameX, frameY;
  var frameWidth, frameHeight;
  if (this.isCropped) {
    var crop = this._crop;
    if (crop.flipX !== this.flipX || crop.flipY !== this.flipY) {
      frame.updateCropUVs(crop, this.flipX, this.flipY);
    }
    u0 = crop.u0;
    v0 = crop.v0;
    u1 = crop.u1;
    v1 = crop.v1;
    frameWidth = crop.width;
    frameHeight = crop.height;
    frameX = crop.x;
    frameY = crop.y;
  } else {
    u0 = this.frame.u0;
    v0 = this.frame.v0;
    u1 = this.frame.u1;
    v1 = this.frame.v1;
    frameWidth = width;
    frameHeight = height;
    frameX = 0;
    frameY = 0;
  }
  var flipX = 1;
  var flipY = 1;
  if (this.flipX) {
    x += width - displayOriginX * 2;
    flipX = -1;
  }
  if (this.flipY) {
    y += height - displayOriginY * 2;
    flipY = -1;
  }
  FrameMatrix.applyITRS(x, y, this.rotation, this.scaleX * flipX, this.scaleY * flipY);
  calcMatrix.multiply(FrameMatrix, FrameMatrix);
  var tx = -displayOriginX + frameX;
  var ty = -displayOriginY + frameY;
  var tw = tx + frameWidth;
  var th = ty + frameHeight;
  var quad = FrameMatrix.setQuad(tx, ty, tw, th, roundPixels);
  var tint = GetTint(this.tint, this.alpha * alpha);
  pipeline.batchQuad(
    this.parent,
    quad[0],
    quad[1],
    quad[2],
    quad[3],
    quad[4],
    quad[5],
    quad[6],
    quad[7],
    u0,
    v0,
    u1,
    v1,
    tint,
    tint,
    tint,
    tint,
    this.tintFill,
    texture,
    textureUnit
  );
};
var WebglRender_default = WebglRender;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/bob/image/CanvasRender.js
var CanvasRender = function(ctx, dx, dy, roundPixels) {
  var frame = this.frame;
  if (!frame) {
    return;
  }
  ctx.save();
  var width = this._width, height = this._height;
  var displayOriginX = width * this.originX, displayOriginY = height * this.originY;
  var x = this.x - displayOriginX, y = this.y - displayOriginY;
  var frameX, frameY;
  var frameWidth, frameHeight;
  if (this.isCropped) {
    var crop = this._crop;
    if (crop.flipX !== this.flipX || crop.flipY !== this.flipY) {
      frame.updateCropUVs(crop, this.flipX, this.flipY);
    }
    frameWidth = crop.cw;
    frameHeight = crop.ch;
    frameX = crop.cx;
    frameY = crop.cy;
  } else {
    frameWidth = frame.cutWidth;
    frameHeight = frame.cutHeight;
    frameX = frame.cutX;
    frameY = frame.cutY;
  }
  var flipX = 1;
  var flipY = 1;
  if (this.flipX) {
    x += width;
    flipX = -1;
  }
  if (this.flipY) {
    y += height;
    flipY = -1;
  }
  var res = frame.source.resolution;
  var fw = frameWidth / res;
  var fh = frameHeight / res;
  if (roundPixels) {
    x = Math.floor(x + 0.5);
    y = Math.floor(y + 0.5);
    fw += 0.5;
    fh += 0.5;
  }
  ctx.translate(x, y);
  ctx.rotate(this.rotation);
  ctx.scale(this.scaleX * flipX, this.scaleY * flipY);
  ctx.drawImage(
    frame.source.image,
    frameX,
    frameY,
    frameWidth,
    frameHeight,
    0,
    0,
    fw,
    fh
  );
  ctx.restore();
};
var CanvasRender_default = CanvasRender;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/bob/image/ImageData.js
var IsPlainObject4 = Phaser.Utils.Objects.IsPlainObject;
var ImageData = class extends RenderBase_default {
  constructor(parent, frame) {
    super(parent, ImageTypeName);
    this._crop = ResetCropObject();
    this.setFrame(frame);
  }
  get width() {
    return this._width;
  }
  set width(value) {
  }
  get height() {
    return this._height;
  }
  set height(value) {
  }
  setFrame(frame) {
    if (arguments.length > 0 && !IsPlainObject4(frame)) {
      frame = this.parent.texture.get(frame);
    }
    this.frame = frame;
    if (frame) {
      this._width = frame.realWidth;
      this._height = frame.realHeight;
    } else {
      this._width = 0;
      this._height = 0;
    }
    return this;
  }
  setFlipX(flipX) {
    if (flipX === void 0) {
      flipX = true;
    }
    this.flipX = flipX;
    return this;
  }
  setFlipY(flipY) {
    if (flipY === void 0) {
      flipY = true;
    }
    this.flipY = flipY;
    return this;
  }
  resetFlip() {
    this.flipX = false;
    this.flipY = false;
    return this;
  }
  get tint() {
    if (this._tint === void 0) {
      return this.parent.tint;
    } else {
      return this._tint;
    }
  }
  set tint(value) {
    this._tint = value;
  }
  setTint(value) {
    this.tint = value;
    this.tintFill = false;
    return this;
  }
  setTintFill(value) {
    this.tint = value;
    this.tintFill = true;
    return this;
  }
  clearTint() {
    this.setTint(16777215);
    return this;
  }
  resetTint() {
    this.tint = void 0;
    this.tintFill = void 0;
    return this;
  }
  get tintFill() {
    if (this._tintFill === void 0) {
      return this.parent.tintFill;
    } else {
      return this._tintFill;
    }
  }
  set tintFill(value) {
    this._tintFill = value;
  }
  setCrop(x, y, width, height) {
    if (x === void 0) {
      this.isCropped = false;
      return this;
    }
    if (!this.frame) {
      return this;
    }
    if (x === 0 && y === 0 && width === this._width && height === this._height) {
      this.isCropped = false;
      return this;
    }
    this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);
    this.isCropped = true;
    return this;
  }
  reset() {
    super.reset();
    this.resetFlip().resetTint().setFrame().setCrop();
    return this;
  }
  modifyPorperties(o) {
    if (!o) {
      return this;
    }
    if (o.hasOwnProperty("width")) {
      o.displayWidth = o.width;
      delete o.width;
    }
    if (o.hasOwnProperty("height")) {
      o.displayHeight = o.height;
      delete o.height;
    }
    if (o.hasOwnProperty("frame")) {
      this.setFrame(o.frame);
    }
    super.modifyPorperties(o);
    if (o.hasOwnProperty("flipX")) {
      this.setFlipX(o.flipX);
    }
    if (o.hasOwnProperty("flipY")) {
      this.setFlipY(o.flipY);
    }
    if (o.hasOwnProperty("tint")) {
      this.setTint(o.tint);
    }
    if (o.hasOwnProperty("tintFill")) {
      this.setTintFill(o.tintFill);
    }
    return this;
  }
};
var ResetCropObject = function(out2) {
  if (out2 === void 0) {
    out2 = {};
  }
  out2.u0 = 0;
  out2.v0 = 0;
  out2.u1 = 0;
  out2.v1 = 0;
  out2.x = 0;
  out2.y = 0;
  out2.width = 0;
  out2.height = 0;
  out2.flipX = false;
  out2.flipY = false;
  out2.cx = 0;
  out2.cy = 0;
  out2.cw = 0, out2.ch = 0;
  return out2;
};
var methods2 = {
  webglRender: WebglRender_default,
  canvasRender: CanvasRender_default
};
Object.assign(
  ImageData.prototype,
  methods2
);
var ImageData_default = ImageData;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/blitterbase/utils/AddImage.js
var AddImage = function(blitter, config) {
  if (typeof config === "string") {
    config = {
      frame: config
    };
  }
  var bob = blitter.poolManager ? blitter.poolManager.allocate(ImageTypeName) : null;
  if (bob === null) {
    bob = new ImageData_default(blitter);
  } else {
    bob.setParent(blitter).setActive();
  }
  bob.modifyPorperties(config);
  blitter.addChild(bob);
  return bob;
};
var AddImage_default = AddImage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/ninepatch/texture/DrawImage.js
var DrawImage2 = function(key2, frame, x, y, width, height) {
  AddImage_default(this, {
    frame,
    x,
    y,
    width,
    height
  });
};
var DrawImage_default2 = DrawImage2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/ninepatch/texture/DrawTileSprite.js
var DrawTileSprite2 = function(key2, frame, x, y, width, height) {
  var frameObj = this.texture.get(frame);
  var frameWidth = frameObj.width, frameHeight = frameObj.height;
  var lastFrameWidth = width % frameWidth, lastFrameHeight = height % frameHeight;
  if (lastFrameWidth === 0) {
    lastFrameWidth = frameWidth;
  }
  if (lastFrameHeight === 0) {
    lastFrameHeight = frameHeight;
  }
  var colCount = Math.ceil(width / frameWidth), rowCount = Math.ceil(height / frameHeight);
  var lastColCount = colCount - 1, lastRowCount = rowCount - 1;
  for (var colIndex = 0; colIndex < colCount; colIndex++) {
    for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
      let bob = AddImage_default(this, {
        frame,
        x: x + colIndex * frameWidth,
        y: y + rowIndex * frameHeight
      });
      var cropWidth = colIndex === lastColCount ? lastFrameWidth : frameWidth;
      var cropHeight = rowIndex === lastRowCount ? lastFrameHeight : frameHeight;
      if (cropWidth !== frameWidth || cropHeight !== frameHeight) {
        bob.setCrop(0, 0, cropWidth, cropHeight);
      }
    }
  }
};
var DrawTileSprite_default2 = DrawTileSprite2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/ninepatch/Methods.js
var Methods_default3 = {
  _drawImage: DrawImage_default2,
  _drawTileSprite: DrawTileSprite_default2
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/blitter/ninepatch/NinePatch.js
var NinePatch2 = class extends NinePatch_default(BlitterBase_default, "rexNinePatch2") {
  setBaseTexture(key2, baseFrameName, columns, rows) {
    this.setTexture(key2, baseFrameName);
    super.setBaseTexture(key2, baseFrameName, columns, rows);
    return this;
  }
};
Object.assign(
  NinePatch2.prototype,
  Methods_default3
);
var NinePatch_default4 = NinePatch2;

// node_modules/phaser3-rex-plugins/plugins/ninepatch2.js
var ninepatch2_default = NinePatch_default4;

// node_modules/phaser3-rex-plugins/templates/ui/ninepatch2/NinePatch.js
var NinePatch_default5 = ninepatch2_default;

// node_modules/phaser3-rex-plugins/templates/ui/ninepatch2/Factory.js
ObjectFactory_default.register("ninePatch2", function(x, y, width, height, key2, columns, rows, config) {
  var gameObject2 = new NinePatch_default5(this.scene, x, y, width, height, key2, columns, rows, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.NinePatch2", NinePatch_default5);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/FillPathWebGL.js
var Utils = Phaser.Renderer.WebGL.Utils;
var FillPathWebGL = function(pipeline, calcMatrix, src, alpha, dx, dy) {
  var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
  var path = src.pathData;
  var pathIndexes = src.pathIndexes;
  for (var i = 0; i < pathIndexes.length; i += 3) {
    var p0 = pathIndexes[i] * 2;
    var p1 = pathIndexes[i + 1] * 2;
    var p2 = pathIndexes[i + 2] * 2;
    var x0 = path[p0 + 0] - dx;
    var y0 = path[p0 + 1] - dy;
    var x1 = path[p1 + 0] - dx;
    var y1 = path[p1 + 1] - dy;
    var x2 = path[p2 + 0] - dx;
    var y2 = path[p2 + 1] - dy;
    var tx0 = calcMatrix.getX(x0, y0);
    var ty0 = calcMatrix.getY(x0, y0);
    var tx1 = calcMatrix.getX(x1, y1);
    var ty1 = calcMatrix.getY(x1, y1);
    var tx2 = calcMatrix.getX(x2, y2);
    var ty2 = calcMatrix.getY(x2, y2);
    pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
  }
};
var FillPathWebGL_default = FillPathWebGL;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/StrokePathWebGL.js
var Utils2 = Phaser.Renderer.WebGL.Utils;
var StrokePathWebGL = function(pipeline, src, alpha, dx, dy) {
  var strokeTint = pipeline.strokeTint;
  var strokeTintColor = Utils2.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
  strokeTint.TL = strokeTintColor;
  strokeTint.TR = strokeTintColor;
  strokeTint.BL = strokeTintColor;
  strokeTint.BR = strokeTintColor;
  var path = src.pathData;
  var pathLength = path.length - 1;
  var lineWidth = src.lineWidth;
  var halfLineWidth = lineWidth / 2;
  var px1 = path[0] - dx;
  var py1 = path[1] - dy;
  if (!src.closePath) {
    pathLength -= 2;
  }
  for (var i = 2; i < pathLength; i += 2) {
    var px2 = path[i] - dx;
    var py2 = path[i + 1] - dy;
    pipeline.batchLine(
      px1,
      py1,
      px2,
      py2,
      halfLineWidth,
      halfLineWidth,
      lineWidth,
      i - 2,
      src.closePath ? i === pathLength - 1 : false
    );
    px1 = px2;
    py1 = py2;
  }
};
var StrokePathWebGL_default = StrokePathWebGL;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangle/render/WebGLRenderer.js
var GetCalcMatrix2 = Phaser.GameObjects.GetCalcMatrix;
var PolygonWebGLRenderer = function(renderer, src, camera, parentMatrix3) {
  if (src.dirty) {
    src.updateData();
    src.dirty = false;
  }
  camera.addToRenderList(src);
  var pipeline = renderer.pipelines.set(src.pipeline);
  var result = GetCalcMatrix2(src, camera, parentMatrix3);
  var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
  var dx = src._displayOriginX;
  var dy = src._displayOriginY;
  var alpha = camera.alpha * src.alpha;
  renderer.pipelines.preBatch(src);
  if (src.isFilled) {
    FillPathWebGL_default(pipeline, calcMatrix, src, alpha, dx, dy);
  }
  if (src.isStroked) {
    StrokePathWebGL_default(pipeline, src, alpha, dx, dy);
  }
  renderer.pipelines.postBatch(src);
};
var WebGLRenderer_default2 = PolygonWebGLRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/FillStyleCanvas.js
var FillStyleCanvas = function(ctx, src, altColor, altAlpha) {
  var fillColor = altColor ? altColor : src.fillColor;
  var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
  var red = (fillColor & 16711680) >>> 16;
  var green = (fillColor & 65280) >>> 8;
  var blue = fillColor & 255;
  ctx.fillStyle = "rgba(" + red + "," + green + "," + blue + "," + fillAlpha + ")";
};
var FillStyleCanvas_default = FillStyleCanvas;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/render/LineStyleCanvas.js
var LineStyleCanvas = function(ctx, src, altColor, altAlpha) {
  var strokeColor = altColor ? altColor : src.strokeColor;
  var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
  var red = (strokeColor & 16711680) >>> 16;
  var green = (strokeColor & 65280) >>> 8;
  var blue = strokeColor & 255;
  ctx.strokeStyle = "rgba(" + red + "," + green + "," + blue + "," + strokeAlpha + ")";
  ctx.lineWidth = src.lineWidth;
};
var LineStyleCanvas_default = LineStyleCanvas;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangle/render/CanvasRenderer.js
var SetTransform2 = Phaser.Renderer.Canvas.SetTransform;
var PolygonCanvasRenderer = function(renderer, src, camera, parentMatrix3) {
  if (src.dirty) {
    src.updateData();
    src.dirty = false;
  }
  camera.addToRenderList(src);
  var ctx = renderer.currentContext;
  if (SetTransform2(renderer, ctx, src, camera, parentMatrix3)) {
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var path = src.pathData;
    var pathLength = path.length - 1;
    var px1 = path[0] - dx;
    var py1 = path[1] - dy;
    ctx.beginPath();
    ctx.moveTo(px1, py1);
    if (!src.closePath) {
      pathLength -= 2;
    }
    for (var i = 2; i < pathLength; i += 2) {
      var px2 = path[i] - dx;
      var py2 = path[i + 1] - dy;
      ctx.lineTo(px2, py2);
    }
    ctx.closePath();
    if (src.isFilled) {
      FillStyleCanvas_default(ctx, src);
      ctx.fill();
    }
    if (src.isStroked) {
      LineStyleCanvas_default(ctx, src);
      ctx.stroke();
    }
    ctx.restore();
  }
};
var CanvasRenderer_default2 = PolygonCanvasRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangle/render/Render.js
var Render_default2 = {
  renderWebGL: WebGLRenderer_default2,
  renderCanvas: CanvasRenderer_default2
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangle/PolygnBase.js
var Shape = Phaser.GameObjects.Shape;
var PolygnBase = class extends Shape {
  get fillColor() {
    return this._fillColor;
  }
  set fillColor(value) {
    this._fillColor = value;
    this.isFilled = value != null && this._fillAlpha > 0;
  }
  get fillAlpha() {
    return this._fillAlpha;
  }
  set fillAlpha(value) {
    this._fillAlpha = value;
    this.isFilled = value > 0 && this._fillColor != null;
  }
  // Fully override setFillStyle method
  setFillStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.fillColor = color;
    this.fillAlpha = alpha;
    return this;
  }
  get strokeColor() {
    return this._strokeColor;
  }
  set strokeColor(value) {
    this._strokeColor = value;
    this.isStroked = value != null && this._strokeAlpha > 0 && this._lineWidth > 0;
  }
  get strokeAlpha() {
    return this._strokeAlpha;
  }
  set strokeAlpha(value) {
    this._strokeAlpha = value;
    this.isStroked = value > 0 && this._strokeColor != null && this._lineWidth > 0;
  }
  get lineWidth() {
    return this._lineWidth;
  }
  set lineWidth(value) {
    this._lineWidth = value;
    this.isStroked = value > 0 && this._strokeColor != null;
  }
  // Fully override setStrokeStyle method
  setStrokeStyle(lineWidth, color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.lineWidth = lineWidth;
    this.strokeColor = color;
    this.strokeAlpha = alpha;
    return this;
  }
  updateData() {
    return this;
  }
  get width() {
    return this.geom.width;
  }
  set width(value) {
    this.resize(value, this.height);
  }
  get height() {
    return this.geom.height;
  }
  set height(value) {
    this.resize(this.width, value);
  }
  setSize(width, height) {
    var input = this.input;
    if (input && !input.customHitArea) {
      input.hitArea.width = width;
      input.hitArea.height = height;
    }
    return this;
  }
  resize(width, height) {
    this.setSize(width, height);
    return this;
  }
};
Object.assign(
  PolygnBase.prototype,
  Render_default2
);
var PolygnBase_default = PolygnBase;

// node_modules/phaser3-rex-plugins/plugins/geom/roundrectangle/RoundRectangle.js
var GetValue7 = Phaser.Utils.Objects.GetValue;
var RoundRectangle = class {
  constructor(x, y, width, height, radiusConfig) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = x;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    if (radiusConfig === void 0) {
      radiusConfig = 0;
    }
    this.cornerRadius = {};
    this._width = 0;
    this._height = 0;
    this.setTo(x, y, width, height, radiusConfig);
  }
  setTo(x, y, width, height, radiusConfig) {
    this.setPosition(x, y);
    this.setRadius(radiusConfig);
    this.setSize(width, height);
    return this;
  }
  setPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setRadius(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radius = value;
    return this;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  get minWidth() {
    var radius = this.cornerRadius;
    return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
  }
  get minHeight() {
    var radius = this.cornerRadius;
    return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value == null) {
      value = 0;
    }
    this._width = Math.max(value, this.minWidth);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    if (value == null) {
      value = 0;
    }
    this._height = Math.max(value, this.minHeight);
  }
  get radius() {
    var radius = this.cornerRadius;
    return Math.max(
      radius.tl.x,
      radius.tl.y,
      radius.tr.x,
      radius.tr.y,
      radius.bl.x,
      radius.bl.y,
      radius.br.x,
      radius.br.y
    );
  }
  set radius(value) {
    var defaultRadiusX, defaultRadiusY;
    if (typeof value === "number") {
      defaultRadiusX = value;
      defaultRadiusY = value;
    } else {
      defaultRadiusX = GetValue7(value, "x", 0);
      defaultRadiusY = GetValue7(value, "y", 0);
    }
    var radius = this.cornerRadius;
    radius.tl = GetRadius(GetValue7(value, "tl", void 0), defaultRadiusX, defaultRadiusY);
    radius.tr = GetRadius(GetValue7(value, "tr", void 0), defaultRadiusX, defaultRadiusY);
    radius.bl = GetRadius(GetValue7(value, "bl", void 0), defaultRadiusX, defaultRadiusY);
    radius.br = GetRadius(GetValue7(value, "br", void 0), defaultRadiusX, defaultRadiusY);
  }
  get radiusTL() {
    var radius = this.cornerRadius.tl;
    return Math.max(radius.x, radius.y);
  }
  set radiusTL(value) {
    SetRadius(this.cornerRadius.tl, value);
  }
  get radiusTR() {
    var radius = this.cornerRadius.tr;
    return Math.max(radius.x, radius.y);
  }
  set radiusTR(value) {
    SetRadius(this.cornerRadius.tr, value);
  }
  get radiusBL() {
    var radius = this.cornerRadius.bl;
    return Math.max(radius.x, radius.y);
  }
  set radiusBL(value) {
    SetRadius(this.cornerRadius.bl, value);
  }
  get radiusBR() {
    var radius = this.cornerRadius.br;
    return Math.max(radius.x, radius.y);
  }
  set radiusBR(value) {
    SetRadius(this.cornerRadius.br, value);
  }
};
var GetRadius = function(radius, defaultRadiusX, defaultRadiusY) {
  if (radius === void 0) {
    radius = {
      x: defaultRadiusX,
      y: defaultRadiusY
    };
  } else if (typeof radius === "number") {
    radius = {
      x: radius,
      y: radius
    };
  }
  SetConvex(radius);
  return radius;
};
var SetRadius = function(radius, value) {
  if (typeof value === "number") {
    radius.x = value;
    radius.y = value;
  } else {
    radius.x = GetValue7(value, "x", 0);
    radius.y = GetValue7(value, "y", 0);
  }
  SetConvex(radius);
};
var SetConvex = function(radius) {
  radius.convex = radius.x >= 0 || radius.y >= 0;
  radius.x = Math.abs(radius.x);
  radius.y = Math.abs(radius.y);
};
var RoundRectangle_default = RoundRectangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/utils/IsArcCorner.js
var IsArcCorner = function(radius) {
  return radius.x > 0 && radius.y > 0;
};
var IsArcCorner_default = IsArcCorner;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/LineTo.js
var LineTo = function(x, y, pathData) {
  var cnt = pathData.length;
  if (cnt >= 2) {
    var lastX = pathData[cnt - 2];
    var lastY = pathData[cnt - 1];
    if (x === lastX && y === lastY) {
      return pathData;
    }
  }
  pathData.push(x, y);
  return pathData;
};
var LineTo_default = LineTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/ArcTo.js
var DegToRad2 = Phaser.Math.DegToRad;
var ArcTo = function(centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
  if (antiClockWise && endAngle > startAngle) {
    endAngle -= 360;
  } else if (!antiClockWise && endAngle < startAngle) {
    endAngle += 360;
  }
  var deltaAngle = endAngle - startAngle;
  var step = DegToRad2(deltaAngle) / iteration;
  startAngle = DegToRad2(startAngle);
  for (var i = 0; i <= iteration; i++) {
    var angle = startAngle + step * i;
    var x = centerX + radiusX * Math.cos(angle);
    var y = centerY + radiusY * Math.sin(angle);
    LineTo_default(x, y, pathData);
  }
  return pathData;
};
var ArcTo_default = ArcTo;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangle/RoundRectangle.js
var IsPlainObject5 = Phaser.Utils.Objects.IsPlainObject;
var GetValue8 = Phaser.Utils.Objects.GetValue;
var Earcut = Phaser.Geom.Polygon.Earcut;
var RoundRectangle2 = class extends PolygnBase_default {
  constructor(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
    var strokeColor, strokeAlpha, strokeWidth, shapeType;
    if (IsPlainObject5(x)) {
      var config = x;
      x = config.x;
      y = config.y;
      width = config.width;
      height = config.height;
      radiusConfig = config.radius;
      fillColor = config.color;
      fillAlpha = config.alpha;
      strokeColor = config.strokeColor;
      strokeAlpha = config.strokeAlpha;
      strokeWidth = config.strokeWidth;
      shapeType = config.shape;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = width;
    }
    if (radiusConfig === void 0) {
      radiusConfig = 0;
    }
    if (shapeType === void 0) {
      shapeType = 0;
    }
    var geom = new RoundRectangle_default();
    super(scene, "rexRoundRectangleShape", geom);
    this.setShapeType(shapeType);
    if (this.shapeType === 0) {
      var radius = GetValue8(radiusConfig, "radius", radiusConfig);
      geom.setTo(0, 0, width, height, radius);
    } else {
      var radius = { x: width / 2, y: height / 2 };
      geom.setTo(0, 0, width, height, radius);
    }
    this.setIteration(GetValue8(radiusConfig, "iteration", void 0));
    this.setPosition(x, y);
    this.setFillStyle(fillColor, fillAlpha);
    if (strokeWidth === void 0) {
      strokeWidth = 2;
    }
    this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
    this.updateDisplayOrigin();
    this.dirty = true;
  }
  updateData() {
    var geom = this.geom;
    var pathData = this.pathData;
    pathData.length = 0;
    var width = geom.width, height = geom.height, cornerRadius = geom.cornerRadius, radius, iteration = this.iteration + 1;
    radius = cornerRadius.tl;
    if (IsArcCorner_default(radius)) {
      if (radius.convex) {
        var centerX = radius.x;
        var centerY = radius.y;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
      } else {
        var centerX = 0;
        var centerY = 0;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 90, 0, true, iteration, pathData);
      }
    } else {
      LineTo_default(0, 0, pathData);
    }
    radius = cornerRadius.tr;
    if (IsArcCorner_default(radius)) {
      if (radius.convex) {
        var centerX = width - radius.x;
        var centerY = radius.y;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
      } else {
        var centerX = width;
        var centerY = 0;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 180, 90, true, iteration, pathData);
      }
    } else {
      LineTo_default(width, 0, pathData);
    }
    radius = cornerRadius.br;
    if (IsArcCorner_default(radius)) {
      if (radius.convex) {
        var centerX = width - radius.x;
        var centerY = height - radius.y;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
      } else {
        var centerX = width;
        var centerY = height;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 270, 180, true, iteration, pathData);
      }
    } else {
      LineTo_default(width, height, pathData);
    }
    radius = cornerRadius.bl;
    if (IsArcCorner_default(radius)) {
      if (radius.convex) {
        var centerX = radius.x;
        var centerY = height - radius.y;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
      } else {
        var centerX = 0;
        var centerY = height;
        ArcTo_default(centerX, centerY, radius.x, radius.y, 360, 270, true, iteration, pathData);
      }
    } else {
      LineTo_default(0, height, pathData);
    }
    pathData.push(pathData[0], pathData[1]);
    this.pathIndexes = Earcut(pathData);
    return this;
  }
  setShapeType(shapeType) {
    if (typeof shapeType === "string") {
      shapeType = ShapeTypeMap[shapeType];
    }
    this.shapeType = shapeType;
    return this;
  }
  setSize(width, height) {
    if (height === void 0) {
      height = width;
    }
    if (this.geom.width === width && this.geom.height === height) {
      return this;
    }
    this.geom.setSize(width, height);
    if (this.shapeType === 1) {
      this.setRadius({ x: width / 2, y: height / 2 });
    }
    this.updateDisplayOrigin();
    this.dirty = true;
    super.setSize(width, height);
    return this;
  }
  get radius() {
    return this.geom.radius;
  }
  set radius(value) {
    this.geom.setRadius(value);
    this.updateDisplayOrigin();
    this.dirty = true;
  }
  get radiusTL() {
    return this.geom.radiusTL;
  }
  set radiusTL(value) {
    this.geom.radiusTL = value;
    this.dirty = true;
  }
  get radiusTR() {
    return this.geom.radiusTR;
  }
  set radiusTR(value) {
    this.geom.radiusTR = value;
    this.dirty = true;
  }
  get radiusBL() {
    return this.geom.radiusBL;
  }
  set radiusBL(value) {
    this.geom.radiusBL = value;
    this.dirty = true;
  }
  get radiusBR() {
    return this.geom.radiusBR;
  }
  set radiusBR(value) {
    this.geom.radiusBR = value;
    this.dirty = true;
  }
  setRadius(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radius = value;
    return this;
  }
  setRadiusTL(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusTL = value;
    return this;
  }
  setRadiusTR(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusTR = value;
    return this;
  }
  setRadiusBL(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusBL = value;
    return this;
  }
  setRadiusBR(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusBR = value;
    return this;
  }
  get cornerRadius() {
    return this.geom.cornerRadius;
  }
  set cornerRadius(value) {
    this.radius = value;
  }
  setCornerRadius(value) {
    return this.setRadius(value);
  }
  get iteration() {
    return this._iteration;
  }
  set iteration(value) {
    if (this._iteration === void 0) {
      this._iteration = value;
      return;
    }
    if (this._iteration === value) {
      return;
    }
    this._iteration = value;
    this.dirty = true;
  }
  setIteration(iteration) {
    if (iteration === void 0) {
      iteration = 6;
    }
    this.iteration = iteration;
    return this;
  }
};
var ShapeTypeMap = {
  rectangle: 0,
  circle: 1
};
var RoundRectangle_default2 = RoundRectangle2;

// node_modules/phaser3-rex-plugins/plugins/roundrectangle.js
var roundrectangle_default = RoundRectangle_default2;

// node_modules/phaser3-rex-plugins/templates/ui/roundrectangle/RoundRectangle.js
var RoundRectangle_default3 = roundrectangle_default;

// node_modules/phaser3-rex-plugins/templates/ui/roundrectangle/Factory.js
ObjectFactory_default.register("roundRectangle", function(x, y, width, height, radiusConfig, fillColor, fillAlpha) {
  var gameObject2 = new RoundRectangle_default3(this.scene, x, y, width, height, radiusConfig, fillColor, fillAlpha);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.RoundRectangle", RoundRectangle_default3);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvasbase/render/WebGLRenderer.js
var Utils3 = Phaser.Renderer.WebGL.Utils;
var WebGLRenderer2 = function(renderer, src, camera, parentMatrix3) {
  if (src.dirty) {
    src.updateTexture();
    src.dirty = false;
  }
  if (src.width === 0 || src.height === 0) {
    return;
  }
  camera.addToRenderList(src);
  var frame = src.frame;
  var width = frame.width;
  var height = frame.height;
  var getTint = Utils3.getTintAppendFloatAlpha;
  var pipeline = renderer.pipelines.set(src.pipeline, src);
  var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
  renderer.pipelines.preBatch(src);
  pipeline.batchTexture(
    src,
    frame.glTexture,
    width,
    height,
    src.x,
    src.y,
    width / src.resolution,
    height / src.resolution,
    src.scaleX,
    src.scaleY,
    src.rotation,
    src.flipX,
    src.flipY,
    src.scrollFactorX,
    src.scrollFactorY,
    src.displayOriginX,
    src.displayOriginY,
    0,
    0,
    width,
    height,
    getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
    getTint(src.tintTopRight, camera.alpha * src._alphaTR),
    getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
    getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
    src.tintFill,
    0,
    0,
    camera,
    parentMatrix3,
    false,
    textureUnit
  );
  renderer.pipelines.postBatch(src);
};
var WebGLRenderer_default3 = WebGLRenderer2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvasbase/render/CanvasRenderer.js
var CanvasRenderer2 = function(renderer, src, camera, parentMatrix3) {
  if (src.dirty) {
    src.updateTexture();
    src.dirty = false;
  }
  if (src.width === 0 || src.height === 0) {
    return;
  }
  camera.addToRenderList(src);
  renderer.batchSprite(src, src.frame, camera, parentMatrix3);
};
var CanvasRenderer_default3 = CanvasRenderer2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvasbase/render/Render.js
var Render_default3 = {
  renderWebGL: WebGLRenderer_default3,
  renderCanvas: CanvasRenderer_default3
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvasbase/CanvasMethods.js
var Color = Phaser.Display.Color;
var CanvasMethods_default = {
  clear() {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.dirty = true;
    return this;
  },
  fill(color) {
    this.context.fillStyle = color;
    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.dirty = true;
    return this;
  },
  drawFrame(key2, frame, dx, dy, dWidth, dHeight, sxOffset, syOffset, sWidth, sHeight) {
    var textureFrame = this.scene.sys.textures.getFrame(key2, frame);
    if (!textureFrame) {
      return this;
    }
    var frameWidth = textureFrame.cutWidth, frameHeight = textureFrame.cutHeight;
    if (dx === void 0) {
      dx = 0;
    }
    if (dy === void 0) {
      dy = 0;
    }
    if (dWidth === void 0) {
      dWidth = frameWidth;
    }
    if (dHeight === void 0) {
      dHeight = frameHeight;
    }
    if (sxOffset === void 0) {
      sxOffset = 0;
    }
    if (syOffset === void 0) {
      syOffset = 0;
    }
    if (sWidth === void 0) {
      sWidth = frameWidth;
    }
    if (sHeight === void 0) {
      sHeight = frameHeight;
    }
    var sx = textureFrame.cutX + sxOffset;
    var sy = textureFrame.cutY + syOffset;
    this.context.drawImage(
      textureFrame.source.image,
      // image
      sx,
      sy,
      sWidth,
      sHeight,
      dx,
      dy,
      dWidth,
      dHeight
    );
    this.dirty = true;
    return this;
  },
  getDataURL(type, encoderOptions) {
    return this.canvas.toDataURL(type, encoderOptions);
  },
  getPixel(x, y, out2) {
    if (out2 === void 0) {
      out2 = new Color();
    }
    var rgb = this.context.getImageData(x, y, 1, 1);
    out2.setTo(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
    return out2;
  },
  setPixel(x, y, r, g, b, a) {
    if (typeof r !== "number") {
      var color = r;
      r = color.red;
      g = color.green;
      b = color.blue;
      a = color.alpha;
    }
    if (a === void 0) {
      a = r !== 0 || g !== 0 || b !== 0 ? 255 : 0;
    }
    var imgData = this.context.createImageData(1, 1);
    imgData.data[0] = r;
    imgData.data[1] = g;
    imgData.data[2] = b;
    imgData.data[3] = a;
    this.context.putImageData(imgData, x, y);
    this.dirty = true;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/texture/CopyCanvasToTexture.js
var CopyCanvasToTexture = function(scene, srcCanvas, key2, x, y, width, height) {
  var textures = scene.sys.textures;
  var renderer = scene.renderer;
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  if (width === void 0) {
    width = srcCanvas.width;
  }
  if (height === void 0) {
    height = srcCanvas.height;
  }
  var texture;
  if (textures.exists(key2)) {
    texture = textures.get(key2);
  } else {
    texture = textures.createCanvas(key2, width, height);
  }
  var destCanvas = texture.getSourceImage();
  if (destCanvas.width !== width) {
    destCanvas.width = width;
  }
  if (destCanvas.height !== height) {
    destCanvas.height = height;
  }
  var destCtx = destCanvas.getContext("2d", { willReadFrequently: true });
  destCtx.clearRect(0, 0, width, height);
  destCtx.drawImage(srcCanvas, x, y, width, height);
  if (renderer.gl && texture) {
    renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
  }
};
var CopyCanvasToTexture_default = CopyCanvasToTexture;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvasbase/TextureMethods.js
var TextureMethods_default = {
  updateTexture(callback, scope) {
    if (callback) {
      var scale = this.resolution;
      if (scale !== 1) {
        this.context.save();
        this.context.scale(scale, scale);
      }
      if (scope) {
        callback.call(scope, this.canvas, this.context);
      } else {
        callback(this.canvas, this.context);
      }
      if (scale !== 1) {
        this.context.restore();
      }
    }
    if (this.canvas.width !== this.frame.width || this.canvas.height !== this.frame.height) {
      this.frame.setSize(this.canvas.width, this.canvas.height);
    }
    if (this.renderer && this.renderer.gl) {
      this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);
      if (typeof WEBGL_DEBUG) {
        this.frame.glTexture.spectorMetadata = { textureKey: "Canvas Game Object" };
      }
    }
    this.dirty = false;
    var input = this.input;
    if (input && !input.customHitArea) {
      input.hitArea.width = this.width;
      input.hitArea.height = this.height;
    }
    return this;
  },
  generateTexture(key2, x, y, width, height) {
    var srcCanvas = this.canvas;
    if (width === void 0) {
      width = srcCanvas.width;
    } else {
      width *= this.resolution;
    }
    if (height === void 0) {
      height = srcCanvas.height;
    } else {
      height *= this.resolution;
    }
    CopyCanvasToTexture_default(this.scene, srcCanvas, key2, x, y, width, height);
    return this;
  },
  loadTexture(key2, frame) {
    var textureFrame = this.scene.sys.textures.getFrame(key2, frame);
    if (!textureFrame) {
      return this;
    }
    if (this.width !== textureFrame.cutWidth || this.height !== textureFrame.cutHeight) {
      this.setSize(textureFrame.cutWidth, textureFrame.cutHeight);
    } else {
      this.clear();
    }
    this.drawFrame(key2, frame);
    this.dirty = true;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvasbase/Canvas.js
CheckP3Version_default();
var CanvasPool = Phaser.Display.Canvas.CanvasPool;
var GameObject2 = Phaser.GameObjects.GameObject;
var UUID = Phaser.Utils.String.UUID;
var Canvas = class extends GameObject2 {
  constructor(scene, x, y, width, height, resolution) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (resolution === void 0) {
      resolution = 1;
    }
    super(scene, "rexCanvas");
    this.renderer = scene.sys.game.renderer;
    this._width = width;
    this._height = height;
    this.resolution = resolution;
    width = Math.max(Math.ceil(width * this.resolution), 1);
    height = Math.max(Math.ceil(height * this.resolution), 1);
    this.canvas = CanvasPool.create(this, width, height);
    this.context = this.canvas.getContext("2d", { willReadFrequently: true });
    this.dirty = false;
    this.setPosition(x, y);
    this.setOrigin(0.5, 0.5);
    this.initPipeline();
    this.initPostPipeline(true);
    this._crop = this.resetCropObject();
    this._textureKey = UUID();
    this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);
    this.frame = this.texture.get();
    this.frame.source.resolution = this.resolution;
    if (this.renderer && this.renderer.gl) {
      this.renderer.deleteTexture(this.frame.source.glTexture);
      this.frame.source.glTexture = null;
    }
    this.dirty = true;
  }
  preDestroy() {
    CanvasPool.remove(this.canvas);
    this.canvas = null;
    this.context = null;
    var texture = this.texture;
    if (texture) {
      texture.destroy();
    }
  }
  setResolution(resolution) {
    if (this.resolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    var width = Math.max(Math.ceil(this.width * resolution), 1);
    var height = Math.max(Math.ceil(this.height * resolution), 1);
    this.canvas.width = width;
    this.canvas.height = height;
    this.frame.source.resolution = resolution;
    this.dirty = true;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this.setSize(value, this._height);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this.setSize(this._width, value);
  }
  setCanvasSize(width, height) {
    if (this._width === width && this._height === height) {
      return this;
    }
    this._width = width;
    this._height = height;
    this.updateDisplayOrigin();
    width = Math.max(Math.ceil(width * this.resolution), 1);
    height = Math.max(Math.ceil(height * this.resolution), 1);
    this.canvas.width = width;
    this.canvas.height = height;
    this.frame.setSize(width, height);
    this.dirty = true;
    return this;
  }
  // setSize might be override
  setSize(width, height) {
    this.setCanvasSize(width, height);
    return this;
  }
  get displayWidth() {
    return this.scaleX * this._width;
  }
  set displayWidth(value) {
    this.scaleX = value / this._width;
  }
  get displayHeight() {
    return this.scaleY * this._height;
  }
  set displayHeight(value) {
    this.scaleY = value / this._height;
  }
  setDisplaySize(width, height) {
    this.displayWidth = width;
    this.displayHeight = height;
    return this;
  }
  getCanvas(readOnly) {
    if (!readOnly) {
      this.dirty = true;
    }
    return this.canvas;
  }
  getContext(readOnly) {
    if (!readOnly) {
      this.dirty = true;
    }
    return this.context;
  }
  needRedraw() {
    this.dirty = true;
    return this;
  }
  resize(width, height) {
    this.setSize(width, height);
    return this;
  }
};
var Components3 = Phaser.GameObjects.Components;
Phaser.Class.mixin(
  Canvas,
  [
    Components3.Alpha,
    Components3.BlendMode,
    Components3.Crop,
    Components3.Depth,
    Components3.Flip,
    Components3.GetBounds,
    Components3.Mask,
    Components3.Origin,
    Components3.Pipeline,
    Components3.PostPipeline,
    Components3.ScrollFactor,
    Components3.Tint,
    Components3.Transform,
    Components3.Visible,
    Render_default3,
    CanvasMethods_default,
    TextureMethods_default
  ]
);
var Canvas_default = Canvas;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/GetStyle.js
var Pad = Phaser.Utils.String.Pad;
var GetStyle = function(style, canvas, context) {
  if (style == null) {
    return style;
  }
  switch (typeof style) {
    case "string":
      return style;
    case "number":
      return `#${Pad(Math.floor(style).toString(16), 6, "0", 1)}`;
    case "function":
      return style(canvas, context);
    case "object":
      if (style.hasOwnProperty("r")) {
        if (style.hasOwnProperty("a")) {
          return `rgba(${style.r},${style.g},${style.b},${style.a})`;
        } else {
          return `rgb(${style.r},${style.g},${style.b})`;
        }
      } else if (style.hasOwnProperty("h")) {
        if (style.hasOwnProperty("a")) {
          return `hsla(${style.h},${style.s},${style.l},${style.a})`;
        } else {
          return `hsl(${style.h},${style.s},${style.l})`;
        }
      } else {
        return style;
      }
    default:
      return style;
  }
};
var GetStyle_default = GetStyle;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/AddRoundRectanglePath.js
var DegToRad3 = Phaser.Math.DegToRad;
var AddRoundRectanglePath = function(context, x, y, width, height, radiusConfig, iteration) {
  var geom = new RoundRectangle_default(x, y, width, height, radiusConfig), minWidth = geom.minWidth, minHeight = geom.minHeight, scaleRX = width >= minWidth ? 1 : width / minWidth, scaleRY = height >= minHeight ? 1 : height / minHeight;
  var cornerRadius = geom.cornerRadius;
  var radius, radiusX, radiusY, centerX, centerY;
  var startX, startY;
  context.save();
  context.beginPath();
  context.translate(x, y);
  radius = cornerRadius.tl;
  if (IsArcCorner2(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = radiusX;
      centerY = radiusY;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 180, 270, false, iteration);
    } else {
      centerX = 0;
      centerY = 0;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 90, 0, true, iteration);
    }
    startX = 0;
    startY = radiusY;
  } else {
    context.lineTo(0, 0);
    startX = 0;
    startY = 0;
  }
  radius = cornerRadius.tr;
  if (IsArcCorner2(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = width - radiusX;
      centerY = radiusY;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 270, 360, false, iteration);
    } else {
      centerX = width;
      centerY = 0;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 180, 90, true, iteration);
    }
  } else {
    context.lineTo(width, 0);
  }
  radius = cornerRadius.br;
  if (IsArcCorner2(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = width - radiusX;
      centerY = height - radiusY;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 0, 90, false, iteration);
    } else {
      centerX = width;
      centerY = height;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 270, 180, true, iteration);
    }
  } else {
    context.lineTo(width, height);
  }
  radius = cornerRadius.bl;
  if (IsArcCorner2(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = radiusX;
      centerY = height - radiusY;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 90, 180, false, iteration);
    } else {
      centerX = 0;
      centerY = height;
      ArcTo2(context, centerX, centerY, radiusX, radiusY, 360, 270, true, iteration);
    }
  } else {
    context.lineTo(0, height);
  }
  context.lineTo(startX, startY);
  context.closePath();
  context.restore();
};
var IsConvexArc = function(radius) {
  return !radius.hasOwnProperty("convex") || // radius does not have convex property
  radius.convex;
};
var IsArcCorner2 = function(radius) {
  return radius.x > 0 && radius.y > 0;
};
var ArcTo2 = function(context, centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration) {
  if (antiClockWise && endAngle > startAngle) {
    endAngle -= 360;
  } else if (!antiClockWise && endAngle < startAngle) {
    endAngle += 360;
  }
  startAngle = DegToRad3(startAngle);
  endAngle = DegToRad3(endAngle);
  if (iteration == null) {
    context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, antiClockWise);
  } else {
    iteration += 1;
    var x, y, angle;
    var step = (endAngle - startAngle) / iteration;
    for (var i = 0; i <= iteration; i++) {
      angle = startAngle + step * i;
      x = centerX + radiusX * Math.cos(angle);
      y = centerY + radiusY * Math.sin(angle);
      context.lineTo(x, y);
    }
  }
};
var AddRoundRectanglePath_default = AddRoundRectanglePath;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/DrawRoundRectangle.js
var DrawRoundRectangle = function(canvas, context, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient, iteration) {
  AddRoundRectanglePath_default(context, x, y, width, height, radiusConfig, iteration);
  if (fillStyle != null) {
    if (fillColor2 != null) {
      var grd;
      if (isHorizontalGradient) {
        grd = context.createLinearGradient(0, 0, width, 0);
      } else {
        grd = context.createLinearGradient(0, 0, 0, height);
      }
      grd.addColorStop(0, fillStyle);
      grd.addColorStop(1, fillColor2);
      fillStyle = grd;
    }
    context.fillStyle = fillStyle;
    context.fill();
  }
  if (strokeStyle != null && lineWidth > 0) {
    context.strokeStyle = strokeStyle;
    context.lineWidth = lineWidth;
    context.stroke();
  }
};
var DrawRoundRectangle_default = DrawRoundRectangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/utils/DrawRoundRectangleBackground.js
var DrawRoundRectangleBackground = function(canvasObject, color, strokeColor, strokeLineWidth, radius, color2, isHorizontalGradient, iteration) {
  if (color == null && strokeColor == null) {
    return;
  }
  var width = canvasObject.canvas.width, height = canvasObject.canvas.height;
  if (strokeColor == null) {
    strokeLineWidth = 0;
  }
  var x = strokeLineWidth / 2;
  width = Math.max(1, width - strokeLineWidth);
  height = Math.max(1, height - strokeLineWidth);
  DrawRoundRectangle_default(
    canvasObject.canvas,
    canvasObject.context,
    x,
    x,
    width,
    height,
    radius,
    color,
    strokeColor,
    strokeLineWidth,
    color2,
    isHorizontalGradient,
    iteration
  );
};
var DrawRoundRectangleBackground_default = DrawRoundRectangleBackground;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/roundrectangle/DrawContent.js
var DrawContent = function() {
  DrawRoundRectangleBackground_default(
    this,
    this.fillStyle,
    this.strokeStyle,
    this.lineWidth,
    this.radius,
    this.fillColor2,
    this.isHorizontalGradient,
    this.iteration
  );
};
var DrawContent_default = DrawContent;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/roundrectangle/RoundRectangle.js
var GetValue9 = Phaser.Utils.Objects.GetValue;
var RoundRectangle3 = class extends Canvas_default {
  constructor(scene, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient, resolution) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = width;
    }
    if (radiusConfig === void 0) {
      radiusConfig = 0;
    }
    if (resolution === void 0) {
      resolution = 1;
    }
    super(scene, x, y, width, height, resolution);
    this.type = "rexRoundRectangleCanvas";
    var radius = GetValue9(radiusConfig, "radius", radiusConfig);
    var iteration = GetValue9(radiusConfig, "iteration", void 0);
    this.setRadius(radius);
    this.setIteration(iteration);
    this.setFillStyle(fillStyle, fillColor2, isHorizontalGradient);
    this.setStrokeStyle(strokeStyle, lineWidth);
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this.dirty |= this._radius != value;
    this._radius = value;
  }
  setRadius(radius) {
    this.radius = radius;
    return this;
  }
  get iteration() {
    return this._iteration;
  }
  set iteration(value) {
    this.dirty |= this._iteration != value;
    this._iteration = value;
  }
  setIteration(iteration) {
    this.iteration = iteration;
    return this;
  }
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty |= this._fillStyle != value;
    this._fillStyle = value;
  }
  get fillColor2() {
    return this._fillColor2;
  }
  set fillColor2(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty |= this._fillColor2 != value;
    this._fillColor2 = value;
  }
  get isHorizontalGradient() {
    return this._isHorizontalGradient;
  }
  set isHorizontalGradient(value) {
    this.dirty |= this._isHorizontalGradient != value;
    this._isHorizontalGradient = value;
  }
  setFillStyle(fillStyle, fillColor2, isHorizontalGradient) {
    if (isHorizontalGradient === void 0) {
      isHorizontalGradient = true;
    }
    this.fillStyle = fillStyle;
    this.fillColor2 = fillColor2;
    this.isHorizontalGradient = isHorizontalGradient;
    return this;
  }
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty |= this._strokeStyle != value;
    this._strokeStyle = value;
  }
  get lineWidth() {
    return this._lineWidth;
  }
  set lineWidth(value) {
    this.dirty |= this._lineWidth != value;
    this._lineWidth = value;
  }
  setStrokeStyle(strokeStyle, lineWidth) {
    this.strokeStyle = strokeStyle;
    this.lineWidth = lineWidth;
    return this;
  }
  updateTexture() {
    super.updateTexture(function() {
      this.clear();
      DrawContent_default.call(this);
    }, this);
    return this;
  }
};
var RoundRectangle_default4 = RoundRectangle3;

// node_modules/phaser3-rex-plugins/plugins/roundrectanglecanvas.js
var roundrectanglecanvas_default = RoundRectangle_default4;

// node_modules/phaser3-rex-plugins/templates/ui/roundrectanglecanvas/RoundRectangleCanvas.js
var RoundRectangleCanvas_default = roundrectanglecanvas_default;

// node_modules/phaser3-rex-plugins/templates/ui/roundrectanglecanvas/Factory.js
ObjectFactory_default.register("roundRectangleCanvas", function(x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient) {
  var gameObject2 = new RoundRectangleCanvas_default(this.scene, x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.RoundRectangleCanvas", RoundRectangleCanvas_default);

// node_modules/phaser3-rex-plugins/plugins/utils/object/HasProperty.js
var HasProperty = function(obj, prop) {
  if (!obj) {
    return false;
  }
  if (obj.hasOwnProperty(prop)) {
    return true;
  }
  while (obj) {
    if (Object.getOwnPropertyDescriptor(obj, prop)) {
      return true;
    }
    obj = obj.__proto__;
  }
  return false;
};
var HasProperty_default = HasProperty;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/quad/methods/PointMethods.js
var InjectPointAccessProperties = function(gameObject2, key2, point) {
  if (!key2 || HasProperty_default(gameObject2, `${key2}X`)) {
    return;
  }
  Object.defineProperty(gameObject2, `${key2}X`, {
    get: function() {
      return point.x;
    },
    set: function(value) {
      point.x = value;
      gameObject2.dirty = true;
    }
  });
  Object.defineProperty(gameObject2, `${key2}Y`, {
    get: function() {
      return point.y;
    },
    set: function(value) {
      point.y = value;
      gameObject2.dirty = true;
    }
  });
  Object.defineProperty(gameObject2, `${key2}T`, {
    get: function() {
      return point.t;
    },
    set: function(value) {
      point.t = value;
      gameObject2.dirty = true;
    }
  });
};
var PointMethods_default = {
  setTLPosition(x, y) {
    this.geom.setTLPosition(x, y);
    this.dirty = true;
    return this;
  },
  setTRPosition(x, y) {
    this.geom.setTRPosition(x, y);
    this.dirty = true;
    return this;
  },
  setBLPosition(x, y) {
    this.geom.setBLPosition(x, y);
    this.dirty = true;
    return this;
  },
  setBRPosition(x, y) {
    this.geom.setBRPosition(x, y);
    this.dirty = true;
    return this;
  },
  resetCornerPosition() {
    this.geom.resetCornerPosition();
    this.dirty = true;
    return this;
  },
  insertTopSidePoint(t, x, y, key2) {
    var points = this.geom.topSidePoints;
    if (Array.isArray(t)) {
      var points = t, point;
      for (var i = 0, cnt = points.length; i < cnt; i++) {
        point = points[i];
        this.geom.insertTopSidePoint(point.t, point.x, point.y);
        InjectPointAccessProperties(this, point.key, points[points.length - 1]);
      }
    } else {
      this.geom.insertTopSidePoint(t, x, y);
      InjectPointAccessProperties(this, key2, points[points.length - 1]);
    }
    this.dirty = true;
    return this;
  },
  insertRightSidePoint(t, x, y, key2) {
    var points = this.geom.rightSidePoints;
    if (Array.isArray(t)) {
      var points = t, point;
      for (var i = 0, cnt = points.length; i < cnt; i++) {
        point = points[i];
        this.geom.insertRightSidePoint(point.t, point.x, point.y);
        InjectPointAccessProperties(this, point.key, points[points.length - 1]);
      }
    } else {
      this.geom.insertRightSidePoint(t, x, y);
      InjectPointAccessProperties(this, key2, points[points.length - 1]);
    }
    this.dirty = true;
    return this;
  },
  insertBottomSidePoint(t, x, y, key2) {
    var points = this.geom.bottomSidePoints;
    if (Array.isArray(t)) {
      var points = t, point;
      for (var i = 0, cnt = points.length; i < cnt; i++) {
        point = points[i];
        this.geom.insertBottomSidePoint(point.t, point.x, point.y);
        InjectPointAccessProperties(this, point.key, points[points.length - 1]);
      }
    } else {
      this.geom.insertBottomSidePoint(t, x, y);
      InjectPointAccessProperties(this, key2, points[points.length - 1]);
    }
    this.dirty = true;
    return this;
  },
  insertLeftSidePoint(t, x, y, key2) {
    var points = this.geom.leftSidePoints;
    if (Array.isArray(t)) {
      var points = t, point;
      for (var i = 0, cnt = points.length; i < cnt; i++) {
        point = points[i];
        this.geom.insertLeftSidePoint(point.t, point.x, point.y);
        InjectPointAccessProperties(this, point.key, points[points.length - 1]);
      }
    } else {
      this.geom.insertLeftSidePoint(t, x, y);
      InjectPointAccessProperties(this, key2, points[points.length - 1]);
    }
    this.dirty = true;
    return this;
  },
  clearTopSidePoints() {
    this.geom.clearTopSidePoints();
    this.dirty = true;
    return this;
  },
  clearRightSidePoints() {
    this.geom.clearRightSidePoints();
    this.dirty = true;
    return this;
  },
  clearBottomSidePoints() {
    this.geom.clearBottomSidePoints();
    this.dirty = true;
    return this;
  },
  clearLeftSidePoints() {
    this.geom.clearLeftSidePoints();
    this.dirty = true;
    return this;
  },
  clearAllSidesPoints() {
    this.geom.clearAllSidesPoints();
    this.dirty = true;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/quad/methods/QuadGeom.js
var QuadGeom = class {
  constructor(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = x;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.setTo(x, y, width, height);
    this.tlx = 0;
    this.tly = 0;
    this.trx = 0;
    this.try = 0;
    this.blx = 0;
    this.bly = 0;
    this.brx = 0;
    this.bry = 0;
    this.topSidePoints = [];
    this.rightSidePoints = [];
    this.bottomSidePoints = [];
    this.leftSidePoints = [];
  }
  setTo(x, y, width, height) {
    this.setPosition(x, y);
    this.setSize(width, height);
    return this;
  }
  setPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  setTLPosition(x, y) {
    this.tlx = x;
    this.tly = y;
    return this;
  }
  setTRPosition(x, y) {
    this.trx = x;
    this.try = y;
    return this;
  }
  setBLPosition(x, y) {
    this.blx = x;
    this.bly = y;
    return this;
  }
  setBRPosition(x, y) {
    this.brx = x;
    this.bry = y;
    return this;
  }
  resetCornerPosition() {
    this.setTLPosition(0, 0).setTRPosition(0, 0).setBLPosition(0, 0).setBRPosition(0, 0);
    return this;
  }
  insertTopSidePoint(t, x, y) {
    AddPoint(this.topSidePoints, t, x, y);
    return this;
  }
  insertRightSidePoint(t, x, y) {
    AddPoint(this.rightSidePoints, t, x, y);
    return this;
  }
  insertBottomSidePoint(t, x, y) {
    AddPoint(this.bottomSidePoints, t, x, y);
    return this;
  }
  insertLeftSidePoint(t, x, y) {
    AddPoint(this.leftSidePoints, t, x, y);
    return this;
  }
  clearTopSidePoints() {
    this.topSidePoints.length = 0;
    return this;
  }
  clearRightSidePoints() {
    this.rightSidePoints.length = 0;
    return this;
  }
  clearBottomSidePoints() {
    this.bottomSidePoints.length = 0;
    return this;
  }
  clearLeftSidePoints() {
    this.leftSidePoints.length = 0;
    return this;
  }
  clearAllSidesPoints() {
    this.clearTopSidePoints().clearRightSidePoints().clearBottomSidePoints().clearLeftSidePoints();
    return this;
  }
};
var AddPoint = function(points, t, x, y) {
  if (typeof t !== "number") {
    var config = t;
    t = config.t;
    x = config.x;
    y = config.y;
  }
  points.push({ t, x, y });
};
var QuadGeom_default = QuadGeom;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/quad/Quad.js
var IsPlainObject6 = Phaser.Utils.Objects.IsPlainObject;
var GetValue10 = Phaser.Utils.Objects.GetValue;
var Linear = Phaser.Math.Linear;
var Earcut2 = Phaser.Geom.Polygon.Earcut;
var Quad = class extends PolygnBase_default {
  constructor(scene, x, y, width, height, fillColor, fillAlpha) {
    var strokeColor, strokeAlpha, strokeWidth;
    if (IsPlainObject6(x)) {
      var config = x;
      x = config.x;
      y = config.y;
      width = config.width;
      height = config.height;
      fillColor = config.color;
      fillAlpha = config.alpha;
      strokeColor = config.strokeColor;
      strokeAlpha = config.strokeAlpha;
      strokeWidth = config.strokeWidth;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = width;
    }
    var geom = new QuadGeom_default();
    super(scene, "rexQuadShape", geom);
    geom.setTo(0, 0, width, height);
    this.setPosition(x, y);
    this.setFillStyle(fillColor, fillAlpha);
    if (strokeColor !== void 0 && strokeWidth === void 0) {
      strokeWidth = 2;
    }
    this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
    this.setTLPosition(GetValue10(config, "tlx", 0), GetValue10(config, "tly", 0)).setTRPosition(GetValue10(config, "trx", 0), GetValue10(config, "try", 0)).setBLPosition(GetValue10(config, "blx", 0), GetValue10(config, "bly", 0)).setBRPosition(GetValue10(config, "brx", 0), GetValue10(config, "bry", 0));
    var leftSidePoints = GetValue10(config, "leftSidePoints");
    if (leftSidePoints) {
      this.insertLeftSidePoint(leftSidePoints);
    }
    var topSidePoints = GetValue10(config, "topSidePoints");
    if (topSidePoints) {
      this.insertTopSidePoint(topSidePoints);
    }
    var rightSidePoints = GetValue10(config, "rightSidePoints");
    if (rightSidePoints) {
      this.insertRightSidePoint(rightSidePoints);
    }
    var bottomSidePoints = GetValue10(config, "bottomSidePoints");
    if (bottomSidePoints) {
      this.insertBottomSidePoint(bottomSidePoints);
    }
    this.updateDisplayOrigin();
    this.dirty = true;
  }
  updateData() {
    var geom = this.geom;
    var pathData = this.pathData;
    pathData.length = 0;
    var width = geom.width;
    var height = geom.height;
    var tlx = 0 + geom.tlx;
    var tly = 0 + geom.tly;
    var trx = width + geom.trx;
    var try_ = 0 + geom.try;
    var brx = width + geom.brx;
    var bry = height + geom.bry;
    var blx = 0 + geom.blx;
    var bly = height + geom.bly;
    var topSidePoints = geom.topSidePoints;
    var rightSidePoints = geom.rightSidePoints;
    var bottomSidePoints = geom.bottomSidePoints;
    var leftSidePoints = geom.leftSidePoints;
    LineTo_default(tlx, tly, pathData);
    SortPoints(topSidePoints);
    for (var i = 0, cnt = topSidePoints.length; i < cnt; i++) {
      var point = topSidePoints[i];
      var px = Linear(tlx, trx, point.t) + point.x;
      var py = Linear(tly, try_, point.t) + point.y;
      LineTo_default(px, py, pathData);
    }
    LineTo_default(trx, try_, pathData);
    SortPoints(rightSidePoints);
    for (var i = 0, cnt = rightSidePoints.length; i < cnt; i++) {
      var point = rightSidePoints[i];
      var px = Linear(trx, brx, point.t) + point.x;
      var py = Linear(try_, bry, point.t) + point.y;
      LineTo_default(px, py, pathData);
    }
    LineTo_default(brx, bry, pathData);
    SortPoints(bottomSidePoints);
    for (var i = bottomSidePoints.length - 1; i >= 0; i--) {
      var point = bottomSidePoints[i];
      var px = Linear(blx, brx, point.t) + point.x;
      var py = Linear(bly, bry, point.t) + point.y;
      LineTo_default(px, py, pathData);
    }
    LineTo_default(blx, bly, pathData);
    SortPoints(leftSidePoints);
    for (var i = leftSidePoints.length - 1; i >= 0; i--) {
      var point = leftSidePoints[i];
      var px = Linear(tlx, blx, point.t) + point.x;
      var py = Linear(tly, bly, point.t) + point.y;
      LineTo_default(px, py, pathData);
    }
    pathData.push(pathData[0], pathData[1]);
    this.pathIndexes = Earcut2(pathData);
    return this;
  }
  get tlx() {
    return this.geom.tlx;
  }
  set tlx(value) {
    this.geom.tlx = value;
    this.dirty = true;
  }
  get tly() {
    return this.geom.tly;
  }
  set tly(value) {
    this.geom.tly = value;
    this.dirty = true;
  }
  get trx() {
    return this.geom.trx;
  }
  set trx(value) {
    this.geom.trx = value;
    this.dirty = true;
  }
  get try() {
    return this.geom.try;
  }
  set try(value) {
    this.geom.try = value;
    this.dirty = true;
  }
  get blx() {
    return this.geom.blx;
  }
  set blx(value) {
    this.geom.blx = value;
    this.dirty = true;
  }
  get bly() {
    return this.geom.bly;
  }
  set bly(value) {
    this.geom.bly = value;
    this.dirty = true;
  }
  get brx() {
    return this.geom.brx;
  }
  set brx(value) {
    this.geom.brx = value;
    this.dirty = true;
  }
  get bry() {
    return this.geom.bry;
  }
  set bry(value) {
    this.geom.bry = value;
    this.dirty = true;
  }
  get leftSidePoints() {
    return this.geom.leftSidePoints;
  }
  get topSidePoints() {
    return this.geom.topSidePoints;
  }
  get bottomSidePoints() {
    return this.geom.bottomSidePoints;
  }
  get rightSidePoints() {
    return this.geom.rightSidePoints;
  }
};
var SortPoints = function(points) {
  if (points.length <= 1) {
    return;
  }
  points.sort(function(pointA, pointB) {
    return pointA.t - pointB.t;
  });
};
Object.assign(
  Quad.prototype,
  PointMethods_default
);
var Quad_default = Quad;

// node_modules/phaser3-rex-plugins/plugins/quadshape.js
var quadshape_default = Quad_default;

// node_modules/phaser3-rex-plugins/templates/ui/quadshape/QuadShape.js
var QuadShape_default = quadshape_default;

// node_modules/phaser3-rex-plugins/templates/ui/quadshape/Factory.js
ObjectFactory_default.register("QuadShape", function(x, y, width, height, fillColor, fillAlpha) {
  var gameObject2 = new QuadShape_default(this.scene, x, y, width, height, fillColor, fillAlpha);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.QuadShape", QuadShape_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/render/WebGLRenderer.js
var Utils4 = Phaser.Renderer.WebGL.Utils;
var WebGLRenderer3 = function(renderer, src, camera, parentMatrix3) {
  if (src.width === 0 || src.height === 0) {
    return;
  }
  camera.addToRenderList(src);
  var frame = src.frame;
  var width = frame.width;
  var height = frame.height;
  var getTint = Utils4.getTintAppendFloatAlpha;
  var pipeline = renderer.pipelines.set(src.pipeline, src);
  var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
  renderer.pipelines.preBatch(src);
  pipeline.batchTexture(
    src,
    frame.glTexture,
    width,
    height,
    src.x,
    src.y,
    width / src.style.resolution,
    height / src.style.resolution,
    src.scaleX,
    src.scaleY,
    src.rotation,
    src.flipX,
    src.flipY,
    src.scrollFactorX,
    src.scrollFactorY,
    src.displayOriginX,
    src.displayOriginY,
    0,
    0,
    width,
    height,
    getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
    getTint(src.tintTopRight, camera.alpha * src._alphaTR),
    getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
    getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
    src.tintFill,
    0,
    0,
    camera,
    parentMatrix3,
    false,
    textureUnit
  );
  renderer.pipelines.postBatch(src);
};
var WebGLRenderer_default4 = WebGLRenderer3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/render/CanvasRenderer.js
var CanvasRenderer3 = function(renderer, src, camera, parentMatrix3) {
  if (src.width === 0 || src.height === 0) {
    return;
  }
  camera.addToRenderList(src);
  renderer.batchSprite(src, src.frame, camera, parentMatrix3);
};
var CanvasRenderer_default4 = CanvasRenderer3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/render/Render.js
var Render_default4 = {
  renderWebGL: WebGLRenderer_default4,
  renderCanvas: CanvasRenderer_default4
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/MeasureTextMargins.js
var CanvasPool2 = Phaser.Display.Canvas.CanvasPool;
var MeasureTextMargins = function(textStyle, testString, out2) {
  if (out2 === void 0) {
    out2 = {};
  }
  var canvas = CanvasPool2.create(this);
  var context = canvas.getContext("2d", { willReadFrequently: true });
  textStyle.syncFont(canvas, context);
  var metrics = context.measureText(testString);
  var width = Math.ceil(metrics.width * textStyle.baselineX);
  var baseline = width;
  var height = 2 * baseline;
  baseline = baseline * textStyle.baselineY | 0;
  canvas.width = width;
  canvas.height = height;
  context.fillStyle = "#f00";
  context.fillRect(0, 0, width, height);
  context.font = textStyle._font;
  context.textBaseline = "alphabetic";
  context.fillStyle = "#000";
  context.fillText(textStyle.testString, 0, baseline);
  out2.left = 0;
  if (width === 0 || height === 0 || !context.getImageData(0, 0, width, height)) {
    CanvasPool2.remove(canvas);
    return out2;
  }
  var imagedata = context.getImageData(0, 0, width, height).data;
  var stop = false;
  for (var x = 0; x < width; x++) {
    for (var y = 0; y < height; y++) {
      var idx = (y * width + x) * 4;
      if (imagedata[idx] !== 255) {
        out2.left = x;
        stop = true;
        break;
      }
    }
    if (stop) {
      break;
    }
  }
  CanvasPool2.remove(canvas);
  return out2;
};
var MeasureTextMargins_default = MeasureTextMargins;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/TextBase.js
CheckP3Version_default();
var GameObject3 = Phaser.GameObjects.GameObject;
var TextBase = class extends GameObject3 {
  setStyle(style) {
    return this.style.setStyle(style);
  }
  setFont(font) {
    return this.style.setFont(font);
  }
  setFontFamily(family) {
    return this.style.setFontFamily(family);
  }
  setFontSize(size) {
    return this.style.setFontSize(size);
  }
  setFontStyle(style) {
    return this.style.setFontStyle(style);
  }
  setTestString(string) {
    return this.style.setTestString(string);
  }
  setFixedSize(width, height) {
    return this.style.setFixedSize(width, height);
  }
  setBackgroundColor(color, color2, isHorizontalGradient) {
    return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
  }
  setBackgroundStrokeColor(color, lineWidth) {
    return this.style.setBackgroundStrokeColor(color, lineWidth);
  }
  setBackgroundCornerRadius(radius, iteration) {
    return this.style.setBackgroundCornerRadius(radius, iteration);
  }
  setFill(color) {
    return this.style.setFill(color);
  }
  setColor(color) {
    return this.style.setColor(color);
  }
  setStroke(color, thickness) {
    return this.style.setStroke(color, thickness);
  }
  setShadow(x, y, color, blur, shadowStroke, shadowFill) {
    return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
  }
  setShadowOffset(x, y) {
    return this.style.setShadowOffset(x, y);
  }
  setShadowColor(color) {
    return this.style.setShadowColor(color);
  }
  setShadowBlur(blur) {
    return this.style.setShadowBlur(blur);
  }
  setShadowStroke(enabled) {
    return this.style.setShadowStroke(enabled);
  }
  setShadowFill(enabled) {
    return this.style.setShadowFill(enabled);
  }
  setUnderline(color, thickness, offset) {
    return this.style.setUnderline(color, thickness, offset);
  }
  setUnderlineColor(color) {
    return this.style.setUnderlineColor(color);
  }
  setUnderlineThickness(thickness) {
    return this.style.setUnderlineThickness(thickness);
  }
  setUnderlineOffset(offset) {
    return this.style.setUnderlineOffset(offset);
  }
  setStrikethrough(color, thickness, offset) {
    return this.style.setStrikethrough(color, thickness, offset);
  }
  setStrikethroughColor(color) {
    return this.style.setStrikethroughColor(color);
  }
  setStrikethroughThickness(thickness) {
    return this.style.setStrikethroughThickness(thickness);
  }
  setStrikethroughOffset(offset) {
    return this.style.setStrikethroughOffset(offset);
  }
  setWrapMode(mode) {
    return this.style.setWrapMode(mode);
  }
  setWrapWidth(width) {
    return this.style.setWrapWidth(width);
  }
  // Align with built-in text game object
  setWordWrapWidth(width) {
    return this.style.setWrapWidth(width);
  }
  setAlign(align) {
    return this.style.setHAlign(align);
  }
  setHAlign(align) {
    return this.style.setHAlign(align);
  }
  setVAlign(align) {
    return this.style.setVAlign(align);
  }
  get lineSpacing() {
    return this.style.lineSpacing;
  }
  set lineSpacing(value) {
    this.style.lineSpacing = value;
  }
  setLineSpacing(value) {
    this.style.lineSpacing = value;
    this.updateText(true);
    return this;
  }
  setXOffset(value) {
    return this.style.setXOffset(value);
  }
  setMaxLines(max) {
    return this.style.setMaxLines(max);
  }
  setResolution(value) {
    return this.style.setResolution(value);
  }
  getTextMetrics() {
    return this.style.getTextMetrics();
  }
  setTextMetrics(metrics, font) {
    return this.style.setTextMetrics(metrics, font);
  }
  measureTextMargins(testString, out2) {
    return MeasureTextMargins_default(this.style, testString, out2);
  }
};
var Components4 = Phaser.GameObjects.Components;
Phaser.Class.mixin(
  TextBase,
  [
    Components4.Alpha,
    Components4.BlendMode,
    Components4.ComputedSize,
    Components4.Crop,
    Components4.Depth,
    Components4.Flip,
    Components4.GetBounds,
    Components4.Mask,
    Components4.Origin,
    Components4.Pipeline,
    Components4.PostPipeline,
    Components4.ScrollFactor,
    Components4.Tint,
    Components4.Transform,
    Components4.Visible,
    Render_default4
  ]
);
var TextBase_default = TextBase;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/PropertyMap.js
var PropertyMap = {
  // background
  backgroundColor: ["backgroundColor", null, GetStyle_default],
  backgroundColor2: ["backgroundColor2", null, GetStyle_default],
  backgroundHorizontalGradient: ["backgroundHorizontalGradient", true, null],
  backgroundStrokeColor: ["backgroundStrokeColor", null, GetStyle_default],
  backgroundStrokeLineWidth: ["backgroundStrokeLineWidth", 2, null],
  backgroundCornerRadius: ["backgroundCornerRadius", 0, null],
  backgroundCornerIteration: ["backgroundCornerIteration", null, null],
  // font
  fontFamily: ["fontFamily", "Courier", null],
  fontSize: ["fontSize", "16px", null],
  fontStyle: ["fontStyle", "", null],
  color: ["color", "#fff", GetStyle_default],
  stroke: ["stroke", "#fff", GetStyle_default],
  strokeThickness: ["strokeThickness", 0, null],
  shadowOffsetX: ["shadow.offsetX", 0, null],
  shadowOffsetY: ["shadow.offsetY", 0, null],
  shadowColor: ["shadow.color", "#000", GetStyle_default],
  shadowBlur: ["shadow.blur", 0, null],
  shadowStroke: ["shadow.stroke", false, null],
  shadowFill: ["shadow.fill", false, null],
  // underline
  underlineColor: ["underline.color", "#000", GetStyle_default],
  underlineThickness: ["underline.thickness", 0, null],
  underlineOffset: ["underline.offset", 0, null],
  // strikethrough
  strikethroughColor: ["strikethrough.color", "#000", GetStyle_default],
  strikethroughThickness: ["strikethrough.thickness", 0, null],
  strikethroughOffset: ["strikethrough.offset", 0, null],
  // align
  halign: ["halign", "left", null],
  valign: ["valign", "top", null],
  // size
  maxLines: ["maxLines", 0, null],
  fixedWidth: ["fixedWidth", 0, null],
  fixedHeight: ["fixedHeight", 0, null],
  resolution: ["resolution", 0, null],
  lineSpacing: ["lineSpacing", 0, null],
  xOffset: ["xOffset", 0, null],
  rtl: ["rtl", false, null],
  testString: ["testString", "|MÃ‰qgy", null],
  baselineX: ["baselineX", 1.2, null],
  baselineY: ["baselineY", 1.4, null],
  // wrap
  wrapMode: ["wrap.mode", 0, null],
  wrapWidth: ["wrap.width", 0, null],
  wrapCallback: ["wrap.callback", null],
  wrapCallbackScope: ["wrap.callbackScope", null]
};
var PropertyMap_default = PropertyMap;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/MeasureText.js
var CanvasPool3 = Phaser.Display.Canvas.CanvasPool;
var MeasureText = function(textStyle) {
  var canvas = CanvasPool3.create(this);
  var context = canvas.getContext("2d", { willReadFrequently: true });
  textStyle.syncFont(canvas, context);
  var metrics = context.measureText(textStyle.testString);
  if ("actualBoundingBoxAscent" in metrics) {
    var ascent = metrics.actualBoundingBoxAscent;
    var descent = metrics.actualBoundingBoxDescent;
    var output = {
      ascent,
      descent,
      fontSize: ascent + descent
    };
    CanvasPool3.remove(canvas);
    return output;
  }
  var width = Math.ceil(metrics.width * textStyle.baselineX);
  var baseline = width;
  var height = 2 * baseline;
  baseline = baseline * textStyle.baselineY | 0;
  canvas.width = width;
  canvas.height = height;
  context.fillStyle = "#f00";
  context.fillRect(0, 0, width, height);
  context.font = textStyle._font;
  context.textBaseline = "alphabetic";
  context.fillStyle = "#000";
  context.fillText(textStyle.testString, 0, baseline);
  var output = {
    ascent: 0,
    descent: 0,
    fontSize: 0
  };
  if (!context.getImageData(0, 0, width, height)) {
    output.ascent = baseline;
    output.descent = baseline + 6;
    output.fontSize = output.ascent + output.descent;
    CanvasPool3.remove(canvas);
    return output;
  }
  var imagedata = context.getImageData(0, 0, width, height).data;
  var pixels = imagedata.length;
  var line = width * 4;
  var i;
  var j;
  var idx = 0;
  var stop = false;
  for (i = 0; i < baseline; i++) {
    for (j = 0; j < line; j += 4) {
      if (imagedata[idx + j] !== 255) {
        stop = true;
        break;
      }
    }
    if (!stop) {
      idx += line;
    } else {
      break;
    }
  }
  output.ascent = baseline - i;
  idx = pixels - line;
  stop = false;
  for (i = height; i > baseline; i--) {
    for (j = 0; j < line; j += 4) {
      if (imagedata[idx + j] !== 255) {
        stop = true;
        break;
      }
    }
    if (!stop) {
      idx -= line;
    } else {
      break;
    }
  }
  output.descent = i - baseline;
  output.fontSize = output.ascent + output.descent;
  CanvasPool3.remove(canvas);
  return output;
};
var MeasureText_default = MeasureText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/const.js
var CONST = {
  // new line mode
  NO_NEWLINE: 0,
  RAW_NEWLINE: 1,
  WRAPPED_NEWLINE: 2,
  // wrap mode
  NO_WRAP: 0,
  WORD_WRAP: 1,
  CHAR_WRAP: 2,
  MIX_WRAP: 3,
  // split lines
  SPLITREGEXP: /(?:\r\n|\r|\n)/
};
var const_default = CONST;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/WrapModes.js
var WRAPMODE = {
  none: const_default.NO_WRAP,
  word: const_default.WORD_WRAP,
  char: const_default.CHAR_WRAP,
  character: const_default.CHAR_WRAP,
  mix: const_default.MIX_WRAP
};
var WrapModes_default = WRAPMODE;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/TextStyle.js
var GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
var GetValue11 = Phaser.Utils.Objects.GetValue;
var TextStyle = class {
  constructor(text, style, propertyMap) {
    this.parent = text;
    if (propertyMap === void 0) {
      propertyMap = PropertyMap_default;
    }
    this.propertyMap = propertyMap;
    this.backgroundColor;
    this.backgroundColor2;
    this.backgroundHorizontalGradient;
    this.backgroundStrokeColor;
    this.backgroundStrokeLineWidth;
    this.backgroundCornerRadius;
    this.backgroundCornerIteration;
    this.fontFamily;
    this.fontSize;
    this.fontStyle;
    this.color;
    this.stroke;
    this.strokeThickness;
    this.shadowOffsetX;
    this.shadowOffsetY;
    this.shadowColor;
    this.shadowBlur;
    this.shadowStroke;
    this.shadowFill;
    this.underlineColor;
    this.underlineThickness;
    this.underlineOffset;
    this.strikethroughColor;
    this.strikethroughThickness;
    this.strikethroughOffset;
    this.halign;
    this.valign;
    this.maxLines;
    this.fixedWidth;
    this.fixedHeight;
    this.resolution;
    this.xOffset;
    this.rtl;
    this.testString;
    this.baselineX;
    this.baselineY;
    this.wrapMode;
    this.wrapWidth;
    this.wrapCallback;
    this.wrapCallbackScope;
    this._font;
    this.setStyle(style, false, true);
  }
  get isWrapFitMode() {
    return this.fixedWidth > 0 && this.wrapMode !== const_default.NO_WRAP && this.wrapWidth === 0;
  }
  setStyle(style, updateText, setDefaults) {
    if (updateText === void 0) {
      updateText = true;
    }
    if (setDefaults === void 0) {
      setDefaults = false;
    }
    if (style && style.hasOwnProperty("wordWrap")) {
      var wordWrap = style.wordWrap;
      if (wordWrap.hasOwnProperty("width")) {
        style.wrap = {
          mode: "word",
          width: wordWrap.width
        };
      }
    }
    if (style && style.hasOwnProperty("wrap")) {
      var wrap = style.wrap;
      if (wrap.hasOwnProperty("mode")) {
        var mode = wrap.mode;
        if (typeof mode === "string") {
          wrap.mode = WrapModes_default[mode];
        }
      } else {
        if (wrap.hasOwnProperty("width")) {
          wrap.mode = 1;
        }
      }
    }
    if (style && style.rtl && setDefaults && !style.hasOwnProperty("halign")) {
      style.halign = "right";
    }
    if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
      style.fontSize = style.fontSize.toString() + "px";
    }
    var propertyMap = this.propertyMap;
    for (var key2 in propertyMap) {
      var prop = propertyMap[key2];
      var objKey = prop[0];
      var defaultValue = setDefaults ? prop[1] : this[key2];
      var postCallback = prop[2];
      if (key2 === "wrapCallback" || key2 === "wrapCallbackScope") {
        this[key2] = GetValue11(style, objKey, defaultValue);
      } else {
        var value = GetAdvancedValue(style, objKey, defaultValue);
        if (postCallback) {
          value = postCallback(value);
        }
        this[key2] = value;
      }
    }
    var font = GetValue11(style, "font", null);
    if (font === null) {
      this._font = this.fontStyle + " " + this.fontSize + " " + this.fontFamily;
    } else {
      this._font = font;
    }
    var fill = GetValue11(style, "fill", null);
    if (fill !== null) {
      this.color = GetStyle_default(fill);
    }
    var metrics = GetValue11(style, "metrics", false);
    if (metrics) {
      this.metrics = {
        ascent: GetValue11(metrics, "ascent", 0),
        descent: GetValue11(metrics, "descent", 0),
        fontSize: GetValue11(metrics, "fontSize", 0)
      };
    } else if (updateText || !this.metrics) {
      this.metrics = MeasureText_default(this);
    }
    if (updateText) {
      return this.parent.updateText();
    } else {
      return this.parent;
    }
  }
  syncFont(canvas, context) {
    context.font = this._font;
  }
  syncStyle(canvas, context) {
    context.textBaseline = "alphabetic";
    context.fillStyle = this.color;
    context.strokeStyle = this.stroke;
    context.lineWidth = this.strokeThickness;
    context.lineCap = "round";
    context.lineJoin = "round";
  }
  syncShadow(context, enabled) {
    if (enabled) {
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
    } else {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowColor = 0;
      context.shadowBlur = 0;
    }
  }
  update(recalculateMetrics) {
    if (recalculateMetrics) {
      this._font = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();
      this.metrics = MeasureText_default(this);
    }
    return this.parent.updateText(recalculateMetrics);
  }
  buildFont() {
    var newFont = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();
    if (newFont !== this._font) {
      this._font = newFont;
    }
    return this;
  }
  setFont(font) {
    if (typeof font === "string") {
      this.fontFamily = font;
      this.fontSize = "";
      this.fontStyle = "";
    } else {
      this.fontFamily = GetValue11(font, "fontFamily", "Courier");
      this.fontSize = GetValue11(font, "fontSize", "16px");
      this.fontStyle = GetValue11(font, "fontStyle", "");
    }
    return this.update(true);
  }
  setFontFamily(family) {
    this.fontFamily = family;
    return this.update(true);
  }
  setFontStyle(style) {
    this.fontStyle = style;
    return this.update(true);
  }
  setFontSize(size) {
    if (typeof size === "number") {
      size = size.toString() + "px";
    }
    this.fontSize = size;
    return this.update(true);
  }
  setTestString(string) {
    this.testString = string;
    return this.update(true);
  }
  setFixedSize(width, height) {
    this.fixedWidth = width;
    this.fixedHeight = height;
    if (width) {
      this.parent.width = width;
    }
    if (height) {
      this.parent.height = height;
    }
    return this.update(this.isWrapFitMode);
  }
  setResolution(value) {
    this.resolution = value;
    return this.update(false);
  }
  setXOffset(value) {
    this.xOffset = value;
    return this.update(false);
  }
  setBackgroundColor(color, color2, isHorizontalGradient) {
    if (isHorizontalGradient === void 0) {
      isHorizontalGradient = true;
    }
    this.backgroundColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.backgroundColor2 = GetStyle_default(color2, this.parent.canvas, this.parent.context);
    this.backgroundHorizontalGradient = isHorizontalGradient;
    return this.update(false);
  }
  setBackgroundStrokeColor(color, lineWidth) {
    this.backgroundStrokeColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.backgroundStrokeLineWidth = lineWidth;
    return this.update(false);
  }
  setBackgroundCornerRadius(radius, iteration) {
    this.backgroundCornerRadius = radius;
    this.backgroundCornerIteration = iteration;
    return this.update(false);
  }
  setFill(color) {
    this.color = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setColor(color) {
    this.color = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setStroke(color, thickness) {
    if (color === void 0) {
      this.strokeThickness = 0;
    } else {
      if (thickness === void 0) {
        thickness = this.strokeThickness;
      }
      this.stroke = GetStyle_default(color, this.parent.canvas, this.parent.context);
      this.strokeThickness = thickness;
    }
    return this.update(true);
  }
  setShadow(x, y, color, blur, shadowStroke, shadowFill) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (color === void 0) {
      color = "#000";
    }
    if (blur === void 0) {
      blur = 0;
    }
    if (shadowStroke === void 0) {
      shadowStroke = false;
    }
    if (shadowFill === void 0) {
      shadowFill = true;
    }
    this.shadowOffsetX = x;
    this.shadowOffsetY = y;
    this.shadowColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.shadowBlur = blur;
    this.shadowStroke = shadowStroke;
    this.shadowFill = shadowFill;
    return this.update(false);
  }
  setShadowOffset(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = x;
    }
    this.shadowOffsetX = x;
    this.shadowOffsetY = y;
    return this.update(false);
  }
  setShadowColor(color) {
    if (color === void 0) {
      color = "#000";
    }
    this.shadowColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setShadowBlur(blur) {
    if (blur === void 0) {
      blur = 0;
    }
    this.shadowBlur = blur;
    return this.update(false);
  }
  setShadowStroke(enabled) {
    this.shadowStroke = enabled;
    return this.update(false);
  }
  setShadowFill(enabled) {
    this.shadowFill = enabled;
    return this.update(false);
  }
  setUnderline(color, thickness, offset) {
    if (color === void 0) {
      color = "#000";
    }
    if (thickness === void 0) {
      thickness = 0;
    }
    if (offset === void 0) {
      offset = 0;
    }
    this.underlineColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.underlineThickness = thickness;
    this.underlineOffset = offset;
    return this.update(false);
  }
  setUnderlineColor(color) {
    if (color === void 0) {
      color = "#000";
    }
    this.underlineColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setUnderlineThickness(thickness) {
    if (thickness === void 0) {
      thickness = 0;
    }
    this.underlineThickness = thickness;
    return this.update(false);
  }
  setUnderlineOffset(offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.underlineOffset = offset;
    return this.update(false);
  }
  setStrikethrough(color, thickness, offset) {
    if (color === void 0) {
      color = "#000";
    }
    if (thickness === void 0) {
      thickness = 0;
    }
    if (offset === void 0) {
      offset = 0;
    }
    this.strikethroughColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.strikethroughThickness = thickness;
    this.strikethroughOffset = offset;
    return this.update(false);
  }
  setStrikethroughColor(color) {
    if (color === void 0) {
      color = "#000";
    }
    this.strikethroughColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setStrikethroughThickness(thickness) {
    if (thickness === void 0) {
      thickness = 0;
    }
    this.strikethroughThickness = thickness;
    return this.update(false);
  }
  setStrikethroughOffset(offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.strikethroughOffset = offset;
    return this.update(false);
  }
  setWrapMode(mode) {
    if (typeof mode === "string") {
      mode = WrapModes_default[mode.toLowerCase()] || 0;
    }
    this.wrapMode = mode;
    return this.update(true);
  }
  setWrapWidth(width) {
    this.wrapWidth = width;
    return this.update(false);
  }
  setAlign(halign, valign) {
    if (halign === void 0) {
      halign = "left";
    }
    if (valign === void 0) {
      valign = "top";
    }
    this.halign = halign;
    this.valign = valign;
    return this.update(false);
  }
  setHAlign(halign) {
    if (halign === void 0) {
      halign = "left";
    }
    this.halign = halign;
    return this.update(false);
  }
  setVAlign(valign) {
    if (valign === void 0) {
      valign = "top";
    }
    this.valign = valign;
    return this.update(false);
  }
  setMaxLines(max) {
    if (max === void 0) {
      max = 0;
    }
    this.maxLines = max;
    return this.update(false);
  }
  getTextMetrics() {
    var metrics = this.metrics;
    return {
      ascent: metrics.ascent,
      descent: metrics.descent,
      fontSize: metrics.fontSize
    };
  }
  setTextMetrics(metrics, font) {
    this.metrics.ascent = metrics.ascent;
    this.metrics.descent = metrics.descent;
    this.metrics.fontSize = metrics.fontSize;
    if (font) {
      if (typeof font === "string") {
        this.fontFamily = font;
        this.fontSize = "";
        this.fontStyle = "";
      } else {
        this.fontFamily = GetValue11(font, "fontFamily", this.fontFamily);
        this.fontSize = GetValue11(font, "fontSize", this.fontSize);
        this.fontStyle = GetValue11(font, "fontStyle", this.fontStyle);
      }
    }
    return this.parent.updateText(true);
  }
  get lineHeight() {
    return this.metrics.fontSize + this.parent.lineSpacing;
  }
  toJSON() {
    var output = {};
    var propertyMap = this.propertyMap;
    for (var key2 in propertyMap) {
      output[key2] = this[key2];
    }
    output.metrics = this.getTextMetrics();
    return output;
  }
  destroy() {
    this.parent = void 0;
  }
};
var TextStyle_default = TextStyle;

// node_modules/phaser3-rex-plugins/plugins/utils/text/GetString.js
var GetString = function(value) {
  if (value == null) {
    value = "";
  } else if (Array.isArray(value)) {
    value = value.join("\n");
  } else if (typeof value === "number") {
    value = value.toString();
  }
  return value;
};
var GetString_default = GetString;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/canvastext/DrawMethods.js
var DrawMethods_default = {
  draw(startX, startY, textWidth, textHeight) {
    var penManager = this.penManager;
    this.hitAreaManager.clear();
    var context = this.context;
    context.save();
    var defaultStyle = this.defaultStyle;
    this.clear();
    DrawRoundRectangleBackground_default(
      this,
      defaultStyle.backgroundColor,
      defaultStyle.backgroundStrokeColor,
      defaultStyle.backgroundStrokeLineWidth,
      defaultStyle.backgroundCornerRadius,
      defaultStyle.backgroundColor2,
      defaultStyle.backgroundHorizontalGradient,
      defaultStyle.backgroundCornerIteration
    );
    startX += this.startXOffset;
    startY += this.startYOffset;
    var defaultHalign = defaultStyle.halign, valign = defaultStyle.valign;
    var lineWidth, lineHeight = defaultStyle.lineHeight;
    var lines = penManager.lines;
    var totalLinesNum = lines.length, maxLines = defaultStyle.maxLines;
    var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
    if (maxLines > 0 && totalLinesNum > maxLines) {
      drawLinesNum = maxLines;
      if (valign === "center") {
        drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
      } else if (valign === "bottom") {
        drawLineStartIdx = totalLinesNum - drawLinesNum;
      } else {
        drawLineStartIdx = 0;
      }
    } else {
      drawLinesNum = totalLinesNum;
      drawLineStartIdx = 0;
    }
    drawLineEndIdx = drawLineStartIdx + drawLinesNum;
    var offsetX, offsetY;
    var rtl = this.rtl, rtlOffset = rtl ? this.parent.width : void 0;
    if (valign === "center") {
      offsetY = Math.max((textHeight - drawLinesNum * lineHeight) / 2, 0);
    } else if (valign === "bottom") {
      offsetY = Math.max(textHeight - drawLinesNum * lineHeight - 2, 0);
    } else {
      offsetY = 0;
    }
    offsetY += startY;
    for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
      lineWidth = penManager.getLineWidth(lineIdx);
      if (lineWidth === 0) {
        continue;
      }
      var pens = lines[lineIdx], penCount = pens.length;
      var halign = defaultHalign;
      for (var penIdx = 0; penIdx < penCount; penIdx++) {
        var penAlign = pens[penIdx].prop.align;
        if (penAlign !== void 0) {
          halign = penAlign;
          break;
        }
      }
      if (halign === "center") {
        offsetX = (textWidth - lineWidth) / 2;
      } else if (halign === "right") {
        offsetX = !rtl ? textWidth - lineWidth : 0;
      } else {
        offsetX = !rtl ? 0 : textWidth - lineWidth;
      }
      offsetX += startX;
      for (var penIdx = 0; penIdx < penCount; penIdx++) {
        this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
      }
    }
    context.restore();
  },
  drawPen(pen, offsetX, offsetY, rtlOffset) {
    offsetX += pen.x;
    offsetY += pen.y + (pen.prop.y || 0);
    if (rtlOffset !== void 0) {
      offsetX = rtlOffset - offsetX;
    }
    var canvas = this.canvas;
    var context = this.context;
    context.save();
    var curStyle = this.parser.propToContextStyle(this.defaultStyle, pen.prop);
    if (curStyle.bgcolor !== null && pen.width > 0) {
      var metrics = this.defaultStyle.metrics;
      var bgTLY = offsetY - metrics.ascent;
      var bgHeight = metrics.fontSize;
      this.drawRectangle(offsetX, bgTLY, pen.width, bgHeight, curStyle.bgcolor, curStyle);
    }
    if (curStyle.underlineThickness > 0 && pen.width > 0) {
      var lineOffsetY = offsetY + curStyle.underlineOffset - curStyle.underlineThickness / 2;
      this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.underlineThickness, curStyle.underlineColor, curStyle);
    }
    if (pen.isTextPen) {
      curStyle.buildFont();
      curStyle.syncFont(canvas, context);
      curStyle.syncStyle(canvas, context);
      this.drawText(offsetX, offsetY, pen.text, curStyle);
    }
    if (pen.isImagePen) {
      this.drawImage(offsetX, offsetY, pen.prop.img, pen.prop.color, curStyle);
    }
    if (curStyle.strikethroughThickness > 0 && pen.width > 0) {
      var lineOffsetY = offsetY + curStyle.strikethroughOffset - curStyle.strikethroughThickness / 2;
      this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.strikethroughThickness, curStyle.strikethroughColor, curStyle);
    }
    context.restore();
    if (pen.hasAreaMarker && pen.width > 0) {
      var data;
      var areaKey = pen.prop.area;
      if (areaKey) {
        data = {
          key: areaKey
        };
      } else {
        var url = pen.prop.url;
        data = {
          key: `url:${url}`,
          url
        };
      }
      this.hitAreaManager.add(
        offsetX,
        // x
        offsetY - this.startYOffset,
        // y
        pen.width,
        // width
        this.defaultStyle.lineHeight,
        // height
        data
      );
    }
  },
  clear() {
    var canvas = this.canvas;
    this.context.clearRect(0, 0, canvas.width, canvas.height);
  },
  drawRectangle(x, y, width, height, color, style) {
    if (this.autoRound) {
      x = Math.round(x);
      y = Math.round(y);
    }
    var context = this.context;
    context.fillStyle = color;
    context.fillRect(x, y, width, height);
  },
  drawLine(x, y, width, height, color, style) {
    if (this.autoRound) {
      x = Math.round(x);
      y = Math.round(y);
    }
    var context = this.context;
    style.syncShadow(context, style.shadowStroke);
    var savedLineCap = context.lineCap;
    context.lineCap = "butt";
    context.strokeStyle = color;
    context.lineWidth = height;
    context.beginPath();
    context.moveTo(x, y);
    context.lineTo(x + width, y);
    context.stroke();
    context.lineCap = savedLineCap;
  },
  drawText(x, y, text, style) {
    if (this.autoRound) {
      x = Math.round(x);
      y = Math.round(y);
    }
    var context = this.context;
    if (style.stroke && style.stroke !== "none" && style.strokeThickness > 0) {
      style.syncShadow(context, style.shadowStroke);
      context.strokeText(text, x, y);
    }
    if (style.color && style.color !== "none") {
      style.syncShadow(context, style.shadowFill);
      context.fillText(text, x, y);
    }
  },
  drawImage(x, y, imgKey, color, style) {
    y -= this.startYOffset;
    this.parent.imageManager.draw(imgKey, this.context, x, y, color, this.autoRound);
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/penmanger/Pen.js
var GetValue12 = Phaser.Utils.Objects.GetValue;
var NO_NEWLINE = const_default.NO_NEWLINE;
var RAW_NEWLINE = const_default.RAW_NEWLINE;
var Pen = class {
  constructor(config) {
    this.prop = {};
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.text = GetValue12(o, "text", "");
    this.x = GetValue12(o, "x", 0);
    this.y = GetValue12(o, "y", 0);
    this.width = GetValue12(o, "width", 0);
    var prop = GetValue12(o, "prop", null);
    if (prop === null) {
      prop = {};
    }
    this.prop = prop;
    this.newLineMode = GetValue12(o, "newLineMode", 0);
    this.startIndex = GetValue12(o, "startIndex", 0);
  }
  get plainText() {
    var txt = this.text;
    if (this.newLineMode === RAW_NEWLINE) {
      txt += "\n";
    }
    return txt;
  }
  get wrapText() {
    var txt = this.text;
    if (this.newLineMode !== NO_NEWLINE) {
      txt += "\n";
    }
    return txt;
  }
  get rawTextLength() {
    var len = this.text.length;
    if (this.newLineMode === RAW_NEWLINE) {
      len += 1;
    }
    return len;
  }
  get endIndex() {
    return this.startIndex + this.rawTextLength;
  }
  get lastX() {
    return this.x + this.width;
  }
  get isTextPen() {
    return this.text !== "";
  }
  get isImagePen() {
    return !!this.prop.img;
  }
  get hasAreaMarker() {
    return !!this.prop.area || !!this.prop.url;
  }
};
var Pen_default = Pen;

// node_modules/phaser3-rex-plugins/plugins/utils/object/Clone.js
var Clone = function(obj, out2) {
  var objIsArray = Array.isArray(obj);
  if (out2 === void 0) {
    out2 = objIsArray ? [] : {};
  } else {
    Clear_default(out2);
  }
  if (objIsArray) {
    out2.length = obj.length;
    for (var i = 0, cnt = obj.length; i < cnt; i++) {
      out2[i] = obj[i];
    }
  } else {
    for (var key2 in obj) {
      out2[key2] = obj[key2];
    }
  }
  return out2;
};
var Clone_default = Clone;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/penmanger/PenManager.js
var GetFastValue = Phaser.Utils.Objects.GetFastValue;
var NO_NEWLINE2 = const_default.NO_NEWLINE;
var WRAPPED_NEWLINE = const_default.WRAPPED_NEWLINE;
var PenManager = class _PenManager {
  constructor(config) {
    this.pens = [];
    this.lines = [];
    this.maxLinesWidth = void 0;
    this.pensPool = config.pensPool;
    this.linesPool = config.linesPool;
    this.tagToText = GetFastValue(config, "tagToText", NOOP_default);
    this.tagToTextScope = GetFastValue(config, "tagToTextScope", void 0);
  }
  destroy() {
    this.clear();
    this.tagToText = void 0;
    this.tagToTextScope = void 0;
  }
  clear() {
    for (var i = 0, len = this.lines.length; i < len; i++) {
      this.lines[i].length = 0;
    }
    this.pensPool.pushMultiple(this.pens);
    this.linesPool.pushMultiple(this.lines);
    this.maxLinesWidth = void 0;
  }
  addTextPen(text, x, y, width, prop, newLineMode) {
    var pen = this.pensPool.pop();
    if (pen == null) {
      pen = new Pen_default();
    }
    PEN_CONFIG.text = text;
    PEN_CONFIG.x = x;
    PEN_CONFIG.y = y;
    PEN_CONFIG.width = width;
    PEN_CONFIG.prop = prop;
    PEN_CONFIG.newLineMode = newLineMode;
    pen.resetFromJSON(PEN_CONFIG);
    this.addPen(pen);
    return this;
  }
  addImagePen(x, y, width, prop) {
    this.addTextPen("", x, y, width, prop, NO_NEWLINE2);
    return this;
  }
  addNewLinePen() {
    var previousPen = this.lastPen;
    var x = previousPen ? previousPen.lastX : 0;
    var y = previousPen ? previousPen.y : 0;
    var prop = previousPen ? Clone_default(previousPen.prop) : null;
    this.addTextPen("", x, y, 0, prop, WRAPPED_NEWLINE);
    return this;
  }
  addPen(pen) {
    var previousPen = this.lastPen;
    if (previousPen == null) {
      pen.startIndex = 0;
    } else {
      pen.startIndex = previousPen.endIndex;
    }
    this.pens.push(pen);
    var line = this.lastLine;
    if (line == null) {
      line = this.linesPool.pop() || [];
      this.lines.push(line);
    }
    line.push(pen);
    if (pen.newLineMode !== NO_NEWLINE2) {
      line = this.linesPool.pop() || [];
      this.lines.push(line);
    }
    this.maxLinesWidth = void 0;
  }
  clone(targetPenManager) {
    if (targetPenManager == null)
      targetPenManager = new _PenManager();
    targetPenManager.clear();
    for (var li = 0, llen = this.lines.length; li < llen; li++) {
      var pens = this.lines[li];
      for (var pi = 0, plen = pens.length; pi < plen; pi++) {
        var pen = pens[pi];
        targetPenManager.addPen(
          pen.text,
          pen.x,
          pen.y,
          pen.width,
          Clone_default(pen.prop),
          pen.newLineMode
        );
      }
    }
    return targetPenManager;
  }
  get lastPen() {
    return this.pens[this.pens.length - 1];
  }
  get lastLine() {
    return this.lines[this.lines.length - 1];
  }
  getLineStartIndex(i) {
    if (i >= this.lines.length) {
      return this.getLineEndIndex(i);
    } else {
      var line = this.lines[i];
      return line && line[0] ? line[0].startIndex : 0;
    }
  }
  getLineEndIndex(i) {
    if (i >= this.lines.length) {
      i = this.lines.length - 1;
    }
    var li, hasLastPen = false, line;
    for (li = i; li >= 0; li--) {
      line = this.lines[li];
      hasLastPen = line != null && line.length > 0;
      if (hasLastPen) {
        break;
      }
    }
    if (!hasLastPen) {
      return 0;
    }
    var lastPen = line[line.length - 1];
    return lastPen.endIndex;
  }
  getLineWidth(i) {
    var line = this.lines[i];
    if (!line) {
      return 0;
    }
    var lastPen = line[line.length - 1];
    if (lastPen == null) {
      return 0;
    }
    var lineWidth = lastPen.lastX;
    return lineWidth;
  }
  getMaxLineWidth() {
    if (this.maxLinesWidth !== void 0) {
      return this.maxLinesWidth;
    }
    var w, maxW = 0;
    for (var i = 0, len = this.lines.length; i < len; i++) {
      w = this.getLineWidth(i);
      if (w > maxW) {
        maxW = w;
      }
    }
    this.maxLinesWidth = maxW;
    return maxW;
  }
  getLineWidths() {
    var result = [];
    for (var i = 0, len = this.lines.length; i < len; i++) {
      result.push(this.getLineWidth(i));
    }
    return result;
  }
  get linesCount() {
    return this.lines.length;
  }
  get plainText() {
    var txt = "", pens = this.pens;
    for (var i = 0, len = pens.length; i < len; i++) {
      txt += pens[i].plainText;
    }
    return txt;
  }
  get rawTextLength() {
    var l = 0, pens = this.pens;
    for (var i = 0, len = this.pens.length; i < len; i++) {
      l += pens[i].rawTextLength;
    }
    return l;
  }
  getSliceTagText(start, end, wrap) {
    var lastPen = this.lastPen;
    if (lastPen == null) {
      return "";
    }
    var lastPenEnd = lastPen.endIndex;
    if (start === void 0 || start === 0) {
      start = -1;
    }
    if (end === void 0 || end === lastPenEnd) {
      end = lastPenEnd + 1;
    }
    if (wrap === void 0) {
      wrap = false;
    }
    var txt = "", formatTxt, pen, penTxt, penStartIdx, penEndIdx, isInRange;
    var currentProp, previousProp;
    for (var i = 0, len = this.pens.length; i < len; i++) {
      pen = this.pens[i];
      penEndIdx = pen.endIndex;
      if (penEndIdx <= start) {
        continue;
      }
      pen = this.pens[i];
      penTxt = !wrap ? pen.plainText : pen.wrapText;
      currentProp = pen.prop;
      penStartIdx = pen.startIndex;
      isInRange = penStartIdx >= start && penEndIdx <= end;
      if (!isInRange) {
        penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
      }
      if (this.tagToTextScope) {
        txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
      } else {
        txt += this.tagToText(penTxt, currentProp, previousProp);
      }
      previousProp = currentProp;
      if (penEndIdx >= end) {
        break;
      }
    }
    return txt;
  }
  get length() {
    return this.lines.length;
  }
  set length(value) {
    this.clear();
  }
};
var PEN_CONFIG = {};
var PenManager_default = PenManager;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/hitareamanager/HitAreaManager.js
var Rectangle = Phaser.Geom.Rectangle;
var RectanglePool = new pool_default();
var HitAreaManager = class {
  constructor() {
    this.hitAreas = [];
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      this.hitAreas[i].data = null;
    }
    RectanglePool.pushMultiple(this.hitAreas);
    return this;
  }
  add(x, y, width, height, data) {
    if (data === void 0) {
      data = {};
    }
    var rectangle = RectanglePool.pop();
    if (rectangle === null) {
      rectangle = new Rectangle(x, y, width, height);
    } else {
      rectangle.setTo(x, y, width, height);
    }
    rectangle.data = data;
    this.hitAreas.push(rectangle);
    return this;
  }
  getFirst(x, y) {
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      var hitArea = this.hitAreas[i];
      if (hitArea.contains(x, y)) {
        return hitArea;
      }
    }
    return null;
  }
  getByKey(key2) {
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      var hitArea = this.hitAreas[i];
      if (hitArea.data.key === key2) {
        return hitArea;
      }
    }
    return null;
  }
  drawBounds(graphics, color, parent) {
    if (color === void 0) {
      color = 16777215;
    }
    if (parent) {
      graphics.save().translateCanvas(parent.x, parent.y).rotateCanvas(parent.rotation).scaleCanvas(parent.scaleX, parent.scaleY);
    }
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      var hitArea = this.hitAreas[i];
      graphics.lineStyle(1, color).strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
    }
    if (parent) {
      graphics.restore();
    }
    return this;
  }
};
var HitAreaManager_default = HitAreaManager;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/canvastext/SetInteractive.js
var SetInteractive = function() {
  this.parent.on("pointerdown", OnAreaDown, this).on("pointerup", OnAreaUp, this).on("pointermove", OnAreaOverOut, this).on("pointerover", OnAreaOverOut, this).on("pointerout", function(pointer, event) {
    OnAreaOverOut.call(this, pointer, null, null, event);
  }, this);
};
var OnAreaDown = function(pointer, localX, localY, event) {
  var area = this.hitAreaManager.getFirst(localX, localY);
  if (area === null) {
    return;
  }
  var key2 = area.data.key;
  FireEvent.call(this, "areadown", key2, pointer, localX, localY, event);
  if (!area.data) {
    return;
  }
  area.data.isDown = true;
};
var OnAreaUp = function(pointer, localX, localY, event) {
  var area = this.hitAreaManager.getFirst(localX, localY);
  if (area === null) {
    return;
  }
  var key2 = area.data.key;
  FireEvent.call(this, "areaup", key2, pointer, localX, localY, event);
  if (!area.data) {
    return;
  }
  if (area.data.isDown) {
    FireEvent.call(this, "areaclick", key2, pointer, localX, localY, event);
    if (!area.data) {
      return;
    }
    var url = area.data.url;
    if (url) {
      window.open(url, "_blank");
    }
  }
  area.data.isDown = false;
};
var OnAreaOverOut = function(pointer, localX, localY, event) {
  if (localX === null) {
    if (this.lastHitAreaKey !== null) {
      FireEvent.call(this, "areaout", this.lastHitAreaKey, pointer, localX, localY, event);
      var area = this.hitAreaManager.getByKey(this.lastHitAreaKey);
      if (area && area.data) {
        area.data.isDown = false;
      }
      this.lastHitAreaKey = null;
    }
    return;
  }
  var area = this.hitAreaManager.getFirst(localX, localY);
  var key2 = area ? area.data.key : null;
  if (this.lastHitAreaKey === key2) {
    return;
  }
  if (this.lastHitAreaKey !== null) {
    FireEvent.call(this, "areaout", this.lastHitAreaKey, pointer, localX, localY, event);
    var prevHitArea = this.hitAreaManager.getByKey(this.lastHitAreaKey);
    if (prevHitArea) {
      if (this.urlTagCursorStyle) {
        SetCursorStyle(this.scene, prevHitArea, "");
      }
      prevHitArea.data.isDown = false;
    }
  }
  if (key2 !== null) {
    FireEvent.call(this, "areaover", key2, pointer, localX, localY, event);
    if (area.data) {
      if (this.urlTagCursorStyle) {
        SetCursorStyle(this.scene, area, this.urlTagCursorStyle);
      }
    }
  }
  this.lastHitAreaKey = key2;
};
var FireEvent = function(eventName, key2, pointer, localX, localY, event) {
  this.parent.emit(`${eventName}-${key2}`, pointer, localX, localY, event);
  this.parent.emit(eventName, key2, pointer, localX, localY, event);
};
var SetCursorStyle = function(scene, area, cursorStyle) {
  if (!area || !area.data || !area.data.url) {
    return;
  }
  scene.input.manager.canvas.style.cursor = cursorStyle;
};
var SetInteractive_default = SetInteractive;

// node_modules/phaser3-rex-plugins/plugins/utils/position/WorldXYToGameObjectLocalXY.js
var TransformMatrix2 = Phaser.GameObjects.Components.TransformMatrix;
var TransformXY = Phaser.Math.TransformXY;
var WorldXYToGameObjectLocalXY = function(gameObject2, worldX, worldY, camera, out2) {
  if (camera === void 0) {
    camera = gameObject2.scene.cameras.main;
  }
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = globOut;
  }
  var csx = camera.scrollX;
  var csy = camera.scrollY;
  var px = worldX + csx * gameObject2.scrollFactorX - csx;
  var py = worldY + csy * gameObject2.scrollFactorY - csy;
  if (gameObject2.parentContainer) {
    if (tempMatrix === void 0) {
      tempMatrix = new TransformMatrix2();
      parentMatrix = new TransformMatrix2();
    }
    gameObject2.getWorldTransformMatrix(tempMatrix, parentMatrix);
    tempMatrix.applyInverse(px, py, out2);
  } else {
    TransformXY(px, py, gameObject2.x, gameObject2.y, gameObject2.rotation, gameObject2.scaleX, gameObject2.scaleY, out2);
  }
  out2.x += gameObject2.displayOriginX;
  out2.y += gameObject2.displayOriginY;
  return out2;
};
var tempMatrix;
var parentMatrix;
var globOut = {};
var WorldXYToGameObjectLocalXY_default = WorldXYToGameObjectLocalXY;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/canvastext/GetHitArea.js
var GetHitArea = function(worldX, worldY, camera) {
  var localXY = WorldXYToGameObjectLocalXY_default(this.parent, worldX, worldY, camera, true);
  var area = this.hitAreaManager.getFirst(localXY.x, localXY.y);
  if (area === null) {
    return;
  }
  return area.data.key;
};
var GetHitArea_default = GetHitArea;

// node_modules/phaser3-rex-plugins/plugins/utils/string/IsASCIIString.js
var RE_ASCII = /^[\x00-\x7F]+$/;
var IsASCIIString = function(s) {
  return RE_ASCII.test(s);
};
var IsASCIIString_default = IsASCIIString;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/wraptext/WrapText.js
var NO_NEWLINE3 = const_default.NO_NEWLINE;
var RAW_NEWLINE2 = const_default.RAW_NEWLINE;
var WRAPPED_NEWLINE2 = const_default.WRAPPED_NEWLINE;
var NO_WRAP = const_default.NO_WRAP;
var WORD_WRAP = const_default.WORD_WRAP;
var CHAR_WRAP = const_default.CHAR_WRAP;
var MIX_WRAP = const_default.MIX_WRAP;
var splitRegExp = const_default.SPLITREGEXP;
var WrapText = function(text, context, wrapMode, wrapWidth, offset, wrapTextLinesPool) {
  if (wrapWidth <= 0) {
    wrapMode = NO_WRAP;
  }
  var retLines = [];
  if (!text || !text.length) {
    return retLines;
  }
  var isNoWrap = wrapMode === NO_WRAP;
  var lines = text.split(splitRegExp), line, remainWidth, newLineMode;
  for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
    line = lines[i];
    newLineMode = i === linesLen - 1 ? NO_NEWLINE3 : RAW_NEWLINE2;
    if (isNoWrap) {
      var textWidth = context.measureText(line).width;
      retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
      continue;
    }
    remainWidth = i === 0 ? wrapWidth - offset : wrapWidth;
    if (line.length <= 100) {
      var textWidth = context.measureText(line).width;
      if (textWidth <= remainWidth) {
        retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
        continue;
      }
    }
    var tokenArray = ParseLine(line, wrapMode);
    var token, tokenWidth, isLastToken;
    var lineText = "", lineWidth = 0;
    var currLineWidth;
    for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
      token = tokenArray[j];
      tokenWidth = context.measureText(token).width;
      if (tokenWidth > wrapWidth && IsWord(token)) {
        if (lineText !== "") {
          retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE2));
        } else if (j === 0 && offset > 0) {
          retLines.push(wrapTextLinesPool.getLine("", 0, WRAPPED_NEWLINE2));
        }
        retLines.push(...WrapText(token, context, CHAR_WRAP, wrapWidth, 0, wrapTextLinesPool));
        var lastwordBreakLine = retLines.pop();
        lineText = lastwordBreakLine.text;
        lineWidth = lastwordBreakLine.width;
        wrapTextLinesPool.freeLine(lastwordBreakLine);
        if (lineText === " ") {
          lineText = "";
          lineWidth = 0;
        }
        continue;
      }
      currLineWidth = lineWidth + tokenWidth;
      if (currLineWidth > remainWidth) {
        retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE2));
        lineText = token;
        lineWidth = tokenWidth;
        remainWidth = wrapWidth;
      } else {
        lineText += token;
        lineWidth = currLineWidth;
      }
      if (j === tokenLen - 1) {
        retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, newLineMode));
      }
    }
  }
  return retLines;
};
var ParseLine = function(s, mode) {
  var tokens;
  switch (mode) {
    case WORD_WRAP:
      tokens = [];
      s = s.split(" ");
      for (var i = 0, icnt = s.length; i < icnt; i++) {
        var token = s[i];
        if (i < icnt - 1) {
          tokens.push(token + " ");
        } else {
          if (token !== "") {
            tokens.push(token);
          }
        }
      }
      break;
    case CHAR_WRAP:
      tokens = s.split("");
      break;
    default:
      tokens = [];
      s = s.split(" ");
      for (var i = 0, icnt = s.length; i < icnt; i++) {
        var token = s[i];
        if (i < icnt - 1) {
          if (IsASCIIString_default(token)) {
            tokens.push(token + " ");
          } else {
            tokens.push(...token.split(""));
            tokens.push(" ");
          }
        } else {
          if (token !== "") {
            if (IsASCIIString_default(token)) {
              tokens.push(token);
            } else {
              tokens.push(...token.split(""));
            }
          }
        }
      }
      break;
  }
  return tokens;
};
var IsWord = function(s) {
  switch (s.length) {
    case 1:
      return false;
    case 2:
      return s.charAt(1) !== " ";
    default:
      return true;
  }
};
var WrapText_default = WrapText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/canvastext/CanvasText.js
var GetValue13 = Phaser.Utils.Objects.GetValue;
var NO_WRAP2 = const_default.NO_WRAP;
var NO_NEWLINE4 = const_default.NO_NEWLINE;
var RAW_NEWLINE3 = const_default.RAW_NEWLINE;
var WRAPPED_NEWLINE3 = const_default.WRAPPED_NEWLINE;
var CanvasText = class {
  constructor(config) {
    this.parent = config.parent;
    this.scene = this.parent.scene;
    this.context = GetValue13(config, "context", null);
    this.canvas = this.context.canvas;
    this.parser = GetValue13(config, "parser", null);
    this.defaultStyle = GetValue13(config, "style", null);
    this.autoRound = true;
    this.pensPool = config.pensPool;
    this.linesPool = config.linesPool;
    this.wrapTextLinesPool = config.wrapTextLinesPool;
    this.penManager = this.newPenManager();
    this._tmpPenManager = null;
    this.hitAreaManager = new HitAreaManager_default();
    this.lastHitAreaKey = null;
    this.urlTagCursorStyle = null;
  }
  destroy() {
    this.parent = void 0;
    this.scene = void 0;
    this.context = void 0;
    this.canvas = void 0;
    this.parser = void 0;
    this.defaultStyle = void 0;
    if (this.penManager) {
      this.penManager.destroy();
      this.penManager = void 0;
    }
    if (this._tmpPenManager) {
      this._tmpPenManager.destroy();
      this._tmpPenManager = void 0;
    }
    if (this.hitAreaManager) {
      this.hitAreaManager.destroy();
      this.hitAreaManager = void 0;
    }
    this.pensPool = void 0;
    this.linesPool = void 0;
    this.wrapTextLinesPool = void 0;
  }
  updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
    if (penManager === void 0) {
      penManager = this.penManager;
    }
    penManager.clear();
    if (text === "") {
      return penManager;
    }
    var textStyle = this.parent.style;
    if (textStyle.isWrapFitMode) {
      var padding = this.parent.padding;
      wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
    }
    var canvas = this.canvas;
    var context = this.context;
    var cursorX = 0, cursorY = 0;
    var customTextWrapCallback = textStyle.wrapCallback, customTextWrapCallbackScope = textStyle.wrapCallbackScope;
    var reuseLines = true;
    var plainText, curProp, curStyle;
    var match = this.parser.splitText(text), result, wrapLines, wrapTextLinesPool = this.wrapTextLinesPool;
    for (var i = 0, len = match.length; i < len; i++) {
      result = this.parser.tagTextToProp(match[i], curProp);
      plainText = result.plainText;
      curProp = result.prop;
      if (curProp.img) {
        var imgWidth = this.imageManager.getOuterWidth(curProp.img);
        if (wrapWidth > 0 && wrapMode !== NO_WRAP2) {
          if (wrapWidth < cursorX + imgWidth) {
            penManager.addNewLinePen();
            cursorY += lineHeight;
            cursorX = 0;
          }
        }
        penManager.addImagePen(cursorX, cursorY, imgWidth, Clone_default(curProp));
        cursorX += imgWidth;
      } else if (plainText !== "") {
        context.save();
        curStyle = this.parser.propToContextStyle(this.defaultStyle, curProp);
        curStyle.buildFont();
        curStyle.syncFont(canvas, context);
        curStyle.syncStyle(canvas, context);
        if (!customTextWrapCallback) {
          wrapLines = WrapText_default(
            plainText,
            context,
            wrapMode,
            wrapWidth,
            cursorX,
            wrapTextLinesPool
          );
        } else {
          wrapLines = customTextWrapCallback.call(
            customTextWrapCallbackScope,
            plainText,
            context,
            wrapWidth,
            cursorX
          );
          if (typeof wrapLines === "string") {
            wrapLines = wrapLines.split("\n");
          }
          var segment;
          for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
            segment = wrapLines[j];
            if (typeof segment === "string") {
              wrapLines[j] = wrapTextLinesPool.getLine(
                segment,
                context.measureText(segment).width,
                j < jLen - 1 ? WRAPPED_NEWLINE3 : NO_NEWLINE4
              );
            } else {
              reuseLines = false;
            }
          }
        }
        var segment;
        for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
          segment = wrapLines[j];
          penManager.addTextPen(
            segment.text,
            cursorX,
            cursorY,
            segment.width,
            Clone_default(curProp),
            segment.newLineMode
          );
          if (segment.newLineMode !== NO_NEWLINE4) {
            cursorX = 0;
            cursorY += lineHeight;
          } else {
            cursorX += segment.width;
          }
        }
        if (reuseLines) {
          wrapTextLinesPool.freeLines(wrapLines);
        }
        wrapLines = null;
        context.restore();
      }
    }
    for (var i = 0, len = this.lines.length; i < len; i++) {
      var line = this.lines[i];
      var lastPen = line[line.length - 1];
      if (lastPen) {
        lastPen.width += this.parser.getStrokeThinkness(this.defaultStyle, lastPen.prop);
      }
    }
    return penManager;
  }
  get startXOffset() {
    return this.defaultStyle.xOffset;
  }
  get startYOffset() {
    return this.defaultStyle.metrics.ascent;
  }
  get lines() {
    return this.penManager.lines;
  }
  get displayLinesCount() {
    var linesCount = this.penManager.linesCount, maxLines = this.defaultStyle.maxLines;
    if (maxLines > 0 && linesCount > maxLines) {
      linesCount = maxLines;
    }
    return linesCount;
  }
  get linesWidth() {
    return Math.ceil(this.penManager.getMaxLineWidth());
  }
  get linesHeight() {
    var linesCount = this.displayLinesCount;
    var linesHeight = this.defaultStyle.lineHeight * linesCount;
    if (linesCount > 0) {
      linesHeight -= this.defaultStyle.lineSpacing;
    }
    return linesHeight;
  }
  get imageManager() {
    return this.parent.imageManager;
  }
  get rtl() {
    return this.parent.style.rtl;
  }
  newPenManager() {
    return new PenManager_default({
      pensPool: this.pensPool,
      linesPool: this.linesPool,
      tagToText: this.parser.propToTagText,
      tagToTextScope: this.parser
    });
  }
  get tmpPenManager() {
    if (this._tmpPenManager === null) {
      this._tmpPenManager = this.newPenManager();
    }
    return this._tmpPenManager;
  }
  getPlainText(text, start, end) {
    var plainText;
    if (text == null) {
      plainText = this.penManager.plainText;
    } else {
      var m, match = this.parser.splitText(text, 1);
      plainText = "";
      for (var i = 0, len = match.length; i < len; i++) {
        plainText += match[i];
      }
    }
    if (start != null || end != null) {
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = plainText.length;
      }
      plainText = plainText.substring(start, end);
    }
    return plainText;
  }
  getPenManager(text, retPenManager) {
    if (text === void 0) {
      return this.copyPenManager(retPenManager, this.penManager);
    }
    if (retPenManager === void 0) {
      retPenManager = this.newPenManager();
    }
    var defaultStyle = this.defaultStyle;
    this.updatePenManager(
      text,
      defaultStyle.wrapMode,
      defaultStyle.wrapWidth,
      defaultStyle.lineHeight,
      retPenManager
    );
    return retPenManager;
  }
  getText(text, start, end, wrap) {
    if (text == null) {
      return this.penManager.getSliceTagText(start, end, wrap);
    }
    var penManager = this.tmpPenManager;
    var defaultStyle = this.defaultStyle;
    this.updatePenManager(
      text,
      defaultStyle.wrapMode,
      defaultStyle.wrapWidth,
      defaultStyle.lineHeight,
      penManager
    );
    return penManager.getSliceTagText(start, end, wrap);
  }
  copyPenManager(ret, src) {
    if (src === void 0) {
      src = this.penManager;
    }
    return src.copy(ret);
  }
  getTextWidth(penManager) {
    if (penManager === void 0) {
      penManager = this.penManager;
    }
    return penManager.getMaxLineWidth();
  }
  getLastPen(penManager) {
    if (penManager === void 0) {
      penManager = this.penManager;
    }
    return penManager.lastPen;
  }
};
var methods3 = {
  setInteractive: SetInteractive_default,
  getHitArea: GetHitArea_default
};
Object.assign(
  CanvasText.prototype,
  DrawMethods_default,
  methods3
);
var CanvasText_default = CanvasText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/wraptext/WrapTextLinesPool.js
var WrapTextLinesPool = class extends pool_default {
  freeLine(line) {
    if (!line) {
      return;
    }
    this.push(line);
    return this;
  }
  freeLines(lines) {
    if (!lines) {
      return;
    }
    this.pushMultiple(lines);
    return this;
  }
  getLine(text, width, newLineMode) {
    var l = this.pop();
    if (l === null) {
      l = {};
    }
    l.text = text;
    l.width = width;
    l.newLineMode = newLineMode;
    return l;
  }
};
var WrapTextLinesPool_default = WrapTextLinesPool;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/imagemanager/AddImage.js
var IsPlainObject7 = Phaser.Utils.Objects.IsPlainObject;
var GetValue14 = Phaser.Utils.Objects.GetValue;
var AddImage2 = function(key2, config) {
  if (IsPlainObject7(key2)) {
    config = key2;
    key2 = config.key;
  } else if (config === void 0) {
    config = {
      key: key2
    };
  }
  if (!config.hasOwnProperty("key")) {
    config.key = key2;
  }
  var textureKey = config.key, frameKey = config.frame;
  var width = config.width, height = config.height;
  if (width === void 0 || height === void 0) {
    var frame = this.textureManager.getFrame(textureKey, frameKey);
    var frameWidth = frame ? frame.cutWidth : 0;
    var frameHeight = frame ? frame.cutHeight : 0;
    if (width === void 0 && height === void 0) {
      width = frameWidth;
      height = frameHeight;
    } else if (width === void 0) {
      width = frameWidth * (height / frameHeight);
    } else if (height === void 0) {
      height = frameHeight * (width / frameWidth);
    }
  }
  this.images[key2] = {
    key: textureKey,
    frame: frameKey,
    width,
    height,
    y: GetValue14(config, "y", 0),
    left: GetValue14(config, "left", 0),
    right: GetValue14(config, "right", 0),
    originX: GetValue14(config, "originX", 0),
    originY: GetValue14(config, "originY", 0),
    tintFill: GetValue14(config, "tintFill", false)
  };
};
var AddImage_default2 = AddImage2;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/DrawFrameToCanvas.js
var CanvasPool4 = Phaser.Display.Canvas.CanvasPool;
var DrawFrameToCanvas = function(frame, canvas, x, y, width, height, color, autoRound) {
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  if (width === void 0) {
    width = frame.cutWidth;
  }
  if (height === void 0) {
    height = frame.cutHeight;
  }
  if (autoRound === void 0) {
    autoRound = false;
  }
  ;
  if (autoRound) {
    x = Math.round(x);
    y = Math.round(y);
  }
  var context = canvas.getContext("2d", { willReadFrequently: true });
  if (color) {
    var tempCanvas = CanvasPool4.create(null, width, height, Phaser.CANVAS, true);
    var tempContext = tempCanvas.getContext("2d", { willReadFrequently: true });
    tempContext.drawImage(
      frame.source.image,
      frame.cutX,
      frame.cutY,
      frame.cutWidth,
      frame.cutHeight,
      0,
      0,
      width,
      height
    );
    tempContext.globalCompositeOperation = "source-in";
    tempContext.fillStyle = color;
    tempContext.fillRect(0, 0, width, height);
    context.drawImage(
      tempCanvas,
      0,
      0,
      width,
      height,
      x,
      y,
      width,
      height
    );
    CanvasPool4.remove(tempCanvas);
  } else {
    context.drawImage(
      frame.source.image,
      frame.cutX,
      frame.cutY,
      frame.cutWidth,
      frame.cutHeight,
      x,
      y,
      width,
      height
    );
  }
};
var DrawFrameToCanvas_default = DrawFrameToCanvas;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/imagemanager/DrawImage.js
var DrawImage3 = function(key2, context, x, y, color, autoRound) {
  var imgData = this.get(key2);
  if (!imgData) {
    return;
  }
  var frame = this.textureManager.getFrame(imgData.key, imgData.frame);
  var width = imgData.width, height = imgData.height;
  x += imgData.left - imgData.originX * width;
  y += imgData.y - imgData.originY * height;
  if (!imgData.tintFill) {
    color = void 0;
  }
  DrawFrameToCanvas_default(
    frame,
    context.canvas,
    x,
    y,
    width,
    height,
    color,
    autoRound
  );
};
var DrawImage_default3 = DrawImage3;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/imagemanager/ImageManager.js
var ImageManager = class {
  constructor(scene) {
    this.textureManager = scene.sys.textures;
    this.images = {};
  }
  destroy() {
    this.textureManager = void 0;
    this.images = void 0;
  }
  add(key2, config) {
    if (typeof key2 === "string") {
      AddImage_default2.call(this, key2, config);
    } else if (Array.isArray(key2)) {
      var data = key2;
      for (var i = 0, cnt = data.length; i < cnt; i++) {
        AddImage_default2.call(this, data[i]);
      }
    } else {
      var data = key2;
      for (var key2 in data) {
        AddImage_default2.call(this, key2, data[key2]);
      }
    }
    return this;
  }
  has(key2) {
    return this.images.hasOwnProperty(key2);
  }
  remove(key2) {
    if (this.has(key2)) {
      delete this.images[key2];
    }
    return this;
  }
  get(key2) {
    if (!this.has(key2)) {
      if (this.textureManager.exists(key2)) {
        this.add(key2);
      }
    }
    return this.images[key2];
  }
  getOuterWidth(key2) {
    var data = this.get(key2);
    return data ? data.width + data.left + data.right : 0;
  }
  getFrame(key2) {
    var data = this.get(key2);
    return data ? this.textureManager.getFrame(data.key, data.frame) : void 0;
  }
  hasTexture(key2) {
    return !!this.getFrame(key2);
  }
};
var methods4 = {
  draw: DrawImage_default3
};
Object.assign(
  ImageManager.prototype,
  methods4
);
var ImageManager_default = ImageManager;

// node_modules/phaser3-rex-plugins/plugins/utils/text/AppendText.js
var AppendText = function(value, addCR) {
  if (!value && value !== 0) {
    value = "";
  }
  if (addCR === void 0) {
    addCR = true;
  }
  if (Array.isArray(value)) {
    value = value.join("\n");
  }
  var newText;
  if (addCR) {
    newText = `${this.text}
${value}`;
  } else {
    newText = `${this.text}${value}`;
  }
  if (newText != this.text) {
    this.setText(newText);
  }
  return this;
};
var AppendText_default = AppendText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/Text.js
var IsPlainObject8 = Phaser.Utils.Objects.IsPlainObject;
var AddToDOM = Phaser.DOM.AddToDOM;
var CanvasPool5 = Phaser.Display.Canvas.CanvasPool;
var GameObject4 = Phaser.GameObjects.GameObject;
var GetValue15 = Phaser.Utils.Objects.GetValue;
var RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
var SPLITREGEXP = const_default.SPLITREGEXP;
var UUID2 = Phaser.Utils.String.UUID;
var SharedPensPools = null;
var SharedLinesPool = null;
var SharedWrapTextLinesPool = null;
var Text = class extends TextBase_default {
  constructor(scene, x, y, text, style, type, parser) {
    if (IsPlainObject8(x)) {
      var config = x;
      x = GetValue15(config, "x", 0);
      y = GetValue15(config, "y", 0);
      text = GetValue15(config, "text", "");
      style = GetValue15(config, "style");
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    super(scene, type);
    this.renderer = scene.sys.game.renderer;
    this.setPosition(x, y);
    this.setOrigin(0, 0);
    this.initPipeline();
    this.initPostPipeline(true);
    this.canvas = CanvasPool5.create(this);
    this.context = this.canvas.getContext("2d", { willReadFrequently: true });
    this._imageManager = void 0;
    if (style) {
      if (style.hasOwnProperty("align")) {
        var halign = style.align;
        delete style.align;
        style.halign = halign;
      }
      if (style.hasOwnProperty("stroke") && !style.hasOwnProperty("strokeThickness")) {
        style.strokeThickness = 1;
      }
    }
    this.style = new TextStyle_default(this, style);
    var imageData = GetValue15(style, "images", void 0);
    if (imageData) {
      this.addImage(imageData);
    }
    this.autoRound = true;
    this._text = void 0;
    this.padding = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.width = 1;
    this.height = 1;
    this.dirty = false;
    if (this.style.resolution === 0) {
      this.style.resolution = 1;
    }
    this._crop = this.resetCropObject();
    this._textureKey = UUID2();
    this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);
    this.frame = this.texture.get();
    this.frame.source.resolution = this.style.resolution;
    if (this.renderer && this.renderer.gl) {
      this.renderer.deleteTexture(this.frame.source.glTexture);
      this.frame.source.glTexture = null;
    }
    var sharedPoolMode = GetValue15(style, "sharedPool", true);
    var pensPool, linesPool, wrapTextLinesPool;
    if (sharedPoolMode) {
      if (!SharedPensPools) {
        SharedPensPools = {};
        SharedLinesPool = new pool_default();
        SharedWrapTextLinesPool = new WrapTextLinesPool_default();
        this.scene.game.events.once("destroy", function() {
          SharedPensPools = null;
          SharedLinesPool = null;
          SharedWrapTextLinesPool = null;
        });
      }
      if (!SharedPensPools.hasOwnProperty(type)) {
        SharedPensPools[type] = new pool_default();
      }
      pensPool = SharedPensPools[type];
      linesPool = SharedLinesPool;
      wrapTextLinesPool = SharedWrapTextLinesPool;
    } else {
      pensPool = new pool_default();
      linesPool = new pool_default();
      wrapTextLinesPool = new WrapTextLinesPool_default();
    }
    this.canvasText = new CanvasText_default({
      parent: this,
      context: this.context,
      parser,
      style: this.style,
      pensPool,
      linesPool,
      wrapTextLinesPool
    });
    this.parser = parser;
    this.initRTL();
    if (style && style.padding) {
      this.setPadding(style.padding);
    }
    this.setText(text);
    this.setUrlTagCursorStyle(GetValue15(style, "urlTagCursorStyle", "pointer"));
    if (GetValue15(style, "interactive", false)) {
      this.setInteractive();
    }
  }
  preDestroy() {
    RemoveFromDOM(this.canvas);
    this.canvasText.destroy();
    this.canvasText = void 0;
    if (this._imageManager) {
      this._imageManager.destroy();
      this._imageManager = void 0;
    }
    CanvasPool5.remove(this.canvas);
    var texture = this.texture;
    if (texture) {
      texture.destroy();
    }
  }
  set text(value) {
    this.setText(value);
  }
  get text() {
    return this._text;
  }
  initRTL() {
    if (!this.style.rtl) {
      return;
    }
    this.canvas.dir = "rtl";
    this.context.direction = "rtl";
    this.canvas.style.display = "none";
    AddToDOM(this.canvas, this.scene.sys.canvas);
    this.originX = 1;
  }
  setRTL(rtl) {
    if (rtl === void 0) {
      rtl = true;
    }
    var style = this.style;
    if (style.rtl === rtl) {
      return this;
    }
    style.rtl = rtl;
    if (rtl) {
      this.canvas.dir = "rtl";
      this.context.direction = "rtl";
      this.canvas.style.display = "none";
      AddToDOM(this.canvas, this.scene.sys.canvas);
    } else {
      this.canvas.dir = "ltr";
      this.context.direction = "ltr";
    }
    if (style.halign === "left") {
      style.halign = "right";
    } else if (style.halign === "right") {
      style.halign = "left";
    }
    if (this._imageManager) {
      var images = this._imageManager.images;
      for (var key2 in images) {
        images[key2].originX = 1 - images[key2].originX;
      }
    }
    return this;
  }
  setText(value) {
    value = GetString_default(value);
    if (value === this._text) {
      return this;
    }
    this._text = value;
    this.updateText();
    return this;
  }
  setPadding(left, top, right, bottom) {
    if (typeof left === "object") {
      var config = left;
      var x = GetValue15(config, "x", null);
      if (x !== null) {
        left = x;
        right = x;
      } else {
        left = GetValue15(config, "left", 0);
        right = GetValue15(config, "right", left);
      }
      var y = GetValue15(config, "y", null);
      if (y !== null) {
        top = y;
        bottom = y;
      } else {
        top = GetValue15(config, "top", 0);
        bottom = GetValue15(config, "bottom", top);
      }
    } else {
      if (left === void 0) {
        left = 0;
      }
      if (top === void 0) {
        top = left;
      }
      if (right === void 0) {
        right = left;
      }
      if (bottom === void 0) {
        bottom = top;
      }
    }
    this.padding.left = left;
    this.padding.top = top;
    this.padding.right = right;
    this.padding.bottom = bottom;
    return this.updateText(false);
  }
  updateText(runWrap) {
    if (runWrap === void 0) {
      runWrap = true;
    }
    var canvasText = this.canvasText;
    var style = this.style;
    if (runWrap) {
      canvasText.updatePenManager(
        this._text,
        style.wrapMode,
        style.wrapWidth,
        style.lineHeight
      );
    }
    var padding = this.padding;
    var textWidth, textHeight;
    var linesWidth = Math.ceil(canvasText.linesWidth);
    if (style.fixedWidth === 0) {
      this.width = linesWidth + padding.left + padding.right;
      textWidth = linesWidth;
    } else {
      this.width = style.fixedWidth;
      textWidth = this.width - padding.left - padding.right;
      if (textWidth < linesWidth) {
        textWidth = linesWidth;
      }
    }
    if (style.fixedHeight === 0) {
      this.height = canvasText.linesHeight + padding.top + padding.bottom;
      textHeight = canvasText.linesHeight;
    } else {
      this.height = style.fixedHeight;
      textHeight = this.height - padding.top - padding.bottom;
      if (textHeight < canvasText.linesHeight) {
        textHeight = canvasText.linesHeight;
      }
    }
    var w = this.width;
    var h = this.height;
    this.updateDisplayOrigin();
    var resolution = style.resolution;
    w *= resolution;
    h *= resolution;
    w = Math.max(Math.ceil(w), 1);
    h = Math.max(Math.ceil(h), 1);
    var canvas = this.canvas;
    var context = this.context;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      this.frame.setSize(w, h);
    } else {
      context.clearRect(0, 0, w, h);
    }
    context.save();
    context.scale(resolution, resolution);
    var startX = !this.style.rtl ? padding.left : padding.right;
    var startY = padding.top;
    canvasText.draw(
      startX,
      startY,
      textWidth,
      textHeight
    );
    context.restore();
    if (this.renderer && this.renderer.gl) {
      this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
      if (typeof WEBGL_DEBUG) {
        this.frame.glTexture.spectorMetadata = { textureKey: "BBCodeText Game Object" };
      }
    }
    this.dirty = true;
    var input = this.input;
    if (input && !input.customHitArea) {
      input.hitArea.width = this.width;
      input.hitArea.height = this.height;
    }
    return this;
  }
  toJSON() {
    var out2 = Components.ToJSON(this);
    var data = {
      autoRound: this.autoRound,
      text: this._text,
      style: this.style.toJSON(),
      resolution: this.resolution,
      padding: {
        left: this.padding.left,
        right: this.padding.right,
        top: this.padding.top,
        bottom: this.padding.bottom
      }
    };
    out2.data = data;
    return out2;
  }
  setInteractive(hitArea, hitAreaCallback, dropZone) {
    var isInteractived = !!this.input;
    GameObject4.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);
    if (!isInteractived) {
      this.canvasText.setInteractive();
    }
    return this;
  }
  setUrlTagCursorStyle(cursor) {
    this.urlTagCursorStyle = cursor;
    return this;
  }
  get urlTagCursorStyle() {
    return this.canvasText.urlTagCursorStyle;
  }
  set urlTagCursorStyle(value) {
    this.canvasText.urlTagCursorStyle = value;
  }
  getWrappedText(text, start, end) {
    if (typeof text === "number") {
      end = start;
      start = text;
      text = void 0;
    }
    text = this.canvasText.getText(text, start, end, true);
    return text.split(SPLITREGEXP);
  }
  getPlainText(text, start, end) {
    if (typeof text === "number") {
      end = start;
      start = text;
      text = void 0;
    }
    return this.canvasText.getPlainText(text, start, end);
  }
  getText(text, start, end, wrap) {
    if (typeof text === "number") {
      wrap = end;
      end = start;
      start = text;
      text = void 0;
    }
    if (wrap === void 0) {
      wrap = false;
    }
    return this.canvasText.getText(text, start, end, wrap);
  }
  getSubString(text, start, end) {
    if (typeof text === "number") {
      end = start;
      start = text;
      text = void 0;
    }
    return this.getText(text, start, end);
  }
  copyPenManager(penManager) {
    return this.canvasText.copyPenManager(penManager);
  }
  getPenManager(text, penManager) {
    return this.canvasText.getPenManager(text, penManager);
  }
  setSize(width, height) {
    return this.setFixedSize(width, height);
  }
  resize(width, height) {
    return this.setFixedSize(width, height);
  }
  get imageManager() {
    if (!this._imageManager) {
      this._imageManager = new ImageManager_default(this.scene);
    }
    return this._imageManager;
  }
  addImage(key2, config) {
    this.imageManager.add(key2, config);
    return this;
  }
  drawAreaBounds(graphics, color) {
    this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
    return this;
  }
  generateTexture(key2, x, y, width, height) {
    var srcCanvas = this.canvas;
    if (width === void 0) {
      width = srcCanvas.width;
    } else {
      width *= this.resolution;
    }
    if (height === void 0) {
      height = srcCanvas.height;
    } else {
      height *= this.resolution;
    }
    CopyCanvasToTexture_default(this.scene, srcCanvas, key2, x, y, width, height);
    return this;
  }
  getHitArea(worldX, worldY, camera) {
    return this.canvasText.getHitArea(worldX, worldY, camera);
  }
};
var methods5 = {
  appendText: AppendText_default
};
Object.assign(
  Text.prototype,
  methods5
);
var Text_default = Text;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/SplitText.js
var SplitText = function(text, mode) {
  var TagRegex = this.tagRegex;
  var result = [];
  var charIdx = 0;
  var rawMode = false, escMode = false;
  while (true) {
    var regexResult = TagRegex.RE_SPLITTEXT.exec(text);
    if (!regexResult) {
      break;
    }
    var match = regexResult[0];
    if (escMode) {
      if (TagRegex.RE_ESC_CLOSE.test(match)) {
        escMode = false;
      } else {
        continue;
      }
    } else if (rawMode) {
      if (TagRegex.RE_RAW_CLOSE.test(match)) {
        rawMode = false;
      } else {
        continue;
      }
    } else {
      if (TagRegex.RE_ESC_OPEN.test(match)) {
        escMode = true;
      } else if (TagRegex.RE_RAW_OPEN.test(match)) {
        rawMode = true;
      }
    }
    var matchEnd = TagRegex.RE_SPLITTEXT.lastIndex;
    var matchStart = matchEnd - match.length;
    if (charIdx < matchStart) {
      var content = text.substring(charIdx, matchStart);
      result.push(content);
    }
    if (mode === void 0) {
      result.push(match);
    }
    charIdx = matchEnd;
  }
  var totalLen = text.length;
  if (charIdx < totalLen) {
    result.push(text.substring(charIdx, totalLen));
  }
  return result;
};
var SplitText_default = SplitText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/TagTextToProp.js
var PROP_REMOVE = false;
var PROP_ADD = true;
var GETPROP_RESULT = {
  plainText: null,
  prevProp: null
};
var TagTextToProp = function(text, prevProp) {
  var TagRegex = this.tagRegex;
  if (prevProp == null) {
    prevProp = {};
  }
  var plainText = "";
  if (prevProp.img) {
    UpdateProp(prevProp, PROP_REMOVE, "img");
  }
  if (prevProp.esc) {
    if (TagRegex.RE_ESC_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "esc");
    } else {
      plainText = text;
    }
  } else if (prevProp.raw) {
    if (TagRegex.RE_RAW_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "raw");
    } else {
      plainText = text;
    }
  } else {
    if (TagRegex.RE_ESC_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "esc", true);
    } else if (TagRegex.RE_ESC_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "esc");
    } else if (TagRegex.RE_RAW_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "raw", true);
    } else if (TagRegex.RE_RAW_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "raw");
    } else if (TagRegex.RE_BLOD_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "b", true);
    } else if (TagRegex.RE_BLOD_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "b");
    } else if (TagRegex.RE_ITALICS_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "i", true);
    } else if (TagRegex.RE_ITALICS_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "i");
    } else if (TagRegex.RE_WEIGHT_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_WEIGHT_OPEN);
      UpdateProp(prevProp, PROP_ADD, "weight", innerMatch[1]);
    } else if (TagRegex.RE_WEIGHT_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "weight");
    } else if (TagRegex.RE_SIZE_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_SIZE_OPEN);
      UpdateProp(prevProp, PROP_ADD, "size", `${innerMatch[1]}px`);
    } else if (TagRegex.RE_SIZE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "size");
    } else if (TagRegex.RE_FAMILY_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_FAMILY_OPEN);
      UpdateProp(prevProp, PROP_ADD, "family", innerMatch[1]);
    } else if (TagRegex.RE_FAMILY_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "family");
    } else if (TagRegex.RE_COLOR_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_COLOR_OPEN);
      UpdateProp(prevProp, PROP_ADD, "color", innerMatch[1]);
    } else if (TagRegex.RE_COLOR_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "color");
    } else if (TagRegex.RE_UNDERLINE_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "u", true);
    } else if (TagRegex.RE_UNDERLINE_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_UNDERLINE_OPENC);
      UpdateProp(prevProp, PROP_ADD, "u", innerMatch[1]);
    } else if (TagRegex.RE_UNDERLINE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "u");
    } else if (TagRegex.RE_STRIKETHROUGH_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "s", true);
    } else if (TagRegex.RE_STRIKETHROUGH_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_STRIKETHROUGH_OPENC);
      UpdateProp(prevProp, PROP_ADD, "s", innerMatch[1]);
    } else if (TagRegex.RE_STRIKETHROUGH_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "s");
    } else if (TagRegex.RE_SHADOW_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "shadow", true);
    } else if (TagRegex.RE_SHADOW_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_SHADOW_OPENC);
      UpdateProp(prevProp, PROP_ADD, "shadow", innerMatch[1]);
    } else if (TagRegex.RE_SHADOW_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "shadow");
    } else if (TagRegex.RE_STROKE_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "stroke", true);
    } else if (TagRegex.RE_STROKE_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_STROKE_OPENC);
      UpdateProp(prevProp, PROP_ADD, "stroke", innerMatch[1]);
    } else if (TagRegex.RE_STROKE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "stroke");
    } else if (TagRegex.RE_BGCOLOR_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_BGCOLOR_OPEN);
      UpdateProp(prevProp, PROP_ADD, "bgcolor", innerMatch[1]);
    } else if (TagRegex.RE_BGCOLOR_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "bgcolor");
    } else if (TagRegex.RE_OFFSETY_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_OFFSETY_OPEN);
      UpdateProp(prevProp, PROP_ADD, "y", parseFloat(innerMatch[1]));
    } else if (TagRegex.RE_OFFSETY_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "y");
    } else if (TagRegex.RE_IMAGE_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_IMAGE_OPEN);
      UpdateProp(prevProp, PROP_ADD, "img", innerMatch[1]);
    } else if (TagRegex.RE_IMAGE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "img");
    } else if (TagRegex.RE_AREA_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_AREA_OPEN);
      UpdateProp(prevProp, PROP_ADD, "area", innerMatch[1]);
    } else if (TagRegex.RE_AREA_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "area");
    } else if (TagRegex.RE_URL_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_URL_OPEN);
      UpdateProp(prevProp, PROP_ADD, "url", innerMatch[1]);
    } else if (TagRegex.RE_URL_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "url");
    } else if (TagRegex.RE_ALIGN_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_ALIGN_OPEN);
      UpdateProp(prevProp, PROP_ADD, "align", innerMatch[1]);
    } else if (TagRegex.RE_ALIGN_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "align");
    } else if (TagRegex.RE_ID_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_ID_OPEN);
      UpdateProp(prevProp, PROP_ADD, "id", innerMatch[1]);
    } else if (TagRegex.RE_ID_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "id");
    } else {
      plainText = text;
    }
  }
  var result = GETPROP_RESULT;
  result.plainText = plainText;
  result.prop = prevProp;
  return result;
};
var UpdateProp = function(prop, op, key2, value) {
  if (op === PROP_ADD) {
    prop[key2] = value;
  } else {
    if (prop.hasOwnProperty(key2)) {
      delete prop[key2];
    }
  }
  return prop;
};
var TagTextToProp_default = TagTextToProp;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/PropToContextStyle.js
var PropToContextStyle = function(defaultStyle, prop) {
  var result = STYLE_RESULT;
  if (!prop.hasOwnProperty("img")) {
    result.image = null;
    if (prop.hasOwnProperty("family")) {
      result.fontFamily = prop.family;
    } else {
      result.fontFamily = defaultStyle.fontFamily;
    }
    if (prop.hasOwnProperty("size")) {
      var size = prop.size;
      if (typeof size === "number") {
        size = `${size}px`;
      }
      result.fontSize = size;
    } else {
      result.fontSize = defaultStyle.fontSize;
    }
    result.fontStyle = GetFontStyle(prop);
    if (prop.hasOwnProperty("color")) {
      result.color = prop.color;
    } else {
      result.color = defaultStyle.color;
    }
    if (prop.hasOwnProperty("stroke")) {
      if (prop.stroke === true) {
        result.stroke = defaultStyle.stroke;
        result.strokeThickness = defaultStyle.strokeThickness;
      } else {
        result.stroke = prop.stroke;
        result.strokeThickness = defaultStyle.strokeThickness;
      }
    } else {
      result.stroke = defaultStyle.stroke;
      result.strokeThickness = 0;
    }
  } else {
    result.image = prop.img;
  }
  if (prop.hasOwnProperty("shadow")) {
    if (prop.shadow === true) {
      result.shadowColor = defaultStyle.shadowColor;
      result.shadowOffsetX = defaultStyle.shadowOffsetX;
      result.shadowOffsetY = defaultStyle.shadowOffsetY;
      result.shadowBlur = defaultStyle.shadowBlur;
      result.shadowStroke = true;
      result.shadowFill = true;
    } else {
      result.shadowColor = prop.shadow;
      result.shadowOffsetX = defaultStyle.shadowOffsetX;
      result.shadowOffsetY = defaultStyle.shadowOffsetY;
      result.shadowBlur = defaultStyle.shadowBlur;
      result.shadowStroke = true;
      result.shadowFill = true;
    }
  } else {
    result.shadowColor = "#000";
    result.shadowOffsetX = 0;
    result.shadowOffsetY = 0;
    result.shadowBlur = 0;
    result.shadowStroke = false;
    result.shadowFill = false;
  }
  if (prop.hasOwnProperty("u")) {
    if (prop.u === true) {
      result.underlineColor = defaultStyle.underlineColor;
      result.underlineThickness = defaultStyle.underlineThickness;
      result.underlineOffset = defaultStyle.underlineOffset;
    } else {
      result.underlineColor = prop.u;
      result.underlineThickness = defaultStyle.underlineThickness;
      result.underlineOffset = defaultStyle.underlineOffset;
    }
  } else {
    result.underlineColor = "#000";
    result.underlineThickness = 0;
    result.underlineOffset = 0;
  }
  if (prop.hasOwnProperty("s")) {
    if (prop.s === true) {
      result.strikethroughColor = defaultStyle.strikethroughColor;
      result.strikethroughThickness = defaultStyle.strikethroughThickness;
      result.strikethroughOffset = defaultStyle.strikethroughOffset;
    } else {
      result.strikethroughColor = prop.s;
      result.strikethroughThickness = defaultStyle.strikethroughThickness;
      result.strikethroughOffset = defaultStyle.strikethroughOffset;
    }
  } else {
    result.strikethroughColor = "#000";
    result.strikethroughThickness = 0;
    result.strikethroughOffset = 0;
  }
  if (prop.hasOwnProperty("bgcolor")) {
    result.bgcolor = prop.bgcolor;
  } else {
    result.bgcolor = null;
  }
  return result;
};
var GetFontStyle = function(prop) {
  var isBold = prop.b;
  var weight = prop.weight;
  var isItalic = prop.i;
  if (isBold || weight || isItalic) {
    if (isItalic) {
      if (isBold) {
        return "bold italic";
      } else if (weight) {
        return `${weight} italic`;
      } else {
        return "italic";
      }
    } else {
      if (isBold) {
        return "bold";
      } else {
        return weight.toString();
      }
    }
  } else {
    return "";
  }
};
var STYLE_RESULT = new TextStyle_default();
var PropToContextStyle_default = PropToContextStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/PropToTagText.js
var PropToTagText = function(text, prop, prevProp) {
  if (prevProp == null) {
    prevProp = EMPTYPROP;
  }
  var delimiterLeft = this.delimiters[0];
  var delimiterRight = this.delimiters[1];
  var headers = [];
  for (var k in prevProp) {
    if (!prop.hasOwnProperty(k)) {
      headers.push(`${delimiterLeft}/${k}${delimiterRight}`);
    }
  }
  for (var k in prop) {
    var value = prop[k];
    if (k === "img") {
    } else {
      if (prevProp[k] === value) {
        continue;
      }
    }
    switch (k) {
      case "size":
        headers.push(`${delimiterLeft}size=${value.replace("px", "")}${delimiterRight}`);
        break;
      case "color":
      case "weight":
      case "family":
      case "stroke":
      case "bgcolor":
      case "y":
      case "img":
      case "area":
      case "url":
      case "align":
      case "id":
        headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
        break;
      case "u":
      case "s":
        if (value === true) {
          headers.push(`${delimiterLeft}${k}${delimiterRight}`);
        } else {
          headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
        }
        break;
      default:
        headers.push(`${delimiterLeft}${k}${delimiterRight}`);
        break;
    }
  }
  headers.push(text);
  return headers.join("");
};
var EMPTYPROP = {};
var PropToTagText_default = PropToTagText;

// node_modules/phaser3-rex-plugins/plugins/utils/string/EscapeRegex.js
var EscapeRegex = function(s) {
  return s.replace(re0, "\\$&").replace(re1, "\\x2d");
};
var re0 = /[|\\{}()[\]^$+*?.]/g;
var re1 = /-/g;
var EscapeRegex_default = EscapeRegex;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/TagRegex.js
var DelimiterLeftSave;
var DelimiterRightSave;
var TagRegexSave = {};
var GetOpenTagRegString = function(delimiterLeft, delimiterRight, tagName, param) {
  if (param === void 0) {
    return `${delimiterLeft}${tagName}${delimiterRight}`;
  } else {
    return `${delimiterLeft}${tagName}=(${param})${delimiterRight}`;
  }
};
var GetCloseTagRegString = function(delimiterLeft, delimiterRight, tagName) {
  return `${delimiterLeft}/${tagName}${delimiterRight}`;
};
var GenerateStringRegEx = function(delimiterRight) {
  return `[^${delimiterRight}]+`;
};
var NUMBER_PARAM = "[-.0-9]+";
var colorParameterList = [
  "[a-zA-Z]+",
  // 'white'
  "#[0-9abcdef]+",
  // '#FFFFFF'
  "rgba?\\(s*[.0-9]+s*(,s*[.0-9]+s*){2,3}\\)"
  // rgb(255,255,255), or rgba(255,255,255,1)
];
var COLOR_PARAM = colorParameterList.join("|");
var SetDelimiters = function(delimiterLeft, delimiterRight) {
  if (delimiterRight === void 0) {
    var delimeters = delimiterLeft;
    delimiterLeft = delimeters[0];
    delimiterRight = delimeters[1];
  }
  if (DelimiterLeftSave === delimiterLeft && DelimiterRightSave === delimiterRight) {
    return false;
  }
  DelimiterLeftSave = delimiterLeft;
  DelimiterRightSave = delimiterRight;
  delimiterLeft = EscapeRegex_default(delimiterLeft);
  delimiterRight = EscapeRegex_default(delimiterRight);
  var STR_PARAM = GenerateStringRegEx(delimiterRight);
  var ESC = "esc";
  var ESC_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ESC);
  var ESC_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ESC);
  var RAW = "raw";
  var RAW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, RAW);
  var RAW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, RAW);
  var BLOD = "b";
  var BLOD_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BLOD);
  var BLOD_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BLOD);
  var ITALICS = "i";
  var ITALICS_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ITALICS);
  var ITALICS_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ITALICS);
  var WEIGHT = "weight";
  var WEIGHT_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, WEIGHT, NUMBER_PARAM);
  var WEIGHT_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, WEIGHT);
  var SIZE = "size";
  var SIZE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SIZE, NUMBER_PARAM);
  var SIZE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SIZE);
  var FAMILY = "family";
  var FAMILY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, FAMILY, STR_PARAM);
  var FAMILY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, FAMILY);
  var COLOR = "color";
  var COLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, COLOR, COLOR_PARAM);
  var COLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, COLOR);
  var UNDERLINE = "u";
  var UNDERLINE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
  var UNDERLINE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE, COLOR_PARAM);
  var UNDERLINE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
  var STRIKETHROUGH = "s";
  var STRIKETHROUGH_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
  var STRIKETHROUGH_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH, COLOR_PARAM);
  var STRIKETHROUGH_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
  var SHADOW = "shadow";
  var SHADOW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW);
  var SHADOW_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW, COLOR_PARAM);
  var SHADOW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SHADOW);
  var STROKE = "stroke";
  var STROKE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE);
  var STROKE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE, COLOR_PARAM);
  var STROKE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STROKE);
  var BGCOLOR = "bgcolor";
  var BGCOLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BGCOLOR, COLOR_PARAM);
  var BGCOLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BGCOLOR);
  var OFFSETY = "y";
  var OFFSETY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, OFFSETY, NUMBER_PARAM);
  var OFFSETY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, OFFSETY);
  var IMAGE = "img";
  var IMAGE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, IMAGE, STR_PARAM);
  var IMAGE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, IMAGE);
  var AREA = "area";
  var AREA_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, AREA, STR_PARAM);
  var AREA_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, AREA);
  var URL2 = "url";
  var URL_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, URL2, STR_PARAM);
  var URL_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, URL2);
  var ALIGN3 = "align";
  var ALIGN_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ALIGN3, STR_PARAM);
  var ALIGN_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ALIGN3);
  var ID = "id";
  var ID_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ID, STR_PARAM);
  var ID_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ID);
  TagRegexSave.RE_ESC_OPEN = new RegExp(ESC_OPEN, "i");
  TagRegexSave.RE_ESC_CLOSE = new RegExp(ESC_CLOSE, "i");
  TagRegexSave.RE_RAW_OPEN = new RegExp(RAW_OPEN, "i");
  TagRegexSave.RE_RAW_CLOSE = new RegExp(RAW_CLOSE, "i");
  TagRegexSave.RE_BLOD_OPEN = new RegExp(BLOD_OPEN, "i");
  TagRegexSave.RE_BLOD_CLOSE = new RegExp(BLOD_CLOSE, "i");
  TagRegexSave.RE_ITALICS_OPEN = new RegExp(ITALICS_OPEN, "i");
  TagRegexSave.RE_ITALICS_CLOSE = new RegExp(ITALICS_CLOSE, "i");
  TagRegexSave.RE_WEIGHT_OPEN = new RegExp(WEIGHT_OPEN, "i");
  TagRegexSave.RE_WEIGHT_CLOSE = new RegExp(WEIGHT_CLOSE, "i");
  TagRegexSave.RE_SIZE_OPEN = new RegExp(SIZE_OPEN, "i");
  TagRegexSave.RE_SIZE_CLOSE = new RegExp(SIZE_CLOSE, "i");
  TagRegexSave.RE_FAMILY_OPEN = new RegExp(FAMILY_OPEN, "i");
  TagRegexSave.RE_FAMILY_CLOSE = new RegExp(FAMILY_CLOSE, "i");
  TagRegexSave.RE_COLOR_OPEN = new RegExp(COLOR_OPEN, "i");
  TagRegexSave.RE_COLOR_CLOSE = new RegExp(COLOR_CLOSE, "i");
  TagRegexSave.RE_UNDERLINE_OPEN = new RegExp(UNDERLINE_OPEN, "i");
  TagRegexSave.RE_UNDERLINE_OPENC = new RegExp(UNDERLINE_OPENC, "i");
  TagRegexSave.RE_UNDERLINE_CLOSE = new RegExp(UNDERLINE_CLOSE, "i");
  TagRegexSave.RE_STRIKETHROUGH_OPEN = new RegExp(STRIKETHROUGH_OPEN, "i");
  TagRegexSave.RE_STRIKETHROUGH_OPENC = new RegExp(STRIKETHROUGH_OPENC, "i");
  TagRegexSave.RE_STRIKETHROUGH_CLOSE = new RegExp(STRIKETHROUGH_CLOSE, "i");
  TagRegexSave.RE_SHADOW_OPEN = new RegExp(SHADOW_OPEN, "i");
  TagRegexSave.RE_SHADOW_OPENC = new RegExp(SHADOW_OPENC, "i");
  TagRegexSave.RE_SHADOW_CLOSE = new RegExp(SHADOW_CLOSE, "i");
  TagRegexSave.RE_STROKE_OPEN = new RegExp(STROKE_OPEN, "i");
  TagRegexSave.RE_STROKE_OPENC = new RegExp(STROKE_OPENC, "i");
  TagRegexSave.RE_STROKE_CLOSE = new RegExp(STROKE_CLOSE, "i");
  TagRegexSave.RE_BGCOLOR_OPEN = new RegExp(BGCOLOR_OPEN, "i");
  TagRegexSave.RE_BGCOLOR_CLOSE = new RegExp(BGCOLOR_CLOSE, "i");
  TagRegexSave.RE_OFFSETY_OPEN = new RegExp(OFFSETY_OPEN, "i");
  TagRegexSave.RE_OFFSETY_CLOSE = new RegExp(OFFSETY_CLOSE, "i");
  TagRegexSave.RE_IMAGE_OPEN = new RegExp(IMAGE_OPEN, "i");
  TagRegexSave.RE_IMAGE_CLOSE = new RegExp(IMAGE_CLOSE, "i");
  TagRegexSave.RE_AREA_OPEN = new RegExp(AREA_OPEN, "i");
  TagRegexSave.RE_AREA_CLOSE = new RegExp(AREA_CLOSE, "i");
  TagRegexSave.RE_URL_OPEN = new RegExp(URL_OPEN, "i");
  TagRegexSave.RE_URL_CLOSE = new RegExp(URL_CLOSE, "i");
  TagRegexSave.RE_ALIGN_OPEN = new RegExp(ALIGN_OPEN, "i");
  TagRegexSave.RE_ALIGN_CLOSE = new RegExp(ALIGN_CLOSE, "i");
  TagRegexSave.RE_ID_OPEN = new RegExp(ID_OPEN, "i");
  TagRegexSave.RE_ID_CLOSE = new RegExp(ID_CLOSE, "i");
  TagRegexSave.RE_SPLITTEXT = new RegExp([
    RAW_OPEN,
    RAW_CLOSE,
    ESC_OPEN,
    ESC_CLOSE,
    BLOD_OPEN,
    BLOD_CLOSE,
    ITALICS_OPEN,
    ITALICS_CLOSE,
    WEIGHT_OPEN,
    WEIGHT_CLOSE,
    SIZE_OPEN,
    SIZE_CLOSE,
    FAMILY_OPEN,
    FAMILY_CLOSE,
    COLOR_OPEN,
    COLOR_CLOSE,
    UNDERLINE_OPEN,
    UNDERLINE_OPENC,
    UNDERLINE_CLOSE,
    STRIKETHROUGH_OPEN,
    STRIKETHROUGH_OPENC,
    STRIKETHROUGH_CLOSE,
    SHADOW_OPEN,
    SHADOW_OPENC,
    SHADOW_CLOSE,
    STROKE_OPEN,
    STROKE_OPENC,
    STROKE_CLOSE,
    BGCOLOR_OPEN,
    BGCOLOR_CLOSE,
    OFFSETY_OPEN,
    OFFSETY_CLOSE,
    IMAGE_OPEN,
    IMAGE_CLOSE,
    AREA_OPEN,
    AREA_CLOSE,
    URL_OPEN,
    URL_CLOSE,
    ALIGN_OPEN,
    ALIGN_CLOSE,
    ID_OPEN,
    ID_CLOSE
  ].join("|"), "ig");
  return true;
};
var GetTagRegex = function(delimiterLeft, delimiterRight) {
  if (delimiterLeft !== void 0) {
    SetDelimiters(delimiterLeft, delimiterRight);
  }
  return Object.assign({}, TagRegexSave);
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/Parser.js
var GetValue16 = Phaser.Utils.Objects.GetValue;
var Parser = class {
  constructor(style) {
    var delimiters = GetValue16(style, "delimiters", "[]");
    this.tagRegex = GetTagRegex(delimiters);
    this.delimiters = delimiters;
  }
  getStrokeThinkness(defaultStyle, prop) {
    var strokeThickness;
    if (prop.hasOwnProperty("stroke")) {
      strokeThickness = defaultStyle.strokeThickness;
    } else {
      strokeThickness = 0;
    }
    return strokeThickness;
  }
  setDelimiters(delimiterLeft, delimiterRight) {
    if (SetDelimiters(delimiterLeft, delimiterRight)) {
      this.tagRegex = GetTagRegex();
    }
    return this;
  }
};
var methods6 = {
  splitText: SplitText_default,
  tagTextToProp: TagTextToProp_default,
  propToContextStyle: PropToContextStyle_default,
  propToTagText: PropToTagText_default
};
Object.assign(
  Parser.prototype,
  methods6
);
var Parser_default = Parser;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/BBCodeText.js
var BBCodeText = class extends Text_default {
  constructor(scene, x, y, text, style) {
    var parser = new Parser_default(style);
    super(scene, x, y, text, style, "rexBBCodeText", parser);
  }
  setDelimiters(delimiterLeft, delimiterRight) {
    this.parser.setDelimiters(delimiterLeft, delimiterRight);
    return this;
  }
};
var BBCodeText_default = BBCodeText;

// node_modules/phaser3-rex-plugins/plugins/bbcodetext.js
var bbcodetext_default = BBCodeText_default;

// node_modules/phaser3-rex-plugins/templates/ui/bbcodetext/BBCodeText.js
var BBCodeText_default2 = bbcodetext_default;

// node_modules/phaser3-rex-plugins/templates/ui/bbcodetext/Factory.js
ObjectFactory_default.register("BBCodeText", function(x, y, text, style) {
  var gameObject2 = new BBCodeText_default2(this.scene, x, y, text, style);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.BBCodeText", BBCodeText_default2);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/tagtext/Parser.js
var GETPROP_RESULT2 = {
  plainText: null,
  prevProp: null
};
var STYLE_RESULT2 = new TextStyle_default();
var Parser2 = class {
  constructor(tags) {
    if (tags === void 0) {
      tags = {};
    }
    this.tags = tags;
  }
  addTag(name2, prop) {
    this.tags[name2] = prop;
  }
  getTag(name2) {
    return this.tags[name2];
  }
  splitText(text, mode) {
    var result = [];
    var charIdx = 0;
    while (true) {
      var regexResult = RE_SPLITTEXT.exec(text);
      if (!regexResult) {
        break;
      }
      var match = regexResult[0];
      var matchStart = RE_SPLITTEXT.lastIndex - match.length;
      if (charIdx < matchStart) {
        result.push(text.substring(charIdx, matchStart));
      }
      if (mode === void 0) {
        result.push(match);
      } else if (mode === 1) {
        if (RE_CLASS_HEADER.test(match)) {
          var innerMatch = match.match(RE_CLASS);
          result.push(innerMatch[2]);
        } else if (RE_STYLE_HEADER.test(match)) {
          var innerMatch = match.match(RE_STYLE);
          result.push(innerMatch[2]);
        }
      }
      charIdx = RE_SPLITTEXT.lastIndex;
    }
    var totalLen = text.length;
    if (charIdx < totalLen) {
      result.push(text.substring(charIdx, totalLen));
    }
    return result;
  }
  tagTextToProp(text, prevProp) {
    var plainText, propOut;
    if (RE_CLASS_HEADER.test(text)) {
      var innerMatch = text.match(RE_CLASS);
      if (innerMatch != null) {
        var name2 = innerMatch[1];
        var tags = this.tags;
        if (tags.hasOwnProperty(name2)) {
          propOut = tags[name2];
        } else {
          propOut = {};
        }
        propOut._class = name2;
        plainText = innerMatch[2];
      }
    } else if (RE_STYLE_HEADER.test(text)) {
      var innerMatch = text.match(RE_STYLE);
      if (innerMatch != null) {
        var style = innerMatch[1];
        propOut = StyleToProp(style);
        propOut._style = style;
        plainText = innerMatch[2];
      }
    }
    if (plainText == null) {
      plainText = text;
    }
    if (propOut == null) {
      propOut = {};
    }
    var result = GETPROP_RESULT2;
    result.plainText = plainText;
    result.prop = propOut;
    return result;
  }
  propToContextStyle(defaultStyle, prop) {
    var result = STYLE_RESULT2;
    if (!prop.hasOwnProperty("img")) {
      result.image = null;
      if (prop.hasOwnProperty("family") || prop.hasOwnProperty("fontFamily") || prop.hasOwnProperty("font-family")) {
        var family = prop.hasOwnProperty("family") ? prop.family : prop.hasOwnProperty("fontFamily") ? prop.fontFamily : prop["font-family"];
        result.fontFamily = family;
      } else {
        result.fontFamily = defaultStyle.fontFamily;
      }
      if (prop.hasOwnProperty("size") || prop.hasOwnProperty("fontSize") || prop.hasOwnProperty("font-size")) {
        var size = prop.hasOwnProperty("size") ? prop.size : prop.hasOwnProperty("fontSize") ? prop.fontSize : prop["font-size"];
        if (typeof size === "number") {
          size = `${size}px`;
        }
        result.fontSize = size;
      } else {
        result.fontSize = defaultStyle.fontSize;
      }
      if (prop.hasOwnProperty("style") || prop.hasOwnProperty("fontStyle") || prop.hasOwnProperty("font-style")) {
        var fontStyle = prop.hasOwnProperty("style") ? prop.style : prop.hasOwnProperty("fontStyle") ? prop.fontStyle : prop["font-style"];
        result.fontStyle = fontStyle;
      } else {
        result.fontStyle = defaultStyle.fontStyle;
      }
      if (prop.hasOwnProperty("color") || prop.hasOwnProperty("font-color")) {
        var color = prop.hasOwnProperty("color") ? prop.color : prop["font-color"];
        result.color = color;
      } else {
        result.color = defaultStyle.color;
      }
      if (prop.hasOwnProperty("stroke")) {
        var stroke = prop.stroke;
        result.stroke = stroke.hasOwnProperty("color") ? stroke.color : defaultStyle.stroke;
        result.strokeThickness = stroke.hasOwnProperty("thickness") ? stroke.thickness : defaultStyle.strokeThickness;
      } else {
        result.stroke = defaultStyle.stroke;
        result.strokeThickness = defaultStyle.strokeThickness;
      }
    } else {
      result.image = prop.img;
    }
    if (prop.hasOwnProperty("shadow")) {
      var shadow = prop.shadow;
      result.shadowColor = shadow.hasOwnProperty("color") ? shadow.color : defaultStyle.shadowColor;
      result.shadowOffsetX = shadow.hasOwnProperty("offsetX") ? shadow.offsetX : defaultStyle.shadowOffsetX;
      result.shadowOffsetY = shadow.hasOwnProperty("offsetY") ? shadow.offsetY : defaultStyle.shadowOffsetY;
      result.shadowBlur = shadow.hasOwnProperty("blur") ? shadow.blur : defaultStyle.shadowBlur;
      result.shadowStroke = true;
      result.shadowFill = true;
    } else {
      result.shadowColor = defaultStyle.shadowColor;
      result.shadowOffsetX = defaultStyle.shadowOffsetX;
      result.shadowOffsetY = defaultStyle.shadowOffsetY;
      result.shadowBlur = defaultStyle.shadowBlur;
      result.shadowStroke = defaultStyle.shadowStroke;
      result.shadowFill = defaultStyle.shadowFill;
    }
    if (prop.hasOwnProperty("u") || prop.hasOwnProperty("underline")) {
      var u = prop.hasOwnProperty("u") ? prop.u : prop.underline;
      result.underlineColor = u.hasOwnProperty("color") ? u.color : defaultStyle.underlineColor;
      result.underlineThickness = u.hasOwnProperty("thickness") ? u.thickness : defaultStyle.underlineThickness;
      result.underlineOffset = u.hasOwnProperty("offset") ? u.offset : defaultStyle.underlineOffset;
    } else {
      result.underlineColor = defaultStyle.underlineColor;
      result.underlineThickness = defaultStyle.underlineThickness;
      result.underlineOffset = defaultStyle.underlineOffset;
    }
    if (prop.hasOwnProperty("s") || prop.hasOwnProperty("strikethrough")) {
      var s = prop.hasOwnProperty("s") ? prop.s : prop.strikethrough;
      result.strikethroughColor = s.hasOwnProperty("color") ? s.color : defaultStyle.strikethroughColor;
      result.strikethroughThickness = s.hasOwnProperty("thickness") ? s.thickness : defaultStyle.strikethroughThickness;
      result.strikethroughOffset = s.hasOwnProperty("offset") ? s.offset : defaultStyle.strikethroughOffset;
    } else {
      result.strikethroughColor = defaultStyle.strikethroughColor;
      result.strikethroughThickness = defaultStyle.strikethroughThickness;
      result.strikethroughOffset = defaultStyle.strikethroughOffset;
    }
    return result;
  }
  getStrokeThinkness(defaultStyle, prop) {
    var strokeThinkness;
    if (prop.hasOwnProperty("stroke")) {
      var stroke = prop.stroke;
      strokeThinkness = stroke.hasOwnProperty("thickness") ? stroke.thickness : defaultStyle.strokeThickness;
    } else {
      strokeThinkness = defaultStyle.strokeThickness;
    }
    return strokeThinkness;
  }
  propToTagText(text, prop, prevProp) {
    if (prop.hasOwnProperty("_class")) {
      if (text === "") {
        if (this.isTextTag(prop._class)) {
          return "";
        }
      }
      return `<class='${prop._class}'>${text}</class>`;
    } else if (prop.hasOwnProperty("_style")) {
      return `<style='${prop._style}'>${text}</style>`;
    } else {
      return text;
    }
  }
  destroy() {
    this.tags = void 0;
  }
  isTextTag(tagName) {
    var tag = this.tags[tagName];
    if (tag) {
      return tag.img == null;
    } else {
      return false;
    }
  }
};
var StyleToProp = function(s) {
  s = s.split(";");
  var result = {}, prop, k, v;
  for (var i = 0, slen = s.length; i < slen; i++) {
    prop = s[i].split(":");
    k = prop[0], v = prop[1];
    if (isEmpty(k) || isEmpty(v)) {
      continue;
    }
    switch (k) {
      case "stroke":
        var params = v.split(" ");
        var len = params.length;
        v = {};
        if (len >= 1) {
          v.color = params[0];
        }
        if (len >= 2) {
          v.thickness = parseInt(params[1].replace("px", ""));
        }
        break;
      case "shadow":
        var params = v.split(" ");
        var len = params.length;
        v = {};
        if (len >= 1) {
          v.color = params[0];
        }
        if (len >= 2) {
          v.offsetX = parseInt(params[1].replace("px", ""));
        }
        if (len >= 3) {
          v.offsetY = parseInt(params[2].replace("px", ""));
        }
        if (len >= 4) {
          v.blur = parseInt(params[3].replace("px", ""));
        }
        break;
      case "u":
      case "underline":
      case "s":
      case "strikethrough":
        var params = v.split(" ");
        var len = params.length;
        v = {};
        if (len >= 1) {
          v.color = params[0];
        }
        if (len >= 2) {
          v.thickness = parseInt(params[1].replace("px", ""));
        }
        if (len >= 3) {
          v.offset = parseInt(params[2].replace("px", ""));
        }
        if (k === "underline") {
          k = "u";
        } else if (k === "strikethrough") {
          k = "s";
        }
        break;
      case "y":
        v = parseFloat(v);
        break;
    }
    result[k] = v;
  }
  return result;
};
var isEmpty = function(s) {
  s = s.replace(RE_SPACE, "");
  return s.length === 0;
};
var RE_SPLITTEXT = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g;
var RE_CLASS_HEADER = /<\s*class=/i;
var RE_CLASS = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/;
var RE_STYLE_HEADER = /<\s*style=/i;
var RE_STYLE = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/;
var RE_SPACE = /^\s+|\s+$/;
var Parser_default2 = Parser2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/tagtext/TagText.js
var GetValue17 = Phaser.Utils.Objects.GetValue;
var TagText = class extends Text_default {
  constructor(scene, x, y, text, style) {
    var tags = GetValue17(style, "tags", void 0);
    var parser = new Parser_default2(tags);
    super(scene, x, y, text, style, "rexTagText", parser);
  }
  addTag(name2, prop) {
    this.parser.addTag(name2, prop);
    return this.updateText(true);
  }
  addTags(tags) {
    for (var name2 in tags) {
      this.parser.addTag(name2, tags[name2]);
    }
    return this.updateText(true);
  }
  getTag(name2) {
    return this.parser.getTag(name2);
  }
  preDestroy() {
    super.preDestroy();
    this.parser.destroy();
    this.parser = void 0;
  }
};
var TagText_default = TagText;

// node_modules/phaser3-rex-plugins/plugins/tagtext.js
var tagtext_default = TagText_default;

// node_modules/phaser3-rex-plugins/templates/ui/tagtext/TagText.js
var TagText_default2 = tagtext_default;

// node_modules/phaser3-rex-plugins/templates/ui/tagtext/Factory.js
ObjectFactory_default.register("tagText", function(x, y, text, style) {
  var gameObject2 = new TagText_default2(this.scene, x, y, text, style);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TagText", TagText_default2);

// node_modules/phaser3-rex-plugins/plugins/utils/padding/PaddingMethods.js
var GetValue18 = Phaser.Utils.Objects.GetValue;
var GetPadding = function(padding, key2) {
  if (key2 === void 0) {
    return padding;
  }
  return padding[key2];
};
var SetPadding = function(padding, key2, value) {
  if (padding === void 0) {
    padding = {};
  }
  if (key2 === void 0) {
    key2 = 0;
  }
  var keyType = typeof key2;
  if (keyType === "string") {
    padding[key2] = value;
  } else if (keyType === "number") {
    padding.left = key2;
    padding.right = key2;
    padding.top = key2;
    padding.bottom = key2;
  } else {
    padding.left = GetValue18(key2, "left", 0);
    padding.right = GetValue18(key2, "right", 0);
    padding.top = GetValue18(key2, "top", 0);
    padding.bottom = GetValue18(key2, "bottom", 0);
  }
  return padding;
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/Base.js
var Base2 = class {
  constructor(parent, type) {
    this.setParent(parent);
    this.type = type;
    this.renderable = false;
    this.reset().setActive();
  }
  destroy() {
    this.parent.removeChild(this);
  }
  setParent(parent) {
    this.parent = parent;
    return this;
  }
  get scene() {
    return this.parent.scene;
  }
  get canvas() {
    return this.parent ? this.parent.canvas : null;
  }
  get context() {
    return this.parent ? this.parent.context : null;
  }
  setDirty(dirty) {
    if (dirty && this.parent) {
      this.parent.dirty = true;
    }
    return this;
  }
  get active() {
    return this._active;
  }
  set active(value) {
    this.setDirty(this._active != value);
    this._active = value;
  }
  setActive(active) {
    if (active === void 0) {
      active = true;
    }
    this.active = active;
    return this;
  }
  modifyPorperties(o) {
    return this;
  }
  // Override
  onFree() {
    this.reset().setParent();
  }
  // Override
  reset() {
    return this;
  }
  // Override
  render() {
  }
  // Override
  contains(x, y) {
    return false;
  }
};
Object.assign(
  Base2.prototype,
  DataMethods_default
);
var Base_default2 = Base2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/renderbase/RenderMethods.js
var RenderMethods_default = {
  // Override
  renderContent() {
  },
  // Override
  render() {
    if (!this.willRender) {
      return this;
    }
    var context = this.context;
    context.save();
    context.globalAlpha = this.alpha;
    if (this.toLocalPosition) {
      var x = this.drawX, y = this.drawY;
      if (this.autoRound) {
        x = Math.round(x);
        y = Math.round(y);
      }
      context.translate(x, y);
      context.scale(this.scaleX, this.scaleY);
      context.rotate(this.rotation);
    }
    if (this.drawBelowCallback) {
      this.drawBelowCallback(this);
    }
    this.renderContent();
    if (this.drawAboveCallback) {
      this.drawAboveCallback(this);
    }
    context.restore();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/utils/transform/CanvasPositionToBobPosition.js
var RotateAround = Phaser.Math.RotateAround;
var CanvasPositionToBobPosition = function(canvasX, canvasY, bob, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    if (globPoint === void 0) {
      globPoint = {};
    }
    out2 = globPoint;
  }
  out2.x = (canvasX - bob.drawX) / bob.scaleX;
  out2.y = (canvasY - bob.drawY) / bob.scaleY;
  if (bob.rotation !== 0) {
    RotateAround(out2, 0, 0, -bob.rotation);
  }
  return out2;
};
var globPoint;
var CanvasPositionToBobPosition_default = CanvasPositionToBobPosition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/renderbase/Contains.js
var Rectangle2 = Phaser.Geom.Rectangle;
var Contains = function(canvasX, canvasY) {
  if (this.width === 0 || this.height === 0) {
    return false;
  }
  var bobPosition = CanvasPositionToBobPosition_default(canvasX, canvasY, this, true);
  return GetBobBounds(this).contains(bobPosition.x, bobPosition.y);
};
var GetBobBounds = function(bob) {
  if (bobBounds === void 0) {
    bobBounds = new Rectangle2();
  }
  var x = bob.drawTLX, y = bob.drawTLY;
  bobBounds.setTo(x, y, bob.drawTRX - x, bob.drawBLY - y);
  return bobBounds;
};
var bobBounds;
var Contains_default = Contains;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/utils/transform/BobPositionToCanvasPosition.js
var RotateAround2 = Phaser.Math.RotateAround;
var BobPositionToCanvasPosition = function(bob, bobX, bobY, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    if (globPoint2 === void 0) {
      globPoint2 = {};
    }
    out2 = globPoint2;
  }
  out2.x = bobX;
  out2.y = bobY;
  if (bob.rotation !== 0) {
    RotateAround2(out2, 0, 0, bob.rotation);
  }
  out2.x = out2.x * bob.scaleX + bob.drawX;
  out2.y = out2.y * bob.scaleY + bob.drawY;
  return out2;
};
var globPoint2;
var BobPositionToCanvasPosition_default = BobPositionToCanvasPosition;

// node_modules/phaser3-rex-plugins/plugins/utils/position/GameObjectLocalXYToWorldXY.js
var TransformMatrix3 = Phaser.GameObjects.Components.TransformMatrix;
var GameObjectLocalXYToWorldXY = function(gameObject2, localX, localY, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = globOut2;
  }
  var px = localX - gameObject2.width * gameObject2.originX;
  var py = localY - gameObject2.height * gameObject2.originY;
  if (tempMatrix2 === void 0) {
    tempMatrix2 = new TransformMatrix3();
    parentMatrix2 = new TransformMatrix3();
  }
  if (gameObject2.parentContainer) {
    gameObject2.getWorldTransformMatrix(tempMatrix2, parentMatrix2);
  } else {
    tempMatrix2.applyITRS(gameObject2.x, gameObject2.y, gameObject2.rotation, gameObject2.scaleX, gameObject2.scaleY);
  }
  tempMatrix2.transformPoint(px, py, out2);
  return out2;
};
var tempMatrix2;
var parentMatrix2;
var globOut2 = {};
var GameObjectLocalXYToWorldXY_default = GameObjectLocalXYToWorldXY;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/utils/transform/BobPositionToWorldPosition.js
var BobPositionToWorldPosition = function(dynamicText, bob, bobX, bobY, out2) {
  var localXY = BobPositionToCanvasPosition_default(bob, bobX, bobY, true);
  var worldXY = GameObjectLocalXYToWorldXY_default(dynamicText, localXY.x, localXY.y, out2);
  return worldXY;
};
var BobPositionToWorldPosition_default = BobPositionToWorldPosition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/utils/transform/GetBobWorldPosition.js
var GetBobWorldPosition = function(dynamicText, bob, offsetX, offsetY, out2) {
  if (typeof offsetX !== "number") {
    out2 = offsetX;
    offsetX = 0;
    offsetY = 0;
  }
  var bobX = bob.drawCenterX + offsetX;
  var bobY = bob.drawCenterY + offsetY;
  return BobPositionToWorldPosition_default(dynamicText, bob, bobX, bobY, out2);
};
var GetBobWorldPosition_default = GetBobWorldPosition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/renderbase/GetWorldPosition.js
var GetWorldPosition = function(offsetX, offsetY, out2) {
  return GetBobWorldPosition_default(this.parent, this, offsetX, offsetY, out2);
};
var GetWorldPosition_default = GetWorldPosition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/renderbase/Methods.js
var Methods2 = {
  contains: Contains_default,
  getWorldPosition: GetWorldPosition_default
};
Object.assign(
  Methods2,
  RenderMethods_default
);
var Methods_default4 = Methods2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/renderbase/RenderBase.js
var DegToRad4 = Phaser.Math.DegToRad;
var RadToDeg2 = Phaser.Math.RadToDeg;
var GetValue19 = Phaser.Utils.Objects.GetValue;
var RenderBase2 = class extends Base_default2 {
  constructor(parent, type) {
    super(parent, type);
    this.renderable = true;
    this.scrollFactorX = 1;
    this.scrollFactorY = 1;
    this.toLocalPosition = true;
    this.originX = 0;
    this.offsetX = 0;
    this.offsetY = 0;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this.setDirty(this._visible != value);
    this._visible = value;
  }
  setVisible(visible) {
    if (visible === void 0) {
      visible = true;
    }
    this.visible = visible;
    return this;
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(value) {
    this.setDirty(this._alpha != value);
    this._alpha = value;
  }
  setAlpha(alpha) {
    this.alpha = alpha;
    return this;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this.setDirty(this._x != value);
    this._x = value;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this.setDirty(this._y != value);
    this._y = value;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setInitialPosition(x, y) {
    this.x0 = x;
    this.y0 = y;
    return this;
  }
  setScrollFactorX(x) {
    this.scrollFactorX = x;
    return this;
  }
  setScrollFactorY(y) {
    this.scrollFactorY = y;
    return this;
  }
  setScrollFactor(x, y) {
    if (y === void 0) {
      y = x;
    }
    this.scrollFactorX = x;
    this.scrollFactorY = y;
    return this;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this.setDirty(this._rotation != value);
    this._rotation = value;
  }
  setRotation(rotation) {
    this.rotation = rotation;
    return this;
  }
  get angle() {
    return RadToDeg2(this._rotation);
  }
  set angle(value) {
    this.rotation = DegToRad4(value);
  }
  setAngle(angle) {
    this.angle = angle;
    return this;
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleX(value) {
    this.setDirty(this._scaleX !== value);
    this._scaleX = value;
  }
  setScaleX(scaleX) {
    this.scaleX = scaleX;
    return this;
  }
  // Override
  get width() {
    return 0;
  }
  // Override
  set width(value) {
  }
  setWidth(width, keepAspectRatio) {
    if (keepAspectRatio === void 0) {
      keepAspectRatio = false;
    }
    this.width = width;
    if (keepAspectRatio) {
      this.scaleY = this.scaleX;
    }
    return this;
  }
  get leftSpace() {
    return this._leftSpace;
  }
  set leftSpace(value) {
    this.setDirty(this._leftSpace !== value);
    this._leftSpace = value;
  }
  setLeftSpace(value) {
    this.leftSpace = value;
    return this;
  }
  get rightSpace() {
    return this._rightSpace;
  }
  set rightSpace(value) {
    this.setDirty(this._rightSpace !== value);
    this._rightSpace = value;
  }
  setRightSpace(value) {
    this.rightSpace = value;
    return this;
  }
  get outerWidth() {
    return this.width + this.leftSpace + this.rightSpace;
  }
  get scaleY() {
    return this._scaleY;
  }
  set scaleY(value) {
    this.setDirty(this._scaleY !== value);
    this._scaleY = value;
  }
  setScaleY(scaleY) {
    this.scaleY = scaleY;
    return this;
  }
  // Override
  get height() {
    return 0;
  }
  // Override
  set height(value) {
  }
  setHeight(height, keepAspectRatio) {
    if (keepAspectRatio === void 0) {
      keepAspectRatio = false;
    }
    this.height = height;
    if (keepAspectRatio) {
      this.scaleX = this.scaleY;
    }
    return this;
  }
  setScale(scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    this.scaleX = scaleX;
    this.scaleY = scaleY;
    return this;
  }
  setOrigin(x) {
    this.originX = x;
    return this;
  }
  setAlign(align) {
    this.align = align;
    return this;
  }
  modifyPorperties(o) {
    if (!o) {
      return this;
    }
    if (o.hasOwnProperty("x")) {
      this.setX(o.x);
    }
    if (o.hasOwnProperty("y")) {
      this.setY(o.y);
    }
    if (o.hasOwnProperty("rotation")) {
      this.setRotation(o.rotation);
    } else if (o.hasOwnProperty("angle")) {
      this.setAngle(o.angle);
    }
    if (o.hasOwnProperty("alpha")) {
      this.setAlpha(o.alpha);
    }
    var width = GetValue19(o, "width", void 0);
    var height = GetValue19(o, "height", void 0);
    var scaleX = GetValue19(o, "scaleX", void 0);
    var scaleY = GetValue19(o, "scaleY", void 0);
    if (width !== void 0) {
      if (height === void 0 && scaleY === void 0) {
        this.setWidth(width, true);
      } else {
        this.setWidth(width);
      }
    } else if (scaleX !== void 0) {
      this.setScaleX(scaleX);
    }
    if (height !== void 0) {
      if (width === void 0 && scaleX === void 0) {
        this.setHeight(height, true);
      } else {
        this.setHeight(height);
      }
    } else if (scaleY !== void 0) {
      this.setScaleY(scaleY);
    }
    if (o.hasOwnProperty("leftSpace")) {
      this.setLeftSpace(o.leftSpace);
    }
    if (o.hasOwnProperty("rightSpace")) {
      this.setRightSpace(o.rightSpace);
    }
    if (o.hasOwnProperty("align")) {
      this.setAlign(o.align);
    }
    return this;
  }
  setDrawBelowCallback(callback) {
    this.drawBelowCallback = callback;
    return this;
  }
  setDrawAboveCallback(callback) {
    this.drawAboveCallback = callback;
    return this;
  }
  reset() {
    this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setLeftSpace(0).setRightSpace(0).setOrigin(0).setAlign().setDrawBelowCallback().setDrawAboveCallback();
    return this;
  }
  // Override
  get willRender() {
    return this.visible && this.alpha > 0;
  }
  get drawX() {
    var x = this.x + this.leftSpace + this.offsetX - this.originX * this.width;
    return this.parent._textOX * this.scrollFactorX + x;
  }
  get drawY() {
    var y = this.y + this.offsetY;
    return this.parent._textOY * this.scrollFactorY + y;
  }
  // Override
  get drawTLX() {
    return 0;
  }
  get drawTLY() {
    return 0;
  }
  get drawBLX() {
    return 0;
  }
  get drawBLY() {
    return 0;
  }
  get drawTRX() {
    return 0;
  }
  get drawTRY() {
    return 0;
  }
  get drawBRX() {
    return 0;
  }
  get drawBRY() {
    return 0;
  }
  get drawCenterX() {
    return (this.drawTRX + this.drawTLX) / 2;
  }
  get drawCenterY() {
    return (this.drawBLY + this.drawTLY) / 2;
  }
};
Object.assign(
  RenderBase2.prototype,
  Methods_default4
);
var RenderBase_default2 = RenderBase2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/utils/GetProperty.js
var GetProperty = function(name2, config, defaultConfig) {
  if (config.hasOwnProperty(name2)) {
    return config[name2];
  } else {
    return defaultConfig[name2];
  }
};
var GetProperty_default = GetProperty;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/background/Background.js
var GetValue20 = Phaser.Utils.Objects.GetValue;
var Background = class extends RenderBase_default2 {
  constructor(parent, config) {
    super(parent, "background");
    this.setScrollFactor(0);
    this.setColor(
      GetValue20(config, "color", null),
      GetValue20(config, "color2", null),
      GetValue20(config, "horizontalGradient", true)
    );
    this.setStroke(
      GetValue20(config, "stroke", null),
      GetValue20(config, "strokeThickness", 2)
    );
    this.setCornerRadius(
      GetValue20(config, "cornerRadius", 0),
      GetValue20(config, "cornerIteration", null)
    );
  }
  set color(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.setDirty(this._color != value);
    this._color = value;
  }
  get color() {
    return this._color;
  }
  set color2(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.setDirty(this._color2 != value);
    this._color2 = value;
  }
  get color2() {
    return this._color2;
  }
  set horizontalGradient(value) {
    this.setDirty(this._horizontalGradient != value);
    this._horizontalGradient = value;
  }
  get horizontalGradient() {
    return this._horizontalGradient;
  }
  setColor(color, color2, isHorizontalGradient) {
    if (isHorizontalGradient === void 0) {
      isHorizontalGradient = true;
    }
    this.color = color;
    this.color2 = color2;
    this.horizontalGradient = isHorizontalGradient;
    return this;
  }
  set stroke(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.setDirty(this._stroke != value);
    this._stroke = value;
  }
  get stroke() {
    return this._stroke;
  }
  set strokeThickness(value) {
    this.setDirty(this._strokeThickness != value);
    this._strokeThickness = value;
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  setStroke(color, lineWidth) {
    if (color != null) {
      if (lineWidth === void 0) {
        lineWidth = 2;
      }
    }
    this.stroke = color;
    this.strokeThickness = lineWidth;
    return this;
  }
  set cornerRadius(value) {
    this.setDirty(this._cornerRadius != value);
    this._cornerRadius = value;
  }
  get cornerRadius() {
    return this._cornerRadius;
  }
  set cornerIteration(value) {
    this.setDirty(this._cornerIteration != value);
    this._cornerIteration = value;
  }
  get cornerIteration() {
    return this._cornerIteration;
  }
  modifyStyle(o) {
    if (o.hasOwnProperty("color")) {
      this.setColor(
        o.color,
        GetProperty_default("color2", o, this),
        GetProperty_default("horizontalGradient", o, this)
      );
    }
    if (o.hasOwnProperty("stroke")) {
      this.setStroke(
        o.stroke,
        GetProperty_default("strokeThickness", o, this)
      );
    }
    if (o.hasOwnProperty("cornerRadius")) {
      this.setCornerRadius(
        o.cornerRadius,
        GetProperty_default("cornerIteration", o, this)
      );
    }
    return this;
  }
  modifyPorperties(o) {
    super.modifyPorperties(o);
    this.modifyStyle(o);
    return this;
  }
  setCornerRadius(radius, iteration) {
    this.cornerRadius = radius;
    this.cornerIteration = iteration;
    return this;
  }
  renderContent() {
    DrawRoundRectangleBackground_default(
      this.parent,
      this.color,
      this.stroke,
      this.strokeThickness,
      this.cornerRadius,
      this.color2,
      this.horizontalGradient,
      this.cornerIteration
    );
  }
};
var Background_default = Background;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/innerbounds/InnerBounds.js
var GetValue21 = Phaser.Utils.Objects.GetValue;
var InnerBounds = class extends RenderBase_default2 {
  constructor(parent, config) {
    super(parent, "innerbounds");
    this.setScrollFactor(0);
    this.setColor(
      GetValue21(config, "color", null),
      GetValue21(config, "color2", null),
      GetValue21(config, "horizontalGradient", true)
    );
    this.setStroke(
      GetValue21(config, "stroke", null),
      GetValue21(config, "strokeThickness", 2)
    );
  }
  set color(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.setDirty(this._color != value);
    this._color = value;
  }
  get color() {
    return this._color;
  }
  set color2(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.setDirty(this._color2 != value);
    this._color2 = value;
  }
  get color2() {
    return this._color2;
  }
  set horizontalGradient(value) {
    this.setDirty(this._horizontalGradient != value);
    this._horizontalGradient = value;
  }
  get horizontalGradient() {
    return this._horizontalGradient;
  }
  setColor(color, color2, isHorizontalGradient) {
    if (isHorizontalGradient === void 0) {
      isHorizontalGradient = true;
    }
    this.color = color;
    this.color2 = color2;
    this.horizontalGradient = isHorizontalGradient;
    return this;
  }
  set stroke(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.setDirty(this._stroke != value);
    this._stroke = value;
  }
  get stroke() {
    return this._stroke;
  }
  set strokeThickness(value) {
    this.setDirty(this._strokeThickness != value);
    this._strokeThickness = value;
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  setStroke(color, lineWidth) {
    if (color != null) {
      if (lineWidth === void 0) {
        lineWidth = 2;
      }
    }
    this.stroke = color;
    this.strokeThickness = lineWidth;
    return this;
  }
  modifyPorperties(o) {
    super.modifyPorperties(o);
    if (o.hasOwnProperty("color")) {
      this.setColor(
        o.color,
        GetValue21(o, "color2", null),
        GetValue21(o, "horizontalGradient", true)
      );
    }
    if (o.hasOwnProperty("stroke")) {
      this.setStroke(
        o.stroke,
        GetValue21(o, "strokeThickness", 2)
      );
    }
  }
  renderContent() {
    var padding = this.parent.padding;
    var x = padding.left, y = padding.top, width = this.parent.width - padding.left - padding.right, height = this.parent.height - padding.top - padding.bottom;
    var context = this.context;
    if (this.color != null) {
      var fillStyle;
      if (this.color2 != null) {
        var grd;
        if (this.horizontalGradient) {
          grd = context.createLinearGradient(0, 0, width, 0);
        } else {
          grd = context.createLinearGradient(0, 0, 0, height);
        }
        grd.addColorStop(0, this.color);
        grd.addColorStop(1, this.color2);
        fillStyle = grd;
      } else {
        fillStyle = this.color;
      }
      context.fillStyle = fillStyle;
      context.fillRect(x, y, width, height);
    }
    if (this.stroke != null && this.strokeThickness > 0) {
      context.strokeStyle = this.stroke;
      context.lineWidth = this.strokeThickness;
      context.strokeRect(x, y, width, height);
    }
  }
};
var InnerBounds_default = InnerBounds;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/char/TextStyle.js
var GetValue22 = Phaser.Utils.Objects.GetValue;
var TextStyle2 = class _TextStyle {
  constructor(parent, config) {
    this.parent = parent;
    this.set(config);
  }
  toJSON() {
    return {
      bold: this.bold,
      italic: this.italic,
      fontSize: this.fontSize,
      fontFamily: this.fontFamily,
      color: this.color,
      stroke: this.stroke,
      strokeThickness: this.strokeThickness,
      shaodwColor: this.shadowColor,
      shadowBlur: this.shadowBlur,
      shadowOffsetX: this.shadowOffsetX,
      shadowOffsetY: this.shadowOffsetY,
      offsetX: this.offsetX,
      offsetY: this.offsetY,
      leftSpace: this.leftSpace,
      rightSpace: this.rightSpace,
      backgroundHeight: this.backgroundHeight,
      backgroundBottomY: this.backgroundBottomY,
      align: this.align
    };
  }
  set(o) {
    this.setBold(GetValue22(o, "bold", false));
    this.setItalic(GetValue22(o, "italic", false));
    this.setFontSize(GetValue22(o, "fontSize", "16px"));
    this.setFontFamily(GetValue22(o, "fontFamily", "Courier"));
    this.setColor(GetValue22(o, "color", "#fff"));
    this.setStrokeStyle(
      GetValue22(o, "stroke", null),
      GetValue22(o, "strokeThickness", 0)
    );
    this.setShadow(
      GetValue22(o, "shadowColor", null),
      GetValue22(o, "shadowOffsetX", 0),
      GetValue22(o, "shadowOffsetY", 0),
      GetValue22(o, "shadowBlur", 0)
    );
    this.setOffset(
      GetValue22(o, "offsetX", 0),
      GetValue22(o, "offsetY", 0)
    );
    this.setSpace(
      GetValue22(o, "leftSpace", 0),
      GetValue22(o, "rightSpace", 0)
    );
    this.setAlign(GetValue22(o, "align", void 0));
    this.setBackgroundColor(GetValue22(o, "backgroundColor", null));
    this.setBackgroundHeight(GetValue22(o, "backgroundHeight", void 0));
    this.setBackgroundBottomY(GetValue22(o, "backgroundBottomY", void 0));
    this.setBackgroundLeftX(GetValue22(o, "backgroundLeftX", 0));
    this.setBackgroundRightX(GetValue22(o, "backgroundRightX", 0));
    return this;
  }
  modify(o) {
    if (o.hasOwnProperty("bold")) {
      this.setBold(o.bold);
    }
    if (o.hasOwnProperty("italic")) {
      this.setItalic(o.italic);
    }
    if (o.hasOwnProperty("fontSize")) {
      this.setFontSize(o.fontSize);
    }
    if (o.hasOwnProperty("fontFamily")) {
      this.setFontFamily(o.fontFamily);
    }
    if (o.hasOwnProperty("color")) {
      this.setColor(o.color);
    }
    if (o.hasOwnProperty("stroke") || o.hasOwnProperty("strokeThickness")) {
      this.setStrokeStyle(
        GetProperty_default("stroke", o, this),
        GetProperty_default("strokeThickness", o, this)
      );
    }
    if (o.hasOwnProperty("shadowColor")) {
      this.setShadowColor(o.shadowColor);
    }
    if (o.hasOwnProperty("shadowOffsetX") || o.hasOwnProperty("shadowOffsetY")) {
      this.setShadowOffset(
        GetProperty_default("shadowOffsetX", o, this),
        GetProperty_default("shadowOffsetY", o, this)
      );
    }
    if (o.hasOwnProperty("shadowBlur")) {
      this.setShadowBlur(o.shaodwBlur);
    }
    if (o.hasOwnProperty("offsetX")) {
      this.setOffsetX(o.offsetX);
    }
    if (o.hasOwnProperty("offsetY")) {
      this.setOffsetY(o.offsetY);
    }
    if (o.hasOwnProperty("leftSpace")) {
      this.setLeftSpace(o.leftSpace);
    }
    if (o.hasOwnProperty("rightSpace")) {
      this.setRightSpace(o.rightSpace);
    }
    if (o.hasOwnProperty("align")) {
      this.setAlign(o.align);
    }
    if (o.hasOwnProperty("backgroundColor")) {
      this.setBackgroundColor(o.backgroundColor);
    }
    if (o.hasOwnProperty("backgroundHeight")) {
      this.setBackgroundHeight(o.backgroundHeight);
    }
    if (o.hasOwnProperty("backgroundBottomY")) {
      this.setBackgroundBottomY(o.backgroundBottomY);
    }
    if (o.hasOwnProperty("backgroundLeftX")) {
      this.setBackgroundLeftX(o.backgroundLeftX);
    }
    if (o.hasOwnProperty("backgroundRightX")) {
      this.setBackgroundRightX(o.backgroundRightX);
    }
    return this;
  }
  setUpdateTextFlag() {
    if (this.parent) {
      this.parent.updateTextFlag = true;
    }
    return this;
  }
  clone() {
    return new _TextStyle(null, this.toJSON());
  }
  copyFrom(sourceTextStyle) {
    this.set(sourceTextStyle.toJSON());
    return this;
  }
  copyTo(targetTextStyle) {
    targetTextStyle.set(this.toJSON());
    return this;
  }
  setBold(value) {
    if (value === void 0) {
      value = true;
    }
    this.bold = value;
    this.setUpdateTextFlag();
    return this;
  }
  setItalic(value) {
    if (value === void 0) {
      value = true;
    }
    this.italic = value;
    this.setUpdateTextFlag();
    return this;
  }
  get fontStyle() {
    if (this.bold && this.italic) {
      return "bold italic";
    } else if (this.bold) {
      return "bold";
    } else if (this.italic) {
      return "italic";
    } else {
      return "";
    }
  }
  setFontSize(fontSize) {
    if (typeof fontSize === "number") {
      fontSize = `${fontSize}px`;
    }
    this.fontSize = fontSize;
    this.setUpdateTextFlag();
    return this;
  }
  setFontFamily(fontFamily) {
    this.fontFamily = fontFamily;
    this.setUpdateTextFlag();
    return this;
  }
  get font() {
    return `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`;
  }
  setColor(color) {
    this.color = GetStyle_default(color);
    return this;
  }
  get hasFill() {
    return this.color != null;
  }
  setStrokeStyle(stroke, strokeThickness) {
    this.stroke = GetStyle_default(stroke);
    if (strokeThickness !== void 0) {
      this.strokeThickness = strokeThickness;
    }
    return this;
  }
  setStrokeThickness(strokeThickness) {
    this.strokeThickness = strokeThickness;
    return this;
  }
  get hasStroke() {
    return this.stroke != null && this.strokeThickness > 0;
  }
  setShadowColor(color) {
    this.shadowColor = GetStyle_default(color);
    return this;
  }
  setShadowOffset(offsetX, offsetY) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    if (offsetY === void 0) {
      offsetY = 0;
    }
    this.shadowOffsetX = offsetX;
    this.shadowOffsetY = offsetY;
    return this;
  }
  setShadowBlur(blur) {
    if (blur === void 0) {
      blur = 0;
    }
    this.shaodwBlur = blur;
    return this;
  }
  setShadow(color, offsetX, offsetY, blur) {
    this.setShadowColor(color).setShadowOffset(offsetX, offsetY).setShadowBlur(blur);
    return this;
  }
  setBackgroundColor(color) {
    this.backgroundColor = GetStyle_default(color);
    return this;
  }
  get hasBackgroundColor() {
    return this.backgroundColor != null;
  }
  setBackgroundHeight(height) {
    this.backgroundHeight = height;
    return this;
  }
  setBackgroundBottomY(y) {
    this.backgroundBottomY = y;
    return this;
  }
  setBackgroundLeftX(x) {
    this.backgroundLeftX = x;
    return this;
  }
  setBackgroundRightX(x) {
    this.backgroundRightX = x;
    return this;
  }
  setOffsetX(offsetX) {
    if (offsetX === void 0) {
      offsetX = 0;
    }
    this.offsetX = offsetX;
    return this;
  }
  setOffsetY(offsetY) {
    if (offsetY === void 0) {
      offsetY = 0;
    }
    this.offsetY = offsetY;
    return this;
  }
  setOffset(offsetX, offsetY) {
    this.setOffsetX(offsetX).setOffsetY(offsetY);
    return this;
  }
  setLeftSpace(space) {
    if (space === void 0) {
      space = 0;
    }
    this.leftSpace = space;
    return this;
  }
  setRightSpace(space) {
    if (space === void 0) {
      space = 0;
    }
    this.rightSpace = space;
    return this;
  }
  setSpace(leftSpace, rightSpace) {
    this.setLeftSpace(leftSpace).setRightSpace(rightSpace);
    return this;
  }
  setAlign(align) {
    this.align = align;
    return this;
  }
  syncFont(context) {
    context.font = this.font;
    return this;
  }
  syncStyle(context) {
    context.textBaseline = "alphabetic";
    var hasFill = this.hasFill;
    var hasStroke = this.hasStroke;
    context.fillStyle = hasFill ? this.color : "#000";
    context.strokeStyle = hasStroke ? this.stroke : "#000";
    context.lineWidth = hasStroke ? this.strokeThickness : 0;
    context.lineCap = "round";
    context.lineJoin = "round";
    return this;
  }
  syncShadow(context) {
    if (context.shadowColor != null) {
      context.shadowColor = this.shadowColor;
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
      context.shadowBlur = this.shadowBlur;
    } else {
      context.shadowColor = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }
  }
  getTextMetrics(context, text) {
    this.syncFont(context).syncStyle(context);
    return context.measureText(text);
  }
};
var TextStyle_default2 = TextStyle2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetFixedSize.js
var SetFixedSize = function(width, height) {
  if (width === void 0) {
    width = 0;
  }
  if (height === void 0) {
    height = 0;
  }
  if (this.fixedWidth === width && this.fixedHeight === height) {
    return this;
  }
  this.fixedWidth = width;
  this.fixedHeight = height;
  this.dirty = true;
  this.setCanvasSize(
    width > 0 ? width : this.width,
    height > 0 ? height : this.height
  );
  return this;
};
var SetFixedSize_default = SetFixedSize;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetPadding.js
var SetPadding2 = function(key2, value) {
  var padding = this.padding;
  var paddingLeft = padding.left, paddingRight = padding.right, paddingTop = padding.top, paddingBottom = padding.bottom;
  SetPadding(padding, key2, value);
  this.dirty = this.dirty || paddingLeft != padding.left || paddingRight != padding.right || paddingTop != padding.top || paddingBottom != padding.bottom;
  return this;
};
var SetPadding_default = SetPadding2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetPadding.js
var GetPadding2 = function(key2) {
  return GetPadding(this.padding, key2);
};
var GetPadding_default = GetPadding2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/ModifyTextStyle.js
var ModifyTextStyle = function(style) {
  this.textStyle.modify(style);
  return this;
};
var ModifyTextStyle_default = ModifyTextStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/ModifyDefaultTextStyle.js
var ModifyDefaultTextStyle = function(style) {
  this.defaultTextStyle.modify(style);
  return this;
};
var ModifyDefaultTextStyle_default = ModifyDefaultTextStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/ResetTextStyle.js
var ResetTextStyle = function() {
  this.textStyle.copyFrom(this.defaultTextStyle);
  return this;
};
var ResetTextStyle_default = ResetTextStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetTestString.js
var SetTestString = function(testString) {
  this.testString = testString;
  return this;
};
var SetTestString_default = SetTestString;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/RemoveChild.js
var RemoveItem2 = Phaser.Utils.Array.Remove;
var RemoveChild2 = function(child) {
  this.poolManager.free(child);
  RemoveItem2(this.children, child);
  this.lastAppendedChildren.length = 0;
  this.lastOverChild = null;
  this.dirty = true;
  return this;
};
var RemoveChild_default2 = RemoveChild2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/RemoveChildren.js
var RemoveChildren2 = function() {
  this.poolManager.freeMultiple(this.children);
  this.children.length = 0;
  this.lastAppendedChildren.length = 0;
  this.lastOverChild = null;
  this.dirty = true;
  return this;
};
var RemoveChildren_default2 = RemoveChildren2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/PopChild.js
var RemoveItem3 = Phaser.Utils.Array.Remove;
var PopChild = function(child) {
  RemoveItem3(this.children, child);
  this.lastAppendedChildren.length = 0;
  this.lastOverChild = null;
  this.dirty = true;
  return this;
};
var PopChild_default = PopChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/ClearContent.js
var ClearContent = function() {
  this.setText();
  return this;
};
var ClearContent_default = ClearContent;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/AddChild.js
var AddChild2 = function(child, index) {
  var areChildren = Array.isArray(child);
  if (index === void 0 || index === this.children.length) {
    if (areChildren) {
      this.children.push(...child);
    } else {
      this.children.push(child);
    }
  } else {
    if (areChildren) {
      this.children.splice(index, 0, ...child);
    } else {
      this.children.splice(index, 0, child);
    }
  }
  this.lastAppendedChildren.length = 0;
  if (areChildren) {
    this.lastAppendedChildren.push(...child);
  } else {
    this.lastAppendedChildren.push(child);
  }
  return this;
};
var AddChild_default2 = AddChild2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/Types.js
var CharTypeName = "text";
var ImageTypeName2 = "image";
var DrawerTypeName = "drawer";
var SpaceTypeName = "space";
var CmdTypeName = "command";
var IsNewLineChar = function(bob) {
  return bob.type === CharTypeName && bob.text === "\n";
};
var IsPageBreakChar = function(bob) {
  return bob.type === CharTypeName && bob.text === "\f";
};
var IsSpaceChar = function(bob) {
  return bob.type === CharTypeName && bob.text === " ";
};
var IsChar = function(bob) {
  return bob.type === CharTypeName;
};
var IsCommand = function(bob) {
  return bob.type === CmdTypeName;
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/char/CharData.js
var CharData = class extends RenderBase_default2 {
  constructor(parent, text, style) {
    super(parent, CharTypeName);
    this.updateTextFlag = false;
    this.style = new TextStyle_default2(this, style);
    this.setText(text);
  }
  get autoRound() {
    return this.parent.autoRound;
  }
  get offsetX() {
    return this.style.offsetX;
  }
  set offsetX(value) {
    if (this.style) {
      this.style.offsetX = value;
    }
  }
  get offsetY() {
    return this.style.offsetY;
  }
  set offsetY(value) {
    if (this.style) {
      this.style.offsetY = value;
    }
  }
  get leftSpace() {
    return this.style.leftSpace * this.scaleX;
  }
  set leftSpace(value) {
    if (this.style) {
      this.style.leftSpace = value;
    }
    super.leftSpace = value;
  }
  get rightSpace() {
    return this.style.rightSpace * this.scaleX;
  }
  set rightSpace(value) {
    if (this.style) {
      this.style.rightSpace = value;
    }
    super.rightSpace = value;
  }
  get align() {
    return this.style.align;
  }
  set align(value) {
    if (this.style) {
      this.style.align = value;
    }
  }
  modifyStyle(style) {
    this.setDirty(true);
    this.style.modify(style);
    if (this.updateTextFlag) {
      this.updateTextSize();
    }
    return this;
  }
  modifyPorperties(o) {
    if (!o) {
      return this;
    }
    this.modifyStyle(o);
    super.modifyPorperties(o);
    return this;
  }
  setText(text) {
    this.setDirty(this.text != text);
    this.text = text;
    this.updateTextSize();
    return this;
  }
  updateTextSize() {
    var text = this.text;
    if (text === "\n" || text === "\f" || text === "") {
      this.clearTextSize();
    } else {
      var metrics = this.style.getTextMetrics(this.context, this.text);
      this.textWidth = metrics.width;
      var ascent, descent;
      if ("actualBoundingBoxAscent" in metrics) {
        ascent = metrics.actualBoundingBoxAscent;
        descent = metrics.actualBoundingBoxDescent;
      } else {
        ascent = 0;
        descent = 0;
      }
      this.textHeight = ascent + descent;
      this.ascent = ascent;
      this.descent = descent;
    }
    this.updateTextFlag = false;
    return this;
  }
  clearTextSize() {
    this.textWidth = 0;
    this.textHeight = 0;
    this.ascent = 0;
    this.descent = 0;
    return this;
  }
  copyTextSize(child) {
    this.textWidth = child.textWidth;
    this.textHeight = child.textHeight;
    this.ascent = child.ascent;
    this.descent = child.descent;
    return this;
  }
  get width() {
    return this.textWidth * this.scaleX;
  }
  set width(value) {
    if (this.textWidth > 0) {
      this.scaleX = value / this.textWidth;
    } else {
      this.scaleX = 1;
    }
  }
  get height() {
    return this.textHeight * this.scaleY;
  }
  set height(value) {
    if (this.textHeight > 0) {
      this.scaleY = value / this.textHeight;
    } else {
      this.scaleY = 1;
    }
  }
  get willRender() {
    if (this.textWidth === 0) {
      return false;
    }
    return super.willRender;
  }
  renderContent() {
    var context = this.context;
    var textStyle = this.style;
    if (textStyle.hasBackgroundColor) {
      context.fillStyle = textStyle.backgroundColor;
      var leftX = this.drawTLX + textStyle.backgroundLeftX;
      var rightX = this.drawTRX + textStyle.backgroundRightX;
      var x = leftX;
      var width = rightX - leftX + 1;
      if (width > 0) {
        var bottomY = textStyle.backgroundBottomY;
        if (bottomY == null) {
          bottomY = this.drawBLY;
        }
        var height = textStyle.backgroundHeight;
        if (height == null) {
          height = bottomY - this.drawTLY;
        }
        var y = bottomY - height;
        context.fillRect(x, y, width, height);
      }
    }
    var hasFill = textStyle.hasFill, hasStroke = textStyle.hasStroke;
    if (!hasFill && !hasStroke) {
      return;
    }
    textStyle.syncFont(context).syncStyle(context);
    if (hasStroke) {
      textStyle.syncShadow(context);
      context.strokeText(this.text, 0, 0);
    }
    if (hasFill) {
      textStyle.syncShadow(context);
      context.fillText(this.text, 0, 0);
    }
  }
  get drawTLX() {
    return -this.leftSpace;
  }
  get drawTLY() {
    return -this.ascent;
  }
  get drawBLX() {
    return -this.leftSpace;
  }
  get drawBLY() {
    return this.descent;
  }
  get drawTRX() {
    return this.textWidth + this.rightSpace;
  }
  get drawTRY() {
    return -this.ascent;
  }
  get drawBRX() {
    return this.textWidth + this.rightSpace;
  }
  get drawBRY() {
    return this.descent;
  }
};
var CharData_default = CharData;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/CreateCharChild.js
var CreateCharChild = function(text, style) {
  if (style) {
    this.textStyle.modify(style);
  }
  var child = this.poolManager.allocate(CharTypeName);
  if (child === null) {
    child = new CharData_default(
      this,
      // parent
      text,
      // text
      this.textStyle
      // style
    );
  } else {
    child.setParent(this).setActive().modifyStyle(this.textStyle).setText(text);
  }
  return child;
};
var CreateCharChild_default = CreateCharChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/CreateCharChildren.js
var CreateCharChildren = function(text, style) {
  if (style) {
    this.textStyle.modify(style);
  }
  var children = [];
  for (var i = 0, cnt = text.length; i < cnt; i++) {
    var char = text.charAt(i);
    var child = this.poolManager.allocate(CharTypeName);
    if (child === null) {
      child = new CharData_default(
        this,
        // parent
        char,
        // text
        this.textStyle
        // style
      );
    } else {
      child.setParent(this).setActive().modifyStyle(this.textStyle).setText(char);
    }
    children.push(child);
  }
  return children;
};
var CreateCharChildren_default = CreateCharChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/AppendText.js
var AppendText2 = function(text, style) {
  var children = this.createCharChildren(text, style);
  this.addChild(children);
  return this;
};
var AppendText_default2 = AppendText2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetText.js
var SetText = function(text, style) {
  if (text === void 0) {
    text = "";
  }
  this.removeChildren();
  AppendText_default2.call(this, text, style);
  this.dirty = true;
  return this;
};
var SetText_default = SetText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/InsertText.js
var InsertText = function(index, text, style) {
  var children = this.createCharChildren(text, style);
  index = this.getCharChildIndex(index, true);
  this.addChild(children, index);
  return this;
};
var InsertText_default = InsertText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/RemoveText.js
var RemoveText = function(index, length) {
  if (length === void 0) {
    length = 1;
  }
  for (var i = 0; i < length; i++) {
    var childIndex = this.getCharChildIndex(index, true);
    if (childIndex === void 0) {
      break;
    }
    this.removeChild(this.children[childIndex]);
  }
  return this;
};
var RemoveText_default = RemoveText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetText.js
var GetText = function(activeOnly) {
  var text = "";
  this.forEachCharChild(function(child) {
    text += child.text;
  }, void 0, activeOnly);
  return text;
};
var GetText_default = GetText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/image/ImageData.js
var CanvasPool6 = Phaser.Display.Canvas.CanvasPool;
var ImageData2 = class extends RenderBase_default2 {
  constructor(parent, key2, frame) {
    super(parent, ImageTypeName2);
    this.setTexture(key2, frame);
    this.color = void 0;
  }
  get frameWidth() {
    return this.frameObj ? this.frameObj.cutWidth : 0;
  }
  get frameHeight() {
    return this.frameObj ? this.frameObj.cutHeight : 0;
  }
  get offsetY() {
    return -this.height;
  }
  set offsetY(value) {
  }
  get key() {
    return this._key;
  }
  set key(value) {
    this.setDirty(this._key != value);
    this._key = value;
  }
  get frame() {
    return this._frame;
  }
  set frame(value) {
    this.setDirty(this._frame != value);
    this._frame = value;
  }
  setTexture(key2, frame) {
    this.key = key2;
    this.frame = frame;
    this.frameObj = this.scene.sys.textures.getFrame(key2, frame);
    return this;
  }
  get width() {
    return this.frameWidth * this.scaleX;
  }
  set width(value) {
    this.setDirty(this.width !== value);
    this.scaleX = value / this.frameWidth;
  }
  get height() {
    return this.frameHeight * this.scaleY;
  }
  set height(value) {
    this.setDirty(this.height !== value);
    this.scaleY = value / this.frameHeight;
  }
  setHeight(height, keepAspectRatio) {
    if (keepAspectRatio === void 0) {
      keepAspectRatio = false;
    }
    this.height = height;
    if (keepAspectRatio) {
      this.scaleX = this.scaleY;
    }
    return this;
  }
  setColor(color) {
    this.color = color;
    return this;
  }
  modifyPorperties(o) {
    if (o.hasOwnProperty("color")) {
      this.setColor(o.color);
    }
    super.modifyPorperties(o);
    return this;
  }
  renderContent() {
    DrawFrameToCanvas_default(
      this.frameObj,
      this.canvas,
      0,
      0,
      this.frameWidth,
      this.frameHeight,
      this.color,
      false
    );
  }
  get drawTLX() {
    return -this.leftSpace;
  }
  get drawTLY() {
    return 0;
  }
  get drawBLX() {
    return -this.leftSpace;
  }
  get drawBLY() {
    return this.frameHeight;
  }
  get drawTRX() {
    return this.frameWidth + this.rightSpace;
  }
  get drawTRY() {
    return 0;
  }
  get drawBRX() {
    return this.frameWidth + this.rightSpace;
  }
  get drawBRY() {
    return this.frameHeight;
  }
};
var ImageData_default2 = ImageData2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/CreateImageChild.js
var CreateImageChild = function(key2, frame, properties) {
  var child = this.poolManager.allocate(ImageTypeName2);
  if (child === null) {
    child = new ImageData_default2(
      this,
      // parent
      key2,
      frame
    );
  } else {
    child.setParent(this).setActive().setTexture(key2, frame);
  }
  child.modifyPorperties(properties);
  return child;
};
var CreateImageChild_default = CreateImageChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/AppendImage.js
var AppendImage = function(key2, frame, properties) {
  var child = this.createImageChild(key2, frame, properties);
  this.addChild(child);
  return this;
};
var AppendImage_default = AppendImage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/drawer/Drawer.js
var Drawer = class extends RenderBase_default2 {
  constructor(parent, renderCallback, width, height) {
    super(parent, DrawerTypeName);
    this.setRenderCallback(renderCallback);
    this.setDrawerSize(width, height);
  }
  setRenderCallback(callback) {
    if (callback) {
      this.renderContent = callback.bind(this);
    } else {
      delete this.renderContent;
    }
    return this;
  }
  setDrawerSize(width, height) {
    if (width === true) {
      this.toLocalPosition = false;
      width = void 0;
      height = void 0;
    } else {
      this.toLocalPosition = true;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = width;
    }
    this.drawerWidth = width;
    this.drawerHeight = height;
    return this;
  }
  onFree() {
    super.onFree();
    this.setRenderCallback();
  }
  get width() {
    return this.drawerWidth * this.scaleX;
  }
  set width(value) {
    this.setDirty(this.width !== value);
    this.scaleX = this.drawerWidth > 0 ? value / this.drawerWidth : 1;
  }
  get height() {
    return this.drawerHeight * this.scaleY;
  }
  set height(value) {
    this.setDirty(this.height !== value);
    this.scaleY = this.drawerHeight > 0 ? value / this.drawerHeight : 1;
  }
  get offsetY() {
    return -this.height;
  }
  set offsetY(value) {
  }
  get drawTLX() {
    return -this.leftSpace;
  }
  get drawTLY() {
    return 0;
  }
  get drawBLX() {
    return -this.leftSpace;
  }
  get drawBLY() {
    return this.drawerHeight;
  }
  get drawTRX() {
    return this.drawerWidth + this.rightSpace;
  }
  get drawTRY() {
    return 0;
  }
  get drawBRX() {
    return this.drawerWidth + this.rightSpace;
  }
  get drawBRY() {
    return this.drawerHeight;
  }
};
var Drawer_default = Drawer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/CreateDrawerChild.js
var CreateDrawerChild = function(renderCallback, width, height) {
  var child = this.poolManager.allocate(DrawerTypeName);
  if (child === null) {
    child = new Drawer_default(
      this,
      // parent
      renderCallback,
      width,
      height
    );
  } else {
    child.setParent(this).setActive().setRenderCallback(renderCallback).setDrawerSize(width, height);
  }
  return child;
};
var CreateDrawerChild_default = CreateDrawerChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/AppendDrawer.js
var AppendDrawer = function(renderCallback, width, height) {
  var child = this.createDrawerChild(renderCallback, width, height);
  this.addChild(child);
  return this;
};
var AppendDrawer_default = AppendDrawer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/space/Space.js
var Space = class extends RenderBase_default2 {
  constructor(parent, width) {
    super(parent, SpaceTypeName);
    this.setSpaceWidth(width);
  }
  get width() {
    return this.spaceWidth * this.scaleX;
  }
  set width(value) {
    if (this.spaceWidth > 0) {
      this.scaleX = value / this.spaceWidth;
    } else {
      this.scaleX = 1;
    }
  }
  setSpaceWidth(width) {
    this.spaceWidth = width;
    return this;
  }
};
var Space_default = Space;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/CreateSpaceChild.js
var CreateSpaceChild = function(width) {
  var child = this.poolManager.allocate(SpaceTypeName);
  if (child === null) {
    child = new Space_default(
      this,
      // parent
      width
    );
  } else {
    child.setParent(this).setActive().setSpaceWidth(width);
  }
  return child;
};
var CreateSpaceChild_default = CreateSpaceChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/AppendSpace.js
var AppendSpace = function(width) {
  var child = this.createSpaceChild(width);
  this.addChild(child);
  return this;
};
var AppendSpace_default = AppendSpace;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/command/Command.js
var Command = class extends Base_default2 {
  constructor(parent, name2, callback, param, scope) {
    super(parent, CmdTypeName);
    this.setName(name2).setParameter(param).setCallback(callback, scope);
  }
  setName(name2) {
    this.name = name2;
    return this;
  }
  setParameter(param) {
    this.param = param;
    return this;
  }
  setCallback(callback, scope) {
    this.callback = callback;
    this.scope = scope;
    return this;
  }
  exec() {
    var result;
    if (this.scope) {
      result = this.callback.call(this.scope, this.param, this.name);
    } else {
      result = this.callback(this.param, this.name);
    }
    return result;
  }
  onFree() {
    super.onFree();
    this.setName().setCallback().setParameter();
  }
};
var Command_default = Command;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/CreateCommandChild.js
var CreateCommandChild = function(name2, callback, param, scope) {
  var child = this.poolManager.allocate(CmdTypeName);
  if (child === null) {
    child = new Command_default(
      this,
      // parent
      name2,
      callback,
      param,
      scope
    );
  } else {
    child.setParent(this).setActive().setName(name2).setCallback(callback, scope).setParameter(param);
  }
  return child;
};
var CreateCommandChild_default = CreateCommandChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/AppendCommand.js
var AppendCommand = function(name2, callback, param, scope) {
  var child = this.createCommandChild(name2, callback, param, scope);
  this.addChild(child);
  return this;
};
var AppendCommand_default = AppendCommand;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetWrapConfig.js
var SetWrapConfig = function(config) {
  if (config === void 0) {
    config = {};
  } else if (typeof config === "object") {
    config = DeepClone_default(config);
  }
  this.wrapConfig = config;
  return this;
};
var SetWrapConfig_default = SetWrapConfig;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/CreateWrapResultData.js
var CreateWrapResultData = function(config) {
  var data = {
    callback: void 0,
    start: 0,
    // Next start index
    isLastPage: false,
    // Is last page
    maxLines: void 0,
    padding: void 0,
    letterSpacing: void 0,
    hAlign: void 0,
    vAlign: void 0,
    children: [],
    // Wrap result
    lines: [],
    // Wrap result in lines
    // WordWrap
    maxLineWidth: 0,
    linesHeight: 0,
    lineHeight: void 0,
    // VerticalWrap
    maxLineHeight: 0,
    linesWidth: 0,
    lineWidth: void 0
  };
  return Object.assign(data, config);
};
var CreateWrapResultData_default = CreateWrapResultData;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/Const.js
var WRAPMODE2 = {
  none: 0,
  word: 1,
  char: 2,
  character: 2,
  mix: 3
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/runwordwrap/GetWord.js
var GetWord = function(children, startIndex, wrapMode, result) {
  if (result === void 0) {
    result = { word: [], width: 0 };
  }
  result.word.length = 0;
  var isCharWrap = wrapMode === 2;
  var isMixWrap = wrapMode === 3;
  var isWordWrap = !isCharWrap && !isMixWrap;
  var endIndex = children.length;
  var currentIndex = startIndex;
  var word = result.word;
  var wordWidth = 0;
  var hasAnyASCIICharacter = false;
  while (currentIndex < endIndex) {
    var child = children[currentIndex];
    if (!child.renderable) {
      word.push(child);
      currentIndex++;
      continue;
    }
    var text = child.type === CharTypeName ? child.text : null;
    if (text === null || text === "\n" || text === "\f") {
      if (currentIndex === startIndex) {
        word.push(child);
        wordWidth += child.outerWidth;
      }
      break;
    }
    if (isWordWrap) {
      word.push(child);
      wordWidth += child.outerWidth;
      if (text === " ") {
        break;
      }
      currentIndex++;
    } else if (isCharWrap) {
      word.push(child);
      wordWidth += child.outerWidth;
      break;
    } else if (isMixWrap) {
      if (!IsASCIIString_default(text)) {
        if (!hasAnyASCIICharacter) {
          word.push(child);
          wordWidth += child.outerWidth;
          var nextChild = children[currentIndex + 1];
          if (nextChild && nextChild.type === CharTypeName && nextChild.text === " ") {
            word.push(nextChild);
            wordWidth += nextChild.outerWidth;
          }
          break;
        } else {
          break;
        }
      } else {
        word.push(child);
        wordWidth += child.outerWidth;
        if (text === " ") {
          break;
        }
        currentIndex++;
        hasAnyASCIICharacter = true;
      }
    }
  }
  result.width = wordWidth;
  return result;
};
var GetWord_default = GetWord;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/GetChildrenAlign.js
var GetChildrenAlign = function(children) {
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (child.align !== void 0) {
      return child.align;
    }
  }
  return void 0;
};
var GetChildrenAlign_default = GetChildrenAlign;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/OffsetChildren.js
var OffsetChildren = function(children, offsetX, offsetY) {
  if (offsetX === 0 && offsetY === 0) {
    return;
  }
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (!child.renderable) {
      continue;
    }
    child.x += offsetX;
    child.y += offsetY;
  }
};
var OffsetChildren_default = OffsetChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/runwordwrap/AlignLines.js
var AlignLines = function(result, width, height) {
  var hAlign = result.hAlign, vAlign = result.vAlign, justifyPercentage = result.justifyPercentage;
  var lines = result.lines;
  var offsetX, offsetY;
  for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
    var line = lines[li];
    var lineWidth = line.width, children = line.children;
    var lineHAlign = GetChildrenAlign_default(children);
    if (lineHAlign === void 0) {
      lineHAlign = hAlign;
    }
    switch (lineHAlign) {
      case 0:
      case "left":
        offsetX = 0;
        break;
      case 1:
      case "center":
        var remainderWidth = width - lineWidth;
        offsetX = remainderWidth / 2;
        break;
      case 2:
      case "right":
        var remainderWidth = width - lineWidth;
        offsetX = remainderWidth;
        break;
      case 3:
      case "justify":
      case "justify-left":
        var remainderWidth = width - lineWidth;
        var remainderPercentage = remainderWidth / width;
        if (remainderPercentage < justifyPercentage) {
          JustifyChildren(children, remainderWidth);
          offsetX = 0;
        } else {
          offsetX = 0;
        }
        break;
      case 4:
      case "justify-center":
        var remainderWidth = width - lineWidth;
        var remainderPercentage = remainderWidth / width;
        if (remainderPercentage < justifyPercentage) {
          JustifyChildren(children, remainderWidth);
          offsetX = 0;
        } else {
          offsetX = remainderWidth / 2;
        }
        break;
      case 5:
      case "justify-right":
        var remainderWidth = width - lineWidth;
        var remainderPercentage = remainderWidth / width;
        if (remainderPercentage < justifyPercentage) {
          JustifyChildren(children, remainderWidth);
          offsetX = 0;
        } else {
          offsetX = remainderWidth;
        }
        break;
      default:
        offsetX = 0;
        break;
    }
    var linesHeight = result.linesHeight;
    switch (vAlign) {
      case 1:
      case "center":
        offsetY = (height - linesHeight) / 2;
        break;
      case 2:
      case "bottom":
        offsetY = height - linesHeight;
        break;
      default:
        offsetY = 0;
        break;
    }
    OffsetChildren_default(children, offsetX, offsetY);
  }
};
var JustifyChildren = function(children, remainderWidth) {
  var offset = remainderWidth / children.length;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (!child.renderable) {
      continue;
    }
    child.x += offset * i;
  }
};
var AlignLines_default = AlignLines;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/runwordwrap/GetDefaultTextHeight.js
var GetDefaultTextHeight = function() {
  var metrics = this.defaultTextStyle.getTextMetrics(this.context, this.testString);
  var ascent, descent;
  if ("actualBoundingBoxAscent" in metrics) {
    ascent = metrics.actualBoundingBoxAscent;
    descent = metrics.actualBoundingBoxDescent;
  } else {
    ascent = 0;
    descent = 0;
  }
  Result.ascent = ascent;
  Result.descent = descent;
  Result.height = ascent + descent;
  return Result;
};
var Result = {};
var GetDefaultTextHeight_default = GetDefaultTextHeight;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/runwordwrap/RunWordWrap.js
var GetValue23 = Phaser.Utils.Objects.GetValue;
var RunWordWrap = function(config) {
  var startIndex = GetValue23(config, "start", 0);
  SetPadding(this.wrapPadding, GetValue23(config, "padding", 0));
  var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
  var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
  var lineHeight = GetValue23(config, "lineHeight");
  var ascent = GetValue23(config, "ascent", lineHeight);
  var maxLines;
  if (lineHeight === void 0) {
    var useDefaultTextHeight = GetValue23(config, "useDefaultTextHeight", false);
    maxLines = GetValue23(config, "maxLines", 0);
    if (this.fixedHeight > 0 && !useDefaultTextHeight) {
      var innerHeight = this.fixedHeight - paddingVertical;
      if (maxLines > 0) {
        lineHeight = innerHeight / maxLines;
      } else {
        var textHeightResult = GetDefaultTextHeight_default.call(this);
        lineHeight = textHeightResult.height;
        ascent = textHeightResult.ascent;
        maxLines = Math.floor((innerHeight - ascent) / lineHeight);
      }
    } else {
      var textHeightResult = GetDefaultTextHeight_default.call(this);
      lineHeight = textHeightResult.height;
      ascent = textHeightResult.ascent;
    }
  } else {
    if (this.fixedHeight > 0) {
      maxLines = GetValue23(config, "maxLines");
      if (maxLines === void 0) {
        var innerHeight = this.fixedHeight - paddingVertical;
        maxLines = Math.floor(innerHeight / lineHeight);
      }
    } else {
      maxLines = GetValue23(config, "maxLines", 0);
    }
  }
  if (ascent === void 0) {
    ascent = lineHeight;
  }
  var showAllLines = maxLines === 0;
  var wrapMode = GetValue23(config, "wrapMode");
  if (wrapMode === void 0) {
    var charWrap = GetValue23(config, "charWrap", false);
    wrapMode = charWrap ? "char" : "word";
  }
  if (typeof wrapMode === "string") {
    wrapMode = WRAPMODE2[wrapMode];
  }
  var wrapWidth = GetValue23(config, "wrapWidth", void 0);
  if (wrapWidth === void 0) {
    if (this.fixedWidth > 0) {
      wrapWidth = this.fixedWidth - paddingHorizontal;
    } else {
      wrapWidth = Infinity;
      wrapMode = 0;
    }
  }
  var letterSpacing = GetValue23(config, "letterSpacing", 0);
  var hAlign = GetValue23(config, "hAlign", 0);
  var vAlign = GetValue23(config, "vAlign", 0);
  var justifyPercentage = GetValue23(config, "justifyPercentage", 0.25);
  var result = CreateWrapResultData_default({
    // Override properties
    callback: "runWordWrap",
    start: startIndex,
    // Next start index
    padding: this.wrapPadding,
    letterSpacing,
    maxLines,
    hAlign,
    vAlign,
    justifyPercentage,
    // Specific properties
    ascent,
    lineHeight,
    wrapWidth,
    wrapMode
  });
  var children = this.children;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    children[i].setActive(false);
  }
  wrapWidth += letterSpacing;
  var startX = this.padding.left + this.wrapPadding.left, startY = this.padding.top + this.wrapPadding.top + ascent, x = startX, y = startY;
  var remainderWidth = wrapWidth, childIndex = startIndex, lastChildIndex = children.length;
  var resultChildren = result.children;
  var resultLines = result.lines, lastLine = [], lastLineWidth = 0, maxLineWidth = 0;
  var wordResult;
  var isPageBreakChar = false;
  while (childIndex < lastChildIndex) {
    wordResult = GetWord_default(children, childIndex, wrapMode, wordResult);
    var word = wordResult.word;
    var charCnt = word.length;
    var wordWidth = wordResult.width + charCnt * letterSpacing;
    childIndex += charCnt;
    var isNewLineChar = IsNewLineChar(word[0]);
    isPageBreakChar = IsPageBreakChar(word[0]);
    var isControlChar = isNewLineChar || isPageBreakChar;
    if (remainderWidth < wordWidth || isControlChar) {
      if (isControlChar) {
        var char = word[0];
        char.setActive().setPosition(x, y);
        resultChildren.push(char);
        lastLine.push(char);
      }
      x = startX;
      y += lineHeight;
      remainderWidth = wrapWidth;
      resultLines.push({ children: lastLine, width: lastLineWidth });
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lastLineWidth = 0;
      lastLine = [];
      var isPageEnd = isPageBreakChar || !showAllLines && resultLines.length === maxLines;
      if (isPageEnd) {
        break;
      } else if (isControlChar) {
        continue;
      }
    }
    remainderWidth -= wordWidth;
    lastLineWidth += wordWidth;
    for (var i = 0, cnt = word.length; i < cnt; i++) {
      var child = word[i];
      child.setActive();
      resultChildren.push(child);
      lastLine.push(child);
      if (child.renderable) {
        child.setPosition(x, y);
        x += child.outerWidth + letterSpacing;
      }
    }
  }
  if (lastLine.length > 0) {
    resultLines.push({ children: lastLine, width: lastLineWidth });
    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
  }
  result.start += resultChildren.length;
  result.isLastPage = !isPageBreakChar && result.start === lastChildIndex;
  result.maxLineWidth = maxLineWidth;
  result.linesHeight = resultLines.length * lineHeight;
  var width = this.fixedWidth > 0 ? this.fixedWidth : result.maxLineWidth + paddingHorizontal;
  var height = this.fixedHeight > 0 ? this.fixedHeight : result.linesHeight + paddingVertical;
  var innerWidth = width - paddingHorizontal;
  var innerHeight = height - paddingVertical;
  AlignLines_default(result, innerWidth, innerHeight);
  this.setCanvasSize(width, height);
  for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
    var child = resultChildren[i];
    if (!child.renderable) {
      continue;
    }
    child.x0 = child.x;
    child.y0 = child.y;
  }
  return result;
};
var RunWordWrap_default = RunWordWrap;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/RunWordWrap.js
var Merge = Phaser.Utils.Objects.Merge;
var RunWordWrap2 = function(config) {
  if (config === void 0) {
    config = {};
  }
  return RunWordWrap_default.call(this, Merge(config, this.wrapConfig));
};
var RunWordWrap_default2 = RunWordWrap2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/runverticalwrap/AlignLines.js
var AlignLines2 = function(result, width, height) {
  var hAlign = result.hAlign, vAlign = result.vAlign;
  var offsetX, offsetY;
  var rtl = result.rtl;
  var lines = result.lines, lineWidth = result.lineWidth, linesWidth = result.linesWidth;
  switch (hAlign) {
    case 1:
    case "center":
      offsetX = (width - linesWidth) / 2;
      break;
    case 2:
    case "right":
      offsetX = width - linesWidth;
      break;
    default:
      offsetX = 0;
      break;
  }
  if (rtl) {
    offsetX += lineWidth;
  }
  for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
    var line = lines[rtl ? lcnt - li - 1 : li];
    var children = line.children;
    var lineHeight = line.height;
    var lineVAlign = GetChildrenAlign_default(children);
    if (lineVAlign === void 0) {
      lineVAlign = vAlign;
    }
    switch (lineVAlign) {
      case 1:
      case "center":
        offsetY = (height - lineHeight) / 2;
        break;
      case 2:
      case "bottom":
        offsetY = height - lineHeight;
        break;
      default:
        offsetY = 0;
        break;
    }
    OffsetChildren_default(children, offsetX, offsetY);
    offsetX += lineWidth;
  }
};
var AlignLines_default2 = AlignLines2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/wrap/runverticalwrap/RunVerticalWrap.js
var GetValue24 = Phaser.Utils.Objects.GetValue;
var RunVerticalWrap = function(config) {
  var startIndex = GetValue24(config, "start", 0);
  SetPadding(this.wrapPadding, GetValue24(config, "padding", 0));
  var paddingVertical = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
  var paddingHorizontal = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
  var lineWidth = GetValue24(config, "lineWidth", void 0);
  var maxLines;
  if (lineWidth === void 0) {
    maxLines = GetValue24(config, "maxLines", 0);
    if (this.fixedWidth > 0) {
      var innerWidth = this.fixedWidth - paddingHorizontal;
      lineWidth = innerWidth / maxLines;
    } else {
      lineWidth = 0;
    }
  } else {
    if (this.fixedWidth > 0) {
      maxLines = GetValue24(config, "maxLines", void 0);
      if (maxLines === void 0) {
        var innerWidth = this.fixedWidth - paddingHorizontal;
        maxLines = Math.floor(innerWidth / lineWidth) + 1;
      }
    } else {
      maxLines = GetValue24(config, "maxLines", 0);
    }
  }
  var showAllLines = maxLines === 0;
  var fixedCharacterHeight = GetValue24(config, "fixedCharacterHeight", void 0);
  if (fixedCharacterHeight === void 0) {
    var charPerLine = GetValue24(config, "charPerLine", void 0);
    if (charPerLine !== void 0) {
      var innerHeight = this.fixedHeight - paddingVertical;
      fixedCharacterHeight = Math.floor(innerHeight / charPerLine);
    } else {
    }
  }
  var wrapHeight = GetValue24(config, "wrapHeight", void 0);
  if (wrapHeight === void 0) {
    if (this.fixedHeight > 0) {
      wrapHeight = this.fixedHeight - paddingVertical;
    } else {
      wrapHeight = Infinity;
    }
  }
  var letterSpacing = GetValue24(config, "letterSpacing", 0);
  var rtl = GetValue24(config, "rtl", true);
  var hAlign = GetValue24(config, "hAlign", rtl ? 2 : 0);
  var vAlign = GetValue24(config, "vAlign", 0);
  var result = CreateWrapResultData_default({
    // Override properties
    callback: "runVerticalWrap",
    start: startIndex,
    // Next start index
    padding: this.wrapPadding,
    letterSpacing,
    maxLines,
    hAlign,
    vAlign,
    // Specific properties
    lineWidth,
    fixedCharacterHeight,
    wrapHeight,
    rtl
  });
  var children = this.children;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    children[i].setActive(false);
  }
  wrapHeight += letterSpacing;
  var startX = this.padding.left + this.wrapPadding.left, startY = this.padding.top + this.wrapPadding.top, x = startX, y = startY;
  var remainderHeight = wrapHeight, childIndex = startIndex, lastChildIndex = children.length;
  var resultChildren = result.children;
  var resultLines = result.lines, lastLine = [], lastLineHeight = 0, maxLineHeight = 0;
  while (childIndex < lastChildIndex) {
    var child = children[childIndex];
    childIndex++;
    if (!child.renderable) {
      child.setActive();
      resultChildren.push(child);
      lastLine.push(child);
      continue;
    }
    var childHeight = (fixedCharacterHeight !== void 0 ? fixedCharacterHeight : child.height) + letterSpacing;
    var isNewLineChar = IsNewLineChar(child);
    var isPageBreakChar = IsPageBreakChar(child);
    var isControlChar = isNewLineChar || isPageBreakChar;
    if (remainderHeight < childHeight || isControlChar) {
      if (isNewLineChar) {
        child.setActive().setPosition(x, y).setOrigin(0.5);
        resultChildren.push(child);
        lastLine.push(child);
      }
      x = startX;
      y = startY;
      remainderHeight = wrapHeight;
      resultLines.push({ children: lastLine, height: lastLineHeight });
      maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
      lastLineHeight = 0;
      lastLine = [];
      var isPageEnd = isPageBreakChar || !showAllLines && resultLines.length === maxLines;
      if (isPageEnd) {
        break;
      } else if (isControlChar) {
        continue;
      }
    }
    remainderHeight -= childHeight;
    lastLineHeight += childHeight;
    child.setActive().setPosition(x, y).setOrigin(0.5);
    resultChildren.push(child);
    lastLine.push(child);
    y += childHeight;
  }
  if (lastLine.length > 0) {
    resultLines.push({ children: lastLine, height: lastLineHeight });
    maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
  }
  result.start += resultChildren.length;
  result.isLastPage = result.start === lastChildIndex;
  result.maxLineHeight = maxLineHeight;
  result.linesWidth = resultLines.length * lineWidth;
  var width = this.fixedWidth > 0 ? this.fixedWidth : result.linesWidth + paddingHorizontal;
  var height = this.fixedHeight > 0 ? this.fixedHeight : result.maxLineHeight + paddingVertical;
  var innerWidth = width - paddingHorizontal;
  var innerHeight = height - paddingVertical;
  AlignLines_default2(result, innerWidth, innerHeight);
  this.setCanvasSize(width, height);
  for (var i = 0, cnt = resultChildren.length; i < cnt; i++) {
    var child = resultChildren[i];
    if (!child.renderable) {
      continue;
    }
    child.x0 = child.x;
    child.y0 = child.y;
  }
  return result;
};
var RunVerticalWrap_default = RunVerticalWrap;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/RunVerticalWrap.js
var Merge2 = Phaser.Utils.Objects.Merge;
var RunVerticalWrap2 = function(config) {
  if (config === void 0) {
    config = {};
  }
  return RunVerticalWrap_default.call(this, Merge2(config, this.wrapConfig));
};
var RunVerticalWrap_default2 = RunVerticalWrap2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/RunWrap.js
var GetValue25 = Phaser.Utils.Objects.GetValue;
var RunWrap = function(config) {
  var wrapCallback = GetValue25(this.wrapConfig, "callback");
  if (!wrapCallback) {
    wrapCallback = GetValue25(config, "callback", this.runWordWrap);
  }
  if (typeof wrapCallback === "string") {
    wrapCallback = this[wrapCallback];
  }
  return wrapCallback.call(this, config);
};
var RunWrap_default = RunWrap;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetAlignMethods.js
var SetAlignMethods_default = {
  setVAlign(align) {
    this.wrapConfig.vAlign = align;
    return this;
  },
  setHAlign(align) {
    this.wrapConfig.hAlign = align;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetTextOXYMethods.js
var SetTextOXYMethods_default = {
  setTextOX(ox) {
    if (ox === this._textOX) {
      return this;
    }
    this._textOX = ox;
    return this;
  },
  setTextOY(oy) {
    if (oy === this._textOY) {
      return this;
    }
    this._textOY = oy;
    return this;
  },
  setTextOXY(ox, oy) {
    if (ox === this._textOX && oy === this._textOY) {
      return;
    }
    this._textOX = ox;
    this._textOY = oy;
    return this;
  },
  addTextOX(incX) {
    this.setTextOX(this._textOX + incX);
    return this;
  },
  addTextOY(incY) {
    this.setTextOY(this._textOY + incY);
    return this;
  },
  addTextOXY(incX, incY) {
    this.setTextOXY(this._textOX + incX, this._textOY + incY);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/RenderContent.js
var RenderContent = function() {
  this.clear();
  this.setCanvasSize(this.width, this.height);
  if (this.background.active) {
    this.background.render();
  }
  var child;
  for (var i = 0, cnt = this.children.length; i < cnt; i++) {
    child = this.children[i];
    if (child.active) {
      child.render();
    }
  }
  if (this.innerBounds.active) {
    this.innerBounds.render();
  }
};
var RenderContent_default = RenderContent;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/ForEachChild.js
var ForEachChild = function(callback, scope, activeOnly) {
  if (activeOnly === void 0) {
    activeOnly = true;
  }
  var children = this.children.filter(function(child2) {
    if (activeOnly && !child2.active) {
      return false;
    }
    return true;
  });
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    var isBreak;
    if (scope) {
      isBreak = callback.call(this, child, i, children);
    } else {
      isBreak = callback(child, i, children);
    }
    if (isBreak) {
      break;
    }
  }
  return this;
};
var ForEachChild_default = ForEachChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/ForEachRenderableChild.js
var ForEachRenderableChild = function(callback, scope, activeOnly) {
  if (activeOnly === void 0) {
    activeOnly = true;
  }
  var children = this.children.filter(function(child2) {
    if (activeOnly && !child2.active) {
      return false;
    }
    if (!child2.renderable || child2.removed) {
      return false;
    }
    return true;
  });
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    var isBreak;
    if (scope) {
      isBreak = callback.call(this, child, i, children);
    } else {
      isBreak = callback(child, i, children);
    }
    if (isBreak) {
      break;
    }
  }
  return this;
};
var ForEachRenderableChild_default = ForEachRenderableChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/ForEachCharChild.js
var ForEachCharChild = function(callback, scope, activeOnly) {
  if (activeOnly === void 0) {
    activeOnly = true;
  }
  var children = this.children.filter(function(child2) {
    if (activeOnly && !child2.active) {
      return false;
    }
    if (!IsChar(child2) || child2.removed) {
      return false;
    }
    return true;
  });
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    var isBreak;
    if (scope) {
      isBreak = callback.call(this, child, i, children);
    } else {
      isBreak = callback(child, i, children);
    }
    if (isBreak) {
      break;
    }
  }
  return this;
};
var ForEachCharChild_default = ForEachCharChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetChildren.js
var GetChildren2 = function() {
  return this.children;
};
var GetChildren_default2 = GetChildren2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetActiveChildren.js
var GetAll = Phaser.Utils.Array.GetAll;
var GetActiveChildren = function() {
  return GetAll(this.children, "active", true);
};
var GetActiveChildren_default = GetActiveChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetCharChildren.js
var GetCharChildren = function(activeOnly, out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  this.forEachCharChild(function(child) {
    out2.push(child);
  }, void 0, activeOnly);
  return out2;
};
var GetCharChildren_default = GetCharChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetLastAppendedChildren.js
var GetLastAppendedChildren2 = function() {
  return this.lastAppendedChildren;
};
var GetLastAppendedChildren_default2 = GetLastAppendedChildren2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/utils/transform/GetBobCenterPosition.js
var GetBobCenterPosition = function(bob, offsetX, offsetY, out2) {
  if (typeof offsetX !== "number") {
    out2 = offsetX;
    offsetX = 0;
    offsetY = 0;
  }
  var bobX = bob.drawCenterX + offsetX;
  var bobY = bob.drawCenterY + offsetY;
  return BobPositionToCanvasPosition_default(bob, bobX, bobY, out2);
};
var GetBobCenterPosition_default = GetBobCenterPosition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetNearestChild.js
var GetDistance = Phaser.Math.Distance.BetweenPointsSquared;
var GetNearestChild = function(canvasX, canvasY) {
  var pointA = { x: canvasX, y: canvasY };
  var minDistance = Infinity;
  var nearestChild = null;
  this.forEachRenderableChild(function(child) {
    var distance = GetDistance(pointA, GetBobCenterPosition_default(child, true));
    if (minDistance > distance) {
      minDistance = distance;
      nearestChild = child;
    }
  });
  return nearestChild;
};
var GetNearestChild_default = GetNearestChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetCharWorldPosition.js
var GetCharWorldPosition = function(child, offsetX, offsetY, out2) {
  if (typeof child === "number") {
    child = this.getCharChild(child, true);
  }
  return GetBobWorldPosition_default(this, child, offsetX, offsetY, out2);
};
var GetCharWorldPosition_default = GetCharWorldPosition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/SetToMinSize.js
var SetToMinSize = function() {
  var children = this.children;
  var maxX = 0, maxY = 0;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (!child.renderable || !child.active || !child.visible) {
      continue;
    }
    var x0 = child.x0 !== void 0 ? child.x0 : child.x;
    var y0 = child.y0 !== void 0 ? child.y0 : child.y;
    maxX = Math.max(maxX, x0);
    maxY = Math.max(maxY, y0);
  }
  var width = maxX + this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right;
  var height = maxY + this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom;
  if (this.width !== width || this.height !== height) {
    this.dirty = true;
    this.setCanvasSize(width, height);
  }
  return this;
};
var SetToMinSize_default = SetToMinSize;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetCharChildIndex.js
var GetCharChildIndex = function(charIndex, activeOnly) {
  if (activeOnly === void 0) {
    activeOnly = true;
  }
  var children = this.children;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (activeOnly && !child.active) {
      continue;
    }
    if (IsChar(child) && !child.removed) {
      if (charIndex === 0) {
        return i;
      } else {
        charIndex--;
      }
    }
  }
  return void 0;
};
var GetCharChildIndex_default = GetCharChildIndex;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetCharChild.js
var GetCharChild = function(charIndex, activeOnly) {
  if (activeOnly === void 0) {
    activeOnly = true;
  }
  var children = this.children;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (activeOnly && !child.active) {
      continue;
    }
    if (IsChar(child) && !child.removed) {
      if (charIndex === 0) {
        return child;
      } else {
        charIndex--;
      }
    }
  }
  return void 0;
};
var GetCharChild_default = GetCharChild;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/GetCharIndex.js
var GetCharIndex = function(childIndex, activeOnly) {
  if (typeof childIndex !== "number") {
    childIndex = this.children.indexOf(childIndex);
    if (childIndex < 0) {
      return null;
    }
  }
  if (activeOnly === void 0) {
    activeOnly = true;
  }
  var children = this.children;
  if (childIndex >= children.length) {
    childIndex = children.length;
  }
  var charIndex = 0;
  for (var i = 0; i < childIndex; i++) {
    var child = children[i];
    if (activeOnly && !child.active) {
      continue;
    }
    if (IsChar(child) && !child.removed) {
      charIndex++;
    }
  }
  return charIndex;
};
var GetCharIndex_default = GetCharIndex;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/input/SetChildrenInteractiveEnable.js
var SetChildrenInteractiveEnable = function(enable) {
  if (enable === void 0) {
    enable = true;
  }
  if (this.childrenInteractiveEnable !== enable) {
    this.lastOverChild = null;
  }
  this.childrenInteractiveEnable = enable;
  return this;
};
var SetChildrenInteractiveEnable_default = SetChildrenInteractiveEnable;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/input/GetFirstChildContains.js
var GetFirstChildContains = function(children, x, y) {
  var children = children;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (!child.active || !child.renderable) {
      continue;
    }
    if (child.contains(x, y)) {
      return child;
    }
  }
  return null;
};
var GetFirstChildContains_default = GetFirstChildContains;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/input/SetChildrenInteractive.js
var SetChildrenInteractive = function() {
  this.on("pointerdown", OnPointerDown, this).on("pointerdown", OnPointerUp, this).on("pointermove", OnPointOverOut, this).on("pointerover", OnPointOverOut, this).on("pointerout", function(pointer, event) {
    OnPointOverOut.call(this, pointer, null, null, event);
  }, this);
  return this;
};
var OnPointerDown = function(pointer, localX, localY, event) {
  if (!this.childrenInteractiveEnable) {
    return;
  }
  var child = GetFirstChildContains_default(this.children, localX, localY);
  if (!child) {
    return;
  }
  this.emit("child.pointerdown", child, pointer, localX, localY, event);
};
var OnPointerUp = function(pointer, localX, localY, event) {
  if (!this.childrenInteractiveEnable) {
    return;
  }
  var child = GetFirstChildContains_default(this.children, localX, localY);
  if (!child) {
    return;
  }
  this.emit("child.pointerup", child, pointer, localX, localY, event);
};
var OnPointOverOut = function(pointer, localX, localY, event) {
  if (!this.childrenInteractiveEnable) {
    return;
  }
  if (localX === null) {
    if (this.lastOverChild !== null) {
      this.emit("child.pointerout", this.lastOverChild, pointer, localX, localY, event);
      this.lastOverChild = null;
    }
    return;
  }
  var child = GetFirstChildContains_default(this.children, localX, localY);
  if (child === this.lastOverChild) {
    return;
  }
  if (this.lastOverChild !== null) {
    this.emit("child.pointerout", this.lastOverChild, pointer, localX, localY, event);
  }
  if (child !== null) {
    this.emit("child.pointerover", child, pointer, localX, localY, event);
  }
  this.lastOverChild = child;
};
var SetChildrenInteractive_default = SetChildrenInteractive;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/input/SetInteractive.js
var GameObject5 = Phaser.GameObjects.GameObject;
var SetInteractive2 = function(hitArea, hitAreaCallback, dropZone) {
  var isInteractived = !!this.input;
  GameObject5.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);
  if (!isInteractived) {
    SetChildrenInteractive_default.call(this);
  }
  return this;
};
var SetInteractive_default2 = SetInteractive2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/MoveChildMethods.js
var BringToTop = Phaser.Utils.Array.BringToTop;
var SendToBack = Phaser.Utils.Array.SendToBack;
var MoveUp = Phaser.Utils.Array.MoveUp;
var MoveDown = Phaser.Utils.Array.MoveDown;
var MoveAbove = Phaser.Utils.Array.MoveAbove;
var MoveBelow = Phaser.Utils.Array.MoveBelow;
var MoveChildMethods_default = {
  moveChildToFist(child) {
    SendToBack(this.children, child);
    return this;
  },
  moveChildToLast(child) {
    BringToTop(this.children, child);
    return this;
  },
  movechildUp(child) {
    MoveUp(this.children, child);
    return this;
  },
  movechildDown(child) {
    MoveDown(this.children, child);
    return this;
  },
  movechildAbove(child, baseChild) {
    MoveAbove(this.children, child, baseChild);
    return this;
  },
  movechildBelow(child, baseChild) {
    MoveBelow(this.children, child, baseChild);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/BackgroundMethods.js
var BackgroundMethods_default = {
  setBackgroundColor(color, color2, isHorizontalGradient) {
    this.background.setColor(color, color2, isHorizontalGradient);
    return this;
  },
  setBackgroundStroke(color, lineWidth) {
    this.background.setStroke(color, lineWidth);
    return this;
  },
  setBackgroundCornerRadius(radius, iteration) {
    this.background.setCornerRadius(radius, iteration);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/InnerBoundsMethods.js
var InnerBoundsMethods_default = {
  setInnerBoundsColor(color, color2, isHorizontalGradient) {
    this.innerBounds.setColor(color, color2, isHorizontalGradient);
    return this;
  },
  setInnerBoundsStroke(color, lineWidth) {
    this.innerBounds.setStroke(color, lineWidth);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/methods/Methods.js
var Methods3 = {
  setFixedSize: SetFixedSize_default,
  setPadding: SetPadding_default,
  getPadding: GetPadding_default,
  modifyTextStyle: ModifyTextStyle_default,
  modifyDefaultTextStyle: ModifyDefaultTextStyle_default,
  resetTextStyle: ResetTextStyle_default,
  setTestString: SetTestString_default,
  removeChild: RemoveChild_default2,
  removeChildren: RemoveChildren_default2,
  popChild: PopChild_default,
  clearContent: ClearContent_default,
  addChild: AddChild_default2,
  createCharChild: CreateCharChild_default,
  createCharChildren: CreateCharChildren_default,
  setText: SetText_default,
  appendText: AppendText_default2,
  insertText: InsertText_default,
  removeText: RemoveText_default,
  getText: GetText_default,
  createImageChild: CreateImageChild_default,
  appendImage: AppendImage_default,
  createDrawerChild: CreateDrawerChild_default,
  appendDrawer: AppendDrawer_default,
  createSpaceChild: CreateSpaceChild_default,
  appendSpace: AppendSpace_default,
  createCommandChild: CreateCommandChild_default,
  appendCommand: AppendCommand_default,
  setWrapConfig: SetWrapConfig_default,
  runWordWrap: RunWordWrap_default2,
  runVerticalWrap: RunVerticalWrap_default2,
  runWrap: RunWrap_default,
  renderContent: RenderContent_default,
  forEachChild: ForEachChild_default,
  forEachRenderableChild: ForEachRenderableChild_default,
  forEachCharChild: ForEachCharChild_default,
  getChildren: GetChildren_default2,
  getActiveChildren: GetActiveChildren_default,
  getCharChildren: GetCharChildren_default,
  getLastAppendedChildren: GetLastAppendedChildren_default2,
  getNearestChild: GetNearestChild_default,
  getCharWorldPosition: GetCharWorldPosition_default,
  setToMinSize: SetToMinSize_default,
  getCharChildIndex: GetCharChildIndex_default,
  getCharChild: GetCharChild_default,
  getCharIndex: GetCharIndex_default,
  setChildrenInteractiveEnable: SetChildrenInteractiveEnable_default,
  setInteractive: SetInteractive_default2
};
Object.assign(
  Methods3,
  MoveChildMethods_default,
  BackgroundMethods_default,
  InnerBoundsMethods_default,
  SetAlignMethods_default,
  SetTextOXYMethods_default
);
var Methods_default5 = Methods3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/poolmanager/PoolManager.js
var GetFastValue2 = Phaser.Utils.Objects.GetFastValue;
var Pools2 = {};
var PoolManager2 = class {
  constructor(config) {
    this.pools = GetFastValue2(config, "pools", Pools2);
  }
  free(bob) {
    if (!this.pools) {
      return this;
    }
    var bobType = bob.type;
    if (!this.pools.hasOwnProperty(bobType)) {
      this.pools[bobType] = new pool_default();
    }
    this.pools[bobType].push(bob);
    bob.onFree();
    return this;
  }
  freeMultiple(arr) {
    if (!this.pools) {
      return this;
    }
    for (var i = 0, cnt = arr.length; i < cnt; i++) {
      this.free(arr[i]);
    }
    return this;
  }
  allocate(bobType) {
    if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
      return null;
    }
    return this.pools[bobType].pop();
  }
};
var PoolManager_default2 = PoolManager2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/DynamicText.js
var IsPlainObject9 = Phaser.Utils.Objects.IsPlainObject;
var GetValue26 = Phaser.Utils.Objects.GetValue;
var DynamicText = class extends Canvas_default {
  constructor(scene, x, y, fixedWidth, fixedHeight, resolution, config) {
    if (IsPlainObject9(x)) {
      config = x;
      x = GetValue26(config, "x", 0);
      y = GetValue26(config, "y", 0);
      fixedWidth = GetValue26(config, "width", 0);
      fixedHeight = GetValue26(config, "height", 0);
      resolution = GetValue26(config, "resolution", 1);
    } else if (IsPlainObject9(fixedWidth)) {
      config = fixedWidth;
      fixedWidth = GetValue26(config, "width", 0);
      fixedHeight = GetValue26(config, "height", 0);
      resolution = GetValue26(config, "resolution", 1);
    } else if (IsPlainObject9(resolution)) {
      config = resolution;
      resolution = GetValue26(config, "resolution", 1);
    }
    var width = fixedWidth === 0 ? 1 : fixedWidth;
    var height = fixedHeight === 0 ? 1 : fixedHeight;
    super(scene, x, y, width, height, resolution);
    this.type = "rexDynamicText";
    this.autoRound = true;
    this.padding = SetPadding();
    this.wrapPadding = SetPadding();
    var textStyleConfig = GetValue26(config, "style", void 0);
    this.defaultTextStyle = new TextStyle_default2(null, textStyleConfig);
    this.textStyle = this.defaultTextStyle.clone();
    this.setTestString(GetValue26(config, "testString", "|MÉqgy"));
    this._textOX = 0;
    this._textOY = 0;
    this.background = new Background_default(this, GetValue26(config, "background", void 0));
    this.innerBounds = new InnerBounds_default(this, GetValue26(config, "innerBounds", void 0));
    this.children = [];
    this.lastAppendedChildren = [];
    this.lastOverChild = null;
    this.poolManager = new PoolManager_default2(config);
    this.setFixedSize(fixedWidth, fixedHeight);
    this.setPadding(GetValue26(config, "padding", 0));
    this.setWrapConfig(GetValue26(config, "wrap", void 0));
    this.setChildrenInteractiveEnable(GetValue26(config, "childrenInteractive", false));
    var text = GetValue26(config, "text", void 0);
    if (text) {
      this.setText(text);
    }
  }
  updateTexture() {
    super.updateTexture(function() {
      this.renderContent();
    }, this);
    return this;
  }
  get text() {
    return this.getText(true);
  }
  set text(value) {
    this.setText(value);
  }
  setSize(width, height) {
    this.setFixedSize(width, height);
    return this;
  }
  get textOX() {
    return this._textOX;
  }
  set textOX(value) {
    this.setTextOX(value);
  }
  get textOY() {
    return this._textOY;
  }
  set textOY(value) {
    this.setTextOY(value);
  }
};
Object.assign(
  DynamicText.prototype,
  Methods_default5
);
var DynamicText_default = DynamicText;

// node_modules/phaser3-rex-plugins/plugins/dynamictext.js
var dynamictext_default = DynamicText_default;

// node_modules/phaser3-rex-plugins/templates/ui/dynamictext/DynamicText.js
var DynamicText_default2 = dynamictext_default;

// node_modules/phaser3-rex-plugins/templates/ui/dynamictext/Factory.js
ObjectFactory_default.register("dynamicText", function(x, y, width, height, config) {
  var gameObject2 = new DynamicText_default2(this.scene, x, y, width, height, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.DynamicText", DynamicText_default2);

// node_modules/phaser3-rex-plugins/plugins/utils/eventemitter/EventEmitterMethods.js
var EventEmitterMethods_default = {
  setEventEmitter(eventEmitter, EventEmitterClass) {
    if (EventEmitterClass === void 0) {
      EventEmitterClass = Phaser.Events.EventEmitter;
    }
    this._privateEE = eventEmitter === true || eventEmitter === void 0;
    this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
    return this;
  },
  destroyEventEmitter() {
    if (this._eventEmitter && this._privateEE) {
      this._eventEmitter.shutdown();
    }
    return this;
  },
  getEventEmitter() {
    return this._eventEmitter;
  },
  on() {
    if (this._eventEmitter) {
      this._eventEmitter.on.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  once() {
    if (this._eventEmitter) {
      this._eventEmitter.once.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  off() {
    if (this._eventEmitter) {
      this._eventEmitter.off.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  emit(event) {
    if (this._eventEmitter && event) {
      this._eventEmitter.emit.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  addListener() {
    if (this._eventEmitter) {
      this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeListener() {
    if (this._eventEmitter) {
      this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeAllListeners() {
    if (this._eventEmitter) {
      this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  listenerCount() {
    if (this._eventEmitter) {
      return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
    }
    return 0;
  },
  listeners() {
    if (this._eventEmitter) {
      return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
    }
    return [];
  },
  eventNames() {
    if (this._eventEmitter) {
      return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
    }
    return [];
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/bobbase/PropertyMethods.js
var PropertyMethods_default = {
  hasProperty(property) {
    var gameObject2 = this.gameObject;
    if (gameObject2.hasOwnProperty(property)) {
      return true;
    } else {
      var value = gameObject2[property];
      return value !== void 0;
    }
  },
  getProperty(property) {
    return this.gameObject[property];
  },
  setProperty(property, value) {
    this.gameObject[property] = value;
    return this;
  },
  easeProperty(config) {
    var property = config.property;
    var value = config.value;
    var duration = config.duration;
    var delay = config.delay;
    var ease = config.ease;
    var repeat = config.repeat;
    var isYoyo = config.yoyo;
    var isFrom = config.from;
    var onComplete = config.complete;
    var target = config.target;
    if (duration === void 0) {
      duration = 1e3;
    }
    if (delay === void 0) {
      delay = 0;
    }
    if (ease === void 0) {
      ease = "Linear";
    }
    if (repeat === void 0) {
      repeat = 0;
    }
    if (isYoyo === void 0) {
      isYoyo = false;
    }
    if (target === void 0) {
      target = this.gameObject;
    }
    if (isFrom) {
      var startValue = value;
      value = target[property];
      target[property] = startValue;
    }
    var config = {
      targets: target,
      duration,
      delay,
      ease,
      repeat,
      yoyo: isYoyo,
      onComplete
    };
    config[property] = value;
    this.addTweenTask(property, config);
    return this;
  },
  addTweenTask(name2, config) {
    var tweenTasks = this.tweens;
    var tweenTask = tweenTasks[name2];
    if (tweenTask) {
      tweenTask.remove();
    }
    var onComplete = config.onComplete;
    config.onComplete = function() {
      tweenTasks[name2].remove();
      tweenTasks[name2] = null;
      if (onComplete) {
        onComplete(config.targets, name2);
      }
    };
    tweenTask = this.scene.tweens.add(config);
    tweenTask.timeScale = this.timeScale;
    tweenTasks[name2] = tweenTask;
    return this;
  },
  getTweenTask(property) {
    return this.tweens[property];
  },
  freeTweens() {
    var tweenTasks = this.tweens, tweenTask;
    for (var propName in tweenTasks) {
      tweenTask = tweenTasks[propName];
      if (tweenTask) {
        tweenTask.remove();
      }
      tweenTasks[propName] = null;
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/bobbase/CallMethods.js
var CallMethods_default = {
  hasMethod(methodName) {
    return typeof this.gameObject[methodName] === "function";
  },
  call(methodName, ...parameters) {
    if (!this.hasMethod(methodName)) {
      console.warn(`[GameObjectManager] Game object '${this.name}' does not have method '${methodName}'`);
      return this;
    }
    var gameObject2 = this.gameObject;
    gameObject2[methodName].apply(gameObject2, parameters);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/bobbase/DataMethods.js
var DataMethods_default2 = {
  hasData(dataKey) {
    var gameObject2 = this.gameObject;
    return gameObject2.data ? gameObject2.data.has(dataKey) : false;
  },
  getData(dataKey) {
    return this.gameObject.getData(dataKey);
  },
  setData(dataKey, value) {
    this.gameObject.setData(dataKey, value);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/bobbase/BobBase.js
var BobBase = class {
  constructor(GOManager2, gameObject2, name2) {
    this.GOManager = GOManager2;
    this.tweens = {};
    this.effects = {};
    this.setGO(gameObject2, name2);
  }
  get scene() {
    return this.GOManager.scene;
  }
  get timeScale() {
    return this.GOManager.timeScale;
  }
  destroy() {
    this.freeGO();
    this.GOManager = void 0;
  }
  freeGO() {
    this.freeTweens();
    this.gameObject.bob = void 0;
    this.gameObject.destroy();
    this.gameObject = void 0;
    return this;
  }
  setGO(gameObject2, name2) {
    gameObject2.goName = name2;
    gameObject2.goType = this.GOManager.name;
    gameObject2.bob = this;
    this.gameObject = gameObject2;
    this.name = name2;
    this.freeTweens();
    return this;
  }
  setTimeScale(timeScale) {
    var tweenTasks = this.tweens;
    for (var key2 in tweenTasks) {
      var tweenTask = tweenTasks[key2];
      if (tweenTask) {
        tweenTask.timeScale = timeScale;
      }
    }
    return this;
  }
};
Object.assign(
  BobBase.prototype,
  PropertyMethods_default,
  CallMethods_default,
  DataMethods_default2
);
var BobBase_default = BobBase;

// node_modules/phaser3-rex-plugins/plugins/utils/object/IsEmpty.js
var IsEmpty = function(source) {
  for (var k in source) {
    return false;
  }
  return true;
};
var IsEmpty_default = IsEmpty;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/IsSingleBob.js
var IsSingleBob = function(name2) {
  return name2 && name2.charAt(0) !== "!";
};
var IsSingleBob_default = IsSingleBob;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/GetMethods.js
var GetMethods_default = {
  has(name2) {
    return this.bobs.hasOwnProperty(name2);
  },
  exists(name2) {
    return this.bobs.hasOwnProperty(name2);
  },
  get(name2, out2) {
    if (IsSingleBob_default(name2)) {
      return this.bobs[name2];
    } else {
      if (out2 === void 0) {
        out2 = [];
      }
      if (name2) {
        name2 = name2.substring(1);
      }
      for (var key2 in this.bobs) {
        if (name2 && key2 === name2) {
          continue;
        }
        out2.push(this.bobs[key2]);
      }
      return out2;
    }
  },
  getFitst(excluded) {
    if (excluded && excluded.charAt(0) === "!") {
      excluded = excluded.substring(1);
    }
    for (var name2 in this.bobs) {
      if (excluded && excluded === name2) {
        continue;
      }
      return this.bobs[name2];
    }
    return null;
  },
  getGO(name2, out2) {
    var bob = this.get(name2);
    if (!bob) {
      return null;
    } else if (!Array.isArray(bob)) {
      return bob.gameObject;
    } else {
      if (out2 === void 0) {
        out2 = [];
      }
      var bobs = bob;
      bobs.forEach(function(bob2) {
        out2.push(bob2.gameObject);
      });
      return out2;
    }
  },
  forEachGO(callback, scope) {
    for (var name2 in this.bobs) {
      var gameObject2 = this.bobs[name2].gameObject;
      var stopLoop;
      if (scope) {
        stopLoop = callback.call(scope, gameObject2, name2, this);
      } else {
        stopLoop = callback(gameObject2, name2, this);
      }
      if (stopLoop) {
        break;
      }
    }
    return this;
  },
  getAllGO(out2) {
    if (out2 === void 0) {
      out2 = [];
    }
    for (var name2 in this.bobs) {
      var gameObject2 = this.bobs[name2].gameObject;
      out2.push(gameObject2);
    }
    return out2;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/color/GetRGB.js
var GetR = function(colorInt) {
  return colorInt >> 16 & 255;
};
var GetG = function(colorInt) {
  return colorInt >> 8 & 255;
};
var GetB = function(colorInt) {
  return colorInt & 255;
};
var GetRGB = function(colorInt, out2) {
  if (out2 === void 0) {
    out2 = {};
  }
  out2.r = colorInt >> 16 & 255;
  out2.g = colorInt >> 8 & 255;
  out2.b = colorInt & 255;
  return out2;
};

// node_modules/phaser3-rex-plugins/plugins/utils/color/SetColor.js
var MaskR = ~(255 << 16) & 16777215;
var MaskG = ~(255 << 8) & 16777215;
var MaskB = ~255 & 16777215;
var SetR = function(colorInt, r) {
  return (r & 255) << 16 | colorInt & MaskR;
};
var SetG = function(colorInt, g) {
  return (g & 255) << 8 | colorInt & MaskG;
};
var SetB = function(colorInt, b) {
  return b & 255 | colorInt & MaskB;
};
var SetRGB = function(colorInt, r, g, b) {
  return (r & 255) << 16 | (g & 255) << 8 | b & 255;
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/tintrgb/AddTintRGBProperties.js
var AddTintRGBProperties = function(gameObject2, tintRGB) {
  if (gameObject2.hasOwnProperty("tintR")) {
    return gameObject2;
  }
  if (tintRGB === void 0) {
    tintRGB = 16777215;
  }
  var tintR = GetR(tintRGB);
  var tintG = GetG(tintRGB);
  var tintB = GetB(tintRGB);
  Object.defineProperty(gameObject2, "tint", {
    get: function() {
      return tintRGB;
    },
    set: function(value) {
      value = Math.floor(value) & 16777215;
      if (gameObject2.setTint) {
        gameObject2.setTint(value);
      }
      if (tintRGB !== value) {
        tintRGB = value;
        tintR = GetR(tintRGB);
        tintG = GetG(tintRGB);
        tintB = GetB(tintRGB);
      }
    }
  });
  Object.defineProperty(gameObject2, "tintR", {
    get: function() {
      return tintR;
    },
    set: function(value) {
      value = Math.floor(value) & 255;
      if (tintR !== value) {
        tintR = value;
        gameObject2.tint = SetR(tintRGB, value);
      }
    }
  });
  Object.defineProperty(gameObject2, "tintG", {
    get: function() {
      return tintG;
    },
    set: function(value) {
      value = Math.floor(value) & 255;
      if (tintG !== value) {
        tintG = value;
        gameObject2.tint = SetG(tintRGB, value);
      }
    }
  });
  Object.defineProperty(gameObject2, "tintB", {
    get: function() {
      return tintB;
    },
    set: function(value) {
      value = Math.floor(value) & 255;
      if (tintB !== value) {
        tintB = value;
        gameObject2.tint = SetB(tintRGB, value);
      }
    }
  });
  Object.defineProperty(gameObject2, "tintGray", {
    get: function() {
      return Math.floor((tintR + tintG + tintB) / 3);
    },
    set: function(value) {
      value = Math.floor(value) & 255;
      if (tintR !== value || tintG !== value || tintB !== value) {
        tintR = value;
        tintG = value;
        tintB = value;
        gameObject2.tint = SetRGB(tintRGB, value, value, value);
      }
    }
  });
  gameObject2.tint = tintRGB;
  return gameObject2;
};
var AddTintRGBProperties_default = AddTintRGBProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/viewportcoordinate/MonitorViewport.js
var EventEmitter = Phaser.Events.EventEmitter;
var MonitorViewport = function(viewport) {
  if (viewport.events) {
    return viewport;
  }
  var events = new EventEmitter();
  var x = viewport.x;
  Object.defineProperty(viewport, "x", {
    get: function() {
      return x;
    },
    set: function(value) {
      if (x !== value) {
        x = value;
        events.emit("update", viewport);
      }
    }
  });
  var y = viewport.y;
  Object.defineProperty(viewport, "y", {
    get: function() {
      return y;
    },
    set: function(value) {
      if (y !== value) {
        y = value;
        events.emit("update", viewport);
      }
    }
  });
  var width = viewport.width;
  Object.defineProperty(viewport, "width", {
    get: function() {
      return width;
    },
    set: function(value) {
      if (width !== value) {
        width = value;
        events.emit("update", viewport);
      }
    }
  });
  var height = viewport.height;
  Object.defineProperty(viewport, "height", {
    get: function() {
      return height;
    },
    set: function(value) {
      if (height !== value) {
        height = value;
        events.emit("update", viewport);
      }
    }
  });
  viewport.events = events;
  return viewport;
};
var MonitorViewport_default = MonitorViewport;

// node_modules/phaser3-rex-plugins/plugins/behaviors/viewportcoordinate/VPXYToXY.js
var VPXYToXY = function(vpx, vpy, vpxOffset, vpyOffset, viewport, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = GlobXY;
  }
  if (typeof vpxOffset !== "number") {
    vpxOffset = 0;
    vpyOffset = 0;
  }
  out2.x = viewport.x + viewport.width * vpx + vpxOffset;
  out2.y = viewport.y + viewport.height * vpy + vpyOffset;
  return out2;
};
var GlobXY = {};
var VPXYToXY_default = VPXYToXY;

// node_modules/phaser3-rex-plugins/plugins/behaviors/viewportcoordinate/AddViewportCoordinateProperties.js
var AddViewportCoordinateProperties = function(gameObject2, viewport, vpx, vpy, vpxOffset, vpyOffset, transformCallback) {
  if (gameObject2.hasOwnProperty("vp")) {
    return gameObject2;
  }
  if (typeof vpx === "function") {
    transformCallback = vpx;
    vpx = void 0;
  }
  if (typeof vpxOffset === "function") {
    transformCallback = vpxOffset;
    vpxOffset = void 0;
  }
  if (vpx === void 0) {
    vpx = 0.5;
  }
  if (vpy === void 0) {
    vpy = 0.5;
  }
  if (vpxOffset === void 0) {
    vpxOffset = 0;
  }
  if (vpyOffset === void 0) {
    vpyOffset = 0;
  }
  if (transformCallback === void 0) {
    transformCallback = VPXYToXY_default;
  }
  MonitorViewport_default(viewport);
  var events = viewport.events;
  gameObject2.vp = viewport;
  var Transform2 = function() {
    transformCallback(vpx, vpy, vpxOffset, vpyOffset, viewport, gameObject2);
  };
  events.on("update", Transform2);
  gameObject2.once("destroy", function() {
    events.off("update", Transform2);
    gameObject2.vp = void 0;
  });
  Object.defineProperty(gameObject2, "vpx", {
    get: function() {
      return vpx;
    },
    set: function(value) {
      if (vpx !== value) {
        vpx = value;
        Transform2();
      }
    }
  });
  Object.defineProperty(gameObject2, "vpy", {
    get: function() {
      return vpy;
    },
    set: function(value) {
      if (vpy !== value) {
        vpy = value;
        Transform2();
      }
    }
  });
  Object.defineProperty(gameObject2, "vpxOffset", {
    get: function() {
      return vpxOffset;
    },
    set: function(value) {
      if (vpxOffset !== value) {
        vpxOffset = value;
        Transform2();
      }
    }
  });
  Object.defineProperty(gameObject2, "vpyOffset", {
    get: function() {
      return vpyOffset;
    },
    set: function(value) {
      if (vpyOffset !== value) {
        vpyOffset = value;
        Transform2();
      }
    }
  });
  Transform2();
};
var AddViewportCoordinateProperties_default = AddViewportCoordinateProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/GetFXFactory.js
var GetFXFactory = function(gameObject2) {
  if (gameObject2.preFX) {
    return gameObject2.preFX;
  }
  if (gameObject2.postFX) {
    return gameObject2.postFX;
  }
  return null;
};
var GetFXFactory_default = GetFXFactory;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddClearEffectCallback.js
var AddClearEffectCallback = function(gameObject2, effectSwitchName) {
  if (!gameObject2._effectSwitchNames) {
    gameObject2._effectSwitchNames = [];
    gameObject2.clearAllEffects = function() {
      var effectSwitchNames = gameObject2._effectSwitchNames;
      for (var i = 0, cnt = effectSwitchNames.length; i < cnt; i++) {
        gameObject2[effectSwitchNames[i]] = null;
      }
      return gameObject2;
    };
    gameObject2.on("destroy", gameObject2.clearAllEffects, gameObject2);
  }
  gameObject2._effectSwitchNames.push(effectSwitchName);
};
var AddClearEffectCallback_default = AddClearEffectCallback;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddBarrelProperties.js
var AddBarrelProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "barrel")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var barrel;
  Object.defineProperty(gameObject2, "barrel", {
    get: function() {
      return barrel;
    },
    set: function(value) {
      if (barrel === value) {
        return;
      }
      barrel = value;
      if (barrel === null || barrel === false) {
        if (gameObject2._barrelEffect) {
          fxFactory.remove(gameObject2._barrelEffect);
          gameObject2._barrelEffect = void 0;
        }
      } else {
        if (!gameObject2._barrelEffect) {
          gameObject2._barrelEffect = fxFactory.addBarrel();
        }
        gameObject2._barrelEffect.amount = barrel;
      }
    }
  });
  gameObject2.barrel = null;
  AddClearEffectCallback_default(gameObject2, "barrel");
  return gameObject2;
};
var AddBarrelProperties_default = AddBarrelProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddColorMatrixEffectPropertiesBase.js
var AddColorMatrixEffectPropertiesBase = function(gameObject2, effectName, inputMode) {
  if (HasProperty_default(gameObject2, effectName)) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var EffectInstancePropertyName = `_${effectName}Effect`;
  var currentValue;
  Object.defineProperty(gameObject2, effectName, {
    get: function() {
      return currentValue;
    },
    set: function(value) {
      if (currentValue === value) {
        return;
      }
      currentValue = value;
      if (currentValue === null || currentValue === false) {
        if (gameObject2[EffectInstancePropertyName]) {
          fxFactory.remove(gameObject2[EffectInstancePropertyName]);
          gameObject2[EffectInstancePropertyName] = void 0;
        }
      } else {
        if (!gameObject2[EffectInstancePropertyName]) {
          gameObject2[EffectInstancePropertyName] = fxFactory.addColorMatrix();
        }
        var effectInstance = gameObject2[EffectInstancePropertyName];
        effectInstance[effectName](inputMode === 1 ? value : void 0);
      }
    }
  });
  gameObject2[effectName] = null;
  AddClearEffectCallback_default(gameObject2, effectName);
  return gameObject2;
};
var AddColorMatrixEffectPropertiesBase_default = AddColorMatrixEffectPropertiesBase;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddBlackWhiteProperties.js
var AddBlackWhiteProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "blackWhite");
  return gameObject2;
};
var AddBlackWhiteProperties_default = AddBlackWhiteProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddBloomProperties.js
var AddBloomProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "bloomColor")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var bloomColor, bloomOffsetX = 1, bloomOffsetY = 1, bloomBlurStrength = 1, bloomStrength = 1, bloomSteps = 4;
  Object.defineProperty(gameObject2, "bloomColor", {
    get: function() {
      return bloomColor;
    },
    set: function(value) {
      if (bloomColor === value) {
        return;
      }
      bloomColor = value;
      if (bloomColor === null || bloomColor === false) {
        if (gameObject2._bloom) {
          fxFactory.remove(gameObject2._bloom);
          gameObject2._bloom = void 0;
          fxFactory.setPadding(0);
        }
      } else {
        if (!gameObject2._bloom) {
          gameObject2._bloom = fxFactory.addBloom(bloomColor, bloomOffsetX, bloomOffsetY, bloomBlurStrength, bloomStrength, bloomSteps);
          fxFactory.setPadding(Math.max(bloomOffsetX, bloomOffsetY) + 1);
        }
        gameObject2._bloom.color = bloomColor;
      }
    }
  });
  Object.defineProperty(gameObject2, "bloomOffsetX", {
    get: function() {
      return bloomOffsetX;
    },
    set: function(value) {
      if (bloomOffsetX === value) {
        return;
      }
      bloomOffsetX = value;
      if (gameObject2._bloom) {
        var offset = Math.max(bloomOffsetX, bloomOffsetY);
        fxFactory.setPadding(offset + 1);
        gameObject2._bloom.offsetX = bloomOffsetX;
      }
    }
  });
  Object.defineProperty(gameObject2, "bloomOffsetY", {
    get: function() {
      return bloomOffsetY;
    },
    set: function(value) {
      if (bloomOffsetY === value) {
        return;
      }
      bloomOffsetY = value;
      if (gameObject2._bloom) {
        var offset = Math.max(bloomOffsetX, bloomOffsetY);
        fxFactory.setPadding(offset + 1);
        gameObject2._bloom.offsetY = bloomOffsetY;
      }
    }
  });
  Object.defineProperty(gameObject2, "bloomBlurStrength", {
    get: function() {
      return bloomBlurStrength;
    },
    set: function(value) {
      if (bloomBlurStrength === value) {
        return;
      }
      bloomBlurStrength = value;
      if (gameObject2._bloom) {
        gameObject2._bloom.blurStrength = bloomBlurStrength;
      }
    }
  });
  Object.defineProperty(gameObject2, "bloomStrength", {
    get: function() {
      return bloomStrength;
    },
    set: function(value) {
      if (bloomStrength === value) {
        return;
      }
      bloomStrength = value;
      if (gameObject2._bloom) {
        gameObject2._bloom.strength = bloomStrength;
      }
    }
  });
  Object.defineProperty(gameObject2, "bloomSteps", {
    get: function() {
      return bloomSteps;
    },
    set: function(value) {
      if (bloomSteps === value) {
        return;
      }
      bloomSteps = value;
      if (gameObject2._bloom) {
        gameObject2._bloom.steps = bloomSteps;
      }
    }
  });
  gameObject2.bloomColor = null;
  AddClearEffectCallback_default(gameObject2, "bloomColor");
  return gameObject2;
};
var AddBloomProperties_default = AddBloomProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddBlurProperties.js
var AddBlurProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "blurColor")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var blurColor, blurQuality = 0, blurX = 1, blurY = 1, blurStrength = 1, blurSteps = 4;
  Object.defineProperty(gameObject2, "blurColor", {
    get: function() {
      return blurColor;
    },
    set: function(value) {
      if (blurColor === value) {
        return;
      }
      blurColor = value;
      if (blurColor === null || blurColor === false) {
        if (gameObject2._blur) {
          fxFactory.remove(gameObject2._blur);
          gameObject2._blur = void 0;
          fxFactory.setPadding(0);
        }
      } else {
        if (!gameObject2._blur) {
          gameObject2._blur = fxFactory.addBlur(blurQuality, blurX, blurY, blurStrength, blurColor, blurSteps);
          fxFactory.setPadding(Math.max(blurX, blurY) + 1);
        }
        gameObject2._blur.color = blurColor;
      }
    }
  });
  Object.defineProperty(gameObject2, "blurQuality", {
    get: function() {
      return blurQuality;
    },
    set: function(value) {
      if (blurQuality === value) {
        return;
      }
      blurQuality = value;
      if (gameObject2._blur) {
        gameObject2._blur.quality = blurQuality;
      }
    }
  });
  Object.defineProperty(gameObject2, "blurX", {
    get: function() {
      return blurX;
    },
    set: function(value) {
      if (blurX === value) {
        return;
      }
      blurX = value;
      if (gameObject2._blur) {
        var offset = Math.max(blurX, blurY);
        fxFactory.setPadding(offset + 1);
        gameObject2._blur.x = blurX;
      }
    }
  });
  Object.defineProperty(gameObject2, "blurY", {
    get: function() {
      return blurY;
    },
    set: function(value) {
      if (blurY === value) {
        return;
      }
      blurY = value;
      if (gameObject2._blur) {
        var offset = Math.max(blurX, blurY);
        fxFactory.setPadding(offset + 1);
        gameObject2._blur.y = blurY;
      }
    }
  });
  Object.defineProperty(gameObject2, "blurStrength", {
    get: function() {
      return blurStrength;
    },
    set: function(value) {
      if (blurStrength === value) {
        return;
      }
      blurStrength = value;
      if (gameObject2._blur) {
        gameObject2._blur.strength = blurStrength;
      }
    }
  });
  Object.defineProperty(gameObject2, "blurSteps", {
    get: function() {
      return blurSteps;
    },
    set: function(value) {
      if (blurSteps === value) {
        return;
      }
      blurSteps = value;
      if (gameObject2._blur) {
        gameObject2._blur.steps = blurSteps;
      }
    }
  });
  gameObject2.blurColor = null;
  AddClearEffectCallback_default(gameObject2, "blurColor");
  return gameObject2;
};
var AddBlurProperties_default = AddBlurProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddBokehProperties.js
var AddBokehProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "bokehRadius")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var bokehRadius, bokehAmount = 1, bokehContrast = 0.2;
  Object.defineProperty(gameObject2, "bokehRadius", {
    get: function() {
      return bokehRadius;
    },
    set: function(value) {
      if (bokehRadius === value) {
        return;
      }
      bokehRadius = value;
      if (bokehRadius === null || bokehRadius === false) {
        if (gameObject2._bokeh) {
          fxFactory.remove(gameObject2._bokeh);
          gameObject2._bokeh = void 0;
        }
      } else {
        if (!gameObject2._bokeh) {
          gameObject2._bokeh = fxFactory.addBokeh(bokehRadius, bokehAmount, bokehContrast);
        }
        gameObject2._bokeh.radius = bokehRadius;
      }
    }
  });
  Object.defineProperty(gameObject2, "bokehAmount", {
    get: function() {
      return bokehAmount;
    },
    set: function(value) {
      if (bokehAmount === value) {
        return;
      }
      bokehAmount = value;
      if (gameObject2._bokeh) {
        gameObject2._bokeh.amount = bokehAmount;
      }
    }
  });
  Object.defineProperty(gameObject2, "bokehContrast", {
    get: function() {
      return bokehContrast;
    },
    set: function(value) {
      if (bokehContrast === value) {
        return;
      }
      bokehContrast = value;
      if (gameObject2._bokeh) {
        gameObject2._bokeh.contrast = bokehContrast;
      }
    }
  });
  gameObject2.bokehRadius = null;
  AddClearEffectCallback_default(gameObject2, "bokehRadius");
  return gameObject2;
};
var AddBokehProperties_default = AddBokehProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddBrightnessProperties.js
var AddBrightnessProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "brightness", 1);
  return gameObject2;
};
var AddBrightnessProperties_default = AddBrightnessProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddBrownProperties.js
var AddBrownProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "brown");
  return gameObject2;
};
var AddBrownProperties_default = AddBrownProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddCircleProperties.js
var AddCircleProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "circleColor")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var circleColor, circleThickness = 8, circleBackgroundColor = 0, circleBackgroundAlpha = 0.4, circleScale = 1, circleFeather = 5e-3;
  Object.defineProperty(gameObject2, "circleColor", {
    get: function() {
      return circleColor;
    },
    set: function(value) {
      if (circleColor === value) {
        return;
      }
      circleColor = value;
      if (circleColor === null || circleColor === false) {
        if (gameObject2._circle) {
          fxFactory.remove(gameObject2._circle);
          gameObject2._circle = void 0;
        }
      } else {
        if (!gameObject2._circle) {
          gameObject2._circle = fxFactory.addCircle(circleThickness, circleColor, circleBackgroundColor, circleScale, circleFeather);
          gameObject2.circleBackgroundAlpha = circleBackgroundAlpha;
        }
        gameObject2._circle.color = circleColor;
      }
    }
  });
  Object.defineProperty(gameObject2, "circleThickness", {
    get: function() {
      return circleThickness;
    },
    set: function(value) {
      if (circleThickness === value) {
        return;
      }
      circleThickness = value;
      if (gameObject2._circle) {
        gameObject2._circle.thickness = circleThickness;
      }
    }
  });
  Object.defineProperty(gameObject2, "circleBackgroundColor", {
    get: function() {
      return circleBackgroundColor;
    },
    set: function(value) {
      if (circleBackgroundColor === value) {
        return;
      }
      circleBackgroundColor = value;
      if (gameObject2._circle) {
        gameObject2._circle.backgroundColor = circleBackgroundColor;
      }
    }
  });
  Object.defineProperty(gameObject2, "circleBackgroundAlpha", {
    get: function() {
      return circleBackgroundAlpha;
    },
    set: function(value) {
      if (circleBackgroundAlpha === value) {
        return;
      }
      circleBackgroundAlpha = value;
      if (gameObject2._circle) {
        gameObject2._circle.glcolor2[3] = circleBackgroundAlpha;
      }
    }
  });
  Object.defineProperty(gameObject2, "circleScale", {
    get: function() {
      return circleScale;
    },
    set: function(value) {
      if (circleScale === value) {
        return;
      }
      circleScale = value;
      if (gameObject2._circle) {
        gameObject2._circle.scale = circleScale;
      }
    }
  });
  Object.defineProperty(gameObject2, "circleFeather", {
    get: function() {
      return circleFeather;
    },
    set: function(value) {
      if (circleFeather === value) {
        return;
      }
      circleFeather = value;
      if (gameObject2._circle) {
        gameObject2._circle.feather = circleFeather;
      }
    }
  });
  gameObject2.circleColor = null;
  AddClearEffectCallback_default(gameObject2, "circleColor");
  return gameObject2;
};
var AddCircleProperties_default = AddCircleProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddContrastProperties.js
var AddContrastProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "contrast", 1);
  return gameObject2;
};
var AddContrastProperties_default = AddContrastProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddDesaturateProperties.js
var AddDesaturateProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "desaturate", 1);
  return gameObject2;
};
var AddDesaturateProperties_default = AddDesaturateProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddDesaturateLuminanceProperties.js
var AddDesaturateLuminanceProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "desaturateLuminance");
  return gameObject2;
};
var AddDesaturateLuminanceProperties_default = AddDesaturateLuminanceProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddDisplacementProperties.js
var AddDisplacementProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "displacementKey")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var displacementKey, displacementX = 5e-3, displacementY = 5e-3;
  Object.defineProperty(gameObject2, "displacementKey", {
    get: function() {
      return displacementKey;
    },
    set: function(value) {
      if (displacementKey === value) {
        return;
      }
      displacementKey = value;
      if (displacementKey === null || displacementKey === false) {
        if (gameObject2._displacement) {
          fxFactory.remove(gameObject2._displacement);
          gameObject2._displacement = void 0;
        }
      } else {
        if (!gameObject2._displacement) {
          gameObject2._displacement = fxFactory.addDisplacement(displacementKey, displacementX, displacementY);
        }
        gameObject2._displacement.setTexture(displacementKey);
      }
    }
  });
  Object.defineProperty(gameObject2, "displacementX", {
    get: function() {
      return displacementX;
    },
    set: function(value) {
      if (displacementX === value) {
        return;
      }
      displacementX = value;
      if (gameObject2._displacement) {
        gameObject2._displacement.x = displacementX;
      }
    }
  });
  Object.defineProperty(gameObject2, "displacementY", {
    get: function() {
      return displacementY;
    },
    set: function(value) {
      if (displacementY === value) {
        return;
      }
      displacementY = value;
      if (gameObject2._displacement) {
        gameObject2._displacement.y = displacementY;
      }
    }
  });
  gameObject2.displacementKey = null;
  AddClearEffectCallback_default(gameObject2, "displacementKey");
  return gameObject2;
};
var AddDisplacementProperties_default = AddDisplacementProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddGlowProperties.js
var AddGlowProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "glowColor")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var glowColor, glowOuterStrength = 4, glowInnerStrength = 0;
  Object.defineProperty(gameObject2, "glowColor", {
    get: function() {
      return glowColor;
    },
    set: function(value) {
      if (glowColor === value) {
        return;
      }
      glowColor = value;
      if (glowColor === null || glowColor === false) {
        if (gameObject2._glow) {
          fxFactory.remove(gameObject2._glow);
          gameObject2._glow = void 0;
          fxFactory.setPadding(0);
        }
      } else {
        if (!gameObject2._glow) {
          gameObject2._glow = fxFactory.addGlow(glowColor, glowOuterStrength, glowInnerStrength);
          fxFactory.setPadding(glowOuterStrength + 1);
        }
        gameObject2._glow.color = glowColor;
      }
    }
  });
  Object.defineProperty(gameObject2, "glowOuterStrength", {
    get: function() {
      return glowOuterStrength;
    },
    set: function(value) {
      if (glowOuterStrength === value) {
        return;
      }
      glowOuterStrength = value;
      if (gameObject2._glow) {
        fxFactory.setPadding(glowOuterStrength + 1);
        gameObject2._glow.outerStrength = glowOuterStrength;
      }
    }
  });
  Object.defineProperty(gameObject2, "glowInnerStrength", {
    get: function() {
      return glowInnerStrength;
    },
    set: function(value) {
      if (glowInnerStrength === value) {
        return;
      }
      glowInnerStrength = value;
      if (gameObject2._glow) {
        gameObject2._glow.innerStrength = glowInnerStrength;
      }
    }
  });
  gameObject2.glowColor = null;
  AddClearEffectCallback_default(gameObject2, "glowColor");
  return gameObject2;
};
var AddGlowProperties_default = AddGlowProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddGradientProperties.js
var AddGradientProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "gradientColor")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var gradientColor1, gradientColor2, gradientAlpha = 0.5, gradientFromX = 0, gradientFromY = 0, gradientToX = 0, gradientToY = 1, gradientSize = 0;
  Object.defineProperty(gameObject2, "gradientColor", {
    get: function() {
      return [gradientColor1, gradientColor2];
    },
    set: function(value) {
      var color1, color2;
      if (value === null || value === false) {
        color1 = null;
        color2 = null;
      } else {
        color1 = value[0];
        color2 = value[1];
      }
      if (gradientColor1 === color1 && gradientColor2 === color2) {
        return;
      }
      gradientColor1 = color1;
      gradientColor2 = color2;
      if (gradientColor1 === null || gradientColor1 === false) {
        if (gameObject2._gradient) {
          fxFactory.remove(gameObject2._gradient);
          gameObject2._gradient = void 0;
        }
      } else {
        if (!gameObject2._gradient) {
          gameObject2._gradient = fxFactory.addGradient(gradientColor1, gradientColor2, gradientAlpha, gradientFromX, gradientFromY, gradientToX, gradientToY, gradientSize);
        }
        gameObject2._gradient.color1 = gradientColor1;
        gameObject2._gradient.color2 = gradientColor2;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientColor1", {
    get: function() {
      return gradientColor1;
    },
    set: function(value) {
      if (value === null || value === false) {
        gameObject2.gradientColor = value;
        return;
      }
      if (gradientColor1 === value) {
        return;
      }
      gradientColor1 = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.color1 = gradientColor1;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientColor2", {
    get: function() {
      return gradientColor2;
    },
    set: function(value) {
      if (value === null || value === false) {
        gameObject2.gradientColor = value;
        return;
      }
      if (gradientColor2 === value) {
        return;
      }
      gradientColor2 = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.color2 = gradientColor2;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientAlpha", {
    get: function() {
      return gradientAlpha;
    },
    set: function(value) {
      if (gradientAlpha === value) {
        return;
      }
      gradientAlpha = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.alpha = gradientAlpha;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientFromX", {
    get: function() {
      return gradientFromX;
    },
    set: function(value) {
      if (gradientFromX === value) {
        return;
      }
      gradientFromX = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.fromX = gradientFromX;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientFromY", {
    get: function() {
      return gradientFromY;
    },
    set: function(value) {
      if (gradientFromY === value) {
        return;
      }
      gradientFromY = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.fromY = gradientFromY;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientToX", {
    get: function() {
      return gradientToX;
    },
    set: function(value) {
      if (gradientToX === value) {
        return;
      }
      gradientToX = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.toX = gradientToX;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientToY", {
    get: function() {
      return gradientToY;
    },
    set: function(value) {
      if (gradientToY === value) {
        return;
      }
      gradientToY = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.toY = gradientToY;
      }
    }
  });
  Object.defineProperty(gameObject2, "gradientSize", {
    get: function() {
      return gradientSize;
    },
    set: function(value) {
      if (gradientSize === value) {
        return;
      }
      gradientSize = value;
      if (gameObject2._gradient) {
        gameObject2._gradient.size = gradientSize;
      }
    }
  });
  gameObject2.gradientColor = null;
  AddClearEffectCallback_default(gameObject2, "gradientColor");
  return gameObject2;
};
var AddGradientProperties_default = AddGradientProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddGrayscaleProperties.js
var AddGrayscaleProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "grayscale", 1);
  return gameObject2;
};
var AddGrayscaleProperties_default = AddGrayscaleProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddHueProperties.js
var AddHueProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "hue", 1);
  return gameObject2;
};
var AddHueProperties_default = AddHueProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddKodachromeProperties.js
var AddKodachromeProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "kodachrome");
  return gameObject2;
};
var AddKodachromeProperties_default = AddKodachromeProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddLSDProperties.js
var AddLSDProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "lsd");
  return gameObject2;
};
var AddLSDProperties_default = AddLSDProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddNegativeProperties.js
var AddNegativeProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "negative");
  return gameObject2;
};
var AddNegativeProperties_default = AddNegativeProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddPixelateProperties.js
var AddPixelateProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "pixelate")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var pixelate;
  Object.defineProperty(gameObject2, "pixelate", {
    get: function() {
      return pixelate;
    },
    set: function(value) {
      if (pixelate === value) {
        return;
      }
      pixelate = value;
      if (pixelate === null || pixelate === false) {
        if (gameObject2._pixelateEffect) {
          fxFactory.remove(gameObject2._pixelateEffect);
          gameObject2._pixelateEffect = void 0;
        }
      } else {
        if (!gameObject2._pixelateEffect) {
          gameObject2._pixelateEffect = fxFactory.addPixelate();
        }
        gameObject2._pixelateEffect.amount = pixelate;
      }
    }
  });
  gameObject2.pixelate = null;
  AddClearEffectCallback_default(gameObject2, "pixelate");
  return gameObject2;
};
var AddPixelateProperties_default = AddPixelateProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddPolaroidProperties.js
var AddPolaroidProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "polaroid");
  return gameObject2;
};
var AddPolaroidProperties_default = AddPolaroidProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddRevealProperties.js
var AddRevealProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "revealLeft")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var revealLeft, revealRight, revealUp, revealDown, revealWidth = 0.1;
  var ClearRevealFlags = function() {
    revealLeft = null;
    revealRight = null;
    revealUp = null;
    revealDown = null;
  };
  var RemoveEffect = function(gameObject3) {
    if (gameObject3._revealEffect) {
      fxFactory.remove(gameObject3._revealEffect);
      gameObject3._revealEffect = void 0;
    }
  };
  Object.defineProperty(gameObject2, "revealLeft", {
    get: function() {
      return revealLeft;
    },
    set: function(value) {
      if (revealLeft === value) {
        return;
      }
      ClearRevealFlags();
      revealLeft = value;
      if (revealLeft === null || revealLeft === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._revealEffect) {
          gameObject2._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
        }
        gameObject2._revealEffect.direction = 1;
        gameObject2._revealEffect.axis = 0;
        gameObject2._revealEffect.progress = revealLeft;
      }
    }
  });
  Object.defineProperty(gameObject2, "revealRight", {
    get: function() {
      return revealRight;
    },
    set: function(value) {
      if (revealRight === value) {
        return;
      }
      ClearRevealFlags();
      revealRight = value;
      if (revealRight === null || revealRight === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._revealEffect) {
          gameObject2._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
        }
        gameObject2._revealEffect.direction = 0;
        gameObject2._revealEffect.axis = 0;
        gameObject2._revealEffect.progress = revealRight;
      }
    }
  });
  Object.defineProperty(gameObject2, "revealUp", {
    get: function() {
      return revealUp;
    },
    set: function(value) {
      if (revealUp === value) {
        return;
      }
      ClearRevealFlags();
      revealUp = value;
      if (revealUp === null || revealUp === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._revealEffect) {
          gameObject2._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
        }
        gameObject2._revealEffect.direction = 1;
        gameObject2._revealEffect.axis = 1;
        gameObject2._revealEffect.progress = revealUp;
      }
    }
  });
  Object.defineProperty(gameObject2, "revealDown", {
    get: function() {
      return revealDown;
    },
    set: function(value) {
      if (revealDown === value) {
        return;
      }
      ClearRevealFlags();
      revealDown = value;
      if (revealDown === null || revealDown === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._revealEffect) {
          gameObject2._revealEffect = fxFactory.addReveal(revealWidth, 0, 0);
        }
        gameObject2._revealEffect.direction = 0;
        gameObject2._revealEffect.axis = 1;
        gameObject2._revealEffect.progress = revealDown;
      }
    }
  });
  Object.defineProperty(gameObject2, "revealWidth", {
    get: function() {
      return revealWidth;
    },
    set: function(value) {
      if (revealWidth === value) {
        return;
      }
      revealWidth = value;
      if (gameObject2._revealEffect) {
        gameObject2._revealEffect.wipeWidth = revealWidth;
      }
    }
  });
  gameObject2.revealLeft = null;
  AddClearEffectCallback_default(gameObject2, "revealLeft");
  AddClearEffectCallback_default(gameObject2, "revealRight");
  AddClearEffectCallback_default(gameObject2, "revealUp");
  AddClearEffectCallback_default(gameObject2, "revealDown");
  return gameObject2;
};
var AddRevealProperties_default = AddRevealProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddSaturateProperties.js
var AddSaturateProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "saturate", 1);
  return gameObject2;
};
var AddSaturateProperties_default = AddSaturateProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddSepiaProperties.js
var AddSepiaProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "sepia");
  return gameObject2;
};
var AddSepiaProperties_default = AddSepiaProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddShadowProperties.js
var AddShadowProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "shadowColor")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var shadowColor, shadowX = 0, shadowY = 0, shadowDecay = 0.1, shadowPower = 1, shadowSamples = 6, shadowIntensity = 1;
  Object.defineProperty(gameObject2, "shadowColor", {
    get: function() {
      return shadowColor;
    },
    set: function(value) {
      if (shadowColor === value) {
        return;
      }
      shadowColor = value;
      if (shadowColor === null || shadowColor === false) {
        if (gameObject2._shadow) {
          fxFactory.remove(gameObject2._shadow);
          gameObject2._shadow = void 0;
        }
      } else {
        if (!gameObject2._shadow) {
          gameObject2._shadow = fxFactory.addShadow(shadowX, shadowY, shadowDecay, shadowPower, shadowColor, shadowSamples, shadowIntensity);
        }
        gameObject2._shadow.color = shadowColor;
      }
    }
  });
  Object.defineProperty(gameObject2, "shadowX", {
    get: function() {
      return shadowX;
    },
    set: function(value) {
      if (shadowX === value) {
        return;
      }
      shadowX = value;
      if (gameObject2._shadow) {
        gameObject2._shadow.x = shadowX;
      }
    }
  });
  Object.defineProperty(gameObject2, "shadowY", {
    get: function() {
      return shadowY;
    },
    set: function(value) {
      if (shadowY === value) {
        return;
      }
      shadowY = value;
      if (gameObject2._shadow) {
        gameObject2._shadow.y = shadowY;
      }
    }
  });
  Object.defineProperty(gameObject2, "decay", {
    get: function() {
      return shadowDecay;
    },
    set: function(value) {
      if (shadowDecay === value) {
        return;
      }
      shadowDecay = value;
      if (gameObject2._shadow) {
        gameObject2._shadow.decay = shadowDecay;
      }
    }
  });
  Object.defineProperty(gameObject2, "shadowPower", {
    get: function() {
      return shadowPower;
    },
    set: function(value) {
      if (shadowPower === value) {
        return;
      }
      shadowPower = value;
      if (gameObject2._shadow) {
        gameObject2._shadow.power = shadowPower;
      }
    }
  });
  Object.defineProperty(gameObject2, "shadowSamples", {
    get: function() {
      return shadowSamples;
    },
    set: function(value) {
      if (shadowSamples === value) {
        return;
      }
      shadowSamples = value;
      if (gameObject2._shadow) {
        gameObject2._shadow.samples = shadowSamples;
      }
    }
  });
  Object.defineProperty(gameObject2, "shadowIntensity", {
    get: function() {
      return shadowIntensity;
    },
    set: function(value) {
      if (shadowIntensity === value) {
        return;
      }
      shadowIntensity = value;
      if (gameObject2._shadow) {
        gameObject2._shadow.intensity = shadowIntensity;
      }
    }
  });
  gameObject2.shadowColor = null;
  AddClearEffectCallback_default(gameObject2, "shadowColor");
  return gameObject2;
};
var AddShadowProperties_default = AddShadowProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddShiftToBGRProperties.js
var AddShiftToBGRProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "shiftToBGR");
  return gameObject2;
};
var AddShiftToBGRProperties_default = AddShiftToBGRProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddShineProperties.js
var AddShineProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "shineSpeed")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var shineSpeed, shineLineWidth = 0.5, shineGradient = 3;
  Object.defineProperty(gameObject2, "shineSpeed", {
    get: function() {
      return shineSpeed;
    },
    set: function(value) {
      if (shineSpeed === value) {
        return;
      }
      shineSpeed = value;
      if (shineSpeed === null || shineSpeed === false) {
        if (gameObject2._shine) {
          fxFactory.remove(gameObject2._shine);
          gameObject2._shine = void 0;
        }
      } else {
        if (!gameObject2._shine) {
          gameObject2._shine = fxFactory.addShine(shineSpeed, shineLineWidth, shineGradient);
        }
        gameObject2._shine.speed = shineSpeed;
      }
    }
  });
  Object.defineProperty(gameObject2, "shineLineWidth", {
    get: function() {
      return shineLineWidth;
    },
    set: function(value) {
      if (shineLineWidth === value) {
        return;
      }
      shineLineWidth = value;
      if (gameObject2._shine) {
        gameObject2._shine.lineWidth = shineLineWidth;
      }
    }
  });
  Object.defineProperty(gameObject2, "shineGradient", {
    get: function() {
      return shineGradient;
    },
    set: function(value) {
      if (shineGradient === value) {
        return;
      }
      shineGradient = value;
      if (gameObject2._shine) {
        gameObject2._shine.gradient = shineGradient;
      }
    }
  });
  gameObject2.shineSpeed = null;
  AddClearEffectCallback_default(gameObject2, "shineSpeed");
  return gameObject2;
};
var AddShineProperties_default = AddShineProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddTechnicolorProperties.js
var AddTechnicolorProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "technicolor");
  return gameObject2;
};
var AddTechnicolorProperties_default = AddTechnicolorProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddTiltShiftProperties.js
var AddTiltShiftProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "tiltShiftRadius")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var tiltShiftRadius, tiltShiftAmount = 1, tiltShiftContrast = 0.2, tiltShiftBlurX = 1, tiltShiftBlurY = 1, tiltShiftStrength = 1;
  Object.defineProperty(gameObject2, "tiltShiftRadius", {
    get: function() {
      return tiltShiftRadius;
    },
    set: function(value) {
      if (tiltShiftRadius === value) {
        return;
      }
      tiltShiftRadius = value;
      if (tiltShiftRadius === null || tiltShiftRadius === false) {
        if (gameObject2._tiltShift) {
          fxFactory.remove(gameObject2._tiltShift);
          gameObject2._tiltShift = void 0;
        }
      } else {
        if (!gameObject2._tiltShift) {
          gameObject2._tiltShift = fxFactory.addTiltShift(tiltShiftRadius, tiltShiftAmount, tiltShiftContrast, tiltShiftBlurX, tiltShiftBlurY, tiltShiftStrength);
        }
        gameObject2._tiltShift.radius = tiltShiftRadius;
      }
    }
  });
  Object.defineProperty(gameObject2, "tiltShiftAmount", {
    get: function() {
      return tiltShiftAmount;
    },
    set: function(value) {
      if (tiltShiftAmount === value) {
        return;
      }
      tiltShiftAmount = value;
      if (gameObject2._tiltShift) {
        gameObject2._tiltShift.amount = tiltShiftAmount;
      }
    }
  });
  Object.defineProperty(gameObject2, "tiltShiftContrast", {
    get: function() {
      return tiltShiftContrast;
    },
    set: function(value) {
      if (tiltShiftContrast === value) {
        return;
      }
      tiltShiftContrast = value;
      if (gameObject2._tiltShift) {
        gameObject2._tiltShift.contrast = tiltShiftContrast;
      }
    }
  });
  Object.defineProperty(gameObject2, "tiltShiftBlurX", {
    get: function() {
      return tiltShiftBlurX;
    },
    set: function(value) {
      if (tiltShiftBlurX === value) {
        return;
      }
      tiltShiftBlurX = value;
      if (gameObject2._tiltShift) {
        gameObject2._tiltShift.blurX = tiltShiftBlurX;
      }
    }
  });
  Object.defineProperty(gameObject2, "tiltShiftBlurY", {
    get: function() {
      return tiltShiftBlurY;
    },
    set: function(value) {
      if (tiltShiftBlurY === value) {
        return;
      }
      tiltShiftBlurY = value;
      if (gameObject2._tiltShift) {
        gameObject2._tiltShift.blurY = tiltShiftBlurY;
      }
    }
  });
  Object.defineProperty(gameObject2, "tiltShiftStrength", {
    get: function() {
      return tiltShiftStrength;
    },
    set: function(value) {
      if (tiltShiftStrength === value) {
        return;
      }
      tiltShiftStrength = value;
      if (gameObject2._tiltShift) {
        gameObject2._tiltShift.strength = tiltShiftStrength;
      }
    }
  });
  gameObject2.tiltShiftRadius = null;
  AddClearEffectCallback_default(gameObject2, "tiltShiftRadius");
  return gameObject2;
};
var AddTiltShiftProperties_default = AddTiltShiftProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddVignetteProperties.js
var AddVignetteProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "vignetteRadius")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var vignetteRadius, vignetteX = 0.5, vignetteY = 0.5, vignetteStrength = 0.5;
  Object.defineProperty(gameObject2, "vignetteRadius", {
    get: function() {
      return vignetteRadius;
    },
    set: function(value) {
      if (vignetteRadius === value) {
        return;
      }
      vignetteRadius = value;
      if (vignetteRadius === null || vignetteRadius === false) {
        if (gameObject2._vignette) {
          fxFactory.remove(gameObject2._vignette);
          gameObject2._vignette = void 0;
        }
      } else {
        if (!gameObject2._vignette) {
          gameObject2._vignette = fxFactory.addVignette(vignetteX, vignetteY, vignetteRadius, vignetteStrength);
        }
        gameObject2._vignette.radius = vignetteRadius;
      }
    }
  });
  Object.defineProperty(gameObject2, "vignetteX", {
    get: function() {
      return vignetteX;
    },
    set: function(value) {
      if (vignetteX === value) {
        return;
      }
      vignetteX = value;
      if (gameObject2._vignette) {
        gameObject2._vignette.x = vignetteX;
      }
    }
  });
  Object.defineProperty(gameObject2, "vignetteY", {
    get: function() {
      return vignetteY;
    },
    set: function(value) {
      if (vignetteY === value) {
        return;
      }
      vignetteY = value;
      if (gameObject2._vignette) {
        gameObject2._vignette.y = vignetteY;
      }
    }
  });
  Object.defineProperty(gameObject2, "vignetteStrength", {
    get: function() {
      return vignetteStrength;
    },
    set: function(value) {
      if (vignetteStrength === value) {
        return;
      }
      vignetteStrength = value;
      if (gameObject2._vignette) {
        gameObject2._vignette.strength = vignetteStrength;
      }
    }
  });
  gameObject2.vignetteRadius = null;
  AddClearEffectCallback_default(gameObject2, "vignetteRadius");
  return gameObject2;
};
var AddVignetteProperties_default = AddVignetteProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/colormatrix/AddVintagePinholeProperties.js
var AddVintagePinholeProperties = function(gameObject2) {
  AddColorMatrixEffectPropertiesBase_default(gameObject2, "vintagePinhole");
  return gameObject2;
};
var AddVintagePinholeProperties_default = AddVintagePinholeProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddWipeProperties.js
var AddWipeProperties = function(gameObject2) {
  if (HasProperty_default(gameObject2, "wipeLeft")) {
    return gameObject2;
  }
  var fxFactory = GetFXFactory_default(gameObject2);
  if (!fxFactory) {
    return gameObject2;
  }
  var wipeLeft, wipeRight, wipeUp, wipeDown, wipeWidth = 0.1;
  var ClearWipeFlags = function() {
    wipeLeft = null;
    wipeRight = null;
    wipeUp = null;
    wipeDown = null;
  };
  var RemoveEffect = function(gameObject3) {
    if (gameObject3._wipeEffect) {
      fxFactory.remove(gameObject3._wipeEffect);
      gameObject3._wipeEffect = void 0;
    }
  };
  Object.defineProperty(gameObject2, "wipeLeft", {
    get: function() {
      return wipeLeft;
    },
    set: function(value) {
      if (wipeLeft === value) {
        return;
      }
      ClearWipeFlags();
      wipeLeft = value;
      if (wipeLeft === null || wipeLeft === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._wipeEffect) {
          gameObject2._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
        }
        gameObject2._wipeEffect.direction = 1;
        gameObject2._wipeEffect.axis = 0;
        gameObject2._wipeEffect.progress = wipeLeft;
      }
    }
  });
  Object.defineProperty(gameObject2, "wipeRight", {
    get: function() {
      return wipeRight;
    },
    set: function(value) {
      if (wipeRight === value) {
        return;
      }
      ClearWipeFlags();
      wipeRight = value;
      if (wipeRight === null || wipeRight === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._wipeEffect) {
          gameObject2._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
        }
        gameObject2._wipeEffect.direction = 0;
        gameObject2._wipeEffect.axis = 0;
        gameObject2._wipeEffect.progress = wipeRight;
      }
    }
  });
  Object.defineProperty(gameObject2, "wipeUp", {
    get: function() {
      return wipeUp;
    },
    set: function(value) {
      if (wipeUp === value) {
        return;
      }
      ClearWipeFlags();
      wipeUp = value;
      if (wipeUp === null || wipeUp === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._wipeEffect) {
          gameObject2._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
        }
        gameObject2._wipeEffect.direction = 1;
        gameObject2._wipeEffect.axis = 1;
        gameObject2._wipeEffect.progress = wipeUp;
      }
    }
  });
  Object.defineProperty(gameObject2, "wipeDown", {
    get: function() {
      return wipeDown;
    },
    set: function(value) {
      if (wipeDown === value) {
        return;
      }
      ClearWipeFlags();
      wipeDown = value;
      if (wipeDown === null || wipeDown === false) {
        RemoveEffect(gameObject2);
      } else {
        if (!gameObject2._wipeEffect) {
          gameObject2._wipeEffect = fxFactory.addWipe(wipeWidth, 0, 0);
        }
        gameObject2._wipeEffect.direction = 0;
        gameObject2._wipeEffect.axis = 1;
        gameObject2._wipeEffect.progress = wipeDown;
      }
    }
  });
  Object.defineProperty(gameObject2, "wipeWidth", {
    get: function() {
      return wipeWidth;
    },
    set: function(value) {
      if (wipeWidth === value) {
        return;
      }
      wipeWidth = value;
      if (gameObject2._wipeEffect) {
        gameObject2._wipeEffect.wipeWidth = wipeWidth;
      }
    }
  });
  gameObject2.wipeLeft = null;
  AddClearEffectCallback_default(gameObject2, "wipeLeft");
  AddClearEffectCallback_default(gameObject2, "wipeRight");
  AddClearEffectCallback_default(gameObject2, "wipeUp");
  AddClearEffectCallback_default(gameObject2, "wipeDown");
  return gameObject2;
};
var AddWipeProperties_default = AddWipeProperties;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/EffectMap.js
var EffectMap = {
  barrel: AddBarrelProperties_default,
  blackWhite: AddBlackWhiteProperties_default,
  bloom: AddBloomProperties_default,
  blur: AddBlurProperties_default,
  bokeh: AddBokehProperties_default,
  brightness: AddBrightnessProperties_default,
  brown: AddBrownProperties_default,
  circle: AddCircleProperties_default,
  contrast: AddContrastProperties_default,
  desaturate: AddDesaturateProperties_default,
  desaturateLuminance: AddDesaturateLuminanceProperties_default,
  displacement: AddDisplacementProperties_default,
  glow: AddGlowProperties_default,
  gradient: AddGradientProperties_default,
  grayscale: AddGrayscaleProperties_default,
  hue: AddHueProperties_default,
  kodachrome: AddKodachromeProperties_default,
  lsd: AddLSDProperties_default,
  negative: AddNegativeProperties_default,
  pixelate: AddPixelateProperties_default,
  polaroid: AddPolaroidProperties_default,
  reveal: AddRevealProperties_default,
  saturate: AddSaturateProperties_default,
  sepia: AddSepiaProperties_default,
  shadow: AddShadowProperties_default,
  shiftToBGR: AddShiftToBGRProperties_default,
  shine: AddShineProperties_default,
  technicolor: AddTechnicolorProperties_default,
  tiltShift: AddTiltShiftProperties_default,
  vignette: AddVignetteProperties_default,
  vintagePinhole: AddVintagePinholeProperties_default,
  wipe: AddWipeProperties_default
};
var EffectMap_default = EffectMap;

// node_modules/phaser3-rex-plugins/plugins/behaviors/effectproperties/AddEffectProperties.js
var AddEffectProperties = function(gameObject2, config) {
  if (config === void 0) {
    config = true;
  } else if (typeof config === "string") {
    config = { config: true };
  } else if (Array.isArray(config)) {
    var nameList = config;
    var config = {};
    for (var i = 0, cnt = nameList.length; i < cnt; i++) {
      config[nameList[i]] = true;
    }
  }
  if (config === true) {
    for (var name2 in EffectMap_default) {
      EffectMap_default[name2](gameObject2);
    }
  } else {
    for (var name2 in config) {
      if (config[name2] && EffectMap_default[name2]) {
        EffectMap_default[name2](gameObject2);
      }
    }
  }
  return gameObject2;
};
var AddEffectProperties_default = AddEffectProperties;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/AddMethods.js
var RemoveItem4 = Phaser.Utils.Array.Remove;
var AddMethods_default = {
  addGO(name2, gameObject2) {
    this.remove(name2, true);
    if (this.useTintFadeEffect(gameObject2)) {
      AddTintRGBProperties_default(gameObject2);
    }
    if (this.viewportCoordinateEnable) {
      AddViewportCoordinateProperties_default(gameObject2, this.viewport);
    }
    if (this.effectPropertiesConfig) {
      AddEffectProperties_default(gameObject2, this.effectPropertiesConfig);
    }
    gameObject2.setName(name2).once("destroy", function() {
      RemoveItem4(this.removedGOs, gameObject2);
      if (this.isEmpty) {
        this.emit("empty");
      }
    }, this);
    var bob = new this.BobClass(this, gameObject2, name2);
    this.bobs[name2] = bob;
    return this;
  },
  add(name2, ...args) {
    var callback = this.createGameObjectCallback;
    var scope = this.createGameObjectScope;
    var gameObject2 = callback.call(scope, this.scene, ...args);
    this.addGO(name2, gameObject2);
    if (this.gameObjectDepth != null) {
      gameObject2.setDepth(this.gameObjectDepth);
    }
    var bob = this.get(name2);
    this.fadeBob(bob, 0, 1);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/RemoveMethods.js
var RemoveMethods_default = {
  remove(name2, ignoreFade) {
    var bobs = this.get(name2);
    if (!bobs) {
      return this;
    } else if (!Array.isArray(bobs)) {
      bobs = [bobs];
    }
    var self = this;
    bobs.forEach(function(bob) {
      delete self.bobs[bob.name];
      var gameObject2 = bob.gameObject;
      self.removedGOs.push(gameObject2);
      gameObject2.setName();
      if (!ignoreFade) {
        self.fadeBob(
          bob,
          // bob
          void 0,
          // fromValue
          0,
          // toValue
          function() {
            bob.destroy();
          }
        );
      } else {
        bob.destroy();
      }
    });
    return this;
  },
  removeAll() {
    var bobs = this.bobs;
    for (var name2 in bobs) {
      this.remove(name2);
    }
    return this;
  },
  clear(destroyChild) {
    if (destroyChild === void 0) {
      destroyChild = true;
    }
    var bobs = this.bobs;
    for (var name2 in bobs) {
      if (destroyChild) {
        bobs[name2].destroy();
      }
      delete bobs[name2];
    }
    this.removedGOs.length = 0;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/PropertyMethods.js
var PropertyMethods_default2 = {
  hasProperty(name2, property) {
    var bob = IsSingleBob_default(name2) ? this.get(name2) : this.getFitst(name2);
    if (!bob) {
      return false;
    }
    return bob.hasProperty(property);
  },
  getProperty(name2, property) {
    var bob = IsSingleBob_default(name2) ? this.get(name2) : this.getFitst(name2);
    if (!bob) {
      return void 0;
    }
    return bob.getProperty(property);
  },
  isNumberProperty(name2, property) {
    var value = this.getProperty(name2, property);
    return typeof value === "number";
  },
  setProperty(name2, property, value) {
    var bobs = this.get(name2);
    if (!bobs) {
      return this;
    } else if (!Array.isArray(bobs)) {
      bobs = [bobs];
    }
    if (this.symbols && typeof value === "string" && this.isNumberProperty(name2, property)) {
      if (value in this.symbols) {
        value = this.symbols[value];
      } else {
        console.warn(`Can't find symbol ${value}`);
      }
    }
    bobs.forEach(function(bob) {
      bob.setProperty(property, value);
    });
    return this;
  },
  easeProperty(name2, config) {
    var bobs = this.get(name2);
    if (!bobs) {
      return this;
    } else if (!Array.isArray(bobs)) {
      bobs = [bobs];
    }
    var value = config.value;
    var property = config.property;
    if (this.symbols && typeof value === "string" && this.isNumberProperty(name2, property) && value in this.symbols) {
      config.value = this.symbols[value];
    }
    bobs.forEach(function(bob) {
      bob.easeProperty(config);
    });
    return this;
  },
  hasTweenTask(name2, property) {
    var bob = IsSingleBob_default(name2) ? this.get(name2) : this.getFitst(name2);
    if (!bob) {
      return false;
    }
    return bob.tweens.hasOwnProperty(property);
  },
  getTweenTask(name2, property) {
    var bob = IsSingleBob_default(name2) ? this.get(name2) : this.getFitst(name2);
    if (!bob) {
      return null;
    }
    return bob.tweens[property] || null;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/CallMethods.js
var CallMethods_default2 = {
  hasMethod(name2, methodName) {
    var bob = IsSingleBob_default(name2) ? this.get(name2) : this.getFitst(name2);
    if (!bob) {
      return false;
    }
    return bob.hasMethod(methodName);
  },
  call(name2, methodName, ...parameters) {
    var bobs = this.get(name2);
    if (!bobs) {
      return this;
    } else if (!Array.isArray(bobs)) {
      bobs = [bobs];
    }
    bobs.forEach(function(bob) {
      bob.call(methodName, ...parameters);
    });
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/DataMethods.js
var DataMethods_default3 = {
  hasData(name2, dataKey) {
    var bob = IsSingleBob_default(name2) ? this.get(name2) : this.getFitst(name2);
    if (!bob) {
      return false;
    }
    return bob.hasData(dataKey);
  },
  getData(name2, dataKey) {
    if (!this.has(name2)) {
      return void 0;
    }
    return this.get(name2).getData(dataKey);
  },
  setData(name2, dataKey, value) {
    var bobs = this.get(name2);
    if (!bobs) {
      return this;
    } else if (!Array.isArray(bobs)) {
      bobs = [bobs];
    }
    bobs.forEach(function(bob) {
      bob.setData(dataKey, value);
    });
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/FadeMethods.js
var FadeTint = 0;
var FadeAlpha = 1;
var FadeRevealUp = 2;
var FadeRevealDown = 3;
var FadeRevealLeft = 4;
var FadeRevealRight = 5;
var FadeMode = {
  tint: FadeTint,
  alpha: FadeAlpha,
  revealUp: FadeRevealUp,
  revealDown: FadeRevealDown,
  revealLeft: FadeRevealLeft,
  revealRight: FadeRevealRight
};
var FadeMethods_default = {
  setGOFadeMode(fadeMode) {
    if (typeof fadeMode === "string") {
      fadeMode = FadeMode[fadeMode];
    }
    this.fadeMode = fadeMode;
    return this;
  },
  setGOFadeTime(time) {
    this.fadeTime = time;
    return this;
  },
  useTintFadeEffect(gameObject2) {
    return (this.fadeMode === void 0 || this.fadeMode === FadeTint) && this.fadeTime > 0 && gameObject2.setTint !== void 0;
  },
  useAlphaFadeEffect(gameObject2) {
    return (this.fadeMode === void 0 || this.fadeMode === FadeAlpha) && this.fadeTime > 0 && gameObject2.setAlpha !== void 0;
  },
  useRevealEffect(gameObject2) {
    return this.fadeMode >= FadeRevealUp && this.fadeMode <= FadeRevealRight && this.fadeTime > 0 && (gameObject2.preFX || gameObject2.postFX);
  },
  fadeBob(bob, fromValue, toValue, onComplete) {
    var gameObject2 = bob.gameObject;
    if (this.useTintFadeEffect(gameObject2)) {
      if (fromValue !== void 0) {
        bob.setProperty("tintGray", 255 * fromValue);
      }
      bob.easeProperty({
        property: "tintGray",
        value: Math.floor(255 * toValue),
        duration: this.fadeTime,
        delay: 0,
        ease: "Linear",
        repeat: 0,
        yoyo: false,
        from: false,
        complete: onComplete
      });
    } else if (this.useAlphaFadeEffect(gameObject2)) {
      if (fromValue !== void 0) {
        bob.setProperty("alpha", fromValue);
      }
      bob.easeProperty({
        property: "alpha",
        value: toValue,
        duration: this.fadeTime,
        delay: 0,
        ease: "Linear",
        repeat: 0,
        yoyo: false,
        from: false,
        complete: onComplete
      });
    } else if (this.useRevealEffect(gameObject2)) {
      AddEffectProperties_default(gameObject2, "reveal");
      var propertyName;
      switch (this.fadeMode) {
        case FadeRevealUp:
          propertyName = "revealUp";
          break;
        case FadeRevealDown:
          propertyName = "revealDown";
          break;
        case FadeRevealLeft:
          propertyName = "revealLeft";
          break;
        case FadeRevealRight:
          propertyName = "revealRight";
          break;
      }
      if (fromValue === void 0) {
        fromValue = 0;
      }
      gameObject2[propertyName] = fromValue;
      bob.easeProperty({
        property: propertyName,
        value: toValue,
        duration: this.fadeTime,
        delay: 0,
        ease: "Linear",
        repeat: 0,
        yoyo: false,
        from: false,
        complete: onComplete
      });
      bob.getTweenTask(propertyName).once("complete", function() {
        gameObject2[propertyName] = null;
      });
    } else {
      if (onComplete) {
        onComplete(gameObject2);
      }
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/size/GetDisplaySize.js
var GetDisplayWidth = function(gameObject2) {
  if (gameObject2.displayWidth !== void 0) {
    return gameObject2.displayWidth;
  } else {
    return gameObject2.width;
  }
};
var GetDisplayHeight = function(gameObject2) {
  if (gameObject2.displayHeight !== void 0) {
    return gameObject2.displayHeight;
  } else {
    return gameObject2.height;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/GetBounds.js
var Rectangle3 = Phaser.Geom.Rectangle;
var Vector2 = Phaser.Math.Vector2;
var RotateAround3 = Phaser.Math.RotateAround;
var P3Container = Phaser.GameObjects.Container;
var GetBounds = function(gameObject2, output) {
  if (output === void 0) {
    output = new Rectangle3();
  } else if (output === true) {
    if (GlobRect === void 0) {
      GlobRect = new Rectangle3();
    }
    output = GlobRect;
  }
  if (gameObject2.getBounds && !(gameObject2 instanceof P3Container)) {
    return gameObject2.getBounds(output);
  }
  var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;
  if (gameObject2.parentContainer) {
    var parentMatrix3 = gameObject2.parentContainer.getBoundsTransformMatrix();
    GetTopLeft(gameObject2, output);
    parentMatrix3.transformPoint(output.x, output.y, output);
    TLx = output.x;
    TLy = output.y;
    GetTopRight(gameObject2, output);
    parentMatrix3.transformPoint(output.x, output.y, output);
    TRx = output.x;
    TRy = output.y;
    GetBottomLeft(gameObject2, output);
    ;
    parentMatrix3.transformPoint(output.x, output.y, output);
    BLx = output.x;
    BLy = output.y;
    GetBottomRight(gameObject2, output);
    parentMatrix3.transformPoint(output.x, output.y, output);
    BRx = output.x;
    BRy = output.y;
  } else {
    GetTopLeft(gameObject2, output);
    TLx = output.x;
    TLy = output.y;
    GetTopRight(gameObject2, output);
    ;
    TRx = output.x;
    TRy = output.y;
    GetBottomLeft(gameObject2, output);
    ;
    BLx = output.x;
    BLy = output.y;
    GetBottomRight(gameObject2, output);
    BRx = output.x;
    BRy = output.y;
  }
  output.x = Math.min(TLx, TRx, BLx, BRx);
  output.y = Math.min(TLy, TRy, BLy, BRy);
  output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
  output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
  return output;
};
var GlobRect = void 0;
var GetTopLeft = function(gameObject2, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject2.getTopLeft) {
    return gameObject2.getTopLeft(output);
  }
  output.x = gameObject2.x - GetDisplayWidth(gameObject2) * gameObject2.originX;
  output.y = gameObject2.y - GetDisplayHeight(gameObject2) * gameObject2.originY;
  return PrepareBoundsOutput(gameObject2, output, includeParent);
};
var GetTopRight = function(gameObject2, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject2.getTopRight) {
    return gameObject2.getTopRight(output);
  }
  output.x = gameObject2.x - GetDisplayWidth(gameObject2) * gameObject2.originX + GetDisplayWidth(gameObject2);
  output.y = gameObject2.y - GetDisplayHeight(gameObject2) * gameObject2.originY;
  return PrepareBoundsOutput(gameObject2, output, includeParent);
};
var GetBottomLeft = function(gameObject2, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject2.getBottomLeft) {
    return gameObject2.getBottomLeft(output);
  }
  output.x = gameObject2.x - GetDisplayWidth(gameObject2) * gameObject2.originX;
  output.y = gameObject2.y - GetDisplayHeight(gameObject2) * gameObject2.originY + GetDisplayHeight(gameObject2);
  return PrepareBoundsOutput(gameObject2, output, includeParent);
};
var GetBottomRight = function(gameObject2, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  if (gameObject2.getBottomRight) {
    return gameObject2.getBottomRight(output);
  }
  output.x = gameObject2.x - GetDisplayWidth(gameObject2) * gameObject2.originX + GetDisplayWidth(gameObject2);
  output.y = gameObject2.y - GetDisplayHeight(gameObject2) * gameObject2.originY + GetDisplayHeight(gameObject2);
  return PrepareBoundsOutput(gameObject2, output, includeParent);
};
var GetCenter = function(gameObject2, output, includeParent) {
  if (output === void 0) {
    output = new Vector2();
  } else if (output === true) {
    if (GlobVector === void 0) {
      GlobVector = new Vector2();
    }
    output = GlobVector;
  }
  var displayWidth = GetDisplayWidth(gameObject2);
  var displayHeight = GetDisplayHeight(gameObject2);
  output.x = gameObject2.x + displayWidth * (0.5 - gameObject2.originX);
  output.y = gameObject2.y + displayHeight * (0.5 - gameObject2.originY);
  return PrepareBoundsOutput(gameObject2, output, includeParent);
};
var GlobVector = void 0;
var PrepareBoundsOutput = function(gameObject2, output, includeParent) {
  if (includeParent === void 0) {
    includeParent = false;
  }
  if (gameObject2.rotation !== 0) {
    RotateAround3(output, gameObject2.x, gameObject2.y, gameObject2.rotation);
  }
  if (includeParent && gameObject2.parentContainer) {
    var parentMatrix3 = gameObject2.parentContainer.getBoundsTransformMatrix();
    parentMatrix3.transformPoint(output.x, output.y, output);
  }
  return output;
};

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/DrawBounds.js
var GetValue27 = Phaser.Utils.Objects.GetValue;
var DrawBounds = function(gameObjects, graphics, config) {
  var strokeColor, lineWidth, fillColor, fillAlpha, padding;
  if (typeof config === "number") {
    strokeColor = config;
  } else {
    strokeColor = GetValue27(config, "color");
    lineWidth = GetValue27(config, "lineWidth");
    fillColor = GetValue27(config, "fillColor");
    fillAlpha = GetValue27(config, "fillAlpha", 1);
    padding = GetValue27(config, "padding", 0);
  }
  if (Array.isArray(gameObjects)) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      Draw(gameObjects[i], graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
    }
  } else {
    Draw(gameObjects, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding);
  }
};
var Draw = function(gameObject2, graphics, strokeColor, lineWidth, fillColor, fillAlpha, padding) {
  var canDrawBound = gameObject2.getBounds || gameObject2.width !== void 0 && gameObject2.height !== void 0;
  if (!canDrawBound) {
    return;
  }
  if (strokeColor === void 0) {
    strokeColor = 16777215;
  }
  if (lineWidth === void 0) {
    lineWidth = 1;
  }
  if (fillColor === void 0) {
    fillColor = null;
  }
  ;
  if (fillAlpha === void 0) {
    fillAlpha = 1;
  }
  ;
  if (padding === void 0) {
    padding = 0;
  }
  var p0 = GetTopLeft(gameObject2, Points[0]);
  p0.x -= padding;
  p0.y -= padding;
  var p1 = GetTopRight(gameObject2, Points[1]);
  p1.x += padding;
  p1.y -= padding;
  var p2 = GetBottomRight(gameObject2, Points[2]);
  p2.x += padding;
  p2.y += padding;
  var p3 = GetBottomLeft(gameObject2, Points[3]);
  p3.x -= padding;
  p3.y += padding;
  if (fillColor !== null) {
    graphics.fillStyle(fillColor, fillAlpha).fillPoints(Points, true, true);
  }
  if (strokeColor !== null) {
    graphics.lineStyle(lineWidth, strokeColor).strokePoints(Points, true, true);
  }
};
var Points = [{ x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }];
var DrawBounds_default = DrawBounds;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/DrawGameObjectsBounds.js
var DrawGameObjectsBounds = function(graphics, config) {
  this.forEachGO(function(gameObject2) {
    if (gameObject2.drawBounds) {
      gameObject2.drawBounds(graphics, config);
    } else {
      DrawBounds_default(gameObject2, graphics, config);
    }
  });
  return this;
};
var DrawGameObjectsBounds_default = DrawGameObjectsBounds;

// node_modules/phaser3-rex-plugins/plugins/utils/camera/GetCameraByName.js
var GetCameraByName = function(scene, name2) {
  var cameraManager = scene.cameras;
  var camera;
  if (name2 === void 0) {
    camera = cameraManager.main;
  } else {
    var cameraNameType = typeof name2;
    switch (cameraNameType) {
      case "string":
        camera = cameraManager.getCamera(name2);
        break;
      case "number":
        camera = cameraManager.cameras[name2];
        break;
      default:
        camera = name2;
        break;
    }
  }
  return camera;
};
var GetCameraByName_default = GetCameraByName;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/CameraMethods.js
var CameraMethods_default = {
  setCamera(goName, cameraName) {
    var bob = this.get(goName);
    if (!bob) {
      return this;
    }
    var camera = GetCameraByName_default(this.scene, cameraName);
    if (!camera) {
      return this;
    }
    bob.gameObject.cameraFilter = 4294967295 ^ camera.id;
    bob.camera = camera;
    return this;
  },
  getCamera(goName) {
    var bob = this.get(goName);
    if (!bob) {
      return null;
    }
    return bob.camera;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/methods/Methods.js
var Methods4 = {
  drawGameObjectsBounds: DrawGameObjectsBounds_default
};
Object.assign(
  Methods4,
  GetMethods_default,
  AddMethods_default,
  RemoveMethods_default,
  PropertyMethods_default2,
  CallMethods_default2,
  DataMethods_default3,
  FadeMethods_default,
  CameraMethods_default
);
var Methods_default6 = Methods4;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsCameraObject.js
var CameraClass = Phaser.Cameras.Scene2D.BaseCamera;
var IsCameraObject = function(object) {
  return object instanceof CameraClass;
};
var IsCameraObject_default = IsCameraObject;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetViewport.js
var Rectangle4 = Phaser.Geom.Rectangle;
var GetViewport = function(scene, camera, out2) {
  if (!IsCameraObject_default(camera)) {
    out2 = camera;
    camera = void 0;
  }
  if (out2 === void 0) {
    out2 = new Rectangle4();
  } else if (out2 === true) {
    out2 = globRect;
  }
  if (camera) {
    return scene.scale.getViewPort(camera, out2);
  } else {
    return scene.scale.getViewPort(out2);
  }
};
var globRect = new Rectangle4();
var GetViewport_default = GetViewport;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/gomanager/GOManager.js
var GetValue28 = Phaser.Utils.Objects.GetValue;
var GOManager = class {
  constructor(scene, config) {
    this.scene = scene;
    this.BobClass = GetValue28(config, "BobClass", BobBase_default);
    this.setCreateGameObjectCallback(
      GetValue28(config, "createGameObject"),
      GetValue28(config, "createGameObjectScope")
    );
    this.setEventEmitter(GetValue28(config, "eventEmitter", void 0));
    this.setGameObjectDepth(GetValue28(config, "depth", void 0));
    var fadeConfig = GetValue28(config, "fade", 500);
    if (typeof fadeConfig === "number") {
      this.setGOFadeMode();
      this.setGOFadeTime(fadeConfig);
    } else {
      this.setGOFadeMode(GetValue28(fadeConfig, "mode"));
      this.setGOFadeTime(GetValue28(fadeConfig, "time", 500));
    }
    var viewportCoordinateConfig = GetValue28(config, "viewportCoordinate", false);
    if (viewportCoordinateConfig !== false) {
      this.setViewportCoordinateEnable(GetValue28(config, "enable", true));
      this.setViewport(GetValue28(viewportCoordinateConfig, "viewport"));
    } else {
      this.setViewportCoordinateEnable(false);
    }
    var effectPropertiesConfig = GetValue28(config, "effectProperties", false);
    this.setEffectPropertiesConfig(effectPropertiesConfig);
    this.setSymbols(GetValue28(config, "symbols"));
    this.bobs = {};
    this.removedGOs = [];
    this._timeScale = 1;
    this.name = GetValue28(config, "name");
  }
  destroy(fromScene) {
    this.clear(!fromScene);
    this.createGameObjectCallback = void 0;
    this.viewport = void 0;
    this.scene = void 0;
  }
  set timeScale(timeScale) {
    if (this._timeScale === timeScale) {
      return;
    }
    this._timeScale = timeScale;
    var bobs = this.bobs;
    for (var name2 in bobs) {
      bobs[name2].setTimeScale(timeScale);
    }
  }
  get timeScale() {
    return this._timeScale;
  }
  setTimeScale(timeScale) {
    this.timeScale = timeScale;
    return this;
  }
  setCreateGameObjectCallback(callback, scope) {
    this.createGameObjectCallback = callback;
    this.createGameObjectScope = scope;
    return this;
  }
  setGameObjectDepth(depth) {
    this.gameObjectDepth = depth;
    return this;
  }
  setViewportCoordinateEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.viewportCoordinateEnable = enable;
    return this;
  }
  setEffectPropertiesConfig(config) {
    if (config === void 0) {
      config = true;
    }
    this.effectPropertiesConfig = config;
    return this;
  }
  setViewport(viewport) {
    if (viewport === void 0) {
      viewport = GetViewport_default(this.scene, this.scene.cameras.main);
    }
    this.viewport = viewport;
    return this;
  }
  setSymbols(symbols) {
    this.symbols = symbols;
    return this;
  }
  get isEmpty() {
    return IsEmpty_default(this.bobs) && this.removedGOs.length === 0;
  }
};
Object.assign(
  GOManager.prototype,
  EventEmitterMethods_default,
  Methods_default6
);
var GOManager_default = GOManager;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsGameObject.js
var GameObjectClass = Phaser.GameObjects.GameObject;
var LayerClass = Phaser.GameObjects.Layer;
var IsGameObject = function(object) {
  return object instanceof GameObjectClass || object instanceof LayerClass;
};
var IsGameObject_default = IsGameObject;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsLayerGameObject.js
var LayerClass2 = Phaser.GameObjects.Layer;
var IsLayerGameObject = function(gameObject2) {
  return gameObject2 instanceof LayerClass2;
};
var IsLayerGameObject_default = IsLayerGameObject;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetLayer.js
var GetLayer = function(gameObject2) {
  var layer = gameObject2.displayList;
  if (!IsLayerGameObject_default(layer)) {
    return null;
  }
  return layer;
};
var GetLayer_default = GetLayer;

// node_modules/phaser3-rex-plugins/plugins/utils/system/SortGameObjectsByDepth.js
var SortGameObjectsByDepth = function(gameObjects, descending) {
  if (gameObjects.length <= 1) {
    return gameObjects;
  }
  if (descending === void 0) {
    descending = false;
  }
  var itemList;
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var gameObject2 = gameObjects[i];
    if (gameObject2.displayList) {
      itemList = gameObject2.displayList;
    } else if (gameObject2.parentContainer) {
      itemList = gameObject2.parentContainer.list;
    }
    if (itemList) {
      break;
    }
  }
  if (!itemList) {
    itemList = gameObject2.scene.sys.displayList;
  }
  if (itemList.depthSort) {
    itemList.depthSort();
    itemList = itemList.list;
  }
  if (descending) {
    gameObjects.sort(function(childA, childB) {
      return itemList.indexOf(childB) - itemList.indexOf(childA);
    });
  } else {
    gameObjects.sort(function(childA, childB) {
      return itemList.indexOf(childA) - itemList.indexOf(childB);
    });
  }
  return gameObjects;
};
var SortGameObjectsByDepth_default = SortGameObjectsByDepth;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/layermanager/methods/LayerMethods.js
var LayerMethods_default = {
  getLayer(name2) {
    return this.getGO(name2);
  },
  getLayers(out2) {
    if (out2 === void 0) {
      out2 = [];
    }
    this.forEachGO(function(gameObject2) {
      out2.push(gameObject2);
    });
    SortGameObjectsByDepth_default(out2, false);
    return out2;
  },
  addToLayer(name2, gameObjects) {
    var layer = this.getGO(name2);
    if (!layer) {
      console.warn(`[LayerManager] Can't get layer "${name2}"`);
      return;
    }
    if (!Array.isArray(gameObjects)) {
      gameObjects = [gameObjects];
    }
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject2 = gameObjects[i];
      if (gameObject2.isRexContainerLite) {
        gameObject2.addToLayer(layer);
      } else {
        layer.add(gameObject2);
      }
    }
    if (layer.scrollFactorX !== void 0) {
      gameObject2.setScrollFactor(layer.scrollFactorX, layer.scrollFactorY);
    }
    return this;
  },
  addToBottomLayer(gameObjects) {
    var bottomLayer = this.getLayers()[0];
    this.addToLayer(bottomLayer.goName, gameObjects);
    return this;
  },
  addToTopLayer(gameObjects) {
    var layers = this.getLayers();
    var topLayer = layers[layers.length - 1];
    this.addToLayer(topLayer.goName, gameObjects);
    return this;
  },
  removeFromLayer(name2, gameObject2, addToScene) {
    var layer = this.getGO(name2);
    if (!layer) {
      console.warn(`[LayerManager] Can't get layer "${name2}"`);
      return;
    }
    if (addToScene === void 0) {
      addToScene = true;
    }
    if (gameObject2.isRexContainerLite) {
      gameObject2.removeFromLayer(layer, addToScene);
    } else {
      layer.remove(gameObject2);
      if (addToScene) {
        gameObject2.addToDisplayList();
      }
    }
    return this;
  },
  clearLayer(name2, destroyChildren) {
    if (destroyChildren === void 0) {
      destroyChildren = true;
    }
    var layer = this.getGO(name2);
    if (!layer) {
      console.warn(`Can't get layer "${name2}"`);
      return;
    }
    if (destroyChildren) {
      var children = layer.getAll();
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].destroy();
      }
    } else {
      layer.removeAll();
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/layermanager/methods/ScrollFactorMethods.js
var ScrollFactorMethods_default = {
  setScrollFactor(name2, scrollFactorX, scrollFactorY) {
    if (scrollFactorY === void 0) {
      scrollFactorY = scrollFactorX;
    }
    var layer = this.getLayer(name2);
    if (!layer) {
      return this;
    }
    layer.scrollFactorX = scrollFactorX;
    layer.scrollFactorY = scrollFactorY;
    var children = layer.getAll();
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setScrollFactor(scrollFactorX, scrollFactorY);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/displaylist/DisplayListMethods.js
var ArrayUtils = Phaser.Utils.Array;
var BringMeToTop = function() {
  var list;
  if (this.parentContainer) {
    list = this.parentContainer.list;
  } else if (this.displayList) {
    list = this.displayList.list;
  }
  if (!list) {
    return this;
  }
  ArrayUtils.BringToTop(list, this);
  return this;
};
var SendMeToBack = function() {
  var list;
  if (this.parentContainer) {
    list = this.parentContainer.list;
  } else if (this.displayList) {
    list = this.displayList.list;
  }
  if (!list) {
    return this;
  }
  ArrayUtils.SendToBack(list, this);
  return this;
};
var MoveMyDepthBelow = function(gameObject2) {
  var list;
  if (gameObject2.parentContainer) {
    list = gameObject2.parentContainer.list;
    if (list.indexOf(this) === -1) {
      gameObject2.parentContainer.add(this);
    }
  } else if (gameObject2.displayList) {
    list = gameObject2.displayList.list;
    if (list.indexOf(this) === -1) {
      gameObject2.displayList.add(this);
    }
  }
  if (!list) {
    return this;
  }
  ArrayUtils.MoveBelow(list, this, gameObject2);
  return this;
};
var MoveMyDepthAbove = function(gameObject2) {
  var list;
  if (gameObject2.parentContainer) {
    list = gameObject2.parentContainer.list;
    if (list.indexOf(this) === -1) {
      if (gameObject2.isRexContainerLite) {
        gameObject2.addToContainer(gameObject2.parentContainer);
      } else {
        gameObject2.parentContainer.add(gameObject2);
      }
    }
  } else if (gameObject2.displayList) {
    list = gameObject2.displayList.list;
    if (list.indexOf(this) === -1) {
      if (gameObject2.isRexContainerLite) {
        gameObject2.addToLayer(gameObject2.displayList);
      } else {
        gameObject2.displayList.add(gameObject2);
      }
    }
  }
  if (!list) {
    return this;
  }
  ArrayUtils.MoveAbove(list, this, gameObject2);
  return this;
};
var DisplayListMethods_default = {
  bringMeToTop: BringMeToTop,
  sendMeToBack: SendMeToBack,
  moveMyDepthBelow: MoveMyDepthBelow,
  moveMyDepthAbove: MoveMyDepthAbove
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/layermanager/methods/DepthMethods.js
var DepthMethods_default = {
  bringLayerToTop(layerName) {
    var layer = this.getLayer(layerName);
    if (!layer) {
      return this;
    }
    DisplayListMethods_default.bringMeToTop.call(layer);
    return this;
  },
  sendLayerToBack(layerName) {
    var layer = this.getLayer(layerName);
    if (!layer) {
      return this;
    }
    DisplayListMethods_default.sendMeToBack.call(layer);
    return this;
  },
  moveLayerBelow(layerName, baseLayerName) {
    if (layerName === baseLayerName) {
      return this;
    }
    var layer = this.getLayer(layerName);
    var baseLayer = this.getLayer(baseLayerName);
    if (!layer || !baseLayer) {
      return this;
    }
    DisplayListMethods_default.moveMyDepthBelow.call(layer, baseLayer);
    return this;
  },
  moveLayerAbove(layerName, baseLayerName) {
    if (layerName === baseLayerName) {
      return this;
    }
    var layer = this.getLayer(layerName);
    var baseLayer = this.getLayer(baseLayerName);
    if (!layer || !baseLayer) {
      return this;
    }
    DisplayListMethods_default.moveMyDepthAbove.call(layer, baseLayer);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/layermanager/methods/CameraMethods.js
var SetCamera = GOManager_default.prototype.setCamera;
var CameraMethods_default2 = {
  setCamera(layerName, cameraName) {
    var camera = GetCameraByName_default(this.scene, cameraName);
    if (!camera) {
      camera = this.scene.cameras.add(void 0, void 0, void 0, void 0, false, cameraName);
    }
    SetCamera.call(this, layerName, camera);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/layermanager/methods/Methods.js
var methods7 = {};
Object.assign(
  methods7,
  LayerMethods_default,
  ScrollFactorMethods_default,
  DepthMethods_default,
  CameraMethods_default2
);
var Methods_default7 = methods7;

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/layermanager/LayerManager.js
var GetValue29 = Phaser.Utils.Objects.GetValue;
var LayerManager = class extends GOManager_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    } else if (Array.isArray(config)) {
      config = {
        layers: config
      };
    }
    if (!config.hasOwnProperty("fade")) {
      config.fade = 0;
    }
    config.viewportCoordinate = false;
    super(scene, config);
    var rootLayer = GetValue29(config, "rootLayer");
    this.setRootLayer(rootLayer);
    var initLayers = GetValue29(config, "layers");
    if (initLayers) {
      for (var i = 0, cnt = initLayers.length; i < cnt; i++) {
        var layerConfig = initLayers[i];
        if (typeof layerConfig === "string") {
          this.add(layerConfig);
        } else {
          var layerName = layerConfig.name;
          this.add(layerName);
          var scrollFactor = layerConfig.scrollFactor;
          var scrollFactorX = GetValue29(layerConfig, "scrollFactorX", scrollFactor);
          var scrollFactorY = GetValue29(layerConfig, "scrollFactorY", scrollFactor);
          if (scrollFactorX !== void 0) {
            this.setScrollFactor(layerName, scrollFactorX, scrollFactorY);
          }
          this.setCamera(layerName, layerConfig.cameraName);
        }
      }
    }
  }
  setCreateGameObjectCallback(callback, scope) {
    if (!callback) {
      callback = CreateLayer;
    }
    super.setCreateGameObjectCallback(callback, scope);
    return this;
  }
  setRootLayer(rootLayer) {
    if (rootLayer === this.rootLayer) {
      return this;
    }
    var currentLayers = this.getAllGO();
    if (rootLayer) {
      rootLayer.add(currentLayers);
    } else {
      this.scene.displayList.add(currentLayers);
    }
    this.rootLayer = rootLayer;
    return this;
  }
  // Override
  addGO(name2, gameObject2) {
    super.addGO(name2, gameObject2);
    gameObject2.name = name2;
    if (this.rootLayer) {
      this.rootLayer.add(gameObject2);
    }
    return this;
  }
  // Override
  get(name2, out2) {
    if (IsGameObject_default(name2)) {
      var layer = GetLayer_default(name2);
      if (!layer) {
        return void 0;
      }
      name2 = layer.name;
      if (!name2) {
        return void 0;
      }
    }
    return super.get(name2, out2);
  }
};
var CreateLayer = function(scene, depth) {
  var layer = scene.add.layer();
  if (depth !== void 0) {
    layer.setDepth(depth);
  }
  return layer;
};
Object.assign(
  LayerManager.prototype,
  Methods_default7
);
var LayerManager_default = LayerManager;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetSoundManager.js
var GetSoundManager = function(game) {
  if (IsSceneObject_default(game)) {
    return game.sys.sound;
  }
  return game.sound;
};
var GetSoundManager_default = GetSoundManager;

// node_modules/phaser3-rex-plugins/plugins/utils/audio/soundmanager/methods/HasAudio.js
var HasaAudio = function(key2) {
  return this.sound.game.cache.audio.has(key2);
};
var HasAudio_default = HasaAudio;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetSceneObject.js
var GetSceneObject = function(object) {
  if (object == null || typeof object !== "object") {
    return null;
  } else if (IsSceneObject_default(object)) {
    return object;
  } else if (object.scene && IsSceneObject_default(object.scene)) {
    return object.scene;
  } else if (object.parent && object.parent.scene && IsSceneObject_default(object.parent.scene)) {
    return object.parent.scene;
  } else {
    return null;
  }
};
var GetSceneObject_default = GetSceneObject;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/ComponentBase.js
var GetValue30 = Phaser.Utils.Objects.GetValue;
var ComponentBase = class {
  constructor(parent, config) {
    this.setParent(parent);
    this.isShutdown = false;
    this.setEventEmitter(GetValue30(config, "eventEmitter", true));
    if (this.parent) {
      if (this.parent === this.scene) {
        this.scene.sys.events.once("shutdown", this.onEnvDestroy, this);
      } else if (this.parent === this.game) {
        this.game.events.once("shutdown", this.onEnvDestroy, this);
      } else if (this.parent.once) {
        this.parent.once("destroy", this.onParentDestroy, this);
      }
    }
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    if (this.parent) {
      if (this.parent === this.scene) {
        this.scene.sys.events.off("shutdown", this.onEnvDestroy, this);
      } else if (this.parent === this.game) {
        this.game.events.off("shutdown", this.onEnvDestroy, this);
      } else if (this.parent.once) {
        this.parent.off("destroy", this.onParentDestroy, this);
      }
    }
    this.destroyEventEmitter();
    this.parent = void 0;
    this.scene = void 0;
    this.game = void 0;
    this.isShutdown = true;
  }
  destroy(fromScene) {
    this.shutdown(fromScene);
  }
  onEnvDestroy() {
    this.destroy(true);
  }
  onParentDestroy(parent, fromScene) {
    this.destroy(fromScene);
  }
  setParent(parent) {
    this.parent = parent;
    this.scene = GetSceneObject_default(parent);
    this.game = GetGame_default(parent);
    return this;
  }
};
Object.assign(
  ComponentBase.prototype,
  EventEmitterMethods_default
);
var ComponentBase_default = ComponentBase;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/TickTask.js
var GetValue31 = Phaser.Utils.Objects.GetValue;
var TickTask = class extends ComponentBase_default {
  constructor(parent, config) {
    super(parent, config);
    this._isRunning = false;
    this.isPaused = false;
    this.tickingState = false;
    this.setTickingMode(GetValue31(config, "tickingMode", 1));
  }
  // override
  boot() {
    if (this.tickingMode === 2 && !this.tickingState) {
      this.startTicking();
    }
  }
  // override
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.stop();
    if (this.tickingState) {
      this.stopTicking();
    }
    super.shutdown(fromScene);
  }
  setTickingMode(mode) {
    if (typeof mode === "string") {
      mode = TICKINGMODE[mode];
    }
    this.tickingMode = mode;
  }
  // override
  startTicking() {
    this.tickingState = true;
  }
  // override
  stopTicking() {
    this.tickingState = false;
  }
  get isRunning() {
    return this._isRunning;
  }
  set isRunning(value) {
    if (this._isRunning === value) {
      return;
    }
    this._isRunning = value;
    if (this.tickingMode === 1 && value != this.tickingState) {
      if (value) {
        this.startTicking();
      } else {
        this.stopTicking();
      }
    }
  }
  start() {
    this.isPaused = false;
    this.isRunning = true;
    return this;
  }
  pause() {
    if (this.isRunning) {
      this.isPaused = true;
      this.isRunning = false;
    }
    return this;
  }
  resume() {
    if (this.isPaused) {
      this.isPaused = false;
      this.isRunning = true;
    }
    return this;
  }
  stop() {
    this.isPaused = false;
    this.isRunning = false;
    return this;
  }
  complete() {
    this.isPaused = false;
    this.isRunning = false;
    this.emit("complete", this.parent, this);
  }
};
var TICKINGMODE = {
  "no": 0,
  "lazy": 1,
  "always": 2
};
var TickTask_default = TickTask;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/SceneUpdateTickTask.js
var GetValue32 = Phaser.Utils.Objects.GetValue;
var SceneUpdateTickTask = class extends TickTask_default {
  constructor(parent, config) {
    super(parent, config);
    var defaultEventName = this.scene ? "update" : "step";
    this.tickEventName = GetValue32(config, "tickEventName", defaultEventName);
    this.isSceneTicker = !IsGameUpdateEvent(this.tickEventName);
  }
  startTicking() {
    super.startTicking();
    if (this.isSceneTicker) {
      this.scene.sys.events.on(this.tickEventName, this.update, this);
    } else {
      this.game.events.on(this.tickEventName, this.update, this);
    }
  }
  stopTicking() {
    super.stopTicking();
    if (this.isSceneTicker && this.scene) {
      this.scene.sys.events.off(this.tickEventName, this.update, this);
    } else if (this.game) {
      this.game.events.off(this.tickEventName, this.update, this);
    }
  }
  // update(time, delta) {
  //     
  // }
};
var IsGameUpdateEvent = function(eventName) {
  return eventName === "step" || eventName === "poststep";
};
var SceneUpdateTickTask_default = SceneUpdateTickTask;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/timerticktask/Timer.js
var GetValue33 = Phaser.Utils.Objects.GetValue;
var Clamp = Phaser.Math.Clamp;
var Timer = class {
  constructor(config) {
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.state = GetValue33(o, "state", IDLE);
    this.timeScale = GetValue33(o, "timeScale", 1);
    this.delay = GetValue33(o, "delay", 0);
    this.repeat = GetValue33(o, "repeat", 0);
    this.repeatCounter = GetValue33(o, "repeatCounter", 0);
    this.repeatDelay = GetValue33(o, "repeatDelay", 0);
    this.duration = GetValue33(o, "duration", 0);
    this.nowTime = GetValue33(o, "nowTime", 0);
    this.justRestart = GetValue33(o, "justRestart", false);
  }
  toJSON() {
    return {
      state: this.state,
      timeScale: this.timeScale,
      delay: this.delay,
      repeat: this.repeat,
      repeatCounter: this.repeatCounter,
      repeatDelay: this.repeatDelay,
      duration: this.duration,
      nowTime: this.nowTime,
      justRestart: this.justRestart
    };
  }
  destroy() {
  }
  setTimeScale(timeScale) {
    this.timeScale = timeScale;
    return this;
  }
  setDelay(delay) {
    if (delay === void 0) {
      delay = 0;
    }
    this.delay = delay;
    return this;
  }
  setDuration(duration) {
    this.duration = duration;
    return this;
  }
  setRepeat(repeat) {
    this.repeat = repeat;
    return this;
  }
  setRepeatInfinity() {
    this.repeat = -1;
    return this;
  }
  setRepeatDelay(repeatDelay) {
    this.repeatDelay = repeatDelay;
    return this;
  }
  start() {
    this.nowTime = this.delay > 0 ? -this.delay : 0;
    this.state = this.nowTime >= 0 ? COUNTDOWN : DELAY;
    this.repeatCounter = 0;
    return this;
  }
  stop() {
    this.state = IDLE;
    return this;
  }
  update(time, delta) {
    if (this.state === IDLE || this.state === DONE || delta === 0 || this.timeScale === 0) {
      return;
    }
    this.nowTime += delta * this.timeScale;
    this.justRestart = false;
    if (this.nowTime >= this.duration) {
      if (this.repeat === -1 || this.repeatCounter < this.repeat) {
        this.repeatCounter++;
        this.justRestart = true;
        this.nowTime -= this.duration;
        if (this.repeatDelay > 0) {
          this.nowTime -= this.repeatDelay;
          this.state = REPEATDELAY;
        }
      } else {
        this.nowTime = this.duration;
        this.state = DONE;
      }
    } else if (this.nowTime >= 0) {
      this.state = COUNTDOWN;
    }
  }
  get t() {
    var t;
    switch (this.state) {
      case IDLE:
      case DELAY:
      case REPEATDELAY:
        t = 0;
        break;
      case COUNTDOWN:
        t = this.nowTime / this.duration;
        break;
      case DONE:
        t = 1;
        break;
    }
    return Clamp(t, 0, 1);
  }
  set t(value) {
    value = Clamp(value, -1, 1);
    if (value < 0) {
      this.state = DELAY;
      this.nowTime = -this.delay * value;
    } else {
      this.state = COUNTDOWN;
      this.nowTime = this.duration * value;
      if (value === 1 && this.repeat !== 0) {
        this.repeatCounter++;
      }
    }
  }
  setT(t) {
    this.t = t;
    return this;
  }
  get isIdle() {
    return this.state === IDLE;
  }
  get isDelay() {
    return this.state === DELAY;
  }
  get isCountDown() {
    return this.state === COUNTDOWN;
  }
  get isRunning() {
    return this.state === DELAY || this.state === COUNTDOWN;
  }
  get isDone() {
    return this.state === DONE;
  }
  get isOddIteration() {
    return (this.repeatCounter & 1) === 1;
  }
  get isEvenIteration() {
    return (this.repeatCounter & 1) === 0;
  }
};
var IDLE = 0;
var DELAY = 1;
var COUNTDOWN = 2;
var REPEATDELAY = 3;
var DONE = -1;
var Timer_default = Timer;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/timerticktask/TimerTask.js
var TimerTickTask = class extends SceneUpdateTickTask_default {
  constructor(parent, config) {
    super(parent, config);
    this.timer = new Timer_default();
  }
  // override
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    super.shutdown(fromScene);
    this.timer.destroy();
    this.timer = void 0;
  }
  start() {
    this.timer.start();
    super.start();
    return this;
  }
  stop() {
    this.timer.stop();
    super.stop();
    return this;
  }
  complete() {
    this.timer.stop();
    super.complete();
    return this;
  }
};
var TimerTask_default = TimerTickTask;

// node_modules/phaser3-rex-plugins/plugins/utils/componentbase/tweentask/EaseValueTaskBase.js
var GetValue34 = Phaser.Utils.Objects.GetValue;
var GetAdvancedValue2 = Phaser.Utils.Objects.GetAdvancedValue;
var GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;
var EaseValueTaskBase = class extends TimerTask_default {
  resetFromJSON(o) {
    this.timer.resetFromJSON(GetValue34(o, "timer"));
    this.setEnable(GetValue34(o, "enable", true));
    this.setTarget(GetValue34(o, "target", this.parent));
    this.setDelay(GetAdvancedValue2(o, "delay", 0));
    this.setDuration(GetAdvancedValue2(o, "duration", 1e3));
    this.setEase(GetValue34(o, "ease", "Linear"));
    this.setRepeat(GetValue34(o, "repeat", 0));
    return this;
  }
  setEnable(e) {
    if (e == void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  setTarget(target) {
    if (target === void 0) {
      target = this.parent;
    }
    this.target = target;
    return this;
  }
  setDelay(time) {
    this.delay = time;
    return this;
  }
  setDuration(time) {
    this.duration = time;
    return this;
  }
  setRepeat(repeat) {
    this.repeat = repeat;
    return this;
  }
  setRepeatDelay(repeatDelay) {
    this.repeatDelay = repeatDelay;
    return this;
  }
  setEase(ease) {
    if (ease === void 0) {
      ease = "Linear";
    }
    this.ease = ease;
    this.easeFn = GetEaseFunction(ease);
    return this;
  }
  // Override
  start() {
    if (this.timer.isRunning) {
      return this;
    }
    super.start();
    return this;
  }
  restart() {
    this.timer.stop();
    this.start.apply(this, arguments);
    return this;
  }
  stop(toEnd) {
    if (toEnd === void 0) {
      toEnd = false;
    }
    super.stop();
    if (toEnd) {
      this.timer.setT(1);
      this.updateTarget(this.target, this.timer);
      this.complete();
    }
    return this;
  }
  update(time, delta) {
    if (!this.isRunning || !this.enable || this.parent.hasOwnProperty("active") && !this.parent.active) {
      return this;
    }
    var target = this.target, timer = this.timer;
    timer.update(time, delta);
    if (!timer.isDelay) {
      this.updateTarget(target, timer);
    }
    this.emit("update", target, this);
    if (timer.isDone) {
      this.complete();
    }
    return this;
  }
  // Override
  updateTarget(target, timer) {
  }
};
var EaseValueTaskBase_default = EaseValueTaskBase;

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsSoundObject.js
var SoundObjectClass = Phaser.Sound.BaseSound;
var IsSoundObject = function(object) {
  return object instanceof SoundObjectClass;
};
var IsSoundObject_default = IsSoundObject;

// node_modules/phaser3-rex-plugins/plugins/audio/fade/Fade.js
var GetValue35 = Phaser.Utils.Objects.GetValue;
var GetAdvancedValue3 = Phaser.Utils.Objects.GetAdvancedValue;
var Linear2 = Phaser.Math.Linear;
var Fade = class extends EaseValueTaskBase_default {
  constructor(scene, sound, config) {
    if (IsSoundObject_default(scene)) {
      config = sound;
      sound = scene;
      scene = void 0;
    }
    sound.active = true;
    sound.scene = scene;
    sound.game = sound.manager.game;
    super(sound, config);
    this.volume = {};
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setMode(GetValue35(o, "mode", 0));
    this.setEnable(GetValue35(o, "enable", true));
    this.setVolumeRange(
      GetAdvancedValue3(o, "volume.start", this.parent.volume),
      GetAdvancedValue3(o, "volume.end", 0)
    );
    return this;
  }
  setMode(m) {
    if (typeof m === "string") {
      m = MODE[m];
    }
    this.mode = m;
    return this;
  }
  setVolumeRange(start, end) {
    this.volume.start = start;
    this.volume.end = end;
    return this;
  }
  start() {
    if (this.timer.isRunning) {
      return this;
    }
    this.parent.setVolume(this.volume.start);
    this.timer.setDelay(this.delay).setDuration(this.duration);
    super.start();
    return this;
  }
  updateTarget(parent, timer) {
    parent.volume = Linear2(this.volume.start, this.volume.end, timer.t);
  }
  complete() {
    super.complete();
    switch (this.mode) {
      case 1:
        this.parent.stop();
        break;
      case 2:
        this.parent.stop();
        this.parent.destroy();
        break;
    }
    return this;
  }
};
var MODE = {
  stop: 1,
  destroy: 2
};
var Fade_default = Fade;

// node_modules/phaser3-rex-plugins/plugins/audio/fade/FadeIn.js
var FadeIn = function(scene, sound, duration, endVolume, startVolume) {
  if (IsSoundObject_default(scene)) {
    startVolume = endVolume;
    endVolume = duration;
    duration = sound;
    sound = scene;
    scene = void 0;
  }
  if (endVolume === void 0) {
    endVolume = 1;
  }
  if (startVolume === void 0) {
    startVolume = 0;
  }
  var config = {
    mode: 0,
    volume: {
      start: startVolume,
      end: endVolume
    },
    duration
  };
  if (typeof sound === "string") {
    sound = scene.sys.sound.add(sound);
  }
  var fade;
  if (sound.hasOwnProperty("_fade")) {
    fade = sound._fade;
    fade.stop().resetFromJSON(config);
  } else {
    fade = new Fade_default(scene, sound, config);
    sound._fade = fade;
  }
  fade.start();
  if (!sound.isPlaying) {
    sound.setVolume(startVolume).play();
  }
  return sound;
};
var FadeIn_default = FadeIn;

// node_modules/phaser3-rex-plugins/plugins/audio/fade/FadeOut.js
var FadeOut = function(scene, sound, duration, destroy) {
  if (IsSoundObject_default(scene)) {
    destroy = duration;
    duration = sound;
    sound = scene;
    scene = void 0;
  }
  if (destroy === void 0) {
    destroy = true;
  }
  var config = {
    mode: destroy ? 2 : 1,
    // 1: stop, 2: destroy
    volume: {
      start: sound.volume,
      end: 0
    },
    duration
  };
  var fade;
  if (sound.hasOwnProperty("_fade")) {
    fade = sound._fade;
    fade.stop().resetFromJSON(config);
  } else {
    fade = new Fade_default(scene, sound, config);
    sound._fade = fade;
  }
  fade.start();
  if (!sound.isPlaying) {
    sound.play();
  }
  return sound;
};
var FadeOut_default = FadeOut;

// node_modules/phaser3-rex-plugins/plugins/utils/audio/soundmanager/methods/BackgroundMusicMethods.js
var GetValue36 = Phaser.Utils.Objects.GetValue;
var BackgroundMusicMethods_default = {
  setBackgroundMusicLoop(value) {
    if (value === void 0) {
      value = true;
    }
    this.backgroundMusicLoop = value;
    return this;
  },
  setBackgroundMusicFadeTime(time) {
    this.backgroundMusicFadeTime = time;
    return this;
  },
  getBackgroundMusic() {
    return this.backgroundMusic;
  },
  // Internal method
  setCurrentBackgroundMusic(music) {
    this.backgroundMusic = music;
    if (music) {
      music.once("complete", function() {
        if (this.backgroundMusic === music) {
          this.backgroundMusic.destroy();
          this.backgroundMusic = void 0;
        }
      }, this).once("destroy", function() {
        if (this.backgroundMusic === music) {
          this.backgroundMusic = void 0;
        }
      }, this);
      if (!music.isPlaying) {
        music.play();
      }
    }
    return this;
  },
  playBackgroundMusic(key2, config) {
    if (!this.hasAudio(key2)) {
      console.error(`[Sound manager] Audio key'${key2}' is not existed`);
      return this;
    }
    if (this.backgroundMusic && this.backgroundMusic.key === key2) {
      return this;
    }
    this.stopBackgroundMusic();
    var music = this.sound.add(key2, {
      loop: GetValue36(config, "loop", this.backgroundMusicLoop),
      mute: GetValue36(config, "mute", this.backgroundMusicMute),
      volume: GetValue36(config, "volume", this.backgroundMusicVolume),
      detune: GetValue36(config, "detune", 0),
      rate: GetValue36(config, "rate", 1)
    });
    this.setCurrentBackgroundMusic(music);
    if (this.backgroundMusicFadeTime > 0) {
      this.fadeInBackgroundMusic(this.backgroundMusicFadeTime);
    }
    return this;
  },
  pauseBackgroundMusic() {
    if (this.backgroundMusic) {
      this.backgroundMusic.pause();
    }
    return this;
  },
  resumeBackgroundMusic() {
    if (this.backgroundMusic) {
      this.backgroundMusic.resume();
    }
    return this;
  },
  stopBackgroundMusic() {
    if (this.backgroundMusic) {
      if (this.backgroundMusicFadeTime > 0) {
        this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, true);
      } else {
        this.backgroundMusic.stop();
        this.backgroundMusic.destroy();
        this.backgroundMusic = void 0;
      }
    }
    return this;
  },
  fadeInBackgroundMusic(time) {
    if (this.backgroundMusic) {
      FadeIn_default(this.backgroundMusic, time, this.backgroundMusicVolume, 0);
    }
    return this;
  },
  fadeOutBackgroundMusic(time, isStopped) {
    if (this.backgroundMusic) {
      FadeOut_default(this.backgroundMusic, time, isStopped);
    }
    return this;
  },
  crossFadeBackgroundMusic(key2, time) {
    if (!this.hasAudio(key2)) {
      console.error(`[Sound manager] Audio key'${key2}' is not existed`);
      return this;
    }
    var backgroundMusicFadeTimeSave = this.backgroundMusicFadeTime;
    this.backgroundMusicFadeTime = 0;
    this.fadeOutBackgroundMusic(time, true).playBackgroundMusic(key2).fadeInBackgroundMusic(time);
    this.backgroundMusicFadeTime = backgroundMusicFadeTimeSave;
    return this;
  },
  setBackgroundMusicMute(mute2) {
    if (mute2 === void 0) {
      mute2 = true;
    }
    this.backgroundMusicMute = mute2;
    return this;
  },
  setBackgroundMusicVolume(volume) {
    this.backgroundMusicVolume = volume;
    return this;
  },
  setBackgroundMusicRate(rate) {
    if (this.backgroundMusic) {
      this.backgroundMusic.setRate(rate);
    }
    return this;
  },
  setBackgroundMusicDetune(detune) {
    if (this.backgroundMusic) {
      this.backgroundMusic.setDetune(detune);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/audio/soundmanager/methods/BackgroundMusic2Methods.js
var GetValue37 = Phaser.Utils.Objects.GetValue;
var BackgroundMusic2Methods_default = {
  setBackgroundMusic2Loop(value) {
    if (value === void 0) {
      value = true;
    }
    this.backgroundMusic2Loop = value;
    return this;
  },
  setBackgroundMusic2FadeTime(time) {
    this.backgroundMusic2FadeTime = time;
    return this;
  },
  getBackgroundMusic2() {
    return this.backgroundMusic2;
  },
  // Internal method
  setCurrentBackgroundMusic2(music) {
    this.backgroundMusic2 = music;
    if (music) {
      music.once("complete", function() {
        if (this.backgroundMusic2 === music) {
          this.backgroundMusic2.destroy();
          this.backgroundMusic2 = void 0;
        }
      }, this).once("destroy", function() {
        if (this.backgroundMusic2 === music) {
          this.backgroundMusic2 = void 0;
        }
      }, this);
      if (!music.isPlaying) {
        music.play();
      }
    }
    return this;
  },
  playBackgroundMusic2(key2, config) {
    if (!this.hasAudio(key2)) {
      console.error(`[Sound manager] Audio key'${key2}' is not existed`);
      return this;
    }
    if (this.backgroundMusic2 && this.backgroundMusic2.key === key2) {
      return this;
    }
    this.stopBackgroundMusic2();
    var music = this.sound.add(key2, {
      loop: GetValue37(config, "loop", this.backgroundMusicLoop),
      mute: GetValue37(config, "mute", this.backgroundMusic2Mute),
      volume: GetValue37(config, "volume", this.backgroundMusic2Volume),
      detune: GetValue37(config, "detune", 0),
      rate: GetValue37(config, "rate", 1)
    });
    this.setCurrentBackgroundMusic2(music);
    if (this.backgroundMusic2FadeTime > 0) {
      this.fadeInBackgroundMusic2(this.backgroundMusic2FadeTime);
    }
    return this;
  },
  pauseBackgroundMusic2() {
    if (this.backgroundMusic2) {
      this.backgroundMusic2.pause();
    }
    return this;
  },
  resumeBackgroundMusic2() {
    if (this.backgroundMusic2) {
      this.backgroundMusic2.resume();
    }
    return this;
  },
  stopBackgroundMusic2() {
    if (this.backgroundMusic2) {
      if (this.backgroundMusic2FadeTime > 0) {
        this.fadeOutBackgroundMusic2(this.backgroundMusic2FadeTime, true);
      } else {
        this.backgroundMusic2.stop();
        this.backgroundMusic2.destroy();
        this.backgroundMusic2 = void 0;
      }
    }
    return this;
  },
  fadeInBackgroundMusic2(time) {
    if (this.backgroundMusic2) {
      FadeIn_default(this.backgroundMusic2, time, this.backgroundMusic2Volume, 0);
    }
    return this;
  },
  fadeOutBackgroundMusic2(time, isStopped) {
    if (this.backgroundMusic2) {
      FadeOut_default(this.backgroundMusic2, time, isStopped);
    }
    return this;
  },
  crossFadeBackgroundMusic2(key2, time) {
    if (!this.hasAudio(key2)) {
      console.error(`[Sound manager] Audio key'${key2}' is not existed`);
      return this;
    }
    var backgroundMusic2FadeTimeSave = this.backgroundMusic2FadeTime;
    this.backgroundMusic2FadeTime = 0;
    this.fadeOutBackgroundMusic2(time, true).playBackgroundMusic2(key2).fadeInBackgroundMusic2(time);
    this.backgroundMusic2FadeTime = backgroundMusic2FadeTimeSave;
    return this;
  },
  setBackgroundMusic2Mute(mute2) {
    if (mute2 === void 0) {
      mute2 = true;
    }
    this.backgroundMusic2Mute = mute2;
    return this;
  },
  setBackgroundMusic2Volume(volume) {
    this.backgroundMusic2Volume = volume;
    return this;
  },
  setBackgroundMusic2Rate(rate) {
    if (this.backgroundMusic2) {
      this.backgroundMusic2.setRate(rate);
    }
    return this;
  },
  setBackgroundMusic2Detune(detune) {
    if (this.backgroundMusic2) {
      this.backgroundMusic2.setDetune(detune);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/audio/soundmanager/methods/SoundEffectsMethods.js
var RemoveItem5 = Phaser.Utils.Array.Remove;
var GetValue38 = Phaser.Utils.Objects.GetValue;
var SoundEffectsMethods_default = {
  getSoundEffects() {
    return this.soundEffects;
  },
  getLastSoundEffect() {
    return this.soundEffects[this.soundEffects.length - 1];
  },
  playSoundEffect(key2, config) {
    if (!this.hasAudio(key2)) {
      console.error(`[Sound manager] Audio key'${key2}' is not existed`);
      return this;
    }
    var music = this.sound.add(key2, {
      mute: GetValue38(config, "mute", this.soundEffectsMute),
      volume: GetValue38(config, "volume", this.soundEffectsVolume),
      detune: GetValue38(config, "detune", 0),
      rate: GetValue38(config, "rate", 1)
    });
    this.soundEffects.push(music);
    music.once("complete", function() {
      music.destroy();
      if (!this.sound) {
        return;
      }
      RemoveItem5(this.soundEffects, music);
    }, this).once("destroy", function() {
      if (!this.sound) {
        return;
      }
      RemoveItem5(this.soundEffects, music);
    }, this).play();
    return this;
  },
  stopAllSoundEffects() {
    for (var i = this.soundEffects.length - 1; i >= 0; i--) {
      var soundEffect = this.soundEffects[i];
      soundEffect.stop();
      soundEffect.destroy();
    }
    return this;
  },
  fadeInSoundEffect(time) {
    var soundEffect = this.getLastSoundEffect();
    if (soundEffect) {
      FadeIn_default(soundEffect, time, this.soundEffectsVolume, 0);
    }
    return this;
  },
  fadeOutSoundEffect(time, isStopped) {
    var soundEffect = this.getLastSoundEffect();
    if (soundEffect) {
      FadeOut_default(soundEffect, time, isStopped);
    }
    return this;
  },
  fadeOutAllSoundEffects(time, isStopped) {
    for (var i = this.soundEffects.length - 1; i >= 0; i--) {
      FadeOut_default(this.soundEffects[i], time, isStopped);
    }
    return this;
  },
  setSoundEffectMute(mute2, lastSoundEffect) {
    if (mute2 === void 0) {
      mute2 = true;
    }
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    if (lastSoundEffect) {
      var soundEffect = this.getLastSoundEffect();
      if (soundEffect) {
        soundEffect.setMute(mute2);
      }
    } else {
      this.soundEffectsMute = mute2;
    }
    return this;
  },
  setSoundEffectVolume(volume, lastSoundEffect) {
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    if (lastSoundEffect) {
      var soundEffect = this.getLastSoundEffect();
      if (soundEffect) {
        soundEffect.setVolume(volume);
      }
    } else {
      this.soundEffectsVolume = volume;
    }
    return this;
  },
  setSoundEffectDetune(detune, lastSoundEffect) {
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    var soundEffects;
    if (lastSoundEffect) {
      soundEffects = [this.getLastSoundEffect()];
    } else {
      soundEffects = this.soundEffects;
    }
    for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
      soundEffects[i].setDetune(detune);
    }
    return this;
  },
  setSoundEffectRate(rate, lastSoundEffect) {
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    var soundEffects;
    if (lastSoundEffect) {
      soundEffects = [this.getLastSoundEffect()];
    } else {
      soundEffects = this.soundEffects;
    }
    for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
      soundEffects[i].setRate(rate);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/audio/soundmanager/methods/SoundEffects2Methods.js
var RemoveItem6 = Phaser.Utils.Array.Remove;
var GetValue39 = Phaser.Utils.Objects.GetValue;
var SoundEffects2Methods_default = {
  getSoundEffects2() {
    return this.soundEffects2;
  },
  getLastSoundEffect2() {
    return this.soundEffects2[this.soundEffects2.length - 1];
  },
  playSoundEffect2(key2, config) {
    if (!this.hasAudio(key2)) {
      console.error(`[Sound manager] Audio key'${key2}' is not existed`);
      return this;
    }
    var music = this.sound.add(key2, {
      mute: GetValue39(config, "mute", this.soundEffects2Mute),
      volume: GetValue39(config, "volume", this.soundEffects2Volume),
      detune: GetValue39(config, "detune", 0),
      rate: GetValue39(config, "rate", 1)
    });
    this.soundEffects2.push(music);
    music.once("complete", function() {
      music.destroy();
      if (!this.sound) {
        return;
      }
      RemoveItem6(this.soundEffects2, music);
    }, this).once("destroy", function() {
      if (!this.sound) {
        return;
      }
      RemoveItem6(this.soundEffects2, music);
    }, this).play();
    return this;
  },
  stopAllSoundEffects2() {
    for (var i = this.soundEffects.length - 1; i >= 0; i--) {
      var soundEffect = this.soundEffects[i];
      soundEffect.stop();
      soundEffect.destroy();
    }
    return this;
  },
  fadeInSoundEffect2(time) {
    var soundEffect = this.getLastSoundEffect2();
    if (soundEffect) {
      FadeIn_default(soundEffect, time, this.soundEffects2Volume, 0);
    }
    return this;
  },
  fadeOutSoundEffect2(time, isStopped) {
    var soundEffect = this.getLastSoundEffect2();
    if (soundEffect) {
      FadeOut_default(soundEffect, time, isStopped);
    }
    return this;
  },
  fadeOutAllSoundEffects2(time, isStopped) {
    for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
      FadeOut_default(this.soundEffects2[i], time, isStopped);
    }
    return this;
  },
  setSoundEffect2Mute(mute2, lastSoundEffect) {
    if (mute2 === void 0) {
      mute2 = true;
    }
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    if (lastSoundEffect) {
      var soundEffect = this.getLastSoundEffect2();
      if (soundEffect) {
        soundEffect.setMute(mute2);
      }
    } else {
      this.soundEffects2Mute = mute2;
    }
    return this;
  },
  setSoundEffect2Volume(volume, lastSoundEffect) {
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    if (lastSoundEffect) {
      var soundEffect = this.getLastSoundEffect2();
      if (soundEffect) {
        soundEffect.setVolume(volume);
      }
    } else {
      this.soundEffects2Volume = volume;
    }
    return this;
  },
  setSoundEffect2Detune(detune, lastSoundEffect) {
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    var soundEffects;
    if (lastSoundEffect) {
      soundEffects = [this.getLastSoundEffect2()];
    } else {
      soundEffects = this.soundEffects2;
    }
    for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
      soundEffects[i].setDetune(detune);
    }
    return this;
  },
  setSoundEffect2Rate(rate, lastSoundEffect) {
    if (lastSoundEffect === void 0) {
      lastSoundEffect = false;
    }
    var soundEffects;
    if (lastSoundEffect) {
      soundEffects = [this.getLastSoundEffect2()];
    } else {
      soundEffects = this.soundEffects2;
    }
    for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
      soundEffects[i].setRate(rate);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/audio/soundmanager/methods/Methods.js
var Methods5 = {
  hasAudio: HasAudio_default
};
Object.assign(
  Methods5,
  BackgroundMusicMethods_default,
  BackgroundMusic2Methods_default,
  SoundEffectsMethods_default,
  SoundEffects2Methods_default
);
var Methods_default8 = Methods5;

// node_modules/phaser3-rex-plugins/plugins/utils/audio/soundmanager/SoundManager.js
var GetValue40 = Phaser.Utils.Objects.GetValue;
var SoundManager = class {
  constructor(game, config) {
    this.sound = GetSoundManager_default(game);
    this.backgroundMusic = void 0;
    this._backgroundMusicVolume = GetValue40(config, "bgm.volume", 1);
    this._backgroundMusicMute = GetValue40(config, "bgm.mute", false);
    this.setBackgroundMusicLoop(GetValue40(config, "bgm.loop", true));
    this.setBackgroundMusicFadeTime(GetValue40(config, "bgm.fade", 500));
    this.backgroundMusic2 = void 0;
    this._backgroundMusic2Volume = GetValue40(config, "bgm2.volume", 1);
    this._backgroundMusic2Mute = GetValue40(config, "bgm2.mute", false);
    this.setBackgroundMusic2Loop(GetValue40(config, "bgm2.loop", true));
    this.setBackgroundMusic2FadeTime(GetValue40(config, "bgm2.fade", 500));
    this.soundEffects = [];
    this._soundEffectsVolume = GetValue40(config, "soundEffect.volume", 1);
    this.soundEffects2 = [];
    this._soundEffects2Volume = GetValue40(config, "soundEffect2.volume", 1);
    var initialBackgroundMusic = GetValue40(config, "bgm.initial", void 0);
    if (initialBackgroundMusic) {
      this.setCurrentBackgroundMusic(initialBackgroundMusic);
    }
    var initialBackgroundMusic2 = GetValue40(config, "bgm2.initial", void 0);
    if (initialBackgroundMusic2) {
      this.setCurrentBackgroundMusic2(initialBackgroundMusic2);
    }
  }
  destroy() {
    if (this.backgroundMusic) {
      this.backgroundMusic.destroy();
    }
    this.backgroundMusic = void 0;
    if (this.backgroundMusic2) {
      this.backgroundMusic2.destroy();
    }
    this.backgroundMusic2 = void 0;
    if (this.soundEffects.length) {
      for (var i = this.soundEffects.length - 1; i >= 0; i--) {
        this.soundEffects[i].destroy();
      }
    }
    this.soundEffects.length = 0;
    if (this.soundEffects2.length) {
      for (var i = this.soundEffects2.length - 1; i >= 0; i--) {
        this.soundEffects2[i].destroy();
      }
    }
    this.soundEffects2.length = 0;
    this.sound = void 0;
    return this;
  }
  // backgroundMusic
  // mute
  get backgroundMusicMute() {
    return this._backgroundMusicMute;
  }
  set backgroundMusicMute(value) {
    this._backgroundMusicMute = value;
    if (this.backgroundMusic) {
      this.backgroundMusic.setMute(mute);
    }
  }
  // volume
  get backgroundMusicVolume() {
    return this._backgroundMusicVolume;
  }
  set backgroundMusicVolume(value) {
    this._backgroundMusicVolume = value;
    if (this.backgroundMusic) {
      this.backgroundMusic.setVolume(value);
    }
  }
  // backgroundMusic2
  // mute
  get backgroundMusic2Mute() {
    return this._backgroundMusic2Mute;
  }
  set backgroundMusic2Mute(value) {
    this._backgroundMusic2Mute = value;
    if (this.backgroundMusic2) {
      this.backgroundMusic2.setMute(mute);
    }
  }
  // volume
  get backgroundMusic2Volume() {
    return this._backgroundMusic2Volume;
  }
  set backgroundMusic2Volume(value) {
    this._backgroundMusic2Volume = value;
    if (this.backgroundMusic2) {
      this.backgroundMusic2.setVolume(value);
    }
  }
  // soundEffects
  // mute
  get soundEffectsMute() {
    return this._soundEffectsMute;
  }
  set soundEffectsMute(value) {
    this._soundEffectsMute = value;
    var soundEffects = this.soundEffects;
    for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
      soundEffects[i].setMute(value);
    }
  }
  // volume
  get soundEffectsVolume() {
    return this._soundEffectsVolume;
  }
  set soundEffectsVolume(value) {
    this._soundEffectsVolume = value;
    var soundEffects = this.soundEffects;
    for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
      soundEffects[i].setVolume(value);
    }
  }
  // soundEffects2
  // mute
  get soundEffects2Mute() {
    return this._soundEffects2Mute;
  }
  set soundEffects2Mute(value) {
    this._soundEffects2Mute = value;
    var soundEffects = this.soundEffects;
    for (var i = 0, cnt = soundEffects2.length; i < cnt; i++) {
      soundEffects[i].setMute(value);
    }
  }
  // volume
  get soundEffects2Volume() {
    return this._soundEffects2Volume;
  }
  set soundEffects2Volume(value) {
    this._soundEffects2Volume = value;
    var soundEffects = this.soundEffects2;
    for (var i = 0, cnt = soundEffects.length; i < cnt; i++) {
      soundEffects[i].setVolume(value);
    }
  }
};
Object.assign(
  SoundManager.prototype,
  Methods_default8
);
var SoundManager_default = SoundManager;

// node_modules/phaser3-rex-plugins/plugins/time/clock/BaseClock.js
var GetValue41 = Phaser.Utils.Objects.GetValue;
var BaseClock = class extends TickTask_default {
  constructor(parent, config) {
    super(parent, config);
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.isRunning = GetValue41(o, "isRunning", false);
    this.timeScale = GetValue41(o, "timeScale", 1);
    this.now = GetValue41(o, "now", 0);
    return this;
  }
  toJSON() {
    return {
      isRunning: this.isRunning,
      timeScale: this.timeScale,
      now: this.now,
      tickingMode: this.tickingMode
    };
  }
  // Override
  // startTicking() { }
  // Override
  // stopTicking() {}
  start(startAt) {
    if (startAt === void 0) {
      startAt = 0;
    }
    this.delta = 0;
    this.now = startAt;
    super.start();
    return this;
  }
  seek(time) {
    this.now = time;
    return this;
  }
  setTimeScale(value) {
    this.timeScale = value;
    return this;
  }
  tick(delta) {
    delta *= this.timeScale;
    this.now += delta;
    this.delta = delta;
    this.emit("update", this.now, this.delta);
    return this;
  }
};
var BaseClock_default = BaseClock;

// node_modules/phaser3-rex-plugins/plugins/time/clock/Clock.js
var Clock = class extends BaseClock_default {
  startTicking() {
    super.startTicking();
    this.scene.sys.events.on("update", this.update, this);
  }
  stopTicking() {
    super.stopTicking();
    if (this.scene) {
      this.scene.sys.events.off("update", this.update, this);
    }
  }
  update(time, delta) {
    if (!this.isRunning || this.timeScale === 0) {
      return this;
    }
    this.tick(delta);
    return this;
  }
};
var Clock_default = Clock;

// node_modules/phaser3-rex-plugins/plugins/utils/math/Yoyo.js
var Yoyo = function(t, threshold) {
  if (threshold === void 0) {
    threshold = 0.5;
  }
  if (t <= threshold) {
    t = t / threshold;
  } else {
    t = 1 - (t - threshold) / (1 - threshold);
  }
  return t;
};
var Yoyo_default = Yoyo;

// node_modules/phaser3-rex-plugins/plugins/time/progresses/Timer.js
var Clamp2 = Phaser.Math.Clamp;
var Timer2 = class {
  constructor(timeline, config) {
    this.setTimeline(timeline).reset(config);
  }
  setTimeline(timeline) {
    this.timeline = timeline;
    return this;
  }
  setName(name2) {
    this.name = name2;
    return this;
  }
  setCallbacks(target, onStart, onProgress, onComplete) {
    this.target = target;
    this.onStart = onStart;
    this.onProgress = onProgress;
    this.onComplete = onComplete;
    return this;
  }
  setDuration(duration, yoyo) {
    if (yoyo === void 0) {
      yoyo = false;
    }
    this.duration = duration;
    this.remainder = duration;
    this.t = 0;
    this.yoyo = yoyo;
    return this;
  }
  setPaused(state) {
    this.isPaused = state;
    return this;
  }
  pause() {
    this.isPaused = true;
    return this;
  }
  resume() {
    this.isPaused = false;
    return this;
  }
  setRemoved(state) {
    this.removed = state;
    return this;
  }
  remove() {
    this.removed = true;
    return this;
  }
  seek(t) {
    this.remainder = this.duration * (1 - t);
    return this;
  }
  reset(o) {
    this.setName(o.name).setDuration(o.duration, o.yoyo).setCallbacks(o.target, o.onStart, o.onProgress, o.onComplete).setPaused(false).setRemoved(false);
    return this;
  }
  onFree() {
    this.setTimeline().setCallbacks();
  }
  getProgress() {
    var value = 1 - this.remainder / this.duration;
    value = Clamp2(value, 0, 1);
    if (this.yoyo) {
      value = Yoyo_default(value);
    }
    return value;
  }
  setProgress(value) {
    value = Clamp2(value, 0, 1);
    this.remainder = this.duration * (1 - value);
  }
  runCallback(callback) {
    if (!callback) {
      return;
    }
    callback(this.target, this.t, this);
  }
  update(time, delta) {
    if (this.removed) {
      return true;
    } else if (this.isPaused) {
      return false;
    }
    this.remainder -= delta;
    this.t = this.getProgress();
    this.runCallback(this.onProgress);
    var isCompleted = this.remainder <= 0;
    if (isCompleted) {
      this.runCallback(this.onComplete);
    }
    return isCompleted;
  }
};
var Timer_default2 = Timer2;

// node_modules/phaser3-rex-plugins/plugins/time/progresses/TimerPool.js
var TimerPool = class extends pool_default {
  allocate() {
    return this.pop();
  }
  free(timer) {
    timer.onFree();
    this.push(timer);
  }
  freeMultiple(arr) {
    for (var i = 0, cnt = arr.length; i < cnt; i++) {
      this.free(arr[i]);
    }
    return this;
  }
};
var TimerPool_default = TimerPool;

// node_modules/phaser3-rex-plugins/plugins/time/progresses/Timeline.js
var GetValue42 = Phaser.Utils.Objects.GetValue;
var TimerPool2 = new TimerPool_default();
var Timeline = class extends Clock_default {
  constructor(parent, config) {
    super(parent, config);
    this.addedTimers = [];
    this.timers = [];
    this.timerPool = GetValue42(config, "pool", TimerPool2);
  }
  shutdown() {
    if (this.isShutdown) {
      return;
    }
    this.timerPool.freeMultiple(this.addedTimers).freeMultiple(this.timers);
    this.timerPool = void 0;
    this.addedTimers = void 0;
    this.timers = void 0;
    super.shutdown();
  }
  addTimer(config) {
    var timer = this.timerPool.allocate();
    if (!timer) {
      timer = new Timer_default2(this, config);
    } else {
      timer.setTimeline(this).reset(config);
    }
    this.addedTimers.push(timer);
    timer.runCallback(timer.onStart);
    if (!this.isRunning) {
      this.start();
    }
    return timer;
  }
  delayCall(delay, callback, args, scope) {
    var timer = this.addTimer({
      duration: delay,
      onComplete: function(target, t, timer2) {
        if (args === void 0) {
          args = [];
        }
        args.push(timer2);
        callback.apply(scope, args);
      }
    });
    return timer;
  }
  delayEvent(delay, eventName) {
    this.removeDelayEvent(eventName);
    var timer = this.delayCall(delay, function() {
      this.removeDelayEvent(eventName);
      this.emit(eventName);
    }, [], this);
    this.once(`_remove.${eventName}`, function() {
      timer.remove();
      timer = void 0;
    });
    return this;
  }
  removeDelayEvent(eventName) {
    this.emit(`_remove.${eventName}`);
    return this;
  }
  getTimers(name2) {
    var timers = [];
    var timerQueues = [this.addedTimers, this.timers];
    for (var ti = 0, tcnt = timerQueues.length; ti < tcnt; ti++) {
      var timerQueue = timerQueues[ti];
      for (var i = 0, cnt = timerQueue.length; i < cnt; i++) {
        var timer = timerQueue[i];
        if (timer.name === name2) {
          timers.push(timer);
        }
      }
    }
    return timers;
  }
  update(time, delta) {
    super.update(time, delta);
    if (!this.isRunning) {
      return;
    }
    this.timers.push(...this.addedTimers);
    this.addedTimers.length = 0;
    var pendingTimers = [];
    for (var i = 0, cnt = this.timers.length; i < cnt; i++) {
      var timer = this.timers[i];
      var isStopped = timer.update(this.now, this.delta);
      if (isStopped) {
        this.timerPool.free(timer);
      } else {
        pendingTimers.push(timer);
      }
    }
    this.timers = pendingTimers;
    if (this.timers.length === 0 && this.addedTimers.length === 0) {
      this.complete();
    }
  }
};
var Timeline_default = Timeline;

// node_modules/phaser3-rex-plugins/plugins/utils/waitevent/const.js
var WaitCompleteEvent = "_wait.complete";
var RemoveWaitEvents = "_remove.wait";

// node_modules/phaser3-rex-plugins/plugins/utils/time/PreUpdateDelayCall.js
var PreUpdateDelayCall = function(gameObject2, delay, callback, scope, args) {
  var scene = GetSceneObject_default(gameObject2);
  var timer = scene.time.delayedCall(delay, function() {
    scene.sys.events.once("preupdate", function() {
      callback.call(scope, args);
    });
  });
  return timer;
};
var PreUpdateDelayCall_default = PreUpdateDelayCall;

// node_modules/phaser3-rex-plugins/plugins/utils/waitevent/WaitEvent.js
var WaitEvent = class {
  constructor(parent) {
    if (!parent) {
      this.setEventEmitter(true);
      parent = this;
    }
    this.parent = parent;
    this.waitId = 0;
    this.waitCompleteEventName = WaitCompleteEvent;
    this.removeWaitEventsEventName = RemoveWaitEvents;
  }
  destroy() {
    this.removeWaitEvents();
    this.clearWaitCompleteCallbacks();
    this.parent = null;
  }
  // Emit completeEvent (default value is 'complete') when eventEmitter firing eventName
  waitEvent(eventEmitter, eventName, completeNextTick) {
    var callback = this.getWaitCompleteTriggerCallback(completeNextTick);
    eventEmitter.once(eventName, callback, this);
    this.parent.once(this.removeWaitEventsEventName, function() {
      eventEmitter.off(eventName, callback, this);
    });
    return this.parent;
  }
  getWaitCompleteTriggerCallback(completeNextTick) {
    if (completeNextTick === void 0) {
      completeNextTick = true;
    }
    var waitId = this.waitId;
    var self = this;
    var completeCallback = function() {
      if (waitId < self.waitId) {
        return;
      }
      self.waitId++;
      self.removeWaitEvents();
      self.parent.emit(self.waitCompleteEventName);
    };
    if (completeNextTick) {
      var completeCallbackNextTick = function() {
        PreUpdateDelayCall_default(self.parent, 0, completeCallback);
      };
      return completeCallbackNextTick;
    } else {
      return completeCallback;
    }
  }
  removeWaitEvents() {
    this.parent.emit(this.removeWaitEventsEventName);
    return this;
  }
  addWaitCompleteCallback(callback, scope) {
    this.parent.on(this.waitCompleteEventName, callback, scope);
    return this;
  }
  clearWaitCompleteCallbacks() {
    this.parent.off(this.waitCompleteEventName);
    return this;
  }
};
Object.assign(
  WaitEvent.prototype,
  EventEmitterMethods_default
);
var WaitEvent_default = WaitEvent;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/WaitTimeMethods.js
var WaitTimeMethods_default = {
  waitTime(duration) {
    var timeline = this.parent.timeline;
    timeline.delayEvent(duration, "delay");
    this.parent.once(this.removeWaitEventsEventName, function() {
      timeline.removeDelayEvent("delay");
    });
    return this.waitEvent(timeline, "delay");
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/string/Split.js
var Split = function(s, delimiter) {
  var regexString = `(?<!\\\\)\\${delimiter}`;
  var escapeString = `\\${delimiter}`;
  return s.split(new RegExp(regexString, "g")).map(function(s2) {
    return s2.replace(escapeString, delimiter);
  });
};
var Split_default = Split;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/WaitInputMethods.js
var WaitInputMethods_default = {
  setClickTarget(target) {
    this.clickTarget = target;
    if (!target) {
      this.touchEE = null;
    } else if (IsSceneObject_default(target)) {
      this.touchEE = target.input;
    } else {
      this.touchEE = target.setInteractive();
    }
    return this;
  },
  clearClickTarget() {
    this.setClickTarget();
    return this;
  },
  setClickShortcutKeys(keys) {
    this.clickShortcutKeys = keys;
    return this;
  },
  clearClickShortcutKeys() {
    this.setClickShortcutKeys();
    return this;
  },
  waitClick() {
    var touchEE = this.touchEE;
    var clickShortcutKeys = this.clickShortcutKeys;
    if (touchEE || clickShortcutKeys) {
      if (touchEE) {
        this.waitEvent(touchEE, "pointerdown");
      }
      if (clickShortcutKeys) {
        this.waitKeyDown(clickShortcutKeys);
      }
    } else {
      this.waitTime(0);
    }
    return this;
  },
  waitKeyDown(key2) {
    var eventEmitter = this.scene.input.keyboard;
    if (typeof key2 === "string") {
      if (key2.indexOf("|") === -1) {
        return this.waitEvent(eventEmitter, `keydown-${key2.toUpperCase()}`);
      } else {
        var keys = Split_default(key2, "|");
        for (var i = 0, cnt = keys.length; i < cnt; i++) {
          this.waitEvent(eventEmitter, `keydown-${keys[i].toUpperCase()}`);
        }
        return this.parent;
      }
    } else {
      return this.waitEvent(eventEmitter, "keydown");
    }
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/WaitGameObjectMethods.js
var WaitGameObjectMethods_default = {
  waitGameObjectTweenComplete(goType, name2, property) {
    var tweenTask = this.parent.getGameObjectTweenTask(goType, name2, property);
    if (tweenTask) {
      return this.waitEvent(tweenTask, "complete");
    }
    return this.waitTime(0);
  },
  waitGameObjectDataFlag(goType, name2, dataKey, trueFlag) {
    var gameObject2 = this.parent.getGameObject(goType, name2);
    if (!gameObject2) {
      return this.waitTime(0);
    }
    if (gameObject2.getData(dataKey) === trueFlag) {
      return this.waitTime(0);
    }
    var eventName = `changedata-${dataKey}`;
    var callback = function(gameObject3, value, previousValue) {
      value = !!value;
      if (value === trueFlag) {
        gameObject3.emit("_dataFlagMatch");
      }
    };
    gameObject2.on(eventName, callback);
    this.parent.once(this.removeWaitEventsEventName, function() {
      gameObject2.off(eventName, callback);
    });
    return this.waitEvent(gameObject2, "_dataFlagMatch");
  },
  waitGameObjectDestroy(goType, name2) {
    var gameObject2 = this.parent.getGameObject(goType, name2);
    if (!gameObject2) {
      return this.waitTime(0);
    }
    return this.waitEvent(gameObject2, "destroy");
  },
  waitGameObjectManagerEmpty(goType) {
    if (goType) {
      var gameObjectManager = this.parent.getGameObjectManager(goType);
      if (!gameObjectManager) {
        return this.waitTime(0);
      }
      return this.waitEvent(gameObjectManager, "empty");
    } else {
      var gameObjectManagers = this.parent.gameObjectManagers;
      var hasAnyWaitEvent = false;
      for (var name2 in gameObjectManagers) {
        hasAnyWaitEvent = true;
        this.waitEvent(gameObjectManagers[name2], "empty");
      }
      if (!hasAnyWaitEvent) {
        return this.waitTime(0);
      }
      return this.parent;
    }
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/WaitCameraMethods.js
var WaitCameraMethods_default = {
  setCameraTarget(camera) {
    this.cameraTarget = camera;
    return this;
  },
  clearCameraTarget() {
    this.setCameraTarget();
    return this;
  },
  waitCameraEffectComplete(effectName, cameraName) {
    var camera;
    if (cameraName) {
      camera = this.scene.cameras.getCamera(cameraName);
    } else {
      camera = this.cameraTarget;
    }
    if (!camera) {
      return this.waitTime(0);
    }
    var effect, completeEventName;
    switch (effectName) {
      case "camera.fadein":
        effect = camera.fadeEffect;
        completeEventName = "camerafadeincomplete";
        break;
      case "camera.fadeout":
        effect = camera.fadeEffect;
        completeEventName = "camerafadeoutcomplete";
        break;
      case "camera.flash":
        effect = camera.flashEffect;
        completeEventName = "cameraflashcomplete";
        break;
      case "camera.shake":
        effect = camera.shakeEffect;
        completeEventName = "camerashakecomplete";
        break;
      case "camera.zoom":
        effect = camera.zoomEffect;
        completeEventName = "camerazoomcomplete";
        break;
      case "camera.rotate":
        effect = camera.rotateToEffect;
        completeEventName = "camerarotatecomplete";
        break;
      case "camera.scroll":
        effect = camera.panEffect;
        completeEventName = "camerapancomplete";
        break;
    }
    if (!effect.isRunning) {
      return this.waitTime(0);
    }
    return this.waitEvent(camera, completeEventName);
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/WaitMusicMethods.js
var WaitMusicMethods_default = {
  waitSoundEffectComplete() {
    if (!this.parent.soundManager) {
      return this.waitTime(0);
    }
    var music = this.parent.soundManager.getLastSoundEffect();
    if (!music) {
      return this.waitTime(0);
    }
    return this.waitEvent(music, "complete");
  },
  waitSoundEffect2Complete() {
    if (!this.parent.soundManager) {
      return this.waitTime(0);
    }
    var music = this.parent.soundManager.getLastSoundEffect2();
    if (!music) {
      return this.waitTime(0);
    }
    return this.waitEvent(music, "complete");
  },
  waitBackgroundMusicComplete() {
    if (!this.parent.soundManager) {
      return this.waitTime(0);
    }
    var music = this.parent.soundManager.getBackgroundMusic();
    if (!music) {
      return this.waitTime(0);
    }
    return this.waitEvent(music, "complete");
  },
  waitBackgroundMusic2Complete() {
    if (!this.parent.soundManager) {
      return this.waitTime(0);
    }
    var music = this.parent.soundManager.getBackgroundMusic2();
    if (!music) {
      return this.waitTime(0);
    }
    return this.waitEvent(music, "complete");
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/WaitAny.js
var WaitAny = function(config) {
  if (!config) {
    return this.waitTime(0);
  }
  var hasAnyWaitEvent = false;
  for (var name2 in config) {
    switch (name2) {
      case "time":
        hasAnyWaitEvent = true;
        this.waitTime(config.time);
        break;
      case "click":
        hasAnyWaitEvent = true;
        this.waitClick();
        break;
      case "key":
        hasAnyWaitEvent = true;
        this.waitKeyDown(config.key);
        break;
      case "bgm":
        hasAnyWaitEvent = true;
        this.waitBackgroundMusicComplete();
        break;
      case "bgm2":
        hasAnyWaitEvent = true;
        this.waitBackgroundMusic2Complete();
        break;
      case "se":
        hasAnyWaitEvent = true;
        this.waitSoundEffectComplete();
        break;
      case "se2":
        hasAnyWaitEvent = true;
        this.waitSoundEffect2Complete();
        break;
      case "camera":
        hasAnyWaitEvent = true;
        this.waitCameraEffectComplete(`camera.${config.camera.toLowerCase()}`, config.cameraName);
        break;
      default:
        var names = name2.split(".");
        if (names.length === 2) {
          var gameObjectName = names[0];
          var propName = names[1];
          var gameObjectManager = this.parent.getGameObjectManager(void 0, gameObjectName);
          if (!gameObjectManager) {
            continue;
          }
          if (propName === "destroy") {
            return this.waitGameObjectDestroy(void 0, gameObjectName);
          }
          var value = gameObjectManager.getProperty(gameObjectName, propName);
          if (typeof value === "number") {
            hasAnyWaitEvent = true;
            this.waitGameObjectTweenComplete(void 0, gameObjectName, propName);
            continue;
          }
          var dataKey = propName;
          var matchFalseFlag = dataKey.startsWith("!");
          if (matchFalseFlag) {
            dataKey = dataKey.substring(1);
          }
          if (gameObjectManager.hasData(gameObjectName, propName)) {
            hasAnyWaitEvent = true;
            this.waitGameObjectDataFlag(void 0, gameObjectName, dataKey, !matchFalseFlag);
            continue;
          }
          this.waitEvent(gameObject, propName);
          continue;
        } else if (names.length === 1) {
        }
        break;
    }
  }
  if (!hasAnyWaitEvent) {
    this.waitTime(0);
  }
  return this.parent;
};
var WaitAny_default = WaitAny;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/Methods.js
var methods8 = {
  waitAny: WaitAny_default
};
Object.assign(
  methods8,
  WaitTimeMethods_default,
  WaitInputMethods_default,
  WaitGameObjectMethods_default,
  WaitCameraMethods_default,
  WaitMusicMethods_default
);
var Methods_default9 = methods8;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/waiteventmanager/WaitEventManager.js
var WaitEventManager = class extends WaitEvent_default {
  constructor(parent, config) {
    super(parent);
    this.waitCompleteEventName = GetValue_default(config, "completeEventName", this.waitCompleteEventName);
    this.setClickTarget(GetValue_default(config, "clickTarget", this.scene));
    this.setClickShortcutKeys(GetValue_default(config, "clickShortcutKeys", void 0));
    this.setCameraTarget(GetValue_default(config, "camera", this.scene.cameras.main));
  }
  get clickTarget() {
    return this.parent.clickTarget;
  }
  set clickTarget(value) {
    this.parent.clickTarget = value;
  }
  get clickShortcutKeys() {
    return this.parent.clickShortcutKeys;
  }
  set clickShortcutKeys(value) {
    this.parent.clickShortcutKeys = value;
  }
  get cameraTarget() {
    return this.parent.cameraTarget;
  }
  set cameraTarget(value) {
    this.parent.cameraTarget = value;
  }
  destroy() {
    this.clearClickTarget();
    this.clearClickShortcutKeys();
    this.clearCameraTarget();
    super.destroy();
  }
  get scene() {
    return this.parent.managersScene;
  }
};
Object.assign(
  WaitEventManager.prototype,
  Methods_default9
);
var WaitEventManager_default = WaitEventManager;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/InitManagers.js
var GetValue43 = Phaser.Utils.Objects.GetValue;
var InitManagers = function(scene, config) {
  this.clickTarget = void 0;
  this.clickShortcutKeys = void 0;
  this.cameraTarget = void 0;
  this.managersScene = scene;
  this.gameObjectManagers = {};
  var layerNames = GetValue43(config, "layers", false);
  if (layerNames !== false) {
    var layerManager = new LayerManager_default(scene, {
      name: "LAYER",
      layers: layerNames,
      rootLayer: GetValue43(config, "rootLayer", void 0),
      depth: GetValue43(config, "layerDepth", void 0)
    });
    this.addGameObjectManager(layerManager);
    this.layerManager = layerManager;
  }
  var soundManagerConfig = GetValue43(config, "sounds");
  if (soundManagerConfig !== false) {
    this.soundManager = new SoundManager_default(scene, soundManagerConfig);
  }
  this.timeline = new Timeline_default(this);
  this.waitEventManager = new WaitEventManager_default(this, config);
  return this;
};
var InitManagers_default = InitManagers;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/SetTimeScale.js
var SetTimeScale = function(value) {
  this.timeline.timeScale = value;
  for (var name2 in this.gameObjectManagers) {
    this.gameObjectManagers[name2].setTimeScale(value);
  }
  return this;
};
var SetTimeScale_default = SetTimeScale;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/GetTimeScale.js
var GetTimeScale = function() {
  return this.timeline.timeScale;
};
var GetTimeScale_default = GetTimeScale;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/DestroyManagers.js
var DestroyManagers = function(fromScene) {
  this.waitEventManager.destroy();
  this.waitEventManager = void 0;
  delete this.gameObjectManagers.layer;
  for (var name2 in this.gameObjectManagers) {
    this.gameObjectManagers[name2].destroy(fromScene);
    delete this.gameObjectManagers[name2];
  }
  if (this.layerManager) {
    this.layerManager.destroy(fromScene);
    this.layerManager = void 0;
  }
  if (this.soundManager) {
    this.soundManager.destroy();
    this.soundManager = void 0;
  }
  if (this.timeline) {
    this.timeline.destroy();
    this.timeline = void 0;
  }
  this.clickTarget = void 0;
  this.clickShortcutKeys = void 0;
  this.cameraTarget = void 0;
  this.managersScene = void 0;
};
var DestroyManagers_default = DestroyManagers;

// node_modules/phaser3-rex-plugins/plugins/utils/managers/GameObjectManagerMethods.js
var GameObjectManagerMethods_default = {
  addGameObjectManager(config, GameObjectManagerClass) {
    var gameobjectManager;
    if (config instanceof GOManager_default) {
      gameobjectManager = config;
    } else if (typeof config === "string") {
      gameobjectManager = GameObjectManagerClass;
      gameobjectManager.name = config;
    } else {
      if (config === void 0) {
        config = {};
      }
      if (GameObjectManagerClass === void 0) {
        GameObjectManagerClass = GOManager_default;
      }
      if (!config.createGameObjectScope) {
        config.createGameObjectScope = this;
      }
      gameobjectManager = new GameObjectManagerClass(this.managersScene, config);
    }
    this.gameObjectManagers[gameobjectManager.name] = gameobjectManager;
    return this;
  },
  getGameObjectManager(managerName, gameObjectName) {
    if (managerName) {
      var manager = this.gameObjectManagers[managerName];
      return manager;
    } else {
      if (gameObjectName && gameObjectName.charAt(0) === "!") {
        gameObjectName = gameObjectName.substring(1);
      }
      for (var managerName in this.gameObjectManagers) {
        var manager = this.gameObjectManagers[managerName];
        if (manager.has(gameObjectName)) {
          return manager;
        }
      }
    }
  },
  getGameObjectManagerNames() {
    var names = [];
    for (var name2 in this.gameObjectManagers) {
      names.push(name2);
    }
    return names;
  },
  getGameObjectManagerName(gameObjectName) {
    var gameObjectManager = this.getGameObjectManager(void 0, gameObjectName);
    if (!gameObjectManager) {
      return void 0;
    }
    return gameObjectManager.name;
  },
  hasGameObjectMananger(managerName) {
    return managerName in this.gameObjectManagers;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/managers/GameObjectMethods.js
var GameObjectMethods_default = {
  createGameObject(goType, name2, ...params) {
    this.getGameObjectManager(goType, name2).add(name2, ...params);
    return this;
  },
  destroyGameObject(goType, name2) {
    var gameObjectManager = this.getGameObjectManager(goType, name2);
    if (name2 === void 0) {
      gameObjectManager.removeAll();
    } else {
      gameObjectManager.remove(name2);
    }
    return this;
  },
  hasGameObject(goType, name2) {
    return !!this.getGameObjectManager(goType, name2);
  },
  callGameObjectMethod(goType, name2, methodName, ...params) {
    this.getGameObjectManager(goType, name2).call(name2, methodName, ...params);
    return this;
  },
  setGameObjectProperty(goType, name2, prop, value) {
    this.getGameObjectManager(goType, name2).setProperty(name2, prop, value);
    return this;
  },
  easeGameObjectProperty(goType, name2, config) {
    this.getGameObjectManager(goType, name2).easeProperty(name2, config);
    return this;
  },
  getGameObjectTweenTask(goType, name2, property) {
    return this.getGameObjectManager(goType, name2).getTweenTask(name2, property);
  },
  getGameObject(goType, name2, out2) {
    var gameobjectManager = this.getGameObjectManager(goType, name2);
    if (!gameobjectManager) {
      return out2;
    }
    if (typeof name2 === "string") {
      return gameobjectManager.getGO(name2);
    } else {
      if (out2 === void 0) {
        out2 = [];
      }
      var names = name2;
      if (names === void 0) {
        names = Object.keys(gameobjectManager.bobs);
      }
      var isArrayOutput = Array.isArray(out2);
      for (var i = 0, cnt = names.length; i < cnt; i++) {
        name2 = names[i];
        var gameObject2 = gameobjectManager.getGO(name2);
        if (!gameObject2) {
          continue;
        }
        if (isArrayOutput) {
          out2.push(gameObject2);
        } else {
          out2[name2] = gameObject2;
        }
      }
      return out2;
    }
  },
  addGameObject(goType, name2, gameObject2) {
    var gameobjectManager = this.getGameObjectManager(goType, name2);
    if (typeof name2 === "string") {
      gameobjectManager.addGO(name2, gameObject2);
    } else {
      var names = name2;
      for (name2 in names) {
        gameobjectManager.addGO(name2, names[name2]);
      }
    }
    return this;
  },
  drawGameObjectsBounds(goTypes, graphics, config) {
    if (goTypes instanceof Phaser.GameObjects.Graphics) {
      config = graphics;
      graphics = goTypes;
      goTypes = void 0;
    }
    if (goTypes === void 0) {
      goTypes = this.getGameObjectManagerNames();
    }
    if (!Array.isArray(goTypes)) {
      goTypes = [goTypes];
    }
    for (var i = 0, cnt = goTypes.length; i < cnt; i++) {
      this.getGameObjectManager(goTypes[i]).drawGameObjectsBounds(graphics, config);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/managers/Extend.js
var Extend = function(BaseClass) {
  class Managers extends BaseClass {
  }
  var Methods22 = {
    initManagers: InitManagers_default,
    setTimeScale: SetTimeScale_default,
    getTimeScale: GetTimeScale_default,
    destroyManagers: DestroyManagers_default
  };
  Object.assign(
    Managers.prototype,
    Methods22,
    GameObjectManagerMethods_default,
    GameObjectMethods_default
  );
  return Managers;
};
var Extend_default = Extend;

// node_modules/phaser3-rex-plugins/plugins/utils/eventemitter/EventEmitter.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var EventEmitter2 = class extends import_eventemitter3.default {
  shutdown() {
    this.removeAllListeners();
  }
  destroy() {
    this.removeAllListeners();
  }
};
var EventEmitter_default = EventEmitter2;

// node_modules/phaser3-rex-plugins/plugins/utils/eventemitter/StandAloneEventEmitterMethods.js
var StandAloneEventEmitterMethods_default = {
  setEventEmitter(eventEmitter, EventEmitterClass) {
    if (EventEmitterClass === void 0) {
      EventEmitterClass = EventEmitter_default;
    }
    this._privateEE = eventEmitter === true || eventEmitter === void 0;
    this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
    return this;
  },
  destroyEventEmitter() {
    if (this._eventEmitter && this._privateEE) {
      this._eventEmitter.shutdown();
    }
    return this;
  },
  getEventEmitter() {
    return this._eventEmitter;
  },
  on: function() {
    if (this._eventEmitter) {
      this._eventEmitter.on.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  once: function() {
    if (this._eventEmitter) {
      this._eventEmitter.once.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  off: function() {
    if (this._eventEmitter) {
      this._eventEmitter.off.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  emit: function(event) {
    if (this._eventEmitter && event) {
      this._eventEmitter.emit.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  addListener: function() {
    if (this._eventEmitter) {
      this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeListener: function() {
    if (this._eventEmitter) {
      this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  removeAllListeners: function() {
    if (this._eventEmitter) {
      this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
    }
    return this;
  },
  listenerCount: function() {
    if (this._eventEmitter) {
      return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
    }
    return 0;
  },
  listeners: function() {
    if (this._eventEmitter) {
      return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
    }
    return [];
  },
  eventNames: function() {
    if (this._eventEmitter) {
      return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
    }
    return [];
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/string/TypeConvert.js
var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
var HEX = /^0x[0-9A-F]+$/i;
var TypeConvert = function(s) {
  if (typeof s !== "string") {
    return s;
  }
  if (s === "") {
    s = null;
  } else if (FLOAT.test(s)) {
    s = parseFloat(s);
  } else if (HEX.test(s)) {
    s = parseInt(s, 16);
  } else {
    switch (s) {
      case "false":
        s = false;
        break;
      case "true":
        s = true;
        break;
      case "null":
        s = null;
        break;
      case "undefined":
        s = void 0;
        break;
    }
  }
  return s;
};
var TypeConvert_default = TypeConvert;

// node_modules/phaser3-rex-plugins/plugins/logic/bracketparser/bracketparserbase/BracketParser.js
var BracketParser = class {
  constructor(config) {
    this.setEventEmitter(GetValue_default(config, "eventEmitter", void 0));
    this.setValueConverter(GetValue_default(config, "valueConvert", true));
    this.setLoopEnable(GetValue_default(config, "loop", false));
    this.setMultipleLinesTagEnable(GetValue_default(config, "multipleLinesTag", false));
    var delimiters = GetValue_default(config, "delimiters", "<>");
    this.setDelimiters(delimiters[0], delimiters[1]);
    this.setTranslateTagNameCallback(GetValue_default(config, "translateTagNameCallback"));
    this.isRunning = false;
    this.isPaused = false;
    this.skipEventFlag = false;
    this.justCompleted = false;
    this.lastTagStart = null;
    this.lastTagEnd = null;
    this.lastContent = null;
  }
  shutdown() {
    this.destroyEventEmitter();
  }
  destroy() {
    this.shutdown();
  }
  setMultipleLinesTagEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.multipleLinesTagEnable = enable;
    return this;
  }
  // Override
  setDelimiters(delimiterLeft, delimiterRight) {
    if (delimiterRight === void 0) {
      delimiterRight = delimiterLeft[1];
      delimiterLeft = delimiterLeft[0];
    }
    this.delimiterLeft = delimiterLeft;
    this.delimiterRight = delimiterRight;
    delimiterLeft = EscapeRegex_default(this.delimiterLeft);
    delimiterRight = EscapeRegex_default(this.delimiterRight);
    var flag = this.multipleLinesTagEnable ? "gs" : "gi";
    this.reSplit = RegExp(`${delimiterLeft}(.+?)${delimiterRight}`, flag);
    return this;
  }
  setTranslateTagNameCallback(callback) {
    this.translateTagNameCallback = callback;
    return this;
  }
  setValueConverter(converter) {
    if (converter === true) {
      converter = TypeConvert_default;
    } else if (!converter) {
      converter = BypassValueConverter;
    }
    this.valueConverter = converter;
    return this;
  }
  setLoopEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.loopEnable = enable;
    return this;
  }
  setSource(source) {
    this.source = source;
    return this;
  }
  resetIndex(index) {
    if (index === void 0) {
      index = 0;
    }
    this.progressIndex = index;
    this.reSplit.lastIndex = index;
    this.lastTagStart = null;
    this.lastTagEnd = null;
    this.lastContent = null;
    this.justCompleted = false;
    this.isRunning = false;
    return this;
  }
  start(source) {
    this.setSource(source).restart();
    return this;
  }
  restart() {
    this.resetIndex().next();
  }
  next() {
    if (this.isPaused) {
      this.onResume();
    }
    if (this.isRunning) {
      return this;
    }
    this.isRunning = true;
    if (this.justCompleted) {
      this.isRunning = false;
      return this;
    }
    if (this.reSplit.lastIndex === 0) {
      this.onStart();
    }
    var text = this.source, lastIndex = text.length;
    this.reSplit.lastIndex = this.progressIndex;
    while (true) {
      var regexResult = this.reSplit.exec(text);
      if (!regexResult) {
        if (this.progressIndex < lastIndex) {
          this.onContent(text.substring(this.progressIndex, lastIndex));
          if (this.isPaused) {
            this.progressIndex = lastIndex;
            break;
          }
        }
        this.onComplete();
        this.isRunning = false;
        return;
      }
      var matchEnd = this.reSplit.lastIndex;
      var matchStart = matchEnd - regexResult[0].length;
      if (this.progressIndex < matchStart) {
        this.onContent(text.substring(this.progressIndex, matchStart));
        if (this.isPaused) {
          this.progressIndex = matchStart;
          break;
        }
      }
      this.lastTagSource = regexResult[0];
      this.onTag(regexResult[1]);
      this.lastTagSource = void 0;
      this.progressIndex = matchEnd;
      if (this.isPaused) {
        break;
      }
    }
    this.isRunning = false;
    return this;
  }
  skipEvent() {
    this.skipEventFlag = true;
    return this;
  }
  pause() {
    if (!this.isPaused) {
      this.onPause();
    }
    return this;
  }
  pauseUntilEvent(eventEmitter, eventName) {
    if (this.isPaused) {
      return this;
    }
    this.pause();
    eventEmitter.once(eventName, function() {
      this.next();
    }, this);
    return this;
  }
  onContent(content) {
    this.skipEventFlag = false;
    this.emit("content", content);
    this.lastContent = content;
  }
  // Override
  onTag(tagContent) {
  }
  onStart() {
    this.isRunning = true;
    this.emit("start", this);
  }
  onComplete() {
    this.isRunning = false;
    this.justCompleted = true;
    this.emit("complete", this);
    if (this.loopEnable) {
      this.resetIndex();
    }
  }
  onPause() {
    this.isPaused = true;
    this.emit("pause", this);
  }
  onResume() {
    this.isPaused = false;
    this.emit("resume", this);
  }
};
var BypassValueConverter = function(s) {
  return s;
};
Object.assign(
  BracketParser.prototype,
  StandAloneEventEmitterMethods_default
);
var BracketParser_default = BracketParser;

// node_modules/phaser3-rex-plugins/plugins/utils/string/StringToValues.js
var StringToValues = function(text, valueConverter, delimiter) {
  if (text == null) {
    return [];
  }
  if (valueConverter === void 0) {
    valueConverter = TypeConvert_default;
  }
  if (delimiter === void 0) {
    delimiter = ",";
  }
  var values = text.split(delimiter);
  for (var i = 0, cnt = values.length; i < cnt; i++) {
    values[i] = valueConverter(values[i]);
  }
  return values;
};
var StringToValues_default = StringToValues;

// node_modules/phaser3-rex-plugins/plugins/logic/bracketparser/bracketparser/BracketParser.js
var BracketParser2 = class extends BracketParser_default {
  constructor(config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("multipleLinesTag")) {
      config.multipleLinesTag = false;
    }
    super(config);
    this.setTagExpression(GetValue_default(config, "regex.tag", void 0));
    this.setValueExpression(GetValue_default(config, "regex.value", void 0));
    var delimiters = GetValue_default(config, "delimiters", "<>");
    this.setDelimiters(delimiters[0], delimiters[1]);
  }
  setTagExpression(express) {
    if (!express) {
      express = DefaultTokenExpression;
    }
    this.tagExpression = express;
    return this;
  }
  setValueExpression(express) {
    if (!express) {
      express = DefaultTokenExpression;
    }
    this.valueExpression = express;
    return this;
  }
  setDelimiters(delimiterLeft, delimiterRight) {
    super.setDelimiters(delimiterLeft, delimiterRight);
    var tag = `(${this.tagExpression})(=(${this.valueExpression}))?`;
    this.reTag = RegExp(tag, "i");
    if (this.tagExpression !== DefaultTokenExpression || this.valueExpression !== DefaultTokenExpression) {
      var startTagExpression = `${this.tagExpression}(=${this.valueExpression})?`;
      var endTagExpression = `/${this.tagExpression}`;
      delimiterLeft = EscapeRegex_default(this.delimiterLeft);
      delimiterRight = EscapeRegex_default(this.delimiterRight);
      var flag = this.multipleLinesTagEnable ? "gs" : "gi";
      this.reSplit = RegExp(`${delimiterLeft}((${startTagExpression})|(${endTagExpression}))${delimiterRight}`, flag);
    }
    return this;
  }
  onTag(tagContent) {
    var regexResult = tagContent.match(this.reTag);
    var tagName = regexResult[1];
    var isEndTag = tagName.charAt(0) === "/";
    if (isEndTag) {
      tagName = tagName.substring(1, tagName.length);
    }
    if (this.translateTagNameCallback) {
      tagName = this.translateTagNameCallback(tagName);
    }
    this.skipEventFlag = false;
    if (!isEndTag) {
      var values = StringToValues_default(regexResult[3], this.valueConverter);
      this.emit(`+${tagName}`, ...values);
      if (!this.skipEventFlag) {
        this.emit("+", tagName, ...values);
      }
      this.lastTagStart = tagName;
    } else {
      this.emit(`-${tagName}`);
      if (!this.skipEventFlag) {
        this.emit("-", tagName);
      }
      this.lastTagEnd = tagName;
    }
  }
};
var DefaultTokenExpression = `[^=]+`;
var BracketParser_default2 = BracketParser2;

// node_modules/phaser3-rex-plugins/plugins/bracketparser.js
var bracketparser_default = BracketParser_default2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseColorTag.js
var OnParseColorTag = function(textPlayer, parser, config) {
  var tagName = "color";
  var defaultColor;
  parser.on("start", function() {
    defaultColor = textPlayer.textStyle.color;
  }).on(`+${tagName}`, function(color) {
    textPlayer.textStyle.setColor(color);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setColor(defaultColor);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setColor(defaultColor);
  });
};
var OnParseColorTag_default = OnParseColorTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseStrokeColorTag.js
var OnParseStrokeColorTag = function(textPlayer, parser, config) {
  var tagName = "stroke";
  var defaultStroke;
  parser.on("start", function() {
    defaultStroke = textPlayer.textStyle.stroke;
    textPlayer.textStyle.setStrokeStyle(null);
  }).on(`+${tagName}`, function(color) {
    if (color === void 0) {
      color = defaultStroke;
    }
    textPlayer.textStyle.setStrokeStyle(color);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setStrokeStyle(null);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setStrokeStyle(defaultStroke);
  });
};
var OnParseStrokeColorTag_default = OnParseStrokeColorTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseBoldTag.js
var OnParseBoldTag = function(textPlayer, parser, config) {
  var tagName = "b";
  parser.on("start", function() {
    textPlayer.textStyle.setBold(false);
  }).on(`+${tagName}`, function() {
    textPlayer.textStyle.setBold(true);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setBold(false);
    parser.skipEvent();
  });
};
var OnParseBoldTag_default = OnParseBoldTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseItalicTag.js
var OnParseItalicTag = function(textPlayer, parser, config) {
  var tagName = "i";
  parser.on("start", function() {
    textPlayer.textStyle.setItalic(false);
  }).on(`+${tagName}`, function() {
    textPlayer.textStyle.setItalic(true);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setItalic(false);
    parser.skipEvent();
  });
};
var OnParseItalicTag_default = OnParseItalicTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseFontSizeTag.js
var OnParseFontSizeTag = function(textPlayer, parser, config) {
  var tagName = "size";
  var defaultFontSize;
  parser.on("start", function() {
    defaultFontSize = textPlayer.textStyle.fontSize;
  }).on(`+${tagName}`, function(fontSize) {
    textPlayer.textStyle.setFontSize(fontSize);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setFontSize(defaultFontSize);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setFontSize(defaultFontSize);
  });
};
var OnParseFontSizeTag_default = OnParseFontSizeTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseOffsetYTag.js
var OnParseOffsetYTag = function(textPlayer, parser, config) {
  var tagName = "y";
  var defaultOffsetY;
  parser.on("start", function() {
    defaultOffsetY = textPlayer.textStyle.offsetY;
    textPlayer.textStyle.setOffsetY(0);
  }).on(`+${tagName}`, function(y) {
    if (y === void 0) {
      y = defaultOffsetY;
    }
    textPlayer.textStyle.setOffsetY(y);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setOffsetY(0);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setOffsetY(0);
  });
};
var OnParseOffsetYTag_default = OnParseOffsetYTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseOffsetXTag.js
var OnParseOffsetXTag = function(textPlayer, parser, config) {
  var tagName = "x";
  var defaultOffsetX;
  parser.on("start", function() {
    defaultOffsetX = textPlayer.textStyle.offsetY;
    textPlayer.textStyle.setOffsetX(0);
  }).on(`+${tagName}`, function(y) {
    if (y === void 0) {
      y = defaultOffsetX;
    }
    textPlayer.textStyle.setOffsetX(y);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setOffsetX(0);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setOffsetX(0);
  });
};
var OnParseOffsetXTag_default = OnParseOffsetXTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseLeftSpaceTag.js
var OnParseLeftSpaceTag = function(textPlayer, parser, config) {
  var tagName = "left";
  var defaultLeftSpace;
  parser.on("start", function() {
    defaultLeftSpace = textPlayer.textStyle.leftSpace;
    textPlayer.textStyle.setLeftSpace(0);
  }).on(`+${tagName}`, function(space) {
    if (space === void 0) {
      space = defaultLeftSpace;
    }
    textPlayer.textStyle.setLeftSpace(space);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setLeftSpace(0);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setLeftSpace(0);
  });
};
var OnParseLeftSpaceTag_default = OnParseLeftSpaceTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseRightSpaceTag.js
var OnParseRightSpaceTag = function(textPlayer, parser, config) {
  var tagName = "right";
  var defaultRightSpace;
  parser.on("start", function() {
    defaultRightSpace = textPlayer.textStyle.rightSpace;
    textPlayer.textStyle.setRightSpace(0);
  }).on(`+${tagName}`, function(space) {
    if (space === void 0) {
      space = defaultRightSpace;
    }
    textPlayer.textStyle.setRightSpace(space);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setRightSpace(0);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setRightSpace(0);
  });
};
var OnParseRightSpaceTag_default = OnParseRightSpaceTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseShadowColorTag.js
var OnParseShadowColorTag = function(textPlayer, parser, config) {
  var tagName = "shadow";
  var defaultShadowColor;
  parser.on("start", function() {
    defaultShadowColor = textPlayer.textStyle.shadowColor;
    textPlayer.textStyle.setShadowColor(null);
  }).on(`+${tagName}`, function(color) {
    if (color === void 0) {
      color = defaultShadowColor;
    }
    textPlayer.textStyle.setShadowColor(color);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setShadowColor(null);
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setShadowColor(defaultShadowColor);
  });
};
var OnParseShadowColorTag_default = OnParseShadowColorTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/textstyle/OnParseAlignTag.js
var OnParseAlignTag = function(textPlayer, parser, config) {
  var tagName = "align";
  parser.on(`+${tagName}`, function(align) {
    textPlayer.textStyle.setAlign(align);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    textPlayer.textStyle.setAlign();
    parser.skipEvent();
  }).on("complete", function() {
    textPlayer.textStyle.setAlign();
  });
};
var OnParseAlignTag_default = OnParseAlignTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/image/OnParseImageTag.js
var OnParseImageTag = function(textPlayer, parser, config) {
  var tagName = "img";
  parser.on(`+${tagName}`, function(name2) {
    var imgData = textPlayer.imageManager.get(name2);
    if (imgData) {
      AppendImage_default.call(
        textPlayer,
        imgData.key,
        imgData.frame,
        {
          width: imgData.width,
          hieght: imgData.height,
          leftSpace: imgData.left,
          rightSpace: imgData.right,
          color: imgData.tintFill ? textPlayer.textStyle.color : void 0
        }
      );
    }
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var OnParseImageTag_default = OnParseImageTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/space/OnParseSpaceTag.js
var OnParseImageTag2 = function(textPlayer, parser, config) {
  var tagName = "space";
  parser.on(`+${tagName}`, function(width) {
    AppendSpace_default.call(
      textPlayer,
      width
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var OnParseSpaceTag_default = OnParseImageTag2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/typing/OnParseTypingSpeedTag.js
var OnParseTypingSpeedTag = function(textPlayer, parser, config) {
  var tagName = "speed";
  parser.on(`+${tagName}`, function(speed) {
    AppendCommand2(textPlayer, speed);
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    AppendCommand2(textPlayer, void 0);
    parser.skipEvent();
  });
};
var SetTypingSpeed = function(speed) {
  this.typeWriter.setTypingSpeed(speed);
};
var AppendCommand2 = function(textPlayer, speed) {
  AppendCommand_default.call(
    textPlayer,
    "speed",
    // name
    SetTypingSpeed,
    // callback
    speed,
    // params
    textPlayer
    // scope
  );
};
var OnParseTypingSpeedTag_default = OnParseTypingSpeedTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/soundeffect/OnParsePlaySoundEffectTag.js
var OnParsePlaySoundEffectTag = function(textPlayer, parser, config) {
  var tagName = "se";
  parser.on(`+${tagName}`, function(name2, fadeInTime) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlaySoundEffect,
      // callback
      [name2, fadeInTime],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "se2";
  parser.on(`+${tagName}`, function(name2, fadeInTime) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlaySoundEffect2,
      // callback
      [name2, fadeInTime],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var PlaySoundEffect = function(params) {
  if (this.skipSoundEffect) {
    return;
  }
  var name2 = params[0];
  var fadeInTime = params[1];
  this.soundManager.playSoundEffect(name2);
  if (fadeInTime) {
    this.soundManager.fadeInSoundEffect(fadeInTime);
  }
};
var PlaySoundEffect2 = function(params) {
  if (this.skipSoundEffect) {
    return;
  }
  var name2 = params[0];
  var fadeInTime = params[1];
  this.soundManager.playSoundEffect2(name2);
  if (fadeInTime) {
    this.soundManager.fadeInSoundEffect2(fadeInTime);
  }
};
var OnParsePlaySoundEffectTag_default = OnParsePlaySoundEffectTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/soundeffect/OnParseFadeInSoundEffectTag.js
var OnParseFadeInSoundEffectTag = function(textPlayer, parser, config) {
  var tagName = "se.fadein";
  parser.on(`+${tagName}`, function(time) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeInSoundEffect,
      // callback
      time,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "se2.fadein";
  parser.on(`+${tagName}`, function(time) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeInSoundEffect2,
      // callback
      time,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var FadeInSoundEffect = function(time) {
  this.soundManager.fadeInSoundEffect(time);
};
var FadeInSoundEffect2 = function(time) {
  this.soundManager.fadeInSoundEffect2(time);
};
var OnParseFadeInSoundEffectTag_default = OnParseFadeInSoundEffectTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/soundeffect/OnParseFadeOutSoundEffectTag.js
var OnParseFadeOutSoundEffectTag = function(textPlayer, parser, config) {
  var tagName = "se.fadeout";
  parser.on(`+${tagName}`, function(time, isStopped) {
    isStopped = isStopped === "stop";
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeOutSoundEffect,
      // callback
      [time, isStopped],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "se2.fadeout";
  parser.on(`+${tagName}`, function(time, isStopped) {
    isStopped = isStopped === "stop";
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeOutSoundEffect2,
      // callback
      [time, isStopped],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var FadeOutSoundEffect = function(params) {
  this.soundManager.fadeOutSoundEffect(...params);
};
var FadeOutSoundEffect2 = function(params) {
  this.soundManager.fadeOutSoundEffect2(...params);
};
var OnParseFadeOutSoundEffectTag_default = OnParseFadeOutSoundEffectTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/soundeffect/OnParseSetSoundEffectVolumeTag.js
var OnParseSetSoundEffectVolumeTag = function(textPlayer, parser, config) {
  var tagName = "se.volume";
  parser.on(`+${tagName}`, function(volume) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetSoundEffectVolume,
      // callback
      volume,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "se2.volume";
  parser.on(`+${tagName}`, function(volume) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetSoundEffectVolume2,
      // callback
      volume,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var SetSoundEffectVolume = function(volume) {
  this.soundManager.setSoundEffectVolume(volume, true);
};
var SetSoundEffectVolume2 = function(volume) {
  this.soundManager.setSoundEffectVolume2(volume, true);
};
var OnParseSetSoundEffectVolumeTag_default = OnParseSetSoundEffectVolumeTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/soundeffect/OnParseSetSoundEffectMuteTag.js
var OnParseSetSoundEffectMuteTag = function(textPlayer, parser, config) {
  var tagName = "se.mute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetSoundEffectMute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "se2.mute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetSoundEffect2Mute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "se.unmute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetSoundEffectUnMute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "se2.unmute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetSoundEffect2UnMute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var SetSoundEffectMute = function() {
  this.soundManager.setSoundEffectMute(true);
};
var SetSoundEffect2Mute = function() {
  this.soundManager.setSoundEffect2Mute(true);
};
var SetSoundEffectUnMute = function() {
  this.soundManager.setSoundEffectMute(false);
};
var SetSoundEffect2UnMute = function() {
  this.soundManager.setSoundEffect2Mute(false);
};
var OnParseSetSoundEffectMuteTag_default = OnParseSetSoundEffectMuteTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/backgroundmusic/OnParsePlayBackgroundMusicTag.js
var OnParsePlayBackgroundMusicTag = function(textPlayer, parser, config) {
  var tagName = "bgm";
  parser.on(`+${tagName}`, function(name2, fadeInTime) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlayBackgroundMusic,
      // callback
      [name2, fadeInTime],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      "bgm.stop",
      // name
      StopBackgroundMusic,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
  var tagName = "bgm2";
  parser.on(`+${tagName}`, function(name2, fadeInTime) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlayBackgroundMusic2,
      // callback
      [name2, fadeInTime],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      "bgm2.stop",
      // name
      StopBackgroundMusic2,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PlayBackgroundMusic = function(params) {
  var name2 = params[0];
  var fadeInTime = params[1];
  this.soundManager.playBackgroundMusic(name2);
  if (fadeInTime) {
    this.soundManager.fadeInBackgroundMusic(fadeInTime);
  }
};
var StopBackgroundMusic = function() {
  this.soundManager.stopBackgroundMusic();
};
var PlayBackgroundMusic2 = function(params) {
  var name2 = params[0];
  var fadeInTime = params[1];
  this.soundManager.playBackgroundMusic2(name2);
  if (fadeInTime) {
    this.soundManager.fadeInBackgroundMusic2(fadeInTime);
  }
};
var StopBackgroundMusic2 = function() {
  this.soundManager.stopBackgroundMusic2();
};
var OnParsePlayBackgroundMusicTag_default = OnParsePlayBackgroundMusicTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/backgroundmusic/OnParseFadeInBackgroundMusicTag.js
var OnParseFadeInBackgroundMusicTag = function(textPlayer, parser, config) {
  var tagName = "bgm.fadein";
  parser.on(`+${tagName}`, function(time) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeInBackgroundMusic,
      // callback
      time,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "bgm2.fadein";
  parser.on(`+${tagName}`, function(time) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeInBackgroundMusic2,
      // callback
      time,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var FadeInBackgroundMusic = function(time) {
  this.soundManager.fadeInBackgroundMusic(time);
};
var FadeInBackgroundMusic2 = function(time) {
  this.soundManager.fadeInBackgroundMusic2(time);
};
var OnParseFadeInBackgroundMusicTag_default = OnParseFadeInBackgroundMusicTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/backgroundmusic/OnParseFadeOutBackgroundMusicTag.js
var OnParseFadeOutBackgroundMusicTag = function(textPlayer, parser, config) {
  var tagName = "bgm.fadeout";
  parser.on(`+${tagName}`, function(time, isStopped) {
    isStopped = isStopped === "stop";
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeOutBackgroundMusic,
      // callback
      [time, isStopped],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "bgm2.fadeout";
  parser.on(`+${tagName}`, function(time, isStopped) {
    isStopped = isStopped === "stop";
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      FadeOutBackgroundMusic2,
      // callback
      [time, isStopped],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var FadeOutBackgroundMusic = function(params) {
  this.soundManager.fadeOutBackgroundMusic(...params);
};
var FadeOutBackgroundMusic2 = function(params) {
  this.soundManager.fadeOutBackgroundMusic2(...params);
};
var OnParseFadeOutBackgroundMusicTag_default = OnParseFadeOutBackgroundMusicTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/backgroundmusic/OnParseCrossFadeBackgroundMusicTag.js
var OnParseCrossFadeBackgroundMusicTag = function(textPlayer, parser, config) {
  var tagName = "bgm.cross";
  parser.on(`+${tagName}`, function(name2, fadeTime) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      CrossFadeBackgroundMusic,
      // callback
      [name2, fadeTime],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "bgm2.cross";
  parser.on(`+${tagName}`, function(name2, fadeTime) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      CrossFadeBackgroundMusic2,
      // callback
      [name2, fadeTime],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var CrossFadeBackgroundMusic = function(params) {
  this.soundManager.crossFadeBackgroundMusic(...params);
};
var CrossFadeBackgroundMusic2 = function(params) {
  this.soundManager.crossFadeBackgroundMusic2(...params);
};
var OnParseCrossFadeBackgroundMusicTag_default = OnParseCrossFadeBackgroundMusicTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/backgroundmusic/OnParsePauseBackgroundMusicTag.js
var OnParsePauseBackgroundMusicTag = function(textPlayer, parser, config) {
  var tagName = "bgm.pause";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PauseBackgroundMusic,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      "bgm.resume",
      // name
      ResumeBackgroundMusic,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
  var tagName = "bgm2.pause";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PauseBackgroundMusic2,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      "bgm2.resume",
      // name
      ResumeBackgroundMusic2,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PauseBackgroundMusic = function() {
  this.soundManager.pauseBackgroundMusic();
};
var ResumeBackgroundMusic = function() {
  this.soundManager.resumeBackgroundMusic();
};
var PauseBackgroundMusic2 = function() {
  this.soundManager.pauseBackgroundMusic2();
};
var ResumeBackgroundMusic2 = function() {
  this.soundManager.resumeBackgroundMusic2();
};
var OnParsePauseBackgroundMusicTag_default = OnParsePauseBackgroundMusicTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/backgroundmusic/OnParseSetBackgroundMusicVolumeTag.js
var OnParseSetBackgroundMusicVolumeTag = function(textPlayer, parser, config) {
  var tagName = "bgm.volume";
  parser.on(`+${tagName}`, function(volume) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetBackgroundMusicVolume,
      // callback
      volume,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "bgm2.volume";
  parser.on(`+${tagName}`, function(volume) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetBackgroundMusicVolume2,
      // callback
      volume,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var SetBackgroundMusicVolume = function(volume) {
  this.soundManager.setBackgroundMusicVolume(volume);
};
var SetBackgroundMusicVolume2 = function(volume) {
  this.soundManager.setBackgroundMusicVolume2(volume);
};
var OnParseSetBackgroundMusicVolumeTag_default = OnParseSetBackgroundMusicVolumeTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/backgroundmusic/OnParseSetBackgroundMusicMuteTag.js
var OnParseSetBackgroundMusicMuteTag = function(textPlayer, parser, config) {
  var tagName = "bgm.mute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetBackgroundMusicMute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "bgm2.mute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetBackgroundMusic2Mute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "bgm.unmute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetBackgroundMusicUnMute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
  var tagName = "bgm2.unmute";
  parser.on(`+${tagName}`, function() {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      SetBackgroundMusic2UnMute,
      // callback
      void 0,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var SetBackgroundMusicMute = function() {
  this.soundManager.setBackgroundMusicMute(true);
};
var SetBackgroundMusic2Mute = function() {
  this.soundManager.setBackgroundMusic2Mute(true);
};
var SetBackgroundMusicUnMute = function() {
  this.soundManager.setBackgroundMusicMute(false);
};
var SetBackgroundMusic2UnMute = function() {
  this.soundManager.setBackgroundMusic2Mute(false);
};
var OnParseSetBackgroundMusicMuteTag_default = OnParseSetBackgroundMusicMuteTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/camera/OnParseFadeInCameraTag.js
var OnParseFadeInCameraTag = function(textPlayer, parser, config) {
  var tagName = "camera.fadein";
  parser.on(`+${tagName}`, function(duration, red, green, blue) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlayFadeInEffect,
      // callback
      [duration, red, green, blue],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PlayFadeInEffect = function(params) {
  this.cameraTarget.fadeIn(...params);
};
var OnParseFadeInCameraTag_default = OnParseFadeInCameraTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/camera/OnParseFadeOutCameraTag.js
var OnParseFadeOutCameraTag = function(textPlayer, parser, config) {
  var tagName = "camera.fadeout";
  parser.on(`+${tagName}`, function(duration, red, green, blue) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlayFadeOutEffect,
      // callback
      [duration, red, green, blue],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PlayFadeOutEffect = function(params) {
  this.cameraTarget.fadeOut(...params);
};
var OnParseFadeOutCameraTag_default = OnParseFadeOutCameraTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/camera/OnParseShakeCameraTag.js
var OnParseShakeCameraTag = function(textPlayer, parser, config) {
  var tagName = "camera.shake";
  parser.on(`+${tagName}`, function(duration, intensity) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlayShakeEffect,
      // callback
      [duration, intensity],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PlayShakeEffect = function(params) {
  this.cameraTarget.shake(...params);
};
var OnParseShakeCameraTag_default = OnParseShakeCameraTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/camera/OnParseFlashCameraTag.js
var OnParseFlashCameraTag = function(textPlayer, parser, config) {
  var tagName = "camera.flash";
  parser.on(`+${tagName}`, function(duration, red, green, blue) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      PlayFlashEffect,
      // callback
      [duration, red, green, blue],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PlayFlashEffect = function(params) {
  this.cameraTarget.flash(...params);
};
var OnParseFlashCameraTag_default = OnParseFlashCameraTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/camera/OnParseZoomCameraTag.js
var OnParseZoomCameraTag = function(textPlayer, parser, config) {
  var tagName = "camera.zoom";
  parser.on(`+${tagName}`, function(value) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      Zoom,
      // callback
      value,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`+${tagName}.to`, function(value, duration, ease) {
    AppendCommand_default.call(
      textPlayer,
      "camera.zoom.to",
      // name
      ZoomTo,
      // callback
      [value, duration, ease],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var Zoom = function(value) {
  this.cameraTarget.setZoom(value);
};
var ZoomTo = function(params) {
  this.cameraTarget.zoomTo(...params);
};
var OnParseZoomCameraTag_default = OnParseZoomCameraTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/camera/OnParseRotateCameraTag.js
var DegToRad5 = Phaser.Math.DegToRad;
var OnParseRotateCameraTag = function(textPlayer, parser, config) {
  var tagName = "camera.rotate";
  parser.on(`+${tagName}`, function(value) {
    value = DegToRad5(value);
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      Rotate,
      // callback
      value,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`+${tagName}.to`, function(value, duration, ease) {
    value = DegToRad5(value);
    AppendCommand_default.call(
      textPlayer,
      "camera.rotate.to",
      // name
      RotateTo,
      // callback
      [value, duration, ease],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var Rotate = function(value) {
  this.cameraTarget.setRotation(value);
};
var RotateTo = function(params) {
  var value = params[0];
  var duration = params[1];
  var ease = params[2];
  this.cameraTarget.rotateTo(value, false, duration, ease);
};
var OnParseRotateCameraTag_default = OnParseRotateCameraTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/camera/OnParseScrollCameraTag.js
var OnParseScrollCameraTag = function(textPlayer, parser, config) {
  var tagName = "camera.scroll";
  parser.on(`+${tagName}`, function(x, y) {
    AppendCommand_default.call(
      textPlayer,
      tagName,
      // name
      Scroll,
      // callback
      [x, y],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on(`+${tagName}.to`, function(x, y, duration, ease) {
    AppendCommand_default.call(
      textPlayer,
      "camera.scroll.to",
      // name
      ScrollTo,
      // callback
      [x, y, duration, ease],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var Scroll = function(params) {
  this.cameraTarget.setScroll(...params);
};
var ScrollTo = function(params) {
  var x = params[0];
  var y = params[1];
  var duration = params[2];
  var ease = params[3];
  var camera = this.cameraTarget;
  var xSave = camera.scrollX;
  var ySave = camera.scrollY;
  camera.setScroll(x, y);
  x += camera.centerX;
  y += camera.centerY;
  camera.setScroll(xSave, ySave);
  camera.pan(x, y, duration, ease);
};
var OnParseScrollCameraTag_default = OnParseScrollCameraTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/wait/OnParseWaitTag.js
var OnParseWaitTag = function(textPlayer, parser, config) {
  var tagWait = "wait";
  var tagClick = "click";
  parser.on(`+${tagWait}`, function(name2) {
    AppendCommand3(textPlayer, name2);
    parser.skipEvent();
  }).on(`-${tagWait}`, function() {
    parser.skipEvent();
  }).on(`+${tagClick}`, function() {
    AppendCommand3(textPlayer, "click");
    parser.skipEvent();
  }).on(`-${tagClick}`, function() {
    parser.skipEvent();
  });
};
var Wait = function(name2) {
  this.typeWriter.wait(name2);
};
var AppendCommand3 = function(textPlayer, name2) {
  AppendCommand_default.call(
    textPlayer,
    "wait",
    // name
    Wait,
    // callback
    name2,
    // params
    textPlayer
    // scope
  );
};
var OnParseWaitTag_default = OnParseWaitTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/content/OnParseNewLineTag.js
var OnParseNewLineTag = function(textPlayer, parser, config) {
  var tagName = "r";
  parser.on(`+${tagName}`, function() {
    AppendText_default2.call(textPlayer, "\n");
    parser.skipEvent();
  }).on(`-${tagName}`, function() {
    parser.skipEvent();
  });
};
var OnParseNewLineTag_default = OnParseNewLineTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/content/OnParsePageBreakTag.js
var OnParsePageBreakTag = function(textPlayer, parser, config) {
  var tagNames = ["pagebreak", "pb"];
  for (var i = 0, cnt = tagNames.length; i < cnt; i++) {
    var tagName = tagNames[i];
    parser.on(`+${tagName}`, function() {
      AppendText_default2.call(textPlayer, "\f");
      parser.skipEvent();
    }).on(`-${tagName}`, function() {
      parser.skipEvent();
    });
  }
};
var OnParsePageBreakTag_default = OnParsePageBreakTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/content/OnParseContentOff.js
var OnParseContentOff = function(textPlayer, parser, config) {
  var tagName = "content.off";
  parser.on(`+${tagName}`, function() {
    parser.setContentOutputEnable(false);
    parser.skipEvent();
  });
};
var OnParseContentOff_default = OnParseContentOff;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/content/OnParseContentOn.js
var OnParseContentOn = function(textPlayer, parser, config) {
  var tagName = "content.on";
  parser.on(`+${tagName}`, function() {
    parser.setContentOutputEnable();
    parser.skipEvent();
  });
};
var OnParseContentOn_default = OnParseContentOn;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/content/OnParseContent.js
var OnParseContent = function(textPlayer, parser, config) {
  parser.on("content", function(content) {
    if (parser.contentOutputEnable) {
      AppendText_default2.call(textPlayer, content);
    } else {
      var startTag = `+${parser.lastTagStart}`;
      textPlayer.emit(`parser.${startTag}#content`, parser, content);
    }
  });
};
var OnParseContent_default = OnParseContent;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/custom/OnParseCustomTag.js
var OnParseCustomTag = function(textPlayer, parser, config) {
  parser.on("start", function() {
    textPlayer.emit("parser.start", parser);
  }).on("+", function(tagName, ...value) {
    if (parser.skipEventFlag) {
      return;
    }
    var startTag = `+${tagName}`;
    var param = value;
    textPlayer.emit(`parser.${startTag}`, parser, ...value, param);
    AppendCommand4(textPlayer, startTag, param);
  }).on("-", function(tagName) {
    if (parser.skipEventFlag) {
      return;
    }
    var endTag = `-${tagName}`;
    var param = [];
    textPlayer.emit(`parser.${endTag}`, parser, param);
    AppendCommand4(textPlayer, endTag, param);
  }).on("complete", function() {
    textPlayer.emit("parser.complete", parser);
  });
};
var FireEvent2 = function(param, tagName) {
  var eventName = `tag.${tagName}`;
  if (param == null) {
    this.emit(eventName);
  } else {
    this.emit(eventName, ...param);
  }
};
var AppendCommand4 = function(textPlayer, name2, param) {
  AppendCommand_default.call(
    textPlayer,
    name2,
    // name
    FireEvent2,
    // callback
    param,
    // params
    textPlayer
    // scope
  );
};
var OnParseCustomTag_default = OnParseCustomTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/AddParseCallbacks.js
var ParseCallbacks = [
  OnParseColorTag_default,
  OnParseStrokeColorTag_default,
  OnParseBoldTag_default,
  OnParseItalicTag_default,
  OnParseFontSizeTag_default,
  OnParseShadowColorTag_default,
  OnParseAlignTag_default,
  OnParseOffsetYTag_default,
  OnParseOffsetXTag_default,
  OnParseLeftSpaceTag_default,
  OnParseRightSpaceTag_default,
  OnParseImageTag_default,
  OnParseSpaceTag_default,
  OnParseTypingSpeedTag_default,
  OnParsePlaySoundEffectTag_default,
  OnParseFadeInSoundEffectTag_default,
  OnParseFadeOutSoundEffectTag_default,
  OnParseSetSoundEffectVolumeTag_default,
  OnParseSetSoundEffectMuteTag_default,
  OnParsePlayBackgroundMusicTag_default,
  OnParseFadeInBackgroundMusicTag_default,
  OnParseFadeOutBackgroundMusicTag_default,
  OnParseCrossFadeBackgroundMusicTag_default,
  OnParsePauseBackgroundMusicTag_default,
  OnParseSetBackgroundMusicVolumeTag_default,
  OnParseSetBackgroundMusicMuteTag_default,
  OnParseFadeInCameraTag_default,
  OnParseFadeOutCameraTag_default,
  OnParseShakeCameraTag_default,
  OnParseFlashCameraTag_default,
  OnParseZoomCameraTag_default,
  OnParseRotateCameraTag_default,
  OnParseScrollCameraTag_default,
  OnParseWaitTag_default,
  OnParseNewLineTag_default,
  OnParsePageBreakTag_default,
  OnParseContentOff_default,
  OnParseContentOn_default,
  OnParseContent_default,
  OnParseCustomTag_default
];
var AddParseCallbacks = function(textPlayer, parser, config) {
  for (var i = 0, cnt = ParseCallbacks.length; i < cnt; i++) {
    ParseCallbacks[i](textPlayer, parser, config);
  }
};
var AddParseCallbacks_default = AddParseCallbacks;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/PreProcessSource.js
var PreProcess = function(parser, source) {
  var comentLineStart = parser.commentLineStart;
  var lines = source.split("\n");
  for (var i = 0, cnt = lines.length; i < cnt; i++) {
    var line = lines[i];
    if (line === "") {
    } else if (line.trim().length === 0) {
      lines[i] = "";
    } else if (comentLineStart && line.startsWith(comentLineStart)) {
      lines[i] = "";
    }
  }
  return lines.join("");
};
var PreProcessSource_default = PreProcess;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/parser/Parser.js
var GetValue44 = Phaser.Utils.Objects.GetValue;
var Parser3 = class extends bracketparser_default {
  constructor(textPlayer, config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("delimiters")) {
      config.delimiters = "[]";
    }
    super(config);
    AddParseCallbacks_default(textPlayer, this, config);
    this.setCommentLineStartSymbol(GetValue44(config, "comment", "//"));
    this.setContentOutputEnable();
  }
  setCommentLineStartSymbol(symbol) {
    this.commentLineStart = symbol;
    return this;
  }
  setContentOutputEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.contentOutputEnable = enable;
    return this;
  }
  start(source) {
    super.start(PreProcessSource_default(this, source));
    return this;
  }
};
var Parser_default3 = Parser3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/TypingSpeedMethods.js
var TypingSpeedMethods_default = {
  setDefaultTypingSpeed(speed) {
    this.defaultSpeed = speed;
    return this;
  },
  setTypingSpeed(speed) {
    if (speed === void 0) {
      speed = this.defaultSpeed;
    }
    this.speed = speed;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/utils/Events.js
var PageFadeOutCompleteEvent = "page.fadeout";
var StopPlayEvent = "_remove.play";
var ClearEvents = [
  PageFadeOutCompleteEvent,
  StopPlayEvent
];

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/FadeOutPage.js
var FadeOutPage = function() {
  if (!this.fadeOutPageCallback || !this.children) {
    this.emit(PageFadeOutCompleteEvent);
    return this;
  }
  var renderableChildren = this.children.filter(function(child) {
    return child.renderable;
  });
  var waitObject = this.fadeOutPageCallback(renderableChildren, this.fadeOutPageDuration);
  if (!waitObject) {
    this.emit(PageFadeOutCompleteEvent);
  } else if (waitObject.once) {
    waitObject.once("complete", function() {
      this.emit(PageFadeOutCompleteEvent);
    }, this);
  } else if (waitObject.then) {
    var self = this;
    waitObject.then(function() {
      self.emit(PageFadeOutCompleteEvent);
    });
  } else {
    this.emit(PageFadeOutCompleteEvent);
  }
  return this;
};
var FadeOutPage_default = FadeOutPage;

// node_modules/phaser3-rex-plugins/plugins/utils/promise/WaitEvent.js
var WaitEvent2 = function(eventEmitter, eventName) {
  return new Promise(function(resolve, reject) {
    eventEmitter.once(eventName, function() {
      resolve();
    });
  });
};
var WaitComplete = function(eventEmitter) {
  return WaitEvent2(eventEmitter, "complete");
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/Start.js
var Start = function(children) {
  this.children = children;
  this.index = 0;
  this.isPageTyping = true;
  if (this.onTypeStart) {
    this.onTypeStart(children);
  }
  this.typing();
  return WaitComplete(this);
};
var Start_default = Start;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/TimerTypes.js
var TypingDelayTimerType = "delay";
var TypingAnimationTimerType = "anim";

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/Typing.js
var Typing = function(offsetTime) {
  if (offsetTime === void 0) {
    offsetTime = 0;
  }
  var delay = 0;
  this.inTypingProcessLoop = true;
  while (this.inTypingProcessLoop) {
    var child = this.getNextChild();
    if (!child) {
      if (this.timeline.isRunning) {
        this.timeline.once("complete", function() {
          this.isPageTyping = false;
          this.emit("complete");
        }, this);
      } else {
        this.isPageTyping = false;
        this.emit("complete");
      }
      break;
    }
    if (child.renderable) {
      var animationConfig = this.animationConfig;
      if (animationConfig.duration > 0) {
        var animationTimer = this.timeline.addTimer({
          name: TypingAnimationTimerType,
          target: child,
          duration: animationConfig.duration,
          yoyo: animationConfig.yoyo,
          onStart: animationConfig.onStart,
          onProgress: animationConfig.onProgress,
          onComplete: animationConfig.onComplete
        });
        if (this.skipTypingAnimation) {
          animationTimer.seek(1);
        }
      } else {
        if (animationConfig.onStart) {
          animationConfig.onStart(child, 0);
        }
      }
      if (this.minSizeEnable) {
        this.textPlayer.setToMinSize();
      }
      this.textPlayer.emit("typing", child);
      var nextChild = this.nextChild;
      if (nextChild) {
        if (this.skipSpaceEnable && IsSpaceChar(nextChild)) {
        } else {
          delay += this.speed + offsetTime;
          offsetTime = 0;
          if (delay > 0) {
            this.typingTimer = this.timeline.addTimer({
              name: TypingDelayTimerType,
              target: this,
              duration: delay,
              onComplete: function(target, t, timer) {
                target.typingTimer = void 0;
                Typing.call(target, timer.remainder);
              }
            });
            break;
          }
        }
      }
    } else if (IsCommand(child)) {
      child.exec();
    }
  }
  if (this.minSizeEnable) {
    this.textPlayer.setToMinSize();
  }
  this.inTypingProcessLoop = false;
};
var Typing_default = Typing;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/Pause.js
var Pause = function() {
  this.timeline.pause();
  return this;
};
var Pause_default = Pause;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/Resume.js
var Resume = function() {
  this.timeline.resume();
  return this;
};
var Resume_default = Resume;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/PauseTyping.js
var PauseTyping = function() {
  if (this.isTypingPaused) {
    return this;
  }
  if (this.typingTimer) {
    this.typingTimer.pause();
    this.isTypingPaused = true;
  } else if (this.inTypingProcessLoop) {
    this.inTypingProcessLoop = false;
    this.isTypingPaused = true;
  }
  return this;
};
var PauseTyping_default = PauseTyping;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/ResumeTyping.js
var ResumeTyping = function(offsetTime) {
  if (!this.isTypingPaused) {
    return this;
  }
  if (offsetTime === void 0) {
    offsetTime = 0;
  }
  if (this.typingTimer) {
    this.isTypingPaused = false;
    this.typingTimer.resume();
    this.typingTimer.remainder += offsetTime;
  } else if (this.isTypingPaused) {
    this.isTypingPaused = false;
    this.typing(offsetTime);
  }
  return this;
};
var ResumeTyping_default = ResumeTyping;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/utils/wait/WaitCameraEffect.js
var IsWaitCameraEffect = function(name2) {
  switch (name2) {
    case "camera.fadein":
    case "camera.fadeout":
    case "camera.flash":
    case "camera.shake":
    case "camera.zoom":
    case "camera.rotate":
    case "camera.scroll":
      return true;
    default:
      return false;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/utils/wait/WaitGameObject.js
var IsWaitGameObject = function(textPlayer, name2) {
  var names = name2.split(".");
  return textPlayer.gameObjectManagers.hasOwnProperty(names[0]);
};
var WaitGameObject = function(textPlayer, tag, callback, scope) {
  var waitEventManager = textPlayer.waitEventManager;
  var tags = tag.split(".");
  var goType = tags[0];
  var gameObjectManager = textPlayer.getGameObjectManager(goType);
  var waitEventName = `wait.${goType}`;
  switch (tags.length) {
    case 1:
      waitEventManager.waitGameObjectManagerEmpty(goType);
      textPlayer.emit(waitEventName);
      return;
    case 2:
      var name2 = tags[1];
      waitEventManager.waitGameObjectDestroy(goType, name2);
      textPlayer.emit(waitEventName, name2);
      return;
    case 3:
      var name2 = tags[1], prop = tags[2];
      var value = gameObjectManager.getProperty(name2, prop);
      if (typeof value === "number") {
        waitEventManager.waitGameObjectTweenComplete(goType, name2, prop);
        textPlayer.emit(waitEventName, name2, prop);
        return;
      }
      var dataKey = prop;
      var matchFalseFlag = dataKey.startsWith("!");
      if (matchFalseFlag) {
        dataKey = dataKey.substring(1);
      }
      if (gameObjectManager.hasData(name2, dataKey)) {
        waitEventManager.waitGameObjectDataFlag(goType, name2, dataKey, !matchFalseFlag);
        textPlayer.emit(waitEventName, name2, dataKey);
        return;
      } else {
        waitEventManager.waitTime(0);
        return;
      }
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/utils/wait/WaitAny.js
var KeyCodes = Phaser.Input.Keyboard.KeyCodes;
var WaitAny2 = function(textPlayer, names, callback, scope) {
  var waitEventManager = textPlayer.waitEventManager;
  waitEventManager.clearWaitCompleteCallbacks().addWaitCompleteCallback(callback, scope);
  if (typeof names === "string" && names.length > 1 && names.indexOf("|") !== -1) {
    names = names.split("|");
  } else {
    names = [names];
  }
  for (var i = 0, cnt = names.length; i < cnt; i++) {
    var name2 = names[i];
    if (name2 == null || name2 === "wait") {
      var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
      textPlayer.emit("wait", waitCompleteTriggerCallback);
    } else if (typeof name2 === "number" || !isNaN(name2)) {
      var time = parseFloat(name2);
      waitEventManager.waitTime(time);
      textPlayer.emit("wait.time", time);
    } else if (name2 === "click") {
      waitEventManager.waitClick();
      textPlayer.emit("wait.click");
    } else if (name2 === "se") {
      waitEventManager.waitSoundEffectComplete();
      var music = textPlayer.soundManager.getLastSoundEffect();
      textPlayer.emit("wait.music", music);
    } else if (name2 === "se2") {
      waitEventManager.waitSoundEffect2Complete();
      var music = textPlayer.soundManager.getLastSoundEffect2();
      textPlayer.emit("wait.music", music);
    } else if (name2 === "bgm") {
      waitEventManager.waitBackgroundMusicComplete();
      var music = textPlayer.soundManager.getBackgroundMusic();
      textPlayer.emit("wait.music", music);
    } else if (name2 === "bgm2") {
      waitEventManager.waitBackgroundMusic2Complete();
      var music = textPlayer.soundManager.getBackgroundMusic2();
      textPlayer.emit("wait.music", music);
    } else if (KeyCodes.hasOwnProperty(name2.toUpperCase())) {
      waitEventManager.waitKeyDown(name2);
      textPlayer.emit("wait.keydown", name2);
    } else if (IsWaitCameraEffect(name2)) {
      waitEventManager.waitCameraEffectComplete(name2);
      textPlayer.emit("wait.camera", name2);
    } else if (IsWaitGameObject(textPlayer, name2)) {
      WaitGameObject(textPlayer, name2, callback, scope);
    } else {
      var waitCompleteTriggerCallback = textPlayer.waitEventManager.getWaitCompleteTriggerCallback();
      textPlayer.emit(`wait.${name2}`, waitCompleteTriggerCallback);
    }
  }
};
var WaitAny_default2 = WaitAny2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/Wait.js
var Wait2 = function(name2) {
  if (this.ignoreWait) {
    return this;
  }
  this.pauseTyping();
  WaitAny_default2(this.textPlayer, name2, this.resumeTyping, this);
  return this;
};
var Wait_default = Wait2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/SetIgnoreWait.js
var SetIgnoreWait = function(value) {
  if (value === void 0) {
    value = true;
  }
  this.ignoreWait = value;
  return this;
};
var SetIgnoreWait_default = SetIgnoreWait;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/SetSkipSpaceEnable.js
var SetSkipSpaceEnable = function(enable) {
  if (enable === void 0) {
    enable = true;
  }
  this.skipSpaceEnable = enable;
  return this;
};
var SetSkipSpaceEnable_default = SetSkipSpaceEnable;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/SetSkipTypingAnimation.js
var SetSkipTypingAnimation = function(value) {
  if (value === void 0) {
    value = true;
  }
  this.skipTypingAnimation = value;
  if (value) {
    var timers = this.timeline.getTimers(TypingAnimationTimerType);
    for (var i = 0, cnt = timers.length; i < cnt; i++) {
      timers[i].seek(1);
    }
  }
  return this;
};
var SetSkipTypingAnimation_default = SetSkipTypingAnimation;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/SetSkipSoundEffect.js
var SetSkipSoundEffect = function(value) {
  if (value === void 0) {
    value = true;
  }
  this.skipSoundEffect = value;
  if (value) {
    var soundManager = this.textPlayer._soundManager;
    if (soundManager) {
      soundManager.fadeOutAllSoundEffects(100, true);
    }
  }
  return this;
};
var SetSkipSoundEffect_default = SetSkipSoundEffect;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/SkipCurrentTypingDelay.js
var SkipCurrentTypingDelay = function() {
  if (this.typingTimer) {
    this.typingTimer.seek(1);
  }
  return this;
};
var SkipCurrentTypingDelay_default = SkipCurrentTypingDelay;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/Methods.js
var Methods6 = {
  fadeOutPage: FadeOutPage_default,
  start: Start_default,
  typing: Typing_default,
  pause: Pause_default,
  resume: Resume_default,
  pauseTyping: PauseTyping_default,
  resumeTyping: ResumeTyping_default,
  wait: Wait_default,
  setIgnoreWait: SetIgnoreWait_default,
  setSkipSpaceEnable: SetSkipSpaceEnable_default,
  setSkipTypingAnimation: SetSkipTypingAnimation_default,
  setSkipSoundEffect: SetSkipSoundEffect_default,
  skipCurrentTypingDelay: SkipCurrentTypingDelay_default
};
Object.assign(
  Methods6,
  TypingSpeedMethods_default
);
var Methods_default10 = Methods6;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/typewriter/TypeWriter.js
var GetValue45 = Phaser.Utils.Objects.GetValue;
var TypeWriter = class {
  constructor(textPlayer, config) {
    this.setEventEmitter();
    this.textPlayer = textPlayer;
    this.isPageTyping = false;
    this.typingTimer = void 0;
    this.pauseTypingTimer = void 0;
    this.inTypingProcessLoop = false;
    this.isTypingPaused = false;
    this.setIgnoreWait(false);
    this.setSkipTypingAnimation(false);
    this.setTypingStartCallback(GetValue45(config, "onTypingStart", SetChildrenInvisible));
    this.setDefaultTypingSpeed(GetValue45(config, "speed", 250));
    this.setTypingSpeed();
    this.setSkipSpaceEnable(GetValue45(config, "skipSpace", false));
    this.setAnimationConfig(GetValue45(config, "animation", void 0));
    this.setMinSizeEnable(GetValue45(config, "minSizeEnable", false));
    this.setFadeOutPageCallback(GetValue45(config, "fadeOutPage"));
  }
  destroy() {
    this.destroyEventEmitter();
    this.textPlayer = void 0;
    this.typingTimer = void 0;
    this.pauseTypingTimer = void 0;
    this.onTypeStart = void 0;
    this.animationConfig = void 0;
  }
  get timeline() {
    return this.textPlayer.timeline;
  }
  setTypingStartCallback(callback) {
    this.onTypeStart = callback;
    return this;
  }
  setAnimationConfig(config) {
    if (!config) {
      config = {};
    }
    if (!config.hasOwnProperty("duration")) {
      config.duration = 0;
    }
    if (!config.hasOwnProperty("onStart")) {
      config.onStart = SetChildVisible;
    }
    this.animationConfig = config;
    return this;
  }
  setFadeOutPageCallback(callback) {
    this.fadeOutPageCallback = callback;
    return this;
  }
  setMinSizeEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.minSizeEnable = enable;
    return this;
  }
  getNextChild() {
    var child = this.nextChild;
    this.index = Math.min(this.index + 1, this.children.length);
    this._nextChild = void 0;
    return child;
  }
  get nextChild() {
    if (!this._nextChild) {
      this._nextChild = this.children[this.index];
    }
    return this._nextChild;
  }
};
var SetChildVisible = function(child) {
  if (child.setVisible) {
    child.setVisible();
  }
};
var SetChildrenInvisible = function(children) {
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (child.setVisible) {
      child.setVisible(false);
    }
  }
};
Object.assign(
  TypeWriter.prototype,
  EventEmitterMethods_default,
  Methods_default10
);
var TypeWriter_default = TypeWriter;

// node_modules/phaser3-rex-plugins/plugins/utils/sprite/spritemanager/SpriteBob.js
var SpriteBob = class extends BobBase_default {
  playAnimation(key2) {
    this.gameObject.anims.timeScale = this.timeScale;
    this.gameObject.play(key2);
    return this;
  }
  stopAnimation() {
    this.gameObject.stop();
    return this;
  }
  chainAnimation(keys) {
    this.gameObject.chain(keys);
    return this;
  }
  pauseAnimation() {
    this.gameObject.anims.pause();
    return this;
  }
  setTimeScale(timeScale) {
    super.setTimeScale(timeScale);
    if (this.gameObject.anims) {
      this.gameObject.anims.timeScale = timeScale;
    }
    return this;
  }
};
var SpriteBob_default = SpriteBob;

// node_modules/phaser3-rex-plugins/plugins/utils/sprite/spritemanager/methods/AnimationMethods.js
var AnimationMethods_default = {
  playAnimation(name2, key2) {
    if (!this.has(name2)) {
      this.add(name2);
    }
    this.get(name2).playAnimation(key2);
    return this;
  },
  stopAnimation(name2) {
    if (!this.has(name2)) {
      return this;
    }
    this.get(name2).stopAnimation();
    return this;
  },
  chainAnimation(name2, keys) {
    if (!this.has(name2)) {
      return this;
    }
    this.get(name2).chainAnimation(keys);
    return this;
  },
  pauseAnimation(name2) {
    if (!this.has(name2)) {
      return this;
    }
    this.get(name2).pauseAnimation();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/sprite/spritemanager/methods/Methods.js
var Methods7 = {};
Object.assign(
  Methods7,
  AnimationMethods_default
);
var Methods_default11 = Methods7;

// node_modules/phaser3-rex-plugins/plugins/utils/sprite/spritemanager/methods/GetCreateGameObjectCallback.js
var GetCreateGameObjectCallback = function(callback) {
  if (!callback || callback === "sprite") {
    callback = CreateSprite;
  } else if (callback === "image") {
    callback = CreateImage;
  }
  return callback;
};
var CreateSprite = function(scene, textureKey, frameName) {
  if (typeof frameName !== "string" && typeof frameName !== "number") {
    frameName = void 0;
  }
  return scene.add.sprite(0, 0, textureKey, frameName);
};
var CreateImage = function(scene, textureKey, frameName) {
  if (typeof frameName !== "string" && typeof frameName !== "number") {
    frameName = void 0;
  }
  return scene.add.image(0, 0, textureKey, frameName);
};
var GetCreateGameObjectCallback_default = GetCreateGameObjectCallback;

// node_modules/phaser3-rex-plugins/plugins/utils/sprite/spritemanager/SpriteManager.js
var SpriteManager = class extends GOManager_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.BobClass = SpriteBob_default;
    super(scene, config);
  }
  setCreateGameObjectCallback(callback, scope) {
    callback = GetCreateGameObjectCallback_default(callback);
    super.setCreateGameObjectCallback(callback, scope);
    return this;
  }
};
Object.assign(
  SpriteManager.prototype,
  Methods_default11
);
var SpriteManager_default = SpriteManager;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/spritemanager/OnParsePlayAnimationTag.js
var IsPlayAnimationTag = function(tags, goType) {
  return tags.length === 3 && tags[0] === goType && tags[2] === "play";
};
var IsStopAnimationTag = function(tags, goType) {
  return tags.length === 3 && tags[0] === goType && tags[2] === "stop";
};
var OnParsePlayAnimationTag = function(textPlayer, parser, config) {
  var goType = config.name;
  parser.on("+", function(tag, ...keys) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2;
    if (IsPlayAnimationTag(tags, goType)) {
      name2 = tags[1];
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.play`,
      // name
      PlayAnimation,
      // callback
      [goType, name2, keys],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on("+", function(tag) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2;
    if (IsStopAnimationTag(tags, goType)) {
      name2 = tags[1];
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.stop`,
      // name
      StopAnimation,
      // callback
      [goType, name2],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on("-", function(tag) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2;
    if (IsPlayAnimationTag(tags, goType)) {
      name2 = tags[1];
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.stop`,
      // name
      StopAnimation,
      // callback
      [goType, name2],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PlayAnimation = function(params) {
  var goType, name2, keys;
  [goType, name2, keys] = params;
  var key2 = keys.shift();
  var gameObjectManager = this.getGameObjectManager(goType);
  gameObjectManager.playAnimation(name2, key2);
  if (keys.length > 0) {
    gameObjectManager.chainAnimation(name2, keys);
  }
};
var StopAnimation = function(params) {
  var goType, args;
  [goType, ...args] = params;
  var gameObjectManager = this.getGameObjectManager(goType);
  gameObjectManager.stopAnimation(...args);
};
var OnParsePlayAnimationTag_default = OnParsePlayAnimationTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/spritemanager/OnParsePauseAnimationTag.js
var IsPauseAnimationTag = function(tags, goType) {
  return tags.length === 3 && tags[0] === goType && tags[2] === "pause";
};
var OnParsePauseAnimationTag = function(textPlayer, parser, config) {
  var goType = config.name;
  parser.on("+", function(tag) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2;
    if (IsPauseAnimationTag(tags, goType)) {
      name2 = tags[1];
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.pause`,
      // name
      PauseAnimation,
      // callback
      [goType, name2],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var PauseAnimation = function(params) {
  var goType, args;
  [goType, ...args] = params;
  var gameObjectManager = this.getGameObjectManager(goType);
  gameObjectManager.pauseAnimation(...args);
};
var OnParsePauseAnimationTag_default = OnParsePauseAnimationTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/spritemanager/OnParseChainAnimationTag.js
var IsChainAnimationTag = function(tags, goType) {
  return tags.length === 3 && tags[0] === goType && tags[2] === "chain";
};
var OnParseChainAnimationTag = function(textPlayer, parser, config) {
  var goType = config.name;
  parser.on("+", function(tag) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2;
    if (IsChainAnimationTag(tags, goType)) {
      name2 = tags[1];
    } else {
      return;
    }
    var keys = Array.prototype.slice.call(arguments, 1);
    AppendCommand_default.call(
      textPlayer,
      `${goType}.chain`,
      // name
      ChainAnimation,
      // callback
      [goType, name2, keys],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var ChainAnimation = function(params) {
  var goType, args;
  [goType, ...args] = params;
  var gameObjectManager = this.getGameObjectManager(goType);
  gameObjectManager.chainAnimation(...args);
};
var OnParseChainAnimationTag_default = OnParseChainAnimationTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/spritemanager/AddSpriteManager.js
var ParseCallbacks2 = [
  OnParsePlayAnimationTag_default,
  OnParsePauseAnimationTag_default,
  OnParseChainAnimationTag_default
];
var AddSpriteManager = function(config) {
  if (config === void 0) {
    config = {};
  }
  config.name = "sprite";
  config.parseCallbacks = ParseCallbacks2;
  config.createGameObject = GetCreateGameObjectCallback_default(config.createGameObject);
  this.addGameObjectManager(config, SpriteManager_default);
};
var AddSpriteManager_default = AddSpriteManager;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/gameobjectmanager/OnParseAddGameObjectTag.js
var IsAddGameObjectTag = function(tags, goType) {
  return tags.length === 2 && tags[0] === goType;
};
var OnParseAddGameObjectTag = function(textPlayer, parser, config) {
  var goType = config.name;
  parser.on("+", function(tag, ...args) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2;
    if (IsAddGameObjectTag(tags, goType)) {
      name2 = tags[1];
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.add`,
      // name
      AddGameObject,
      // callback
      [goType, name2, ...args],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  }).on("-", function(tag) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2;
    if (IsAddGameObjectTag(tags, goType)) {
      name2 = tags[1];
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.remove`,
      // name
      RemoveGameObject,
      // callback
      [goType, name2],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var AddGameObject = function(params) {
  var goType, args;
  [goType, ...args] = params;
  var gameObjectManager = this.getGameObjectManager(goType);
  gameObjectManager.add(...args);
};
var RemoveGameObject = function(params) {
  var goType, args;
  [goType, ...args] = params;
  var gameObjectManager = this.getGameObjectManager(goType);
  gameObjectManager.remove(...args);
};
var OnParseAddGameObjectTag_default = OnParseAddGameObjectTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/gameobjectmanager/OnParseRemoveAllGameObjectsTag.js
var OnParseRemoveAllGameObjectsTag = function(textPlayer, parser, config) {
  var goType = config.name;
  parser.on("-", function(tag) {
    if (parser.skipEventFlag) {
      return;
    }
    if (tag === goType) {
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.removeall`,
      // name
      RemoveAllSprites,
      // callback
      goType,
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var RemoveAllSprites = function(goType) {
  var gameObjectManager = this.getGameObjectManager(goType);
  gameObjectManager.removeAll();
};
var OnParseRemoveAllGameObjectsTag_default = OnParseRemoveAllGameObjectsTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/gameobjectmanager/OnParseCallGameObjectMethodTag.js
var IsPropTag = function(tags, goType) {
  return tags.length === 3 && tags[0] === goType;
};
var OnParseCallGameObjectMethodTag = function(textPlayer, parser, config) {
  var goType = config.name;
  parser.on(`+`, function(tag, ...parameters) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2, prop;
    if (IsPropTag(tags, goType)) {
      name2 = tags[1];
      prop = tags[2];
    } else {
      return;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.call`,
      // name
      CallMethod,
      // callback
      [goType, name2, prop, ...parameters],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var CallMethod = function(params) {
  var goType, name2, prop, args;
  [goType, name2, prop, ...args] = params;
  var eventName = `${goType}.${prop}`;
  this.emit(
    eventName,
    name2,
    ...args
  );
  if (this.listenerCount(eventName) > 0) {
    return;
  }
  var gameObjectManager = this.getGameObjectManager(goType);
  if (gameObjectManager.hasMethod(name2, prop)) {
    gameObjectManager.call(name2, prop, ...args);
  } else {
    gameObjectManager.setProperty(name2, prop, args[0]);
  }
};
var OnParseCallGameObjectMethodTag_default = OnParseCallGameObjectMethodTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/gameobjectmanager/OnParseEaseGameObjectPropertyTag.js
var EaseMode = {
  to: true,
  yoyo: true,
  from: true,
  toLeft: true,
  toRight: true,
  toUp: true,
  toDown: true,
  yoyoLeft: true,
  yoyoRight: true,
  yoyoUp: true,
  yoyoDown: true,
  fromLeft: true,
  fromRight: true,
  fromUp: true,
  fromDown: true
};
var IsEasePropertyTag = function(tags, goType) {
  return tags.length === 4 && tags[0] === goType && EaseMode[tags[3]];
};
var OnParseEaseGameObjectPropertyTag = function(textPlayer, parser, config) {
  var goType = config.name;
  var gameObjectManager = textPlayer.getGameObjectManager(goType);
  parser.on(`+`, function(tag, value, duration, ease, repeat) {
    if (parser.skipEventFlag) {
      return;
    }
    var tags = tag.split(".");
    var name2, property, easeMode;
    if (IsEasePropertyTag(tags, goType)) {
      name2 = tags[1];
      property = tags[2];
      easeMode = tags[3];
    } else {
      return;
    }
    if (typeof ease === "number") {
      repeat = ease;
      ease = void 0;
    }
    AppendCommand_default.call(
      textPlayer,
      `${goType}.ease`,
      // name
      EaseProperty,
      // callback
      [
        goType,
        name2,
        property,
        value,
        duration,
        ease,
        repeat,
        easeMode
      ],
      // params
      textPlayer
      // scope
    );
    parser.skipEvent();
  });
};
var EaseProperty = function(params) {
  var goType, name2, property, value, duration, ease, repeat, easeMode;
  [
    goType,
    name2,
    property,
    value,
    duration,
    ease,
    repeat,
    easeMode
  ] = params;
  var gameObjectManager = this.getGameObjectManager(goType);
  var currentValue = gameObjectManager.getProperty(name2, property);
  if (typeof currentValue !== "number") {
    return;
  }
  if (easeMode.endsWith("Left") || easeMode.endsWith("Up")) {
    if (easeMode.startsWith("to") || easeMode.startsWith("yoyo")) {
      value = currentValue - value;
    } else if (easeMode.startsWith("from")) {
      gameObjectManager.setProperty(name2, property, currentValue - value);
      value = currentValue;
    }
  } else if (easeMode.endsWith("Right") || easeMode.endsWith("Down")) {
    if (easeMode.startsWith("to") || easeMode.startsWith("yoyo")) {
      value = currentValue + value;
    } else if (easeMode.startsWith("from")) {
      gameObjectManager.setProperty(name2, property, currentValue + value);
      value = currentValue;
    }
  } else if (easeMode === "from") {
    gameObjectManager.setProperty(name2, property, value);
    value = currentValue;
  }
  var isYoyo = easeMode.startsWith("yoyo");
  gameObjectManager.easeProperty(
    name2,
    {
      property,
      value,
      duration,
      ease,
      repeat,
      yoyo: isYoyo
    }
  );
};
var OnParseEaseGameObjectPropertyTag_default = OnParseEaseGameObjectPropertyTag;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/gameobjectmanager/GameObjectManagerMethods.js
var ParseCallbacks3 = [
  OnParseAddGameObjectTag_default,
  OnParseRemoveAllGameObjectsTag_default,
  OnParseCallGameObjectMethodTag_default,
  OnParseEaseGameObjectPropertyTag_default
];
var AddGameObjectManager = GameObjectManagerMethods_default.addGameObjectManager;
var GameObjectManagerMethods_default2 = {
  addGameObjectManager(config, GameObjectManagerClass) {
    config = config ? Clone_default(config) : {};
    var name2 = config.name;
    if (!name2) {
      console.warn(`[TextPlayer] Parameter 'name' is required in addGameObjectManager(config) method`);
    }
    var defaultLayer = config.defaultLayer;
    var createGameObject = config.createGameObject;
    var layerManager = this.layerManager;
    config.createGameObject = function(scene, ...args) {
      var gameObject2 = createGameObject.call(this, scene, ...args);
      if (defaultLayer && layerManager) {
        layerManager.addToLayer(defaultLayer, gameObject2);
      }
      return gameObject2;
    };
    AddGameObjectManager.call(this, config, GameObjectManagerClass);
    var customParseCallbacks = config.parseCallbacks;
    if (!customParseCallbacks) {
      customParseCallbacks = ParseCallbacks3;
    } else {
      customParseCallbacks = [
        ...customParseCallbacks,
        // customParseCallbacks have higher priority
        ...ParseCallbacks3
      ];
    }
    for (var i = 0, cnt = customParseCallbacks.length; i < cnt; i++) {
      customParseCallbacks[i](this, this.parser, config);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/SetClickTarget.js
var SetClickTarget = function(target) {
  this.waitEventManager.setClickTarget(target);
  return this;
};
var SetClickTarget_default = SetClickTarget;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/SetCameraTarget.js
var SetCameraTarget = function(camera) {
  this.waitEventManager.setCameraTarget(camera);
  return this;
};
var SetCameraTarget_default = SetCameraTarget;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/SetNextPageInput.js
var SetNextPageInput = function(input) {
  var textPlayer = this;
  if (!input) {
    this.nextPageInput = null;
  } else if (typeof input === "function") {
    this.nextPageInput = function(callback, scope) {
      var waitEventManager = textPlayer.waitEventManager;
      waitEventManager.clearWaitCompleteCallbacks().addWaitCompleteCallback(callback, scope);
      var waitCompleteTriggerCallback = waitEventManager.getWaitCompleteTriggerCallback();
      input.call(textPlayer, waitCompleteTriggerCallback);
    };
  } else {
    this.nextPageInput = function(callback, scope) {
      WaitAny_default2(textPlayer, input, callback, scope);
    };
  }
};
var SetNextPageInput_default = SetNextPageInput;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/AddImage.js
var AddImage3 = function(key2, config) {
  this.imageManager.add(key2, config);
  return this;
};
var AddImage_default3 = AddImage3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/PlayMethods.js
var PlayMethods_default = {
  play(content) {
    if (this.isPlaying) {
      return this;
    }
    this.removeChildren();
    this.parser.start(content);
    this.isPlaying = true;
    this.once("complete", function() {
      this.isPlaying = false;
    }, this);
    this.lastWrapResult = void 0;
    this.typingNextPage();
    return this;
  },
  playPromise(content) {
    var promise = WaitComplete(this);
    this.play(content);
    return promise;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/TypingNextPage.js
var TypingNextPage = function() {
  if (!this.isPlaying || this.isPageTyping) {
    return this;
  }
  this.typeWriter.once(PageFadeOutCompleteEvent, _TypingNextPage, this).fadeOutPage();
  return this;
};
var _TypingNextPage = function() {
  var result = this.runWrap(this.lastWrapResult);
  this.lastWrapResult = result;
  this.emit("page.start");
  var OnTypingPageComplete = function() {
    this.emit(StopPlayEvent);
    if (result.isLastPage) {
      this.emit("complete");
    } else {
      this.emit("page.complete");
      if (this.ignoreNextPageInput) {
        TypingNextPage.call(this);
      } else if (this.nextPageInput) {
        this.nextPageInput(TypingNextPage, this);
      } else {
      }
    }
  };
  this.once(StopPlayEvent, function() {
    this.typeWriter.off("complete", OnTypingPageComplete, this);
  }, this);
  this.typeWriter.once("complete", OnTypingPageComplete, this).start(result.children);
};
var TypingNextPage_default = TypingNextPage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/PauseMethods.js
var PauseMethods_default = {
  pauseTyping() {
    this.typeWriter.pauseTyping();
    return this;
  },
  pause() {
    this.pauseTyping();
    this.timeline.pause();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/ResumeMethods.js
var ResumeMethods_default = {
  resumeTyping(offsetTime) {
    this.typeWriter.resumeTyping(offsetTime);
    return this;
  },
  resume() {
    this.resumeTyping();
    this.timeline.resume();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/Wait.js
var Wait3 = function(name2) {
  this.typeWriter.wait(name2);
  return this;
};
var Wait_default2 = Wait3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/TypingSpeedMethods.js
var TypingSpeedMethods_default2 = {
  setDefaultTypingSpeed(speed) {
    this.defaultTypingSpeed = speed;
    return this;
  },
  setTypingSpeed(speed) {
    this.typingSpeed = speed;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/SetIgnoreWait.js
var SetIgnoreWait2 = function(value) {
  this.typeWriter.setIgnoreWait(value);
  return this;
};
var SetIgnoreWait_default2 = SetIgnoreWait2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/SetIgnoreNextPageInput.js
var SetIgnoreNextPageInput = function(enable) {
  if (enable === void 0) {
    enable = true;
  }
  this.ignoreNextPageInput = enable;
  return this;
};
var SetIgnoreNextPageInput_default = SetIgnoreNextPageInput;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/ShowPage.js
var ShowPage = function() {
  if (!this.isPlaying || !this.isPageTyping) {
    return this;
  }
  var typingSpeedSave = this.typeWriter.speed;
  var ignoreWaitSave = this.typeWriter.ignoreWait;
  var skipTypingAnimationSave = this.typeWriter.skipTypingAnimation;
  var skipSoundEffectSave = this.typeWriter.skipSoundEffect;
  this.typeWriter.once("complete", function() {
    this.typeWriter.setTypingSpeed(typingSpeedSave).setIgnoreWait(ignoreWaitSave).setSkipTypingAnimation(skipTypingAnimationSave).setSkipSoundEffect(skipSoundEffectSave);
  }, this).setTypingSpeed(0).skipCurrentTypingDelay().setIgnoreWait(true).setSkipTypingAnimation(true).setSkipSoundEffect(true);
  return this;
};
var ShowPage_default = ShowPage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/spritemanager/SpriteMethods.js
var SpriteMethods_default = {
  getSprite(name2) {
    return this.getGameObject("sprite", name2);
  },
  addSprite(name2, gameObject2) {
    this.addGameObject("sprite", name2, gameObject2);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/ContentMethods.js
var ContentMethods_default = {
  setContentOutputEnable(enable) {
    this.parser.setContentOutputEnable(enable);
    return this;
  },
  setContentCallback(callback, scope) {
    this.contentCallback = callback;
    this.contentCallbackScope = scope;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/Methods.js
var Methods8 = {
  setClickTarget: SetClickTarget_default,
  setCameraTarget: SetCameraTarget_default,
  setNextPageInput: SetNextPageInput_default,
  addImage: AddImage_default3,
  typingNextPage: TypingNextPage_default,
  wait: Wait_default2,
  setIgnoreWait: SetIgnoreWait_default2,
  setIgnoreNextPageInput: SetIgnoreNextPageInput_default,
  showPage: ShowPage_default
};
Object.assign(
  Methods8,
  GameObjectManagerMethods_default2,
  PlayMethods_default,
  PauseMethods_default,
  ResumeMethods_default,
  TypingSpeedMethods_default2,
  SpriteMethods_default,
  ContentMethods_default
);
var Methods_default12 = Methods8;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/methods/utils/ClearEvents.js
var ClearEvents2 = function(textPlayer) {
  for (var i = 0, cnt = ClearEvents.length; i < cnt; i++) {
    textPlayer.emit(ClearEvents[i]);
  }
};
var ClearEvents_default = ClearEvents2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/textplayer/TextPlayer.js
var IsPlainObject10 = Phaser.Utils.Objects.IsPlainObject;
var GetValue46 = Phaser.Utils.Objects.GetValue;
var TextPlayer = class extends Extend_default(DynamicText_default) {
  constructor(scene, x, y, fixedWidth, fixedHeight, config) {
    if (IsPlainObject10(x)) {
      config = x;
    } else if (IsPlainObject10(fixedWidth)) {
      config = fixedWidth;
    }
    if (config === void 0) {
      config = {};
    }
    var content = config.text;
    delete config.text;
    super(scene, x, y, fixedWidth, fixedHeight, config);
    this.type = "rexTextPlayer";
    this.initManagers(scene, config);
    this.parser = new Parser_default3(this, GetValue46(config, "parser", void 0));
    this.typeWriter = new TypeWriter_default(this, GetValue46(config, "typing", void 0));
    this._imageManager = void 0;
    var imageData = GetValue46(config, "images", void 0);
    if (imageData) {
      this.addImage(imageData);
    }
    var spriteManagerConfig = GetValue46(config, "sprites");
    if (spriteManagerConfig !== false && spriteManagerConfig !== null) {
      AddSpriteManager_default.call(this, spriteManagerConfig);
    }
    this.setIgnoreNextPageInput(GetValue46(config, "ignoreNextPageInput", false));
    this.setNextPageInput(GetValue46(config, "nextPageInput", null));
    this.isPlaying = false;
    if (content) {
      this.play(content);
    }
  }
  get imageManager() {
    if (this._imageManager === void 0) {
      this._imageManager = new ImageManager_default(this.scene);
    }
    return this._imageManager;
  }
  get spriteManager() {
    return this.getGameObjectManager("sprite");
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    ClearEvents_default(this);
    this.parser.destroy();
    this.parser = void 0;
    this.typeWriter.destroy(fromScene);
    this.typeWriter = void 0;
    if (this._imageManager) {
      this._imageManager.destroy(fromScene);
    }
    this._imageManager = void 0;
    this.destroyManagers(fromScene);
    super.destroy(fromScene);
  }
  get isPageTyping() {
    return this.typeWriter.isPageTyping;
  }
  set defaultTypingSpeed(speed) {
    this.typeWriter.setDefaultTypingSpeed(speed);
  }
  get defaultTypingSpeed() {
    return this.typeWriter.defaultTypingSpeed;
  }
  set typingSpeed(speed) {
    this.typeWriter.setTypingSpeed(speed);
  }
  get typingSpeed() {
    return this.typeWriter.speed;
  }
  set timeScale(value) {
    this.setTimeScale(value);
  }
  get timeScale() {
    return this.getTimeScale();
  }
};
Object.assign(
  TextPlayer.prototype,
  Methods_default12
);
var TextPlayer_default = TextPlayer;

// node_modules/phaser3-rex-plugins/plugins/textplayer.js
var textplayer_default = TextPlayer_default;

// node_modules/phaser3-rex-plugins/templates/ui/textplayer/TextPlayer.js
var TextPlayer_default2 = textplayer_default;

// node_modules/phaser3-rex-plugins/templates/ui/textplayer/Factory.js
ObjectFactory_default.register("textPlayer", function(x, y, width, height, config) {
  var gameObject2 = new TextPlayer_default2(this.scene, x, y, width, height, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TextPlayer", TextPlayer_default2);

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/InputTextProperties.js
var ElementProperties = {
  maxLength: ["maxLength", void 0],
  minLength: ["minLength", void 0],
  readOnly: ["readOnly", false]
};
var StyleProperties = {
  direction: ["direction", void 0]
};

// node_modules/phaser3-rex-plugins/plugins/utils/object/CopyProperty.js
var CopyProperty = function(from, to, key2) {
  if (typeof key2 === "string") {
    if (from.hasOwnProperty(key2)) {
      to[key2] = from[key2];
    }
  } else {
    var keys = key2;
    if (Array.isArray(keys)) {
      for (var i = 0, cnt = keys.length; i < cnt; i++) {
        CopyProperty(from, to, keys[i]);
      }
    } else {
      for (var key2 in keys) {
        CopyProperty(from, to, key2);
      }
    }
  }
};
var CopyProperty_default = CopyProperty;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/CopyElementConfig.js
var CopyElementConfig = function(from) {
  if (from === void 0) {
    from = {};
  }
  var to = {};
  CopyProperty_default(from, to, "inputType");
  CopyProperty_default(from, to, "type");
  CopyProperty_default(from, to, "style");
  CopyProperty_default(from, to, StyleProperties);
  CopyProperty_default(from, to, ElementProperties);
  return to;
};
var CopyElementConfig_default = CopyElementConfig;

// node_modules/phaser3-rex-plugins/plugins/utils/input/IsPointerInHitArea.js
var IsPointerInHitArea = function(gameObject2, pointer, preTest, postTest, returnFirstPointer) {
  if (pointer) {
    if (preTest && !preTest(gameObject2, pointer)) {
      return false;
    }
    if (!HitTest(gameObject2, pointer)) {
      return false;
    }
    if (postTest && !postTest(gameObject2, pointer)) {
      return false;
    }
    return true;
  } else {
    if (returnFirstPointer === void 0) {
      returnFirstPointer = false;
    }
    var inputManager = gameObject2.scene.input.manager;
    var pointersTotal = inputManager.pointersTotal;
    var pointers = inputManager.pointers, pointer;
    for (var i = 0; i < pointersTotal; i++) {
      pointer = pointers[i];
      if (preTest && !preTest(gameObject2, pointer)) {
        continue;
      }
      if (!HitTest(gameObject2, pointer)) {
        continue;
      }
      if (postTest && !postTest(gameObject2, pointer)) {
        continue;
      }
      if (returnFirstPointer) {
        return pointer;
      }
      return true;
    }
    return false;
  }
};
var HitTest = function(gameObject2, pointer) {
  var scene = gameObject2.scene;
  var cameras = scene.input.cameras.getCamerasBelowPointer(pointer);
  var inputManager = scene.input.manager;
  var gameObjects = [gameObject2];
  for (var i = 0, len = cameras.length; i < len; i++) {
    inputManager.hitTest(pointer, gameObjects, cameras[i], HitTestResult);
    if (HitTestResult.length > 0) {
      HitTestResult.length = 0;
      return true;
    }
  }
  HitTestResult.length = 0;
  return false;
};
var HitTestResult = [];
var IsPointerInHitArea_default = IsPointerInHitArea;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/LastOpenedEditor.js
var LastOpenedEditor = void 0;
var SetLastOpenedEditor = function(editor) {
  if (editor === LastOpenedEditor) {
    return;
  }
  if (LastOpenedEditor !== void 0) {
    LastOpenedEditor.close();
  }
  LastOpenedEditor = editor;
};
var CloseLastOpenEditor = function(editor) {
  if (editor !== LastOpenedEditor) {
    return;
  }
  LastOpenedEditor = void 0;
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/EnterClose.js
var EnterClose = function() {
  this.close();
  this.emit("keydown-ENTER", this.parent, this);
  return this;
};
var EnterClose_default = EnterClose;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/OnOpen.js
var OnOpen = function() {
  this.isOpened = true;
  this.initText();
  if (this.enterCloseEnable) {
    this.scene.input.keyboard.once("keydown-ENTER", EnterClose_default, this);
  }
  this.scene.sys.events.on("postupdate", this.updateText, this);
  if (this.clickOutSideTarget) {
    MoveMyDepthAbove.call(this.clickOutSideTarget, this.parent);
    MoveMyDepthBelow.call(this.clickOutSideTarget, this.parent);
    this.clickOutSideTarget.setInteractive().on("pointerdown", this.onClickOutside, this);
  } else {
    this.scene.input.on("pointerdown", this.onClickOutside, this);
  }
  if (this.onOpenCallback) {
    this.onOpenCallback(this.parent, this);
  }
  this.emit("open", this);
};
var OnOpen_default = OnOpen;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/RemoveElement.js
var RemoveElement = function(element) {
  if (!element) {
    return;
  }
  var parentElement = element.parentElement;
  if (parentElement) {
    parentElement.removeChild(element);
  }
};
var RemoveElement_default = RemoveElement;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/OnClose.js
var OnClose = function() {
  this.isOpened = false;
  this.updateText();
  if (this.enterCloseEnable) {
    this.scene.input.keyboard.off("keydown-ENTER", EnterClose_default, this);
  }
  this.scene.sys.events.off("postupdate", this.updateText, this);
  if (this.clickOutSideTarget) {
    this.clickOutSideTarget.disableInteractive().off("pointerdown", this.onClickOutside, this);
  } else {
    this.scene.input.off("pointerdown", this.onClickOutside, this);
  }
  if (this.onCloseCallback) {
    this.onCloseCallback(this.parent, this);
  }
  RemoveElement_default(this.node);
  this.node = void 0;
  this.emit("close", this);
};
var OnClose_default = OnClose;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/CreateElement.js
var GetValue47 = Phaser.Utils.Objects.GetValue;
var CreateElement = function(parent, config) {
  var element;
  var textType = GetValue47(config, "inputType", void 0);
  if (textType === void 0) {
    textType = GetValue47(config, "type", "text");
  }
  if (textType === "textarea") {
    element = document.createElement("textarea");
    element.style.resize = "none";
  } else {
    element = document.createElement("input");
    element.type = textType;
  }
  var style = GetValue47(config, "style", void 0);
  var elementStyle = element.style;
  SetProperties_default(StyleProperties, style, elementStyle);
  elementStyle.position = "absolute";
  elementStyle.opacity = 0;
  elementStyle.pointerEvents = "none";
  elementStyle.zIndex = 0;
  elementStyle.transform = "scale(0)";
  SetProperties_default(ElementProperties, config, element);
  StopPropagationTouchEvents_default(element);
  var scaleManager = parent.scene.sys.scale;
  var parentElement = scaleManager.isFullscreen ? scaleManager.fullscreenTarget : document.body;
  parentElement.appendChild(element);
  element.addEventListener("focus", function(e) {
    OnOpen_default.call(parent);
  });
  element.addEventListener("blur", function(e) {
    OnClose_default.call(parent);
  });
  return element;
};
var CreateElement_default = CreateElement;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/Open.js
var Open = function() {
  if (this.isOpened) {
    return this;
  }
  if (this.readOnly) {
    return this;
  }
  SetLastOpenedEditor(this);
  if (!this.node) {
    this.node = CreateElement_default(this, this.nodeConfig);
  }
  this.setFocus();
  return this;
};
var Open_default = Open;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/Close.js
var Close = function() {
  if (!this.isOpened) {
    return this;
  }
  CloseLastOpenEditor(this);
  this.setBlur();
  return this;
};
var Close_default = Close;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/methods/Methods.js
var Methods9 = {
  open: Open_default,
  close: Close_default
};
var Methods_default13 = Methods9;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/HiddenTextEditBase.js
var GetValue48 = Phaser.Utils.Objects.GetValue;
var HiddenTextEditBase = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2);
    var textType = GetValue48(config, "inputType", void 0);
    if (textType === void 0) {
      textType = GetValue48(config, "type", "text");
    }
    this.setEnterCloseEnable(GetValue48(config, "enterClose", textType !== "textarea"));
    var onOpen = GetValue48(config, "onOpen", void 0);
    if (!onOpen) {
      onOpen = GetValue48(config, "onFocus", void 0);
    }
    this.onOpenCallback = onOpen;
    this.clickOutSideTarget = GetValue48(config, "clickOutSideTarget", void 0);
    var onClose = GetValue48(config, "onClose", void 0);
    if (!onClose) {
      onClose = GetValue48(config, "onBlur", void 0);
    }
    this.onCloseCallback = onClose;
    this.onUpdateCallback = GetValue48(config, "onUpdate", void 0);
    this.isOpened = false;
    gameObject2.on("pointerdown", function() {
      this.open();
    }, this).setInteractive();
    this.nodeConfig = CopyElementConfig_default(config);
    this.node = void 0;
  }
  destroy() {
    this.close();
    if (this.clickOutSideTarget) {
      this.clickOutSideTarget.destroy();
    }
    super.destroy();
  }
  onClickOutside(pointer) {
    if (!IsPointerInHitArea_default(this.parent, pointer)) {
      this.close();
    }
  }
  setEnterCloseEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.enterCloseEnable = enable;
    return this;
  }
  // Override
  initText() {
  }
  // Override, invoking under 'postupdate' event of scene
  updateText() {
  }
  // Copy from InputText class
  get text() {
    if (!this.node) {
      return "";
    }
    return this.node.value;
  }
  set text(value) {
    if (!this.node) {
      return;
    }
    this.node.value = value;
  }
  setText(value) {
    this.text = value;
    return this;
  }
  get maxLength() {
    return this.nodeConfig.maxLength;
  }
  set maxLength(value) {
    this.nodeConfig.maxLength = value;
    if (this.node) {
      this.node.maxLength = value;
    }
  }
  setMaxLength(value) {
    this.maxLength = value;
    return this;
  }
  get minLength() {
    return this.nodeConfig.minLength;
  }
  set minLength(value) {
    this.nodeConfig.minLength = value;
    if (this.node) {
      this.node.minLength = value;
    }
  }
  setMinLength(value) {
    this.minLength = value;
    return this;
  }
  get placeholder() {
    return this.node.placeholder;
  }
  set placeholder(value) {
    if (!this.node) {
      return;
    }
    this.node.placeholder = value;
  }
  setPlaceholder(value) {
    this.placeholder = value;
    return this;
  }
  selectText(selectionStart, selectionEnd) {
    if (!this.node) {
      return this;
    }
    if (selectionStart === void 0) {
      this.node.select();
    } else {
      this.node.setSelectionRange(selectionStart, selectionEnd);
    }
    return this;
  }
  selectAll() {
    this.selectText();
    return this;
  }
  get selectionStart() {
    if (!this.node) {
      return 0;
    }
    return this.node.selectionStart;
  }
  get selectionEnd() {
    if (!this.node) {
      return 0;
    }
    return this.node.selectionEnd;
  }
  get selectedText() {
    if (!this.node) {
      return "";
    }
    var node = this.node;
    return node.value.substring(node.selectionStart, node.selectionEnd);
  }
  get cursorPosition() {
    if (!this.node) {
      return 0;
    }
    return this.node.selectionStart;
  }
  set cursorPosition(value) {
    if (!this.node) {
      return;
    }
    this.node.setSelectionRange(value, value);
  }
  setCursorPosition(value) {
    if (value === void 0) {
      value = this.text.length;
    } else if (value < 0) {
      value = this.text.length + value;
    }
    this.cursorPosition = value;
    return this;
  }
  get tooltip() {
    if (!this.node) {
      return "";
    }
    return this.node.title;
  }
  set tooltip(value) {
    if (!this.node) {
      return this;
    }
    this.node.title = value;
  }
  setTooltip(value) {
    this.tooltip = value;
    return this;
  }
  setTextChangedCallback(callback) {
    this.onTextChanged = callback;
    return this;
  }
  get readOnly() {
    return this.nodeConfig.readOnly;
  }
  set readOnly(value) {
    this.nodeConfig.readOnly = value;
    if (this.node) {
      this.node.readOnly = value;
    }
  }
  setReadOnly(value) {
    if (value === void 0) {
      value = true;
    }
    this.readOnly = value;
    return this;
  }
  get spellCheck() {
    if (!this.node) {
      return "";
    }
    return this.node.spellcheck;
  }
  set spellCheck(value) {
    if (!this.node) {
      return;
    }
    this.node.spellcheck = value;
  }
  setSpellCheck(value) {
    this.spellCheck = value;
    return this;
  }
  get fontColor() {
    if (!this.node) {
      return void 0;
    }
    return this.node.style.color;
  }
  set fontColor(value) {
    if (!this.node) {
      return;
    }
    this.node.style.color = value;
  }
  setFontColor(value) {
    this.fontColor = value;
    return this;
  }
  setStyle(key2, value) {
    if (!this.node) {
      return this;
    }
    this.node.style[key2] = value;
    return this;
  }
  getStyle(key2) {
    if (!this.node) {
      return void 0;
    }
    return this.node.style[key2];
  }
  scrollToBottom() {
    if (!this.node) {
      return this;
    }
    this.node.scrollTop = this.node.scrollHeight;
    return this;
  }
  setEnabled(enabled) {
    if (!this.node) {
      return this;
    }
    if (enabled === void 0) {
      enabled = true;
    }
    this.node.disabled = !enabled;
    return this;
  }
  setBlur() {
    if (!this.node) {
      return this;
    }
    this.node.blur();
    return this;
  }
  setFocus() {
    if (!this.node) {
      return this;
    }
    this.node.focus();
    return this;
  }
  get isFocused() {
    return this.isOpened;
  }
};
Object.assign(
  HiddenTextEditBase.prototype,
  Methods_default13
);
var HiddenTextEditBase_default = HiddenTextEditBase;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/defaultcallbacks/NumberInputUpdateCallback.js
var NumberInputUpdateCallback = function(text, textObject, hiddenInputText) {
  text = text.replace(" ", "");
  var previousText = hiddenInputText.previousText;
  if (text === previousText) {
    return text;
  }
  if (isNaN(text)) {
    hiddenInputText.emit("nan", text, hiddenInputText);
    text = previousText;
    var cursorPosition = hiddenInputText.cursorPosition - 1;
    hiddenInputText.setText(text);
    hiddenInputText.setCursorPosition(cursorPosition);
  } else {
    hiddenInputText.previousText = text;
  }
  return text;
};
var NumberInputUpdateCallback_default = NumberInputUpdateCallback;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/textedit/SelectRange.js
var SelectRange = function(hiddenTextEdit) {
  var textObject = hiddenTextEdit.parent;
  var selectionStart = hiddenTextEdit.isOpened ? hiddenTextEdit.selectionStart : null;
  var selectionEnd = hiddenTextEdit.isOpened ? hiddenTextEdit.selectionEnd : null;
  var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
  var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;
  if (prevSelectionStart === selectionStart && prevSelectionEnd === selectionEnd) {
    return;
  }
  var min, max;
  if (prevSelectionStart === null) {
    min = selectionStart;
    max = selectionEnd;
  } else if (selectionStart === null) {
    min = prevSelectionStart;
    max = prevSelectionEnd;
  } else {
    min = Math.min(prevSelectionStart, selectionStart);
    max = Math.max(prevSelectionEnd, selectionEnd);
  }
  for (var i = min; i < max; i++) {
    var inPrevSelectionRange;
    if (prevSelectionStart === null) {
      inPrevSelectionRange = false;
    } else {
      inPrevSelectionRange = i >= prevSelectionStart && i < prevSelectionEnd;
    }
    var inSelectionRange;
    if (selectionStart === null) {
      inSelectionRange = false;
    } else {
      inSelectionRange = i >= selectionStart && i < selectionEnd;
    }
    if (inPrevSelectionRange === inSelectionRange) {
      continue;
    }
    var child = textObject.getCharChild(i);
    if (child) {
      var eventName = inPrevSelectionRange ? "rangeout" : "rangein";
      textObject.emit(eventName, child, i, textObject);
    }
  }
  hiddenTextEdit.prevSelectionStart = selectionStart;
  hiddenTextEdit.prevSelectionEnd = selectionEnd;
};
var SelectRange_default = SelectRange;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/dynamictext/bob/utils/ScrollToBob.js
var ScrollToBob = function(bob) {
  var textObject = bob.parent;
  var textObjectLeftX = 0, textObjectRightX = textObject.width, textObjectTopY = 0, textObjectBottomY = textObject.height;
  var childX = bob.drawX, childY = bob.drawY;
  var childLeftX = childX + bob.drawTLX, childRightX = childX + bob.drawTRX, childTopY = childY + bob.drawTLY, childBottomY = childY + bob.drawBLY;
  var dx;
  if (childLeftX < textObjectLeftX) {
    dx = textObjectLeftX - childLeftX;
  } else if (childRightX > textObjectRightX) {
    dx = textObjectRightX - childRightX;
  } else {
    dx = 0;
  }
  var dy;
  if (childTopY < textObjectTopY) {
    dy = textObjectTopY - childTopY;
  } else if (childBottomY > textObjectBottomY) {
    dy = textObjectBottomY - childBottomY;
  } else {
    dy = 0;
  }
  textObject._textOX += dx;
  textObject._textOY += dy;
};
var ScrollToBob_default = ScrollToBob;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/textedit/MoveCursor.js
var MoveCursor = function(hiddenTextEdit) {
  var textObject = hiddenTextEdit.parent;
  var text = textObject.text;
  if (hiddenTextEdit.requestCursorPosition !== null) {
    hiddenTextEdit.setCursorPosition(hiddenTextEdit.requestCursorPosition);
    hiddenTextEdit.requestCursorPosition = null;
  }
  var cursorPosition = hiddenTextEdit.cursorPosition;
  if (hiddenTextEdit.prevCursorPosition === cursorPosition) {
    return;
  }
  if (hiddenTextEdit.prevCursorPosition !== null) {
    if (hiddenTextEdit.prevCursorPosition > text.length) {
      hiddenTextEdit.prevCursorPosition = null;
    }
  }
  if (hiddenTextEdit.prevCursorPosition !== null) {
    var child = textObject.getCharChild(hiddenTextEdit.prevCursorPosition);
    if (child) {
      if (child.text === "\n") {
        child.clearTextSize();
      }
      textObject.emit("cursorout", child, hiddenTextEdit.prevCursorPosition, textObject);
    }
  }
  if (cursorPosition != null) {
    var child = textObject.getCharChild(cursorPosition);
    if (child) {
      if (child.text === "\n") {
        child.copyTextSize(textObject.lastInsertCursor);
      }
      ScrollToBob_default(child);
      textObject.emit("cursorin", child, cursorPosition, textObject);
    }
  }
  textObject.emit("movecursor", cursorPosition, hiddenTextEdit.prevCursorPosition, textObject);
  hiddenTextEdit.prevCursorPosition = cursorPosition;
};
var MoveCursor_default = MoveCursor;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/textedit/ClearSelectRange.js
var ClearSelectRange = function(hiddenTextEdit) {
  var prevSelectionStart = hiddenTextEdit.prevSelectionStart;
  if (prevSelectionStart === null) {
    return;
  }
  var prevSelectionEnd = hiddenTextEdit.prevSelectionEnd;
  var textObject = hiddenTextEdit.parent;
  for (var i = prevSelectionStart; i < prevSelectionEnd; i++) {
    var child = textObject.getCharChild(i);
    if (child) {
      textObject.emit("cursorout", child, i, textObject);
    }
  }
  hiddenTextEdit.prevSelectionStart = null;
  hiddenTextEdit.prevSelectionEnd = null;
};
var ClearSelectRange_default = ClearSelectRange;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/textedit/ClearCursor.js
var ClearCursor = function(hiddenTextEdit) {
  var prevCursorPosition = hiddenTextEdit.prevCursorPosition;
  if (prevCursorPosition === null) {
    return;
  }
  var textObject = hiddenTextEdit.parent;
  var child = textObject.getCharChild(prevCursorPosition);
  if (child) {
    textObject.emit("cursorout", child, prevCursorPosition, textObject);
  }
  hiddenTextEdit.prevCursorPosition = null;
};
var ClearCursor_default = ClearCursor;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/textedit/HiddenTextEdit.js
var GetValue49 = Phaser.Utils.Objects.GetValue;
var HiddenTextEdit = class extends HiddenTextEditBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.setSelectAllWhenFocusEnable(GetValue49(config, "selectAll", false));
    this.cursorMoveStartIndex = null;
    this.prevCursorPosition = null;
    this.prevSelectionStart = null;
    this.prevSelectionEnd = null;
    this.firstClickAfterOpen = false;
    this.requestCursorPosition = null;
    gameObject2.on("pointerdown", function(pointer, localX, localY, event) {
      var child = gameObject2.getNearestChild(localX, localY);
      var charIndex = gameObject2.getCharIndex(child);
      if (!this.selectAllWhenFocus || !this.firstClickAfterOpen) {
        this.setCursorPosition(charIndex);
      }
      this.cursorMoveStartIndex = charIndex;
      this.firstClickAfterOpen = false;
    }, this).on("pointermove", function(pointer, localX, localY, event) {
      if (!pointer.isDown) {
        return;
      }
      var child = gameObject2.getNearestChild(localX, localY);
      var charIndex = gameObject2.getCharIndex(child);
      if (this.cursorMoveStartIndex < charIndex) {
        this.selectText(this.cursorMoveStartIndex, charIndex + 1);
      } else {
        this.selectText(charIndex, this.cursorMoveStartIndex + 1);
      }
    }, this);
    this.on("open", function() {
      if (this.selectAllWhenFocus) {
        this.selectAll();
      }
      this.firstClickAfterOpen = true;
      gameObject2.emit("open");
    }, this).on("close", function() {
      gameObject2.emit("close");
    }).on("keydown-ENTER", function() {
      gameObject2.emit("keydown-ENTER");
    });
  }
  initText() {
    var textObject = this.parent;
    this.prevCursorPosition = null;
    this.setText(textObject.text);
    return this;
  }
  updateText() {
    var textObject = this.parent;
    var text = this.text;
    if (this.onUpdateCallback) {
      var newText = this.onUpdateCallback(text, textObject, this);
      if (newText != null) {
        text = newText;
      }
    }
    if (textObject.text !== text) {
      textObject.setText(text);
    }
    if (this.isOpened) {
      if (this.selectionStart !== this.selectionEnd) {
        ClearCursor_default(this);
        SelectRange_default(this);
      } else {
        ClearSelectRange_default(this);
        MoveCursor_default(this);
      }
    } else {
      ClearSelectRange_default(this);
      ClearCursor_default(this);
    }
    return this;
  }
  setNumberInput() {
    this.onUpdateCallback = NumberInputUpdateCallback_default;
    return this;
  }
  setSelectAllWhenFocusEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.selectAllWhenFocus = enable;
    return this;
  }
  setRequestCursorPosition(value) {
    if (!this.isOpened) {
      return this;
    }
    this.requestCursorPosition = value;
    return this;
  }
};
var HiddenTextEdit_default = HiddenTextEdit;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/textedit/CreateHiddenTextEdit.js
var GetValue50 = Phaser.Utils.Objects.GetValue;
var PropertiesList = [
  "inputType",
  "onOpen",
  "clickOutSideTarget",
  "onFocus",
  "onClose",
  "onBlur",
  "onUpdate",
  "enterClose",
  "readOnly",
  "maxLength",
  "minLength",
  "selectAll"
];
var CreateHiddenTextEdit = function(parent, parentConfig) {
  var config = GetValue50(parentConfig, "edit");
  if (config === void 0) {
    config = {};
  }
  CopyProperty_default(parentConfig, config, PropertiesList);
  return new HiddenTextEdit_default(parent, config);
};
var CreateHiddenTextEdit_default = CreateHiddenTextEdit;

// node_modules/phaser3-rex-plugins/plugins/utils/object/HasValue.js
var HasValue = function(source, key2) {
  if (!source || typeof source === "number") {
    return false;
  } else if (source.hasOwnProperty(key2)) {
    return true;
  } else if (key2.indexOf(".") !== -1) {
    var keys = key2.split(".");
    var parent = source;
    for (var i = 0; i < keys.length; i++) {
      if (parent.hasOwnProperty(keys[i])) {
        parent = parent[keys[i]];
      } else {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
};
var HasValue_default = HasValue;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetRootGameObject.js
var GetRootGameObject = function(gameObject2) {
  if (gameObject2.parentContainer) {
    return GetRootGameObject(gameObject2.parentContainer);
  }
  var layer = GetLayer_default(gameObject2);
  if (layer) {
    return GetRootGameObject(layer);
  }
  return gameObject2;
};
var GetRootGameObject_default = GetRootGameObject;

// node_modules/phaser3-rex-plugins/plugins/utils/camera/GetFirstRenderCamera.js
var GetFirstRenderCamera = function(gameObject2) {
  var cameraFilter = GetRootGameObject_default(gameObject2).cameraFilter;
  var cameras = gameObject2.scene.sys.cameras.cameras;
  var camera, isCameraIgnore;
  for (var i = 0, cnt = cameras.length; i < cnt; i++) {
    camera = cameras[i];
    isCameraIgnore = (cameraFilter & camera.id) > 0;
    if (!isCameraIgnore) {
      return camera;
    }
  }
  return null;
};
var GetFirstRenderCamera_default = GetFirstRenderCamera;

// node_modules/phaser3-rex-plugins/plugins/behaviors/fullwindow/FullWindow.js
var FullWindow = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2);
    this.targetCamera = void 0;
    this.boot();
  }
  boot() {
    this.scene.sys.events.on("prerender", this.resize, this);
  }
  destroy() {
    if (!this.scene) {
      return;
    }
    this.scene.sys.events.off("prerender", this.resize, this);
    super.destroy();
  }
  resize() {
    var scene = this.scene;
    var gameObject2 = this.parent;
    var camera = GetFirstRenderCamera_default(gameObject2);
    if (!camera) {
      return;
    }
    gameObject2.setScrollFactor(0).setOrigin(0.5);
    var gameSize = scene.sys.scale.gameSize;
    var gameWidth = gameSize.width, gameHeight = gameSize.height, scale = 1 / camera.zoom;
    var x = gameWidth / 2, y = gameHeight / 2;
    var width = gameWidth * scale, height = gameHeight * scale;
    if (gameObject2.x !== x || gameObject2.y !== y) {
      gameObject2.setPosition(x, y);
    }
    if (gameObject2.width !== width || gameObject2.height !== height) {
      gameObject2.setSize(width, height);
    }
  }
};
var FullWindow_default = FullWindow;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/fullwindow/fullwindowzone/FullWindowZone.js
var Zone = Phaser.GameObjects.Zone;
var FullWindowRectangle = class extends Zone {
  constructor(scene) {
    super(scene, 0, 0, 2, 2);
    this.fullWindow = new FullWindow_default(this);
  }
};
var FullWindowZone_default = FullWindowRectangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/InjectDefaultConfig.js
var InjectDefaultConfig = function(scene, config) {
  var isSingleLineMode = !config.textArea;
  if (!HasValue_default(config, "wrap.vAlign")) {
    var defaultValue = isSingleLineMode ? "center" : "top";
    SetValue_default(config, "wrap.vAlign", defaultValue);
  }
  if (!HasValue_default(config, "wrap.wrapMode")) {
    SetValue_default(config, "wrap.wrapMode", "char");
  }
  if (!HasValue_default(config, "wrap.maxLines")) {
    var defaultValue = isSingleLineMode ? 1 : void 0;
    SetValue_default(config, "wrap.maxLines", defaultValue);
  }
  if (isSingleLineMode) {
    SetValue_default(config, "wrap.wrapWidth", Infinity);
  }
  if (!HasValue_default(config, "wrap.useDefaultTextHeight")) {
    SetValue_default(config, "wrap.useDefaultTextHeight", true);
  }
  if (!config.edit) {
    config.edit = {};
  }
  if (!HasValue_default(config.edit, "inputType")) {
    var defaultValue = isSingleLineMode ? "text" : "textarea";
    SetValue_default(config.edit, "inputType", defaultValue);
  }
  if (config.clickOutSideTarget === true) {
    var clickOutSideTarget = new FullWindowZone_default(scene);
    scene.add.existing(clickOutSideTarget);
    config.clickOutSideTarget = clickOutSideTarget;
  }
  return config;
};
var InjectDefaultConfig_default = InjectDefaultConfig;

// node_modules/phaser3-rex-plugins/plugins/utils/object/ExtractByPrefix.js
var ExtractByPrefix = function(obj, prefix, delimiter, out2) {
  if (delimiter === void 0) {
    delimiter = ".";
  }
  if (out2 === void 0) {
    out2 = {};
  }
  if (!obj) {
    return out2;
  }
  if (prefix in obj) {
    return Object.assign(out2, obj[prefix]);
  }
  prefix += delimiter;
  for (var key2 in obj) {
    if (!key2.startsWith(prefix)) {
      continue;
    }
    out2[key2.replace(prefix, "")] = obj[key2];
  }
  return out2;
};
var ExtractByPrefix_default = ExtractByPrefix;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/RegisterArrowKeysEvent.js
var RegisterArrowKeysEvent = function() {
  var keyEventManager = this.scene.input.keyboard;
  this.textEdit.on("open", function() {
    keyEventManager.on("keydown-UP", this.cursorMoveUp, this).on("keydown-DOWN", this.cursorMoveDown, this);
  }, this).on("close", function() {
    keyEventManager.off("keydown-UP", this.cursorMoveUp, this).off("keydown-DOWN", this.cursorMoveDown, this);
  }, this);
};
var RegisterArrowKeysEvent_default = RegisterArrowKeysEvent;

// node_modules/phaser3-rex-plugins/plugins/utils/object/GetPartialData.js
var GetPartialData = function(obj, keys, out2) {
  if (out2 === void 0) {
    out2 = {};
  }
  if (Array.isArray(keys)) {
    var key2;
    for (var i = 0, cnt = keys.length; i < cnt; i++) {
      key2 = keys[i];
      out2[key2] = obj[key2];
    }
  } else {
    for (var key2 in keys) {
      out2[key2] = obj[key2];
    }
  }
  return out2;
};
var GetPartialData_default = GetPartialData;

// node_modules/phaser3-rex-plugins/plugins/utils/object/IsKeyValueEqual.js
var IsKeyValueEqual = function(objA, objB) {
  for (var key2 in objA) {
    if (!(key2 in objB)) {
      return false;
    }
    if (objA[key2] !== objB[key2]) {
      return false;
    }
  }
  for (var key2 in objB) {
    if (!(key2 in objA)) {
      return false;
    }
  }
  return true;
};
var IsKeyValueEqual_default = IsKeyValueEqual;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/RegisterCursorStyle.js
var RegisterCursorStyle = function(cursorStyle) {
  if (IsEmpty_default(cursorStyle)) {
    return;
  }
  this.setCursorStyle(cursorStyle).on("cursorin", function(child) {
    var cursorStyle2 = this.cursorStyle;
    var styleSave = GetPartialData_default(child.style, cursorStyle2);
    if (IsKeyValueEqual_default(cursorStyle2, styleSave)) {
      return;
    }
    child.styleSave = styleSave;
    child.modifyStyle(cursorStyle2);
  }, this).on("cursorout", function(child) {
    if (!child.styleSave) {
      return;
    }
    child.modifyStyle(child.styleSave);
    child.styleSave = void 0;
  }, this);
};
var RegisterCursorStyle_default = RegisterCursorStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/RegisterRangeStyle.js
var RegisterRangeStyle = function(rangeStyle) {
  if (IsEmpty_default(rangeStyle)) {
    return;
  }
  this.setRangeStyle(rangeStyle).on("rangein", function(child) {
    var rangeStyle2 = this.rangeStyle;
    var styleSave = GetPartialData_default(child.style, rangeStyle2);
    if (IsKeyValueEqual_default(rangeStyle2, styleSave)) {
      return;
    }
    child.styleSave = styleSave;
    child.modifyStyle(rangeStyle2);
  }, this).on("rangeout", function(child) {
    if (!child.styleSave) {
      return;
    }
    child.modifyStyle(child.styleSave);
    child.styleSave = void 0;
  }, this);
};
var RegisterRangeStyle_default = RegisterRangeStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/RegisterFocusStyle.js
var RegisterFocusStyle = function(focusStyle) {
  if (IsEmpty_default(focusStyle)) {
    return;
  }
  this.setFocusStyle(focusStyle).on("open", function() {
    var child = this.background;
    var focusStyle2 = this.focusStyle;
    var styleSave = GetPartialData_default(child, focusStyle2);
    if (IsKeyValueEqual_default(focusStyle2, styleSave)) {
      return;
    }
    child.styleSave = styleSave;
    child.modifyStyle(focusStyle2);
  }, this).on("close", function() {
    var child = this.background;
    if (!child.styleSave) {
      return;
    }
    child.modifyStyle(child.styleSave);
    child.styleSave = void 0;
  }, this);
};
var RegisterFocusStyle_default = RegisterFocusStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/CreateInsertCursorChild.js
var CreateInsertCursorChild = function(textObject) {
  var child = textObject.createCharChild("|");
  child.text = "";
  return child;
};
var CreateInsertCursorChild_default = CreateInsertCursorChild;

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/base.js
function Diff() {
}
Diff.prototype = {
  diff(oldString, newString, options = {}) {
    let callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    let self = this;
    function done(value) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    let newLen = newString.length, oldLen = oldString.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    let bestPath = [{ newPos: -1, components: [] }];
    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      return done([{ value: this.join(newString), count: newString.length }]);
    }
    function execEditLength() {
      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        let basePath;
        let addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], oldPos2 = (removePath ? removePath.newPos : 0) - diagonalPath;
        if (addPath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= oldPos2 && oldPos2 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, void 0, true);
        } else {
          basePath = addPath;
          basePath.newPos++;
          self.pushComponent(basePath.components, true, void 0);
        }
        oldPos2 = self.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.newPos + 1 >= newLen && oldPos2 + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        let ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent(components, added, removed) {
    let last = components[components.length - 1];
    if (last && last.added === added && last.removed === removed) {
      components[components.length - 1] = { count: last.count + 1, added, removed };
    } else {
      components.push({ count: 1, added, removed });
    }
  },
  extractCommon(basePath, newString, oldString, diagonalPath) {
    let newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.components.push({ count: commonCount });
    }
    basePath.newPos = newPos;
    return oldPos;
  },
  equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty(array) {
    let ret = [];
    for (let i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput(value) {
    return value;
  },
  tokenize(value) {
    return value.split("");
  },
  join(chars) {
    return chars.join("");
  }
};
function buildValues(diff, components, newString, oldString, useLongestToken) {
  let componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    let component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        let value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          let oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - 1].added) {
        let tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  let lastComponent = components[componentLen - 1];
  if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }
  return components;
}
function clonePath(path) {
  return { newPos: path.newPos, components: path.components.slice(0) };
}

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/character.js
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/word.js
var extendedWordChars = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value) {
  let tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (let i = 0; i < tokens.length - 1; i++) {
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }
  return tokens;
};

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/line.js
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
  let retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i = 0; i < linesAndNewlines.length; i++) {
    let line = linesAndNewlines[i];
    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }
  return retLines;
};

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/sentence.js
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/css.js
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/json.js
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
  const { undefinedReplacement, stringifyReplacer = (k, v) => typeof v === "undefined" ? undefinedReplacement : v } = this.options;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
};
function canonicalize(obj, stack, replacementStack, replacer, key2) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key2, obj);
  }
  let i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  let canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key2);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (typeof obj === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    let sortedKeys = [], key3;
    for (key3 in obj) {
      if (obj.hasOwnProperty(key3)) {
        sortedKeys.push(key3);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      key3 = sortedKeys[i];
      canonicalizedObj[key3] = canonicalize(obj[key3], stack, replacementStack, replacer, key3);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}

// node_modules/phaser3-rex-plugins/plugins/utils/jsdiff/diff/array.js
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/SetText.js
var RemoveItem7 = Phaser.Utils.Array.Remove;
var SetText2 = function(textObject, newText) {
  var text = textObject.text;
  if (newText === text) {
    return;
  }
  if (text == null) {
    text = "";
  }
  RemoveItem7(textObject.children, textObject.lastInsertCursor);
  if (newText === "") {
    textObject.removeChildren();
  } else {
    var results = diffChars(text, newText);
    var charIndex = 0;
    for (var i = 0, cnt = results.length; i < cnt; i++) {
      var result = results[i];
      if (result.removed) {
        textObject.removeText(charIndex, result.count);
      } else if (result.added) {
        textObject.insertText(charIndex, result.value);
        charIndex += result.count;
      } else {
        charIndex += result.count;
      }
    }
  }
  textObject.children.push(textObject.lastInsertCursor);
  textObject.runWrap();
  if (textObject.isOpened) {
    textObject.textEdit.setText(newText);
  }
  textObject.emit("textchange", newText, textObject);
};
var SetText_default2 = SetText2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/SetTextOXYMethods.js
var SetTextOXYMethods_default2 = {
  setTextOYByPercentage(percentage) {
    this.setTextOY(-this.textVisibleHeight * percentage);
    return this;
  },
  getTextOYPercentage() {
    var textVisibleHeight = this.textVisibleHeight;
    if (textVisibleHeight === 0) {
      return 0;
    }
    return this._textOY / -textVisibleHeight;
  },
  setTextOXByPercentage(percentage) {
    this.setTextOX(-this.textVisibleWidth * percentage);
    return this;
  },
  getTextOXPercentage() {
    var textVisibleWidth = this.textVisibleWidth;
    if (textVisibleWidth === 0) {
      return 0;
    }
    return this._textOX / -textVisibleWidth;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/methods/MoveCursorMethods.js
var Clamp3 = Phaser.Math.Clamp;
var GetIndex = function(characterCountOfLines, position) {
  var result = { lineIndex: 0, position: 0 };
  if (position < 0) {
    return result;
  }
  for (var li = 0, lcnt = characterCountOfLines.length; li < lcnt; li++) {
    var characterCount = characterCountOfLines[li];
    if (position <= characterCount) {
      result.lineIndex = li;
      break;
    }
    position -= characterCount;
  }
  result.position = position;
  return result;
};
var GetPosition = function(characterCountOfLines, index) {
  var position = 0;
  var lineIndex = index.lineIndex;
  if (lineIndex < 0) {
    return position;
  }
  for (var li = 0, lcnt = characterCountOfLines.length; li < lcnt; li++) {
    var characterCount = characterCountOfLines[li];
    if (lineIndex > li) {
      position += characterCount;
    } else if (lineIndex === li) {
      position += Math.min(index.position, characterCount);
    } else {
      break;
    }
  }
  return position;
};
var MoveCursorMethods_default = {
  cursorMoveLeft() {
    if (!this.isOpened) {
      return this;
    }
    var position = Clamp3(this.cursorPosition - 1, 0, this.inputText.length);
    this.setCursorPosition(position);
    return this;
  },
  cursorMoveRight() {
    if (!this.isOpened) {
      return this;
    }
    var position = Clamp3(this.cursorPosition + 1, 0, this.inputText.length);
    this.setCursorPosition(position);
    return this;
  },
  cursorMoveUp() {
    if (!this.isOpened) {
      return this;
    }
    var result = GetIndex(this.characterCountOfLines, this.cursorPosition);
    result.lineIndex -= 1;
    var position = Clamp3(GetPosition(this.characterCountOfLines, result), 0, this.inputText.length);
    this.setCursorPosition(position);
    return this;
  },
  cursorMoveDown() {
    if (!this.isOpened) {
      return this;
    }
    var result = GetIndex(this.characterCountOfLines, this.cursorPosition);
    result.lineIndex += 1;
    var position = Clamp3(GetPosition(this.characterCountOfLines, result), 0, this.inputText.length);
    this.setCursorPosition(position);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dynamictext/canvasinput/CanvasInput.js
var IsPlainObject11 = Phaser.Utils.Objects.IsPlainObject;
var CanvasInput = class extends DynamicText_default {
  constructor(scene, x, y, fixedWidth, fixedHeight, config) {
    if (IsPlainObject11(x)) {
      config = x;
    } else if (IsPlainObject11(fixedWidth)) {
      config = fixedWidth;
    }
    if (config === void 0) {
      config = {};
    }
    InjectDefaultConfig_default(scene, config);
    var text = config.text;
    if (text) {
      delete config.text;
    }
    var focusStyle = ExtractByPrefix_default(config.background, "focus");
    var cursorStyle = ExtractByPrefix_default(config.style, "cursor");
    var rangeStyle = ExtractByPrefix_default(config.style, "range");
    super(scene, x, y, fixedWidth, fixedHeight, config);
    this.type = "rexCanvasInput";
    this.contentWidth = void 0;
    this.contentHeight = void 0;
    this.lineHeight = void 0;
    this.linesCount = void 0;
    this.characterCountOfLines = [];
    this._text;
    this.textEdit = CreateHiddenTextEdit_default(this, config);
    RegisterArrowKeysEvent_default.call(this);
    if (config.focusStyle) {
      Object.assign(focusStyle, config.focusStyle);
    }
    RegisterFocusStyle_default.call(this, focusStyle);
    if (config.cursorStyle) {
      Object.assign(cursorStyle, config.cursorStyle);
    }
    RegisterCursorStyle_default.call(this, cursorStyle);
    if (config.rangeStyle) {
      Object.assign(rangeStyle, config.rangeStyle);
    }
    if (IsEmpty_default(rangeStyle)) {
      Object.assign(rangeStyle, cursorStyle);
    }
    RegisterRangeStyle_default.call(this, rangeStyle);
    var addCharCallback = config.onAddChar;
    if (addCharCallback) {
      this.on("addchar", addCharCallback);
    }
    var cursorInCallback = config.onCursorIn;
    if (cursorInCallback) {
      this.on("cursorin", cursorInCallback);
    }
    var cursorOutCallback = config.onCursorOut;
    if (cursorOutCallback) {
      this.on("cursorout", cursorOutCallback);
    }
    var useCursorCallback = !config.onRangeIn && !config.onRangeOut;
    var rangeInCallback = !useCursorCallback ? config.onRangeIn : config.onCursorIn;
    if (rangeInCallback) {
      this.on("rangein", rangeInCallback);
    }
    var rangeOutCallback = !useCursorCallback ? config.onRangeOut : config.onCursorOut;
    if (rangeOutCallback) {
      this.on("rangeout", rangeOutCallback);
    }
    var moveCursorCallback = config.onMoveCursor;
    if (moveCursorCallback) {
      this.on("movecursor", moveCursorCallback);
    }
    this.setParseTextCallback(config.parseTextCallback);
    this.lastInsertCursor = CreateInsertCursorChild_default(this);
    if (!text) {
      text = "";
    }
    this.setText(text);
  }
  addChild(child, index) {
    super.addChild(child, index);
    if (Array.isArray(child)) {
      var children = child;
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];
        if (IsChar(child)) {
          this.emit("addchar", child, index + i, this);
        }
      }
    } else {
      if (IsChar(child)) {
        this.emit("addchar", child, index, this);
      }
    }
    return this;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    if (value == null) {
      value = "";
    } else {
      value = value.toString();
    }
    if (this._text === value) {
      return;
    }
    SetText_default2(this, value);
    this._text = value;
  }
  setText(text) {
    this.text = text;
    return this;
  }
  appendText(text) {
    this.setText(this.text + text);
    return this;
  }
  runWrap(config) {
    var result = super.runWrap(config);
    this.contentWidth = result.maxLineWidth;
    this.contentHeight = result.linesHeight;
    this.lineHeight = result.lineHeight;
    this.linesCount = result.lines.length;
    this.characterCountOfLines.length = 0;
    var wrapLines = result.lines;
    for (var li = 0, lcnt = wrapLines.length; li < lcnt; li++) {
      var line = wrapLines[li].children;
      var characterCount = 0;
      for (var ci = 0, ccnt = line.length; ci < ccnt; ci++) {
        var child = line[ci];
        if (child.active && !child.removed && IsChar(child)) {
          characterCount++;
        }
      }
      this.characterCountOfLines.push(characterCount);
    }
    return result;
  }
  setSize(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }
    super.setSize(width, height);
    this.runWrap();
    return this;
  }
  get displayText() {
    return this.text;
  }
  set displayText(value) {
    this.text = value;
  }
  setDisplayText(value) {
    this.displayText = value;
    return this;
  }
  get inputText() {
    return this.textEdit.text;
  }
  set inputText(value) {
    this.textEdit.text = value;
  }
  setInputText(value) {
    this.inputText = value;
    return this;
  }
  setParseTextCallback(callback) {
    if (!callback) {
      callback = DefaultParseTextCallback;
    }
    this.parseTextCallback = callback;
    return this;
  }
  get value() {
    return this.parseTextCallback(this.text);
  }
  set value(value) {
    this.setText(value);
  }
  getValue() {
    return this.value;
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  get readOnly() {
    return this.textEdit.readOnly;
  }
  set readOnly(value) {
    this.textEdit.readOnly = value;
  }
  setReadOnly(value) {
    this.textEdit.setReadOnly(value);
    return this;
  }
  open(onCloseCallback) {
    if (onCloseCallback) {
      this.textEdit.once("close", onCloseCallback);
    }
    this.textEdit.open();
    return this;
  }
  close() {
    this.textEdit.close();
    return this;
  }
  get isOpened() {
    return this.textEdit.isOpened;
  }
  setFocusStyle(style) {
    this.focusStyle = style;
    return this;
  }
  setCursorStyle(style) {
    this.cursorStyle = style;
    return this;
  }
  setRangeStyle(style) {
    this.rangeStyle = style;
    return this;
  }
  setNumberInput() {
    this.textEdit.setNumberInput().setSelectAllWhenFocusEnable();
    this.parseTextCallback = Number;
    return this;
  }
  get maxLength() {
    return this.textEdit.maxLength;
  }
  set maxLength(value) {
    this.textEdit.maxLength = value;
  }
  setMaxLength(value) {
    this.maxLength = value;
    return this;
  }
  get minLength() {
    return this.textEdit.minLength;
  }
  set minLength(value) {
    this.textEdit.minLength = value;
  }
  setMinLength(value) {
    this.minLength = value;
    return this;
  }
  get cursorPosition() {
    return this.textEdit.cursorPosition;
  }
  set cursorPosition(value) {
    if (!this.isOpened) {
      return;
    }
    this.textEdit.cursorPosition = value;
    this.textEdit.requestCursorPosition = value;
  }
  setCursorPosition(value) {
    this.cursorPosition = value;
    return this;
  }
  get topTextOY() {
    return 0;
  }
  get bottomTextOY() {
    return -this.tableVisibleHeight;
  }
  get leftTextOX() {
    return 0;
  }
  get rightTextOX() {
    return -this.textVisibleWidth;
  }
  get textVisibleHeight() {
    var h = this.contentHeight - this.height;
    if (h < 0) {
      h = 0;
    }
    return h;
  }
  get textVisibleWidth() {
    var w = this.contentWidth - this.width;
    if (w < 0) {
      w = 0;
    }
    return w;
  }
  set t(value) {
    this.setTextOYByPercentage(value).updateTexture();
  }
  get t() {
    return this.getTextOYPercentage();
  }
  set s(value) {
    this.setTextOXByPercentage(value).updateTexture();
  }
  get s() {
    return this.getTextOXPercentage();
  }
};
var DefaultParseTextCallback = function(text) {
  return text;
};
Object.assign(
  CanvasInput.prototype,
  SetTextOXYMethods_default2,
  MoveCursorMethods_default
);
var CanvasInput_default = CanvasInput;

// node_modules/phaser3-rex-plugins/plugins/canvasinput.js
var canvasinput_default = CanvasInput_default;

// node_modules/phaser3-rex-plugins/templates/ui/canvasinput/CanvasInput.js
var CanvasInput_default2 = canvasinput_default;

// node_modules/phaser3-rex-plugins/templates/ui/canvasinput/Factory.js
ObjectFactory_default.register("canvasInput", function(x, y, fixedWidth, fixedHeight, config) {
  var gameObject2 = new CanvasInput_default2(this.scene, x, y, fixedWidth, fixedHeight, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.CanvasInput", CanvasInput_default2);

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetTickDelta.js
var GetTickDelta = function(game) {
  return GetGame_default(game).loop.delta;
};
var GetTickDelta_default = GetTickDelta;

// node_modules/phaser3-rex-plugins/plugins/behaviors/hiddentextedit/HiddenTextEdit.js
var GetValue51 = Phaser.Utils.Objects.GetValue;
var Wrap = Phaser.Math.Wrap;
var HiddenTextEdit2 = class extends HiddenTextEditBase_default {
  constructor(gameObject2, config) {
    if (config === void 0) {
      config = {};
    }
    if (config.onUpdate === "number") {
      config.onUpdate = NumberInputUpdateCallback_default;
    }
    super(gameObject2, config);
    this.setCursor(GetValue51(config, "cursor", "|"));
    this.setCursorFlashDuration(GetValue51(config, "cursorFlashDuration", 1e3));
    this.cursorFlashTimer = 0;
  }
  initText() {
    this.cursorFlashTimer = 0;
    this.prevCursorPosition = void 0;
    this.setText(this.parent.text);
    this.setCursorPosition();
    return this;
  }
  updateText() {
    var textObject = this.parent;
    var text = this.text;
    if (this.onUpdateCallback) {
      var newText = this.onUpdateCallback(text, textObject, this);
      if (newText != null) {
        text = newText;
      }
    }
    if (this.isOpened && this.hasCursor) {
      var cursorPosition = this.cursorPosition;
      text = text.substring(0, cursorPosition) + this.cursor + text.substring(cursorPosition);
      if (this.prevCursorPosition !== cursorPosition) {
        this.prevCursorPosition = cursorPosition;
      }
    }
    if (textObject.text !== text) {
      textObject.setText(text);
      this.emit("textchange", text, textObject, this);
    }
    return this;
  }
  setCursor(s) {
    this._cursor = s;
    this.hasCursor = s && s !== "";
    return s;
  }
  setCursorFlashDuration(duration) {
    this.cursorFlashDuration = duration;
    return this;
  }
  get cursor() {
    if (!this._isFocused) {
      return this._cursor;
    }
    var cursor;
    if (this.cursorFlashTimer < this.cursorFlashDuration / 2) {
      cursor = this._cursor;
    } else {
      cursor = " ";
    }
    var timerValue = this.cursorFlashTimer + GetTickDelta_default(this.scene);
    this.cursorFlashTimer = Wrap(timerValue, 0, this.cursorFlashDuration);
    return cursor;
  }
};
var HiddenTextEdit_default2 = HiddenTextEdit2;

// node_modules/phaser3-rex-plugins/plugins/hiddeninputtext.js
var hiddeninputtext_default = HiddenTextEdit_default2;

// node_modules/phaser3-rex-plugins/templates/ui/hiddenedit/HiddenEdit.js
var HiddenEdit_default = hiddeninputtext_default;

// node_modules/phaser3-rex-plugins/templates/ui/hiddenedit/Factory.js
ObjectFactory_default.register("hiddenEdit", function(textObject, config) {
  var gameObject2 = new HiddenEdit_default(textObject, config);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.HiddenEdit", HiddenEdit_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/render/WebGLRenderer.js
var GetCalcMatrix3 = Phaser.GameObjects.GetCalcMatrix;
var WebGLRenderer4 = function(renderer, src, camera, parentMatrix3) {
  src.updateData();
  camera.addToRenderList(src);
  var pipeline = renderer.pipelines.set(src.pipeline);
  var result = GetCalcMatrix3(src, camera, parentMatrix3);
  var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
  var dx = src._displayOriginX;
  var dy = src._displayOriginY;
  var alpha = camera.alpha * src.alpha;
  renderer.pipelines.preBatch(src);
  var shapes = src.geom, shape;
  for (var i = 0, cnt = shapes.length; i < cnt; i++) {
    shape = shapes[i];
    if (shape.visible) {
      shape.webglRender(pipeline, calcMatrix, alpha, dx, dy);
    }
  }
  renderer.pipelines.postBatch(src);
};
var WebGLRenderer_default5 = WebGLRenderer4;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/render/CanvasRenderer.js
var SetTransform3 = Phaser.Renderer.Canvas.SetTransform;
var CanvasRenderer4 = function(renderer, src, camera, parentMatrix3) {
  src.updateData();
  camera.addToRenderList(src);
  var ctx = renderer.currentContext;
  if (SetTransform3(renderer, ctx, src, camera, parentMatrix3)) {
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var shapes = src.geom, shape;
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      shape = shapes[i];
      if (shape.visible) {
        shape.canvasRender(ctx, dx, dy);
      }
    }
    ctx.restore();
  }
};
var CanvasRenderer_default5 = CanvasRenderer4;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/render/Render.js
var Render_default5 = {
  renderWebGL: WebGLRenderer_default5,
  renderCanvas: CanvasRenderer_default5
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/BaseShapes.js
var Shape2 = Phaser.GameObjects.Shape;
var RemoveItem8 = Phaser.Utils.Array.Remove;
var BaseShapes = class extends Shape2 {
  constructor(scene, x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 2;
    }
    if (height === void 0) {
      height = width;
    }
    super(scene, "rexShapes", []);
    this._width = -1;
    this._height = -1;
    this.dirty = true;
    this.isSizeChanged = true;
    this.shapes = {};
    this.setPosition(x, y);
    this.setSize(width, height);
    this.updateDisplayOrigin();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this.setSize(value, this._height);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this.setSize(this._width, value);
  }
  setDirty(value) {
    if (value === void 0) {
      value = true;
    }
    this.dirty = value;
    return this;
  }
  setSize(width, height) {
    this.isSizeChanged = this.isSizeChanged || this._width !== width || this._height !== height;
    this.dirty = this.dirty || this.isSizeChanged;
    this._width = width;
    this._height = height;
    this.updateDisplayOrigin();
    var input = this.input;
    if (input && !input.customHitArea) {
      input.hitArea.width = width;
      input.hitArea.height = height;
    }
    return this;
  }
  resize(width, height) {
    this.setSize(width, height);
    return this;
  }
  get fillColor() {
    return this._fillColor;
  }
  set fillColor(value) {
    this.setFillStyle(value, this._fillAlpha);
  }
  get fillAlpha() {
    return this._fillAlpha;
  }
  set fillAlpha(value) {
    this.setFillStyle(this._fillColor, value);
  }
  setFillStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.fillColor !== color || this.fillAlpha !== alpha;
    this._fillColor = color;
    this._fillAlpha = alpha;
    return this;
  }
  get lineWidth() {
    return this._lineWidth;
  }
  set lineWidth(value) {
    this.setStrokeStyle(value, this._strokeColor, this._strokeAlpha);
  }
  get strokeColor() {
    return this._strokeColor;
  }
  set strokeColor(value) {
    this.setStrokeStyle(this._lineWidth, value, this._strokeAlpha);
  }
  get strokeAlpha() {
    return this._strokeAlpha;
  }
  set strokeAlpha(value) {
    this.setStrokeStyle(this._lineWidth, this._strokeColor, value);
  }
  setStrokeStyle(lineWidth, color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.lineWidth !== lineWidth || this.strokeColor !== color || this.strokeAlpha !== alpha;
    this._lineWidth = lineWidth;
    this._strokeColor = color;
    this._strokeAlpha = alpha;
    return this;
  }
  updateShapes() {
  }
  updateData() {
    if (!this.dirty) {
      return this;
    }
    this.updateShapes();
    var shapes = this.geom;
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var shape = shapes[i];
      if (shape.dirty) {
        shape.updateData();
      }
    }
    this.isSizeChanged = false;
    this.dirty = false;
    return this;
  }
  clear() {
    this.geom.length = 0;
    Clear_default(this.shapes);
    this.dirty = true;
    return this;
  }
  getShape(name2) {
    return this.shapes[name2];
  }
  getShapes() {
    return this.geom;
  }
  addShape(shape) {
    this.geom.push(shape);
    var name2 = shape.name;
    if (name2) {
      this.shapes[name2] = shape;
    }
    this.dirty = true;
    return this;
  }
  deleteShape(name2) {
    var shape = this.getShape(name2);
    if (shape) {
      delete this.shapes[name2];
      RemoveItem8(this.geom, shape);
    }
    return this;
  }
};
Object.assign(
  BaseShapes.prototype,
  Render_default5
);
var BaseShapes_default = BaseShapes;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/methods/StyleMethods.js
var StyleMethods_default = {
  setBoxFillStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.boxFillColor !== color || this.boxFillAlpha !== alpha;
    this.boxFillColor = color;
    this.boxFillAlpha = alpha;
    return this;
  },
  setUncheckedBoxFillStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.uncheckedBoxFillColor !== color || this.uncheckedBoxFillAlpha !== alpha;
    this.uncheckedBoxFillColor = color;
    this.uncheckedBoxFillAlpha = alpha;
    return this;
  },
  setBoxStrokeStyle(lineWidth, color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.boxLineWidth !== lineWidth || this.boxStrokeColor !== color || this.boxStrokeAlpha !== alpha;
    this.boxLineWidth = lineWidth;
    this.boxStrokeColor = color;
    this.boxStrokeAlpha = alpha;
    return this;
  },
  setUncheckedBoxStrokeStyle(lineWidth, color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.uncheckedBoxLineWidth !== lineWidth || this.uncheckedBoxStrokeColor !== color || this.uncheckedBoxStrokeAlpha !== alpha;
    this.uncheckedBoxLineWidth = lineWidth;
    this.uncheckedBoxStrokeColor = color;
    this.uncheckedBoxStrokeAlpha = alpha;
    return this;
  },
  setCheckerStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.checkerColor !== color || this.checkAlpha !== alpha;
    this.checkerColor = color;
    this.checkAlpha = alpha;
    return this;
  },
  setBoxShape(isCircleShape) {
    if (isCircleShape === void 0) {
      isCircleShape = false;
    }
    if (this.isCircleShape === isCircleShape) {
      return this;
    }
    this.isCircleShape = isCircleShape;
    this.isSizeChanged = true;
    this.dirty = true;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/methods/SizeMethods.js
var SizeMethods_default = {
  setBoxSize(size) {
    this.dirty = this.dirty || this.boxSize !== size;
    this.boxSize = size;
    return this;
  },
  setCheckerSize(size) {
    this.dirty = this.dirty || this.checkerSize !== size;
    this.checkerSize = size;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/base/StyleMethods.js
var FillStyle = function(color, alpha) {
  if (color == null) {
    this.isFilled = false;
  } else {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.isFilled = true;
    this.fillColor = color;
    this.fillAlpha = alpha;
  }
  return this;
};
var LineStyle = function(lineWidth, color, alpha) {
  if (lineWidth == null || color == null) {
    this.isStroked = false;
  } else {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.isStroked = true;
    this.lineWidth = lineWidth;
    this.strokeColor = color;
    this.strokeAlpha = alpha;
  }
  return this;
};
var StyleMethods_default2 = {
  fillStyle: FillStyle,
  lineStyle: LineStyle
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/base/BaseGeom.js
var BaseGeom = class {
  constructor() {
    this.name = void 0;
    this.dirty = true;
    this.visible = true;
    this.data = void 0;
    this.isFilled = false;
    this.fillColor = void 0;
    this.fillAlpha = 1;
    this.isStroked = false;
    this.lineWidth = 1;
    this.strokeColor = void 0;
    this.strokeAlpha = 1;
  }
  setName(name2) {
    this.name = name2;
    return this;
  }
  setVisible(visible) {
    if (visible === void 0) {
      visible = true;
    }
    this.visible = visible;
    return this;
  }
  reset() {
    this.setVisible().fillStyle().lineStyle();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
  }
  canvasRender(ctx, dx, dy) {
  }
  updateData() {
    this.dirty = false;
  }
};
Object.assign(
  BaseGeom.prototype,
  StyleMethods_default2,
  DataMethods_default
);
var BaseGeom_default = BaseGeom;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/PathBase.js
var Earcut3 = Phaser.Geom.Polygon.Earcut;
var PathBase = class extends BaseGeom_default {
  constructor() {
    super();
    this.pathData = [];
    this.pathIndexes = [];
    this.closePath = false;
  }
  updateData() {
    this.pathIndexes = Earcut3(this.pathData);
    super.updateData();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
    if (this.isFilled) {
      FillPathWebGL_default(pipeline, calcMatrix, this, alpha, dx, dy);
    }
    if (this.isStroked) {
      StrokePathWebGL_default(pipeline, this, alpha, dx, dy);
    }
  }
  canvasRender(ctx, dx, dy) {
    var path = this.pathData;
    var pathLength = path.length - 1;
    var px1 = path[0] - dx;
    var py1 = path[1] - dy;
    ctx.beginPath();
    ctx.moveTo(px1, py1);
    if (!this.closePath) {
      pathLength -= 2;
    }
    for (var i = 2; i < pathLength; i += 2) {
      var px2 = path[i] - dx;
      var py2 = path[i + 1] - dy;
      ctx.lineTo(px2, py2);
    }
    if (this.closePath) {
      ctx.closePath();
    }
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fill();
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.stroke();
    }
  }
};
var PathBase_default = PathBase;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/arc/Arc.js
var DegToRad6 = Phaser.Math.DegToRad;
var Arc = class extends PathBase_default {
  constructor(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (radiusX === void 0) {
      radiusX = 0;
    }
    if (radiusY === void 0) {
      radiusY = 0;
    }
    if (startAngle === void 0) {
      startAngle = 0;
    }
    if (endAngle === void 0) {
      endAngle = 360;
    }
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    if (pie === void 0) {
      pie = false;
    }
    super();
    this.setCenterPosition(x, y);
    this.setRadius(radiusX, radiusY);
    this.setAngle(startAngle, endAngle, anticlockwise);
    this.setPie(pie);
    this.setIterations(32);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this.dirty = this.dirty || this._x !== value;
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this.dirty = this.dirty || this._y !== value;
    this._y = value;
  }
  setCenterPosition(x, y) {
    if (y === void 0) {
      y = x;
    }
    this.x = x;
    this.y = y;
    return this;
  }
  get radiusX() {
    return this._radiusX;
  }
  set radiusX(value) {
    this.dirty = this.dirty || this._radiusX !== value;
    this._radiusX = value;
  }
  get radiusY() {
    return this._radiusY;
  }
  set radiusY(value) {
    this.dirty = this.dirty || this._radiusY !== value;
    this._radiusY = value;
  }
  setRadius(radiusX, radiusY) {
    if (radiusY === void 0) {
      radiusY = radiusX;
    }
    this.radiusX = radiusX;
    this.radiusY = radiusY;
    return this;
  }
  get startAngle() {
    return this._startAngle;
  }
  set startAngle(value) {
    this.dirty = this.dirty || this._startAngle !== value;
    this._startAngle = value;
  }
  get endAngle() {
    return this._endAngle;
  }
  set endAngle(value) {
    this.dirty = this.dirty || this._endAngle !== value;
    this._endAngle = value;
  }
  get anticlockwise() {
    return this._anticlockwise;
  }
  set anticlockwise(value) {
    this.dirty = this.dirty || this._anticlockwise !== value;
    this._anticlockwise = value;
  }
  setAngle(startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.anticlockwise = anticlockwise;
    return this;
  }
  get pie() {
    return this._pie;
  }
  set pie(value) {
    this.dirty = this.dirty || this._pie !== value;
    this._pie = value;
  }
  setPie(pie) {
    if (pie === void 0) {
      pie = true;
    }
    this.pie = pie;
    return this;
  }
  get iterations() {
    return this._iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this._iterations !== value;
    this._iterations = value;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    if (this.pie) {
      this.pathData.push(this.x, this.y);
    }
    ArcTo_default(
      this.x,
      this.y,
      this.radiusX,
      this.radiusY,
      this.startAngle,
      this.endAngle,
      this.anticlockwise,
      this.iterations,
      this.pathData
    );
    if (this.pie) {
      this.pathData.push(this.x, this.y);
    }
    this.pathData.push(this.pathData[0], this.pathData[1]);
    super.updateData();
    return this;
  }
  canvasRender(ctx, dx, dy) {
    ctx.beginPath();
    var x = this.x - dx, y = this.y - dy, startAngle = DegToRad6(this.startAngle), endAngle = DegToRad6(this.endAngle);
    if (this.pie) {
      ctx.moveTo(x, y);
      ctx.lineTo(
        x + Math.cos(startAngle) * this.radiusX,
        y + Math.sin(startAngle) * this.radiusY
      );
    }
    ctx.ellipse(
      x,
      y,
      this.radiusX,
      this.radiusY,
      0,
      startAngle,
      endAngle,
      this.anticlockwise
    );
    if (this.pie) {
      ctx.lineTo(x, y);
    }
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fill();
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.stroke();
    }
  }
};
var Arc_default = Arc;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/arc/Circle.js
var Circle = class extends Arc_default {
  constructor(x, y, radius) {
    super(x, y, radius, radius, 0, 360);
  }
};
var Circle_default = Circle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/Curve.js
var Curve = class extends PathBase_default {
  constructor(curve) {
    super();
    this.setCurve(curve);
    this.setIterations(32);
  }
  get curve() {
    return this._curve;
  }
  set curve(value) {
    this.dirty = this.dirty || this._curve !== value;
    this._curve = value;
  }
  setCurve(curve) {
    this.curve = curve;
    return this;
  }
  get iterations() {
    return this._iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this._iterations !== value;
    this._iterations = value;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    var points = this.curve.getPoints(this.iterations);
    for (var i = 0, cnt = points.length; i < cnt; i++) {
      this.pathData.push(points[i].x, points[i].y);
    }
    this.pathData.push(points[0].x, points[0].y);
    super.updateData();
    return this;
  }
};
var Curve_default = Curve;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/arc/Ellipse.js
var Ellipse = class extends Arc_default {
  constructor(x, y, radiusX, radiusY) {
    super(x, y, radiusX, radiusY, 0, 360);
  }
};
var Ellipse_default = Ellipse;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/Line.js
var Line = class extends PathBase_default {
  constructor(x0, y0, x1, y1) {
    if (x0 === void 0) {
      x0 = 0;
    }
    if (y0 === void 0) {
      y0 = 0;
    }
    if (x1 === void 0) {
      x1 = 0;
    }
    if (y1 === void 0) {
      y1 = 0;
    }
    super();
    this.setP0(x0, y0);
    this.setP1(x1, y1);
  }
  get x0() {
    return this._x0;
  }
  set x0(value) {
    this.dirty = this.dirty || this._x0 !== value;
    this._x0 = value;
  }
  get y0() {
    return this._y0;
  }
  set y0(value) {
    this.dirty = this.dirty || this._y0 !== value;
    this._y0 = value;
  }
  setP0(x, y) {
    this.x0 = x;
    this.y0 = y;
    return this;
  }
  get x1() {
    return this._x1;
  }
  set x1(value) {
    this.dirty = this.dirty || this._x1 !== value;
    this._x1 = value;
  }
  get y1() {
    return this._y1;
  }
  set y1(value) {
    this.dirty = this.dirty || this._y1 !== value;
    this._y1 = value;
  }
  setP1(x, y) {
    this.x1 = x;
    this.y1 = y;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    this.pathData.push(this.x0, this.y0);
    this.pathData.push(this.x1, this.y1);
    this.pathData.push(this.x0, this.y0);
    super.updateData();
    return this;
  }
};
var Line_default = Line;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/StartAt.js
var StartAt = function(x, y, pathData) {
  pathData.length = 0;
  if (x != null) {
    pathData.push(x, y);
  }
  return pathData;
};
var StartAt_default = StartAt;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/QuadraticBezierTo.js
var QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;
var QuadraticBezierTo = function(cx, cy, x, y, iterations, pathData) {
  var pathDataCnt2 = pathData.length;
  var p0x = pathData[pathDataCnt2 - 2];
  var p0y = pathData[pathDataCnt2 - 1];
  for (var i = 1, last = iterations - 1; i <= last; i++) {
    var t = i / last;
    pathData.push(
      QuadraticBezierInterpolation(t, p0x, cx, x),
      QuadraticBezierInterpolation(t, p0y, cy, y)
    );
  }
  return pathData;
};
var QuadraticBezierTo_default = QuadraticBezierTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/CubicBezierCurveTo.js
var CubicBezierInterpolation = Phaser.Math.Interpolation.CubicBezier;
var CubicBezierCurveTo = function(cx0, cy0, cx1, cy1, x, y, iterations, pathData) {
  var pathDataCnt2 = pathData.length;
  var p0x = pathData[pathDataCnt2 - 2];
  var p0y = pathData[pathDataCnt2 - 1];
  for (var i = 1, last = iterations - 1; i <= last; i++) {
    var t = i / last;
    pathData.push(
      CubicBezierInterpolation(t, p0x, cx0, cx1, x),
      CubicBezierInterpolation(t, p0y, cy0, cy1, y)
    );
  }
  return pathData;
};
var CubicBezierCurveTo_default = CubicBezierCurveTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/CatmullRomTo.js
var CatmullRomInterpolation = Phaser.Math.Interpolation.CatmullRom;
var CatmullRomTo = function(points, iterations, pathData) {
  var pathDataCnt2 = pathData.length;
  var p0x = pathData[pathDataCnt2 - 2];
  var p0y = pathData[pathDataCnt2 - 1];
  var xList = [p0x];
  var yList = [p0y];
  for (var i = 0, cnt = points.length; i < cnt; i += 2) {
    xList.push(points[i]);
    yList.push(points[i + 1]);
  }
  for (var i = 1, last = iterations - 1; i <= last; i++) {
    var t = i / last;
    pathData.push(
      CatmullRomInterpolation(xList, t),
      CatmullRomInterpolation(yList, t)
    );
  }
  return pathData;
};
var CatmullRomTo_default = CatmullRomTo;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/DuplicateLast.js
var DuplicateLast = function(pathData) {
  var len = pathData.length;
  if (len < 2) {
    return pathData;
  }
  var lastX = pathData[len - 2];
  var lastY = pathData[len - 1];
  pathData.push(lastX);
  pathData.push(lastY);
  return pathData;
};
var DuplicateLast_default = DuplicateLast;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/AddPathMethods.js
var AddPathMethods_default = {
  clear() {
    this.start();
    return this;
  },
  start() {
    this.startAt();
    return this;
  },
  startAt(x, y) {
    this.restorePathData();
    this.accumulationLengths = void 0;
    StartAt_default(x, y, this.pathData);
    this.firstPointX = x;
    this.firstPointY = y;
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  lineTo(x, y, relative) {
    if (relative === void 0) {
      relative = false;
    }
    if (relative) {
      x += this.lastPointX;
      y += this.lastPointY;
    }
    LineTo_default(x, y, this.pathData);
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  verticalLineTo(x, relative) {
    this.lineTo(x, this.lastPointY, relative);
    return this;
  },
  horizontalLineTo(y, relative) {
    this.lineTo(this.lastPointX, y, relative);
    return this;
  },
  ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    ArcTo_default(
      centerX,
      centerY,
      radiusX,
      radiusY,
      startAngle,
      endAngle,
      anticlockwise,
      this.iterations,
      this.pathData
    );
    this.lastPointX = this.pathData[this.pathData.length - 2];
    this.lastPointY = this.pathData[this.pathData.length - 1];
    return this;
  },
  arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
    this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
    return this;
  },
  quadraticBezierTo(cx, cy, x, y) {
    QuadraticBezierTo_default(
      cx,
      cy,
      x,
      y,
      this.iterations,
      this.pathData
    );
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
    CubicBezierCurveTo_default(
      cx0,
      cy0,
      cx1,
      cy1,
      x,
      y,
      this.iterations,
      this.pathData
    );
    this.lastPointX = x;
    this.lastPointY = y;
    return this;
  },
  catmullRomTo(...points) {
    CatmullRomTo_default(
      points,
      this.iterations,
      this.pathData
    );
    this.lastPointX = points[points.length - 2];
    this.lastPointY = points[points.length - 1];
    return this;
  },
  close() {
    var startX = this.pathData[0], startY = this.pathData[1];
    if (startX !== this.lastPointX || startY !== this.lastPointY) {
      this.lineTo(startX, startY);
    }
    this.closePath = true;
    return this;
  },
  end() {
    DuplicateLast_default(this.pathData);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/RotateAround.js
var PointRotateAround = Phaser.Math.RotateAround;
var RotateAround4 = function(centerX, centerY, angle, pathData) {
  var point = { x: 0, y: 0 };
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    point.x = pathData[i];
    point.y = pathData[i + 1];
    PointRotateAround(point, centerX, centerY, angle);
    pathData[i] = point.x;
    pathData[i + 1] = point.y;
  }
  return pathData;
};
var RotateAround_default = RotateAround4;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/Scale.js
var Scale = function(centerX, centerY, scaleX, scaleY, pathData) {
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    var x = pathData[i] - centerX;
    var y = pathData[i + 1] - centerY;
    x *= scaleX;
    y *= scaleY;
    pathData[i] = x + centerX;
    pathData[i + 1] = y + centerY;
  }
  return pathData;
};
var Scale_default = Scale;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/Offset.js
var Offset = function(x, y, pathData) {
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    pathData[i] += x;
    pathData[i + 1] += y;
  }
  return pathData;
};
var Offset_default = Offset;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/TransformPointsMethods.js
var DegToRad7 = Phaser.Math.DegToRad;
var PointRotateAround2 = Phaser.Math.RotateAround;
var TransformPointsMethods_default = {
  rotateAround(centerX, centerY, angle) {
    if (this.pathData.length === 0) {
      return this;
    }
    angle = DegToRad7(angle);
    RotateAround_default(centerX, centerY, angle, this.pathData);
    var pathDataCnt2 = this.pathData.length;
    this.lastPointX = this.pathData[pathDataCnt2 - 2];
    this.lastPointY = this.pathData[pathDataCnt2 - 1];
    return this;
  },
  scale(centerX, centerY, scaleX, scaleY) {
    if (this.pathData.length === 0) {
      return this;
    }
    Scale_default(centerX, centerY, scaleX, scaleY, this.pathData);
    this.lastPointX = this.pathData[pathDataCnt - 2];
    this.lastPointY = this.pathData[pathDataCnt - 1];
    return this;
  },
  offset(x, y) {
    Offset_default(x, y, this.pathData);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/array/Copy.js
var Copy = function(dest, src, startIdx, endIdx) {
  if (startIdx === void 0) {
    startIdx = 0;
  }
  ;
  if (endIdx === void 0) {
    endIdx = src.length;
  }
  dest.length = endIdx - startIdx;
  for (var i = 0, len = dest.length; i < len; i++) {
    dest[i] = src[i + startIdx];
  }
  return dest;
};
var Copy_default = Copy;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/SavePathDataMethods.js
var SavePathDataMethods_default = {
  savePathData() {
    if (this.pathDataSaved) {
      return this;
    }
    this.pathDataSave = [...this.pathData];
    this.pathData.length = 0;
    this.pathDataSaved = true;
    return this;
  },
  restorePathData() {
    if (!this.pathDataSaved) {
      return this;
    }
    Copy_default(this.pathData, this.pathDataSave);
    this.pathDataSave = void 0;
    this.pathDataSaved = false;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/PathSegmentMethods.js
var DistanceBetween = Phaser.Math.Distance.Between;
var Wrap2 = Phaser.Math.Wrap;
var Linear3 = Phaser.Math.Linear;
var AppendFromPathSegment = function(srcPathData, accumulationLengths, startT, endT, destPathData) {
  if (endT === void 0) {
    endT = startT;
    startT = 0;
  }
  startT = WrapT(startT);
  endT = WrapT(endT);
  if (startT === endT) {
    return;
  }
  var totalPathLength = accumulationLengths[accumulationLengths.length - 1];
  var startL = totalPathLength * startT;
  var endL = totalPathLength * endT;
  if (startT < endT) {
    AddPathSegment(srcPathData, accumulationLengths, startL, endL, destPathData);
  } else {
    AddPathSegment(srcPathData, accumulationLengths, startL, totalPathLength, destPathData);
    AddPathSegment(srcPathData, accumulationLengths, 0, endL, destPathData);
  }
  DuplicateLast_default(destPathData);
};
var AddPathSegment = function(srcPathData, accumulationLengths, startL, endL, destPathData) {
  var skipState = startL > 0;
  for (var i = 0, cnt = accumulationLengths.length; i < cnt; i++) {
    var pIdx = i * 2;
    var d = accumulationLengths[i];
    if (skipState) {
      if (d < startL) {
        continue;
      } else if (d == startL) {
        skipState = false;
      } else {
        var deltaD = d - accumulationLengths[i - 1];
        var t = 1 - (d - startL) / deltaD;
        destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
        destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
        skipState = false;
      }
    }
    if (d <= endL) {
      destPathData.push(srcPathData[pIdx]);
      destPathData.push(srcPathData[pIdx + 1]);
      if (d === endL) {
        break;
      }
    } else {
      var deltaD = d - accumulationLengths[i - 1];
      var t = 1 - (d - endL) / deltaD;
      destPathData.push(GetInterpolation(srcPathData, pIdx - 2, pIdx, t));
      destPathData.push(GetInterpolation(srcPathData, pIdx - 1, pIdx + 1, t));
      break;
    }
  }
};
var GetInterpolation = function(pathData, i0, i1, t) {
  var p0 = pathData[i0], p1 = pathData[i1];
  return Linear3(p0, p1, t);
};
var WrapT = function(t) {
  if (t === 0) {
    return 0;
  } else if (t % 1 === 0) {
    return 1;
  }
  return Wrap2(t, 0, 1);
};
var PathSegmentMethods_default = {
  updateAccumulationLengths() {
    if (this.accumulationLengths == null) {
      this.accumulationLengths = [];
    } else if (this.accumulationLengths.length === this.pathData.length / 2) {
      return this;
    }
    var accumulationLengths = this.accumulationLengths;
    var pathData = this.pathData;
    var prevX, prevY, x, y;
    var d, accumulationLength = 0;
    for (var i = 0, cnt = pathData.length; i < cnt; i += 2) {
      x = pathData[i];
      y = pathData[i + 1];
      d = prevX === void 0 ? 0 : DistanceBetween(prevX, prevY, x, y);
      accumulationLength += d;
      accumulationLengths.push(accumulationLength);
      prevX = x;
      prevY = y;
    }
    this.totalPathLength = accumulationLength;
    return this;
  },
  setDisplayPathSegment(startT, endT) {
    if (!this.pathDataSaved) {
      this.updateAccumulationLengths();
      this.savePathData();
    }
    this.pathData.length = 0;
    AppendFromPathSegment(this.pathDataSave, this.accumulationLengths, startT, endT, this.pathData);
    return this;
  },
  appendFromPathSegment(src, startT, endT) {
    if (startT === void 0) {
      this.pathData.push(...src.pathData);
    } else {
      src.updateAccumulationLengths();
      AppendFromPathSegment(src.pathData, src.accumulationLengths, startT, endT, this.pathData);
    }
    this.firstPointX = this.pathData[0];
    this.firstPointY = this.pathData[1];
    this.lastPointX = this.pathData[this.pathData.length - 2];
    this.lastPointY = this.pathData[this.pathData.length - 1];
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/GraphicsMethods.js
var GraphicsMethods_default = {
  draw(graphics, isFill, isStroke) {
    var points = this.toPoints();
    if (isFill) {
      graphics.fillPoints(points, this.closePath, this.closePath);
    }
    if (isStroke) {
      graphics.strokePoints(points, this.closePath, this.closePath);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/ToPoints.js
var ToPoints = function(pathData, points) {
  if (points === void 0) {
    points = [];
  }
  for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
    points.push({
      x: pathData[i],
      y: pathData[i + 1]
    });
  }
  return points;
};
var ToPoints_default = ToPoints;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/ToPolygon.js
var Polygon = Phaser.Geom.Polygon;
var ToPolygon = function(pathData, polygon) {
  if (polygon === void 0) {
    polygon = new Polygon();
  }
  polygon.setTo(pathData);
  return polygon;
};
var ToPolygon_default = ToPolygon;

// node_modules/phaser3-rex-plugins/plugins/geom/pathdata/PathDataBuilder/PathDataBuilder.js
var PathDataBuilder = class {
  constructor(pathData) {
    if (pathData === void 0) {
      pathData = [];
    }
    this.pathData = pathData;
    this.closePath = false;
    this.setIterations(32);
    this.firstPointX = void 0;
    this.firstPointY = void 0;
    this.lastPointX = void 0;
    this.lastPointY = void 0;
    this.accumulationLengths = void 0;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  toPoints() {
    return ToPoints_default(this.pathData);
  }
  toPolygon(polygon) {
    return ToPolygon_default(this.pathData, polygon);
  }
};
Object.assign(
  PathDataBuilder.prototype,
  AddPathMethods_default,
  TransformPointsMethods_default,
  SavePathDataMethods_default,
  PathSegmentMethods_default,
  GraphicsMethods_default
);
var PathDataBuilder_default = PathDataBuilder;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/Lines.js
var Lines = class extends PathBase_default {
  constructor() {
    super();
    this.builder = new PathDataBuilder_default(this.pathData);
  }
  get iterations() {
    return this.builder.iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this.builder.iterations !== value;
    this.builder.setIterations(value);
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  get lastPointX() {
    return this.builder.lastPointX;
  }
  get lastPointY() {
    return this.builder.lastPointY;
  }
  start() {
    this.builder.start();
    this.dirty = true;
    return this;
  }
  startAt(x, y) {
    this.builder.startAt(x, y);
    this.dirty = true;
    return this;
  }
  lineTo(x, y, relative) {
    this.builder.lineTo(x, y, relative);
    this.dirty = true;
    return this;
  }
  verticalLineTo(x, relative) {
    this.builder.verticalLineTo(x, relative);
    this.dirty = true;
    return this;
  }
  horizontalLineTo(y, relative) {
    this.builder.horizontalLineTo(y, relative);
    this.dirty = true;
    return this;
  }
  ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
    this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);
    this.dirty = true;
    return this;
  }
  arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
    this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);
    this.dirty = true;
    return this;
  }
  quadraticBezierTo(cx, cy, x, y) {
    this.builder.quadraticBezierTo(cx, cy, x, y);
    this.dirty = true;
    return this;
  }
  cubicBezierTo(cx0, cy0, cx1, cy1, x, y) {
    this.builder.cubicBezierTo(cx0, cy0, cx1, cy1, x, y);
    this.dirty = true;
    return this;
  }
  catmullRomTo(...points) {
    this.builder.catmullRomTo(...points);
    this.dirty = true;
    return this;
  }
  close() {
    this.builder.close();
    this.closePath = this.builder.closePath;
    this.dirty = true;
    return this;
  }
  end() {
    this.builder.end();
    this.dirty = true;
    return this;
  }
  rotateAround(centerX, centerY, angle) {
    this.builder.rotateAround(centerX, centerY, angle);
    this.dirty = true;
    return this;
  }
  scale(centerX, centerY, scaleX, scaleY) {
    this.builder.scale(centerX, centerY, scaleX, scaleY);
    this.dirty = true;
    return this;
  }
  offset(x, y) {
    this.builder.offset(x, y);
    this.dirty = true;
    return this;
  }
  toPolygon(polygon) {
    return this.builder.toPolygon(polygon);
  }
  appendPathFrom(src, startT, endT) {
    this.builder.appendFromPathSegment(src.builder, startT, endT);
    return this;
  }
  copyPathFrom(src, startT, endT) {
    this.builder.clear().appendFromPathSegment(src.builder, startT, endT);
    return this;
  }
  setDisplayPathSegment(startT, endT) {
    this.builder.setDisplayPathSegment(startT, endT);
    return this;
  }
};
var Lines_default = Lines;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/rectangle/Rectangle.js
var GetTint2 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
var Rectangle5 = class extends BaseGeom_default {
  constructor(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = width;
    }
    super();
    this.pathData = [];
    this.closePath = true;
    this.setTopLeftPosition(x, y);
    this.setSize(width, height);
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this.dirty = this.dirty || this._x !== value;
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this.dirty = this.dirty || this._y !== value;
    this._y = value;
  }
  setTopLeftPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this.dirty = this.dirty || this._width !== value;
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this.dirty = this.dirty || this._height !== value;
    this._height = value;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  get centerX() {
    return this.x + this.width / 2;
  }
  set centerX(value) {
    this.x = value - this.width / 2;
  }
  get centerY() {
    return this.y + this.height / 2;
  }
  set centerY(value) {
    this.y = value - this.height / 2;
  }
  setCenterPosition(x, y) {
    this.centerX = x;
    this.centerY = y;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    var x0 = this.x, x1 = x0 + this.width, y0 = this.y, y1 = y0 + this.height;
    this.pathData.push(x0, y0);
    this.pathData.push(x1, y0);
    this.pathData.push(x1, y1);
    this.pathData.push(x0, y1);
    this.pathData.push(x0, y0);
    super.updateData();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
    if (this.isFilled) {
      var fillTint = pipeline.fillTint;
      var fillTintColor = GetTint2(this.fillColor, this.fillAlpha * alpha);
      fillTint.TL = fillTintColor;
      fillTint.TR = fillTintColor;
      fillTint.BL = fillTintColor;
      fillTint.BR = fillTintColor;
      pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
    }
    if (this.isStroked) {
      StrokePathWebGL_default(pipeline, this, alpha, dx, dy);
    }
  }
  canvasRender(ctx, dx, dy) {
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fillRect(-dx, -dy, this.width, this.height);
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.beginPath();
      ctx.rect(-dx, -dy, this.width, this.height);
      ctx.stroke();
    }
  }
};
var Rectangle_default = Rectangle5;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/lines/roundrectangle/RoundRectangle.js
var GetValue52 = Phaser.Utils.Objects.GetValue;
var RoundRectangle4 = class extends PathBase_default {
  constructor(x, y, width, height, radius, iterations) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = width;
    }
    if (radius === void 0) {
      radius = 0;
    }
    if (iterations === void 0) {
      iterations = 6;
    }
    super();
    this.setTopLeftPosition(x, y);
    this.setSize(width, height);
    this.setRadius(radius);
    this.setIterations(iterations);
    this.closePath = true;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this.dirty = this.dirty || this._x !== value;
    this._x = value;
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this.dirty = this.dirty || this._y !== value;
    this._y = value;
  }
  setTopLeftPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this.dirty = this.dirty || this._width !== value;
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this.dirty = this.dirty || this._height !== value;
    this._height = value;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  get centerX() {
    return this.x + this.width / 2;
  }
  set centerX(value) {
    this.x = value - this.width / 2;
  }
  get centerY() {
    return this.y + this.height / 2;
  }
  set centerY(value) {
    this.y = value - this.height / 2;
  }
  setCenterPosition(x, y) {
    this.centerX = x;
    this.centerY = y;
    return this;
  }
  get radiusTL() {
    return this._radiusTL;
  }
  set radiusTL(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusTL !== value || this._convexTL !== isConvex;
    this._convexTL = isConvex;
    this._radiusTL = Math.abs(value);
  }
  get radiusTR() {
    return this._radiusTR;
  }
  set radiusTR(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusTR !== value || this._convexTR !== isConvex;
    this._convexTR = isConvex;
    this._radiusTR = Math.abs(value);
  }
  get radiusBL() {
    return this._radiusBL;
  }
  set radiusBL(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusBL !== value || this._convexBL !== isConvex;
    this._convexBL = isConvex;
    this._radiusBL = Math.abs(value);
  }
  get radiusBR() {
    return this._radiusBR;
  }
  set radiusBR(value) {
    var isConvex = value > 0;
    this.dirty = this.dirty || this._radiusBR !== value || this._convexBR !== isConvex;
    this._convexBR = isConvex;
    this._radiusBR = Math.abs(value);
  }
  get radius() {
    return Math.max(this.radiusTL, this.radiusTR, this.radiusBL, this.radiusBR);
  }
  set radius(value) {
    if (typeof value === "number") {
      this.radiusTL = value;
      this.radiusTR = value;
      this.radiusBL = value;
      this.radiusBR = value;
    } else {
      this.radiusTL = GetValue52(value, "tl", 0);
      this.radiusTR = GetValue52(value, "tr", 0);
      this.radiusBL = GetValue52(value, "bl", 0);
      this.radiusBR = GetValue52(value, "br", 0);
    }
  }
  setRadius(radius) {
    if (radius === void 0) {
      radius = 0;
    }
    this.radius = radius;
    return this;
  }
  get iterations() {
    return this._iterations;
  }
  set iterations(value) {
    this.dirty = this.dirty || this._iterations !== value;
    this._iterations = value;
  }
  setIterations(iterations) {
    this.iterations = iterations;
    return this;
  }
  updateData() {
    var pathData = this.pathData;
    pathData.length = 0;
    var width = this.width, height = this.height, radius, iterations = this.iterations + 1;
    radius = this.radiusTL;
    if (radius > 0) {
      if (this._convexTL) {
        var centerX = radius;
        var centerY = radius;
        ArcTo_default(centerX, centerY, radius, radius, 180, 270, false, iterations, pathData);
      } else {
        var centerX = 0;
        var centerY = 0;
        ArcTo_default(centerX, centerY, radius, radius, 90, 0, true, iterations, pathData);
      }
    } else {
      LineTo_default(0, 0, pathData);
    }
    radius = this.radiusTR;
    if (radius > 0) {
      if (this._convexTR) {
        var centerX = width - radius;
        var centerY = radius;
        ArcTo_default(centerX, centerY, radius, radius, 270, 360, false, iterations, pathData);
      } else {
        var centerX = width;
        var centerY = 0;
        ArcTo_default(centerX, centerY, radius, radius, 180, 90, true, iterations, pathData);
      }
    } else {
      LineTo_default(width, 0, pathData);
    }
    radius = this.radiusBR;
    if (radius > 0) {
      if (this._convexBR) {
        var centerX = width - radius;
        var centerY = height - radius;
        ArcTo_default(centerX, centerY, radius, radius, 0, 90, false, iterations, pathData);
      } else {
        var centerX = width;
        var centerY = height;
        ArcTo_default(centerX, centerY, radius, radius, 270, 180, true, iterations, pathData);
      }
    } else {
      LineTo_default(width, height, pathData);
    }
    radius = this.radiusBL;
    if (radius > 0) {
      if (this._convexBL) {
        var centerX = radius;
        var centerY = height - radius;
        ArcTo_default(centerX, centerY, radius, radius, 90, 180, false, iterations, pathData);
      } else {
        var centerX = 0;
        var centerY = height;
        ArcTo_default(centerX, centerY, radius, radius, 360, 270, true, iterations, pathData);
      }
    } else {
      LineTo_default(0, height, pathData);
    }
    pathData.push(pathData[0], pathData[1]);
    Offset_default(this.x, this.y, pathData);
    super.updateData();
    return this;
  }
};
var RoundRectangle_default5 = RoundRectangle4;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/shapes/geoms/triangle/Triangle.js
var GetTint3 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
var Triangle = class extends BaseGeom_default {
  constructor(x0, y0, x1, y1, x2, y2) {
    if (x0 === void 0) {
      x0 = 0;
    }
    if (y0 === void 0) {
      y0 = 0;
    }
    if (x1 === void 0) {
      x1 = 0;
    }
    if (y1 === void 0) {
      y1 = 0;
    }
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    super();
    this.pathData = [];
    this.closePath = true;
    this.setP0(x0, y0);
    this.setP1(x1, y1);
    this.setP2(x2, y2);
  }
  get x0() {
    return this._x0;
  }
  set x0(value) {
    this.dirty = this.dirty || this._x0 !== value;
    this._x0 = value;
  }
  get y0() {
    return this._y0;
  }
  set y0(value) {
    this.dirty = this.dirty || this._y0 !== value;
    this._y0 = value;
  }
  setP0(x, y) {
    this.x0 = x;
    this.y0 = y;
    return this;
  }
  get x1() {
    return this._x1;
  }
  set x1(value) {
    this.dirty = this.dirty || this._x1 !== value;
    this._x1 = value;
  }
  get y1() {
    return this._y1;
  }
  set y1(value) {
    this.dirty = this.dirty || this._y1 !== value;
    this._y1 = value;
  }
  setP1(x, y) {
    this.x1 = x;
    this.y1 = y;
    return this;
  }
  get x2() {
    return this._x2;
  }
  set x2(value) {
    this.dirty = this.dirty || this._x2 !== value;
    this._x2 = value;
  }
  get y2() {
    return this._y2;
  }
  set y2(value) {
    this.dirty = this.dirty || this._y2 !== value;
    this._y2 = value;
  }
  setP2(x, y) {
    this.dirty = this.dirty || this.x2 !== x || this.y2 !== y;
    this.x2 = x;
    this.y2 = y;
    return this;
  }
  updateData() {
    this.pathData.length = 0;
    this.pathData.push(this.x0, this.y0);
    this.pathData.push(this.x1, this.y1);
    this.pathData.push(this.x2, this.y2);
    this.pathData.push(this.x0, this.y0);
    super.updateData();
    return this;
  }
  webglRender(pipeline, calcMatrix, alpha, dx, dy) {
    if (this.isFilled) {
      var fillTintColor = GetTint3(this.fillColor, this.fillAlpha * alpha);
      var x0 = this.x0 - dx;
      var y0 = this.y0 - dy;
      var x1 = this.x1 - dx;
      var y1 = this.y1 - dy;
      var x2 = this.x2 - dx;
      var y2 = this.y2 - dy;
      var tx0 = calcMatrix.getX(x0, y0);
      var ty0 = calcMatrix.getY(x0, y0);
      var tx1 = calcMatrix.getX(x1, y1);
      var ty1 = calcMatrix.getY(x1, y1);
      var tx2 = calcMatrix.getX(x2, y2);
      var ty2 = calcMatrix.getY(x2, y2);
      pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
    }
    if (this.isStroked) {
      StrokePathWebGL_default(pipeline, this, alpha, dx, dy);
    }
  }
  canvasRender(ctx, dx, dy) {
    var x1 = this.x1 - dx;
    var y1 = this.y1 - dy;
    var x2 = this.x2 - dx;
    var y2 = this.y2 - dy;
    var x3 = this.x3 - dx;
    var y3 = this.y3 - dy;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
    if (this.isFilled) {
      FillStyleCanvas_default(ctx, this);
      ctx.fill();
    }
    if (this.isStroked) {
      LineStyleCanvas_default(ctx, this);
      ctx.stroke();
    }
  }
};
var Triangle_default = Triangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/methods/ShapesUpdateMethods.js
var ShapesUpdateMethods_default = {
  buildShapes() {
    this.addShape(new RoundRectangle_default5().setName("box")).addShape(new Lines_default().setName("checker"));
  },
  updateShapes() {
    var centerX = this.width / 2, centerY = this.height / 2, radius = Math.min(centerX, centerY);
    var width = radius * 2;
    var x = centerX - radius, y = centerY - radius;
    var boxLineWidth = this.boxLineWidth;
    var checkLineWidth = Math.max(width / 10, 2);
    var boxShape = this.getShape("box");
    var checkerShape = this.getShape("checker");
    if (this.isSizeChanged) {
      var posOffset = width * (1 - this.boxSize) / 2;
      var halfBoxLineWidth = boxLineWidth / 2;
      var boxInnerWidth = width * this.boxSize - boxLineWidth;
      boxShape.setTopLeftPosition(x + halfBoxLineWidth + posOffset, y + halfBoxLineWidth + posOffset).setSize(boxInnerWidth, boxInnerWidth);
      if (this.isCircleShape) {
        boxShape.setRadius(boxInnerWidth / 2);
      } else {
        boxShape.setRadius(0);
      }
      var posOffset = width * (1 - this.checkerSize) / 2;
      var unit = width * this.checkerSize / 4;
      var u0 = 0, u1 = unit * 1, u2 = unit * 2, u3 = unit * 3;
      checkerShape.startAt(u1, u2).lineTo(u2, u3).lineTo(u3, u1).offset(x + posOffset, y + posOffset).end();
    }
    if (this.checked) {
      boxShape.fillStyle(this.boxFillColor, this.boxFillAlpha).lineStyle(boxLineWidth, this.boxStrokeColor, this.boxStrokeAlpha);
      checkerShape.lineStyle(checkLineWidth, this.checkerColor);
    } else {
      boxShape.fillStyle(this.uncheckedBoxFillColor, this.uncheckedBoxFillAlpha).lineStyle(boxLineWidth, this.uncheckedBoxStrokeColor, this.uncheckedBoxStrokeAlpha);
      checkerShape.lineStyle();
    }
    if (this.checked) {
      checkerShape.setDisplayPathSegment(this.checkerAnimProgress);
    }
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/ease/EaseValueTask.js
var GetValue53 = Phaser.Utils.Objects.GetValue;
var Linear4 = Phaser.Math.Linear;
var EaseValueTask = class extends EaseValueTaskBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.resetFromJSON();
    this.boot();
  }
  start(config) {
    if (this.timer.isRunning) {
      return this;
    }
    var target = this.target;
    this.propertyKey = GetValue53(config, "key", "value");
    var currentValue = target[this.propertyKey];
    this.fromValue = GetValue53(config, "from", currentValue);
    this.toValue = GetValue53(config, "to", currentValue);
    this.setEase(GetValue53(config, "ease", this.ease));
    this.setDuration(GetValue53(config, "duration", this.duration));
    this.setRepeat(GetValue53(config, "repeat", 0));
    this.setDelay(GetValue53(config, "delay", 0));
    this.setRepeatDelay(GetValue53(config, "repeatDelay", 0));
    this.timer.setDuration(this.duration).setRepeat(this.repeat).setDelay(this.delay).setRepeatDelay(this.repeatDelay);
    target[this.propertyKey] = this.fromValue;
    super.start();
    return this;
  }
  updateTarget(target, timer) {
    var t = timer.t;
    t = this.easeFn(t);
    target[this.propertyKey] = Linear4(this.fromValue, this.toValue, t);
  }
};
var EaseValueTask_default = EaseValueTask;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/methods/CheckerAnimationMethods.js
var CheckerAnimationMethods_default = {
  setCheckerAnimationDuration(duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.checkerAnimDuration = duration;
    return this;
  },
  playCheckerAnimation() {
    if (this.checkerAnimProgressTask === void 0) {
      this.checkerAnimProgressTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.checkerAnimProgressTask.restart({
      key: "checkerAnimProgress",
      from: 0,
      to: 1,
      duration: this.checkerAnimDuration
    });
    return this;
  },
  stopCheckerAnimation() {
    if (this.checkerAnimProgressTask === void 0) {
      return this;
    }
    this.checkerAnimProgressTask.stop();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/methods/Methods.js
var methods9 = {};
Object.assign(
  methods9,
  StyleMethods_default,
  SizeMethods_default,
  ShapesUpdateMethods_default,
  CheckerAnimationMethods_default
);
var Methods_default14 = methods9;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/Const.js
var DefaultBoxFillColor = 23730;
var DefaultCheckerColor = 16777215;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/CheckboxShape.js
var GetValue54 = Phaser.Utils.Objects.GetValue;
var IsPlainObject12 = Phaser.Utils.Objects.IsPlainObject;
var CheckboxShape = class extends BaseShapes_default {
  constructor(scene, x, y, width, height, color, config) {
    if (IsPlainObject12(x)) {
      config = x;
      x = GetValue54(config, "x", 0);
      y = GetValue54(config, "y", 0);
      width = GetValue54(config, "width", 2);
      height = GetValue54(config, "height", 2);
      color = GetValue54(config, "color", DefaultBoxFillColor);
    } else if (IsPlainObject12(color)) {
      config = color;
      color = GetValue54(config, "color", DefaultBoxFillColor);
    }
    super(scene, x, y, width, height);
    this.type = "rexCheckbox";
    if (color === void 0) {
      color = DefaultBoxFillColor;
    }
    this.setBoxShape(
      GetValue54(config, "circleBox", false)
    );
    this.setBoxFillStyle(
      color,
      GetValue54(config, "boxFillAlpha", 1)
    );
    this.setUncheckedBoxFillStyle(
      GetValue54(config, "uncheckedColor", null),
      GetValue54(config, "uncheckedBoxFillAlpha", 1)
    );
    this.setBoxStrokeStyle(
      GetValue54(config, "boxLineWidth", 4),
      GetValue54(config, "boxStrokeColor", color),
      GetValue54(config, "boxStrokeAlpha", 1)
    );
    this.setUncheckedBoxStrokeStyle(
      this.boxLineWidth,
      GetValue54(config, "uncheckedBoxStrokeColor", this.boxStrokeColor),
      GetValue54(config, "uncheckedBoxStrokeAlpha", this.boxStrokeAlpha)
    );
    this.setCheckerStyle(
      GetValue54(config, "checkerColor", DefaultCheckerColor),
      GetValue54(config, "checkerAlpha", 1)
    );
    this.setBoxSize(
      GetValue54(config, "boxSize", 1)
    );
    this.setCheckerSize(
      GetValue54(config, "checkerSize", 1)
    );
    this.setCheckerAnimationDuration(
      GetValue54(config, "animationDuration", 150)
    );
    this.buildShapes();
    var value = GetValue54(config, "checked");
    if (value === void 0) {
      value = GetValue54(config, "value", false);
    }
    this.setValue(value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    value = !!value;
    if (this._value === value) {
      return;
    }
    this.dirty = true;
    this._value = value;
    if (value) {
      this.playCheckerAnimation();
    } else {
      this.stopCheckerAnimation();
    }
    this.emit("valuechange", value);
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  toggleValue() {
    this.setValue(!this.value);
    return this;
  }
  get checked() {
    return this.value;
  }
  set checked(value) {
    this.value = value;
  }
  setChecked(checked) {
    if (checked === void 0) {
      checked = true;
    }
    this.setValue(checked);
    return this;
  }
  toggleChecked() {
    this.toggleValue();
    return this;
  }
  get checkerAnimProgress() {
    return this._checkerAnimProgress;
  }
  set checkerAnimProgress(value) {
    if (this._checkerAnimProgress === value) {
      return;
    }
    this._checkerAnimProgress = value;
    this.dirty = true;
  }
};
Object.assign(
  CheckboxShape.prototype,
  Methods_default14
);
var CheckboxShape_default = CheckboxShape;

// node_modules/phaser3-rex-plugins/plugins/input/button/Button.js
var GetValue55 = Phaser.Utils.Objects.GetValue;
var Button = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this._enable = void 0;
    gameObject2.setInteractive(GetValue55(config, "inputConfig", void 0));
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.pointer = void 0;
    this.lastClickTime = void 0;
    this.isDown = false;
    this.isOver = false;
    this.setEnable(GetValue55(o, "enable", true));
    this.setMode(GetValue55(o, "mode", 1));
    this.setClickInterval(GetValue55(o, "clickInterval", 100));
    this.setDragThreshold(GetValue55(o, "threshold", void 0));
    return this;
  }
  boot() {
    var gameObject2 = this.parent;
    gameObject2.on("pointerdown", this.onPress, this);
    gameObject2.on("pointerup", this.onRelease, this);
    gameObject2.on("pointerout", this.onPointOut, this);
    gameObject2.on("pointermove", this.onMove, this);
    gameObject2.on("pointerover", this.onOver, this);
    gameObject2.on("pointerout", this.onOut, this);
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.pointer = null;
    super.shutdown(fromScene);
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.cancel();
    }
    this._enable = e;
    var eventName = e ? "enable" : "disable";
    this.emit(eventName, this, this.parent);
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  setMode(m) {
    if (typeof m === "string") {
      m = CLICKMODE[m];
    }
    this.mode = m;
    return this;
  }
  setClickInterval(interval) {
    this.clickInterval = interval;
    return this;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
  // internal
  onPress(pointer, localX, localY, event) {
    if (this.pointer !== void 0) {
      return;
    }
    this.pointer = pointer;
    this.isDown = true;
    this.emit("down", this, this.parent, pointer, event);
    if (this.mode === 0) {
      this.click(pointer.downTime, pointer, event);
    }
  }
  onRelease(pointer, localX, localY, event) {
    if (this.pointer !== pointer) {
      return;
    }
    this.isDown = false;
    this.emit("up", this, this.parent, pointer, event);
    if (this.mode === 1) {
      this.click(pointer.upTime, pointer, event);
    }
    this.pointer = void 0;
  }
  onPointOut(pointer, event) {
    if (this.pointer !== pointer) {
      return;
    }
    this.cancel();
  }
  onMove(pointer, localX, localY, event) {
    if (this.pointer !== pointer) {
      return;
    }
    if (this.dragThreshold === void 0) {
      return;
    }
    if (this.mode === 1) {
      if (pointer.getDistance() >= this.dragThreshold) {
        this.cancel();
      }
    }
  }
  onOver(pointer, localX, localY, event) {
    if (!this.enable) {
      return this;
    }
    this.isOver = true;
    this.emit("over", this, this.parent, pointer, event);
    return this;
  }
  onOut(pointer, event) {
    if (!this.enable) {
      return this;
    }
    this.isOver = false;
    this.emit("out", this, this.parent, pointer, event);
    return this;
  }
  click(nowTime, pointer, event) {
    if (!this.enable) {
      return this;
    }
    if (nowTime === void 0) {
      this.emit("click", this, this.parent, pointer, event);
      return this;
    }
    this.pointer = void 0;
    var lastClickTime = this.lastClickTime;
    if (lastClickTime !== void 0 && nowTime - lastClickTime <= this.clickInterval) {
      return this;
    }
    this.lastClickTime = nowTime;
    this.emit("click", this, this.parent, pointer, event);
    return this;
  }
  cancel() {
    this.pointer = void 0;
    return this;
  }
};
var CLICKMODE = {
  press: 0,
  pointerdown: 0,
  release: 1,
  pointerup: 1
};
var Button_default = Button;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/checkbox/Checkbox.js
var GetValue56 = Phaser.Utils.Objects.GetValue;
var IsPlainObject13 = Phaser.Utils.Objects.IsPlainObject;
var Checkbox = class extends CheckboxShape_default {
  constructor(scene, x, y, width, height, color, config) {
    if (IsPlainObject13(x)) {
      config = x;
      x = GetValue56(config, "x", 0);
      y = GetValue56(config, "y", 0);
      width = GetValue56(config, "width", 2);
      height = GetValue56(config, "height", 2);
      color = GetValue56(config, "color", DefaultBoxFillColor);
    } else if (IsPlainObject13(color)) {
      config = color;
      color = GetValue56(config, "color", DefaultBoxFillColor);
    }
    super(scene, x, y, width, height, color, config);
    this._click = new Button_default(this, GetValue56(config, "click"));
    this._click.on("click", function() {
      this.toggleValue();
    }, this);
    this.setReadOnly(GetValue56(config, "readOnly", false));
  }
  get readOnly() {
    return !this._click.enable;
  }
  set readOnly(value) {
    this._click.enable = !value;
  }
  setReadOnly(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.readOnly = enable;
    return this;
  }
};
var Checkbox_default = Checkbox;

// node_modules/phaser3-rex-plugins/plugins/checkbox.js
var checkbox_default = Checkbox_default;

// node_modules/phaser3-rex-plugins/templates/ui/checkbox/Checkbox.js
var Checkbox_default2 = checkbox_default;

// node_modules/phaser3-rex-plugins/templates/ui/checkbox/Factory.js
ObjectFactory_default.register("checkbox", function(x, y, width, height, color, config) {
  var gameObject2 = new Checkbox_default2(this.scene, x, y, width, height, color, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Checkbox", Checkbox_default2);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/methods/StyleMethods.js
var StyleMethods_default3 = {
  setTrackFillStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.trackFillColor !== color || this.trackFillAlpha !== alpha;
    this.trackFillColor = color;
    this.trackFillAlpha = alpha;
    return this;
  },
  setFalseValueTrackFillStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.falseValueTrackColor !== color || this.uncheckedTrackFillAlpha !== alpha;
    this.falseValueTrackColor = color;
    this.falseValueTrackFillAlpha = alpha;
    return this;
  },
  setThumbStyle(color, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    this.dirty = this.dirty || this.thumbColor !== color || this.checkAlpha !== alpha;
    this.thumbColor = color;
    this.thumbAlpha = alpha;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/methods/SizeMethods.js
var SizeMethods_default2 = {
  setTrackSize(width, height) {
    this.dirty = this.dirty || this.trackWidth !== width || this.trackHeight !== height;
    this.trackWidth = width;
    this.trackHeight = height;
    return this;
  },
  setTrackRadius(radius) {
    this.dirty = this.dirty || this.trackRadius !== radius;
    this.trackRadius = radius;
    return this;
  },
  setThumbSize(width, height) {
    if (height === void 0) {
      height = width;
    }
    this.dirty = this.dirty || this.thumbWidth !== width || this.thumbHeight !== height;
    this.thumbWidth = width;
    this.thumbHeight = height;
    return this;
  },
  setThumbRadius(radius) {
    this.dirty = this.dirty || this.thumbRadius !== radius;
    this.thumbRadius = radius;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/methods/PositionMethods.js
var PositionMethods_default = {
  setThumbPosition(left, right) {
    if (right === void 0) {
      right = 1 - left;
    }
    this.thumbLeftX = left;
    this.thumbRightX = right;
    return this;
  },
  setRTL(rtl) {
    if (rtl === void 0) {
      rtl = true;
    }
    this.rtl = rtl;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/math/Linear.js
var Linear5 = function(p0, p1, t) {
  return (p1 - p0) * t + p0;
};
var Linear_default = Linear5;

// node_modules/phaser3-rex-plugins/plugins/utils/color/MixColor.js
var MixColor = function(color0, color1, t) {
  var r = Linear_default(GetR(color0), GetR(color1), t);
  var g = Linear_default(GetG(color0), GetG(color1), t);
  var b = Linear_default(GetB(color0), GetB(color1), t);
  return (r & 255) << 16 | (g & 255) << 8 | b & 255;
};
var MixColor_default = MixColor;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/methods/ShapesUpdateMethods.js
var Linear6 = Phaser.Math.Linear;
var ShapesUpdateMethods_default2 = {
  buildShapes() {
    this.addShape(new RoundRectangle_default5().setName("track")).addShape(new RoundRectangle_default5().setName("thumb"));
  },
  updateShapes() {
    var width = this.width, height = this.height;
    var toggleAnimProgress = this.value ? this.toggleAnimProgress : 1 - this.toggleAnimProgress;
    var trackShape = this.getShape("track");
    if (this.isSizeChanged) {
      var trackWidth = width * this.trackWidth, trackHeight = height * this.trackHeight, trackX = (width - trackWidth) / 2, trackY = (height - trackHeight) / 2, trackRadius = height * this.trackRadius;
      trackShape.setTopLeftPosition(trackX, trackY).setSize(trackWidth, trackHeight).setRadius(trackRadius);
    }
    var trackFillColor = MixColor_default(this.falseValueTrackColor, this.trackFillColor, toggleAnimProgress);
    var trackFillAlpha = Linear6(this.falseValueTrackFillAlpha, this.trackFillAlpha, toggleAnimProgress);
    trackShape.fillStyle(trackFillColor, trackFillAlpha);
    var thumbShape = this.getShape("thumb");
    if (this.isSizeChanged) {
      var thumbWidth = width * this.thumbWidth, thumbHeight = height * this.thumbHeight, thumbRadius = height * this.thumbRadius;
      thumbShape.setSize(thumbWidth, thumbHeight).setRadius(thumbRadius);
    }
    var thumbX = Linear6(this.thumbLeftX, this.thumbRightX, toggleAnimProgress) * width;
    if (this.rtl) {
      thumbX = width - thumbX;
    }
    var thumbY = height / 2;
    thumbShape.setCenterPosition(thumbX, thumbY);
    thumbShape.fillStyle(this.thumbColor, this.thumbAlpha);
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/methods/ToggleAnimationMethods.js
var ToggleAnimationMethods_default = {
  setToggleAnimationDuration(duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.toggleAnimDuration = duration;
    return this;
  },
  playToggleAnimation() {
    if (this.toggleAnimProgressTask === void 0) {
      this.toggleAnimProgressTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.toggleAnimProgressTask.restart({
      key: "toggleAnimProgress",
      from: 0,
      to: 1,
      duration: this.toggleAnimDuration
    });
    return this;
  },
  stopToggleAnimation() {
    if (this.toggleAnimProgressTask === void 0) {
      return this;
    }
    this.toggleAnimProgressTask.stop();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/methods/Methods.js
var methods10 = {};
Object.assign(
  methods10,
  StyleMethods_default3,
  SizeMethods_default2,
  PositionMethods_default,
  ShapesUpdateMethods_default2,
  ToggleAnimationMethods_default
);
var Methods_default15 = methods10;

// node_modules/phaser3-rex-plugins/plugins/utils/color/GrayScale.js
var GrayScale = function(color) {
  var shade = 0.3 * GetR(color) + 0.59 * GetG(color) + 0.11 * GetB(color);
  return (shade & 255) << 16 | (shade & 255) << 8 | shade & 255;
};
var GrayScale_default = GrayScale;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/ToggleSwitchShape.js
var GetValue57 = Phaser.Utils.Objects.GetValue;
var IsPlainObject14 = Phaser.Utils.Objects.IsPlainObject;
var DefaultTrackFillColor = 23730;
var DefaultThumbFillColor = 16777215;
var ToggleSwitchShape = class extends BaseShapes_default {
  constructor(scene, x, y, width, height, color, config) {
    if (IsPlainObject14(x)) {
      config = x;
      x = GetValue57(config, "x", 0);
      y = GetValue57(config, "y", 0);
      width = GetValue57(config, "width", 2);
      height = GetValue57(config, "height", 2);
      color = GetValue57(config, "color", DefaultTrackFillColor);
    } else if (IsPlainObject14(color)) {
      config = color;
      color = GetValue57(config, "color", DefaultTrackFillColor);
    }
    super(scene, x, y, width, height);
    this.type = "rexToggleSwitch";
    if (color === void 0) {
      color = DefaultTrackFillColor;
    }
    this.setTrackFillStyle(
      color,
      GetValue57(config, "trackFillAlpha", 1)
    );
    this.setFalseValueTrackFillStyle(
      GetValue57(config, "falseValueTrackColor", GrayScale_default(color)),
      GetValue57(config, "falseValueTrackFillAlpha", 1)
    );
    this.setThumbStyle(
      GetValue57(config, "thumbColor", DefaultThumbFillColor),
      GetValue57(config, "thumbAlpha", 1)
    );
    this.setTrackSize(
      GetValue57(config, "trackWidth", 0.9),
      GetValue57(config, "trackHeight", 0.5)
    );
    this.setTrackRadius(
      GetValue57(config, "trackRadius", this.trackHeight * 0.5)
    );
    var thumbHeight = GetValue57(config, "thumbHeight", void 0);
    var thumbWidth = GetValue57(config, "thumbWidth", thumbHeight);
    if (thumbWidth === void 0) {
      thumbWidth = this.trackHeight * 0.9;
    }
    this.setThumbSize(thumbWidth, thumbHeight);
    this.setThumbRadius(
      GetValue57(config, "thumbRadius", this.thumbHeight * 0.5)
    );
    this.setThumbPosition(
      GetValue57(config, "thumbLeft", 0.3),
      GetValue57(config, "thumbRight", void 0)
    );
    this.setRTL(GetValue57(config, "rtl", false));
    this.setToggleAnimationDuration(
      GetValue57(config, "animationDuration", 150)
    );
    this.buildShapes();
    this.setValue(GetValue57(config, "value", false), 0);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    value = !!value;
    if (this._value === value) {
      return;
    }
    this.dirty = true;
    this._value = value;
    this.playToggleAnimation();
    this.emit("valuechange", value);
  }
  setValue(value, duration) {
    if (duration === void 0) {
      duration = this.toggleAnimDuration;
    }
    var durationSave = this.toggleAnimDuration;
    this.toggleAnimDuration = duration;
    this.value = value;
    this.toggleAnimDuration = durationSave;
    return this;
  }
  toggleValue(duration) {
    this.setValue(!this.value, duration);
    return this;
  }
  get toggleAnimProgress() {
    return this._toggleAnimProgress;
  }
  set toggleAnimProgress(value) {
    if (this._toggleAnimProgress === value) {
      return;
    }
    this._toggleAnimProgress = value;
    this.dirty = true;
  }
};
Object.assign(
  ToggleSwitchShape.prototype,
  Methods_default15
);
var ToggleSwitchShape_default = ToggleSwitchShape;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/toggleswitch/ToggleSwitch.js
var GetValue58 = Phaser.Utils.Objects.GetValue;
var ToggleSwitch = class extends ToggleSwitchShape_default {
  constructor(scene, x, y, width, height, color, config) {
    super(scene, x, y, width, height, color, config);
    this._click = new Button_default(this, GetValue58(config, "click"));
    this._click.on("click", function() {
      this.toggleValue();
    }, this);
    this.setReadOnly(GetValue58(config, "readOnly", false));
  }
  get readOnly() {
    return !this._click.enable;
  }
  set readOnly(value) {
    this._click.enable = !value;
  }
  setReadOnly(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.readOnly = enable;
    return this;
  }
};
var ToggleSwitch_default = ToggleSwitch;

// node_modules/phaser3-rex-plugins/plugins/toggleswitch.js
var toggleswitch_default = ToggleSwitch_default;

// node_modules/phaser3-rex-plugins/templates/ui/toggleswitch/ToggleSwitch.js
var ToggleSwitch_default2 = toggleswitch_default;

// node_modules/phaser3-rex-plugins/templates/ui/toggleswitch/Factory.js
ObjectFactory_default.register("toggleSwitch", function(x, y, width, height, color, config) {
  var gameObject2 = new ToggleSwitch_default2(this.scene, x, y, width, height, color, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ToggleSwitch", ToggleSwitch_default2);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvas/LoadImageMethods.js
var LoadImageMethods_default = {
  loadFromURL(url, callback) {
    var self = this;
    var img = new Image();
    img.onload = function() {
      if (self.width !== img.width || self.height !== img.height) {
        self.resize(img.width, img.height);
      } else {
        self.clear();
      }
      self.context.drawImage(img, 0, 0);
      self.updateTexture();
      if (callback) {
        callback();
      }
      img.onload = null;
      img.src = "";
      img.remove();
    };
    img.src = url;
    return this;
  },
  loadFromURLPromise(url) {
    var self = this;
    return new Promise(function(resolve, reject) {
      self.loadFromURL(url, resolve);
    });
  },
  loadFromFile(file, callback) {
    var url = URL.createObjectURL(file);
    this.loadFromURL(url, function() {
      URL.revokeObjectURL(url);
      if (callback) {
        callback();
      }
    });
    return this;
  },
  loadFromFilePromise(file) {
    var self = this;
    return new Promise(function(resolve, reject) {
      self.loadFromFile(file, resolve);
    });
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/canvas/Canvas.js
var Canvas2 = class extends Canvas_default {
};
Object.assign(
  Canvas2.prototype,
  LoadImageMethods_default
);
var Canvas_default2 = Canvas2;

// node_modules/phaser3-rex-plugins/plugins/canvas.js
var canvas_default = Canvas_default2;

// node_modules/phaser3-rex-plugins/templates/ui/canvas/Canvas.js
var Canvas_default3 = canvas_default;

// node_modules/phaser3-rex-plugins/templates/ui/canvas/Factory.js
ObjectFactory_default.register("canvas", function(x, y, width, height) {
  var gameObject2 = new Canvas_default3(this.scene, x, y, width, height);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Canvas", Canvas_default3);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/circlemaskimage/CircleMaskImage.js
var GetValue59 = Phaser.Utils.Objects.GetValue;
var CircleMaskImage = class extends Canvas_default {
  constructor(scene, x, y, key2, frame, config) {
    super(scene, x, y);
    this.type = "rexCircleMaskImage";
    this.setTexture(key2, frame, config);
  }
  setTexture(key2, frame, config) {
    if (typeof frame === "object") {
      config = frame;
      frame = void 0;
    }
    if (typeof config === "string") {
      config = {
        maskType: config
      };
    }
    var maskType = GetValue59(config, "maskType", 0);
    var backgroundColor = GetValue59(config, "backgroundColor", void 0);
    var strokeColor = GetValue59(config, "strokeColor", void 0);
    var defaultStrokeWidth = strokeColor != null ? 10 : 0;
    var strokeWidth = GetValue59(config, "strokeWidth", defaultStrokeWidth);
    if (maskType === void 0) {
      maskType = 0;
    } else if (typeof maskType === "string") {
      maskType = MASKTYPE[maskType];
    }
    this._textureKey = key2;
    this._frameName = frame;
    if (maskType === null) {
      this.loadTexture(key2, frame);
      this.dirty = true;
      return this;
    }
    var textureFrame = this.scene.sys.textures.getFrame(key2, frame);
    if (!textureFrame) {
      return this;
    }
    if (textureFrame.cutWidth !== this.width || textureFrame.cutHeight !== this.height) {
      this.setCanvasSize(textureFrame.cutWidth, textureFrame.cutHeight);
    } else {
      this.clear();
    }
    var canvas = this.canvas, ctx = this.context;
    var width = canvas.width, height = canvas.height;
    if (backgroundColor != null) {
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, width, height);
    }
    ctx.save();
    ctx.beginPath();
    var halfStrokeLineWidth = strokeWidth / 2;
    switch (maskType) {
      case 1:
        var centerX = Math.floor(width / 2);
        var centerY = Math.floor(height / 2);
        var radiusX = centerX - halfStrokeLineWidth;
        var radiusY = centerY - halfStrokeLineWidth;
        ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
        break;
      case 2:
        var radiusConfig = GetValue59(config, "radius", 0);
        var iteration = GetValue59(config, "iteration", void 0);
        AddRoundRectanglePath_default(
          ctx,
          halfStrokeLineWidth,
          halfStrokeLineWidth,
          width - strokeWidth,
          height - strokeWidth,
          radiusConfig,
          iteration
        );
        break;
      default:
        var centerX = Math.floor(width / 2);
        var centerY = Math.floor(height / 2);
        var radius = Math.min(centerX, centerY) - halfStrokeLineWidth;
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        break;
    }
    if (strokeColor != null) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke();
    }
    ctx.clip();
    this.loadTexture(key2, frame);
    ctx.restore();
    this.dirty = true;
    return this;
  }
  resize(width, height) {
    this.setDisplaySize(width, height);
    return this;
  }
};
var MASKTYPE = {
  circle: 0,
  ellipse: 1,
  roundRectangle: 2
};
var CircleMaskImage_default = CircleMaskImage;

// node_modules/phaser3-rex-plugins/plugins/circlemaskimage.js
var circlemaskimage_default = CircleMaskImage_default;

// node_modules/phaser3-rex-plugins/templates/ui/circlemaskimage/CircleMaskImage.js
var CircleMaskImage_default2 = circlemaskimage_default;

// node_modules/phaser3-rex-plugins/templates/ui/circlemaskimage/Factory.js
ObjectFactory_default.register("circleMaskImage", function(x, y, key2, frame, config) {
  var gameObject2 = new CircleMaskImage_default2(this.scene, x, y, key2, frame, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.CircleMaskImage", CircleMaskImage_default2);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/alphamaskimage/AlphaMaskImage.js
var GetValue60 = Phaser.Utils.Objects.GetValue;
var AlphaMaskImage = class extends Canvas_default {
  constructor(scene, x, y, key2, frame, config) {
    super(scene, x, y);
    this.type = "rexAlphaMaskImage";
    this.maskFrame = null;
    this.setTexture(key2, frame, config);
  }
  setTexture(key2, frame, config) {
    if (typeof frame === "object") {
      config = frame;
      frame = void 0;
    }
    if (typeof config === "string") {
      config = {
        mask: {
          key: config
        }
      };
    }
    var maskKey = GetValue60(config, "mask.key");
    var maskFrame = GetValue60(config, "mask.frame");
    var invertMaskAlpha = GetValue60(config, "mask.invertAlpha", false);
    var maskScale = GetValue60(config, "mask.scale");
    var backgroundColor = GetValue60(config, "backgroundColor");
    if (maskKey) {
      this._maskKey = maskKey;
      this._maskFrame = maskFrame;
      this._maskScale = maskScale;
      var texture = maskKey ? this.scene.sys.textures.get(maskKey) : null;
      this.maskFrame = texture ? texture.get(maskFrame) : null;
    }
    this._textureKey = key2;
    this._frameName = frame;
    var maskTextureFrame = this.maskFrame;
    if (maskTextureFrame === null) {
      this.loadTexture(key2, frame);
      this.dirty = true;
      return this;
    }
    var hasBackgroundColor = backgroundColor != null;
    this.loadTexture(key2, frame);
    var canvas = this.canvas, ctx = this.context;
    var width = canvas.width, height = canvas.height;
    ctx.save();
    ctx.globalCompositeOperation = invertMaskAlpha ? "destination-out" : "destination-in";
    var maskWidth, maskHeight;
    if (this._maskScale != null) {
      maskWidth = maskTextureFrame.cutWidth * this._maskScale;
      maskHeight = maskTextureFrame.cutHeight * this._maskScale;
    } else {
      maskWidth = width;
      maskHeight = height;
    }
    var maskX = (width - maskWidth) / 2;
    var maskY = (height - maskHeight) / 2;
    this.drawFrame(
      this._maskKey,
      this._maskFrame,
      maskX,
      maskY,
      maskWidth,
      maskHeight
    );
    ctx.restore();
    if (hasBackgroundColor) {
      ctx.save();
      ctx.globalCompositeOperation = "destination-over";
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }
    this.dirty = true;
    return this;
  }
  resize(width, height) {
    this.setDisplaySize(width, height);
    return this;
  }
};
var AlphaMaskImage_default = AlphaMaskImage;

// node_modules/phaser3-rex-plugins/plugins/alphamaskimage.js
var alphamaskimage_default = AlphaMaskImage_default;

// node_modules/phaser3-rex-plugins/templates/ui/alphamaskimage/AlphaMaskImage.js
var AlphaMaskImage_default2 = alphamaskimage_default;

// node_modules/phaser3-rex-plugins/templates/ui/alphamaskimage/Factory.js
ObjectFactory_default.register("alphaMaskImage", function(x, y, key2, frame, config) {
  var gameObject2 = new AlphaMaskImage_default2(this.scene, x, y, key2, frame, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.AlphaMaskImage", AlphaMaskImage_default2);

// node_modules/phaser3-rex-plugins/plugins/utils/progressvalue/ProgressValueMethods.js
var Linear7 = Phaser.Math.Linear;
var Percent = Phaser.Math.Percent;
var ProgressValueMethods_default = {
  setValue(value, min, max) {
    if (value === void 0 || value === null) {
      return this;
    }
    if (min !== void 0) {
      value = Percent(value, min, max);
    }
    this.value = value;
    return this;
  },
  addValue(inc, min, max) {
    if (min !== void 0) {
      inc = Percent(inc, min, max);
    }
    this.value += inc;
    return this;
  },
  getValue(min, max) {
    var value = this.value;
    if (min !== void 0 && max !== void 0) {
      value = Linear7(min, max, value);
    }
    return value;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/ease/EaseValueMethods.js
var Percent2 = Phaser.Math.Percent;
var EaseValueMethods_default = {
  setEaseValuePropName(name2) {
    this.easeValuePropName = name2;
    return this;
  },
  setEaseValueDuration(duration) {
    this.easeValueDuration = duration;
    return this;
  },
  setEaseValueFunction(ease) {
    this.easeFunction = ease;
    return this;
  },
  stopEaseValue() {
    if (this.easeValueTask) {
      this.easeValueTask.stop();
    }
    return this;
  },
  easeValueTo(value, min, max) {
    if (value === void 0 || value === null) {
      return this;
    }
    if (min !== void 0) {
      value = Percent2(value, min, max);
    }
    if (this.easeValueTask === void 0) {
      this.easeValueTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.easeValueTask.restart({
      key: this.easeValuePropName,
      to: value,
      duration: this.easeValueDuration,
      ease: this.easeFunction
    });
    return this;
  },
  easeValueRepeat(from, to, repeat, repeatDelay) {
    if (repeat === void 0) {
      repeat = -1;
    }
    if (repeatDelay === void 0) {
      repeatDelay = 0;
    }
    if (this.easeValueTask === void 0) {
      this.easeValueTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.easeValueTask.restart({
      key: this.easeValuePropName,
      from,
      to,
      duration: this.easeValueDuration,
      ease: this.easeFunction,
      repeat,
      repeatDelay
    });
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/progressbase/ProgressBase.js
var GetValue61 = Phaser.Utils.Objects.GetValue;
var Clamp4 = Phaser.Math.Clamp;
function ProgressBase_default(BaseClass) {
  class ProgressBase extends BaseClass {
    bootProgressBase(config) {
      this.eventEmitter = GetValue61(config, "eventEmitter", this);
      var callback = GetValue61(config, "valuechangeCallback", null);
      if (callback !== null) {
        var scope = GetValue61(config, "valuechangeCallbackScope", void 0);
        this.eventEmitter.on("valuechange", callback, scope);
      }
      this.setEaseValuePropName("value").setEaseValueDuration(GetValue61(config, "easeValue.duration", 0)).setEaseValueFunction(GetValue61(config, "easeValue.ease", "Linear"));
      return this;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      value = Clamp4(value, 0, 1);
      var oldValue = this._value;
      var valueChanged = oldValue != value;
      this.dirty = this.dirty || valueChanged;
      this._value = value;
      if (valueChanged) {
        this.eventEmitter.emit("valuechange", this._value, oldValue, this.eventEmitter);
      }
    }
  }
  Object.assign(
    ProgressBase.prototype,
    ProgressValueMethods_default,
    EaseValueMethods_default
  );
  return ProgressBase;
}

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/circularprogress/ShapesUpdateMethods.js
var RadToDeg3 = Phaser.Math.RadToDeg;
var DegToRad8 = Phaser.Math.DegToRad;
var FillArc = function(shape, x, y, outerRadius, innerRadius, startAngle, endAngle, anticlockwise) {
  var isCircle = Math.abs(endAngle - startAngle) === 360;
  var radStartAngle = DegToRad8(startAngle), radEndAngle = DegToRad8(endAngle);
  var cosStartAngle = Math.cos(radStartAngle), sinStartAngle = Math.sin(radStartAngle), cosEndAngle = Math.cos(radEndAngle), sinEndAngle = Math.sin(radEndAngle);
  shape.startAt(x + cosStartAngle * outerRadius, y + sinStartAngle * outerRadius);
  shape.arc(x, y, outerRadius, startAngle, endAngle, anticlockwise);
  if (isCircle && innerRadius === 0) {
  } else {
    shape.lineTo(x + cosEndAngle * innerRadius, y + sinEndAngle * innerRadius);
    if (innerRadius > 0) {
      shape.arc(x, y, innerRadius, endAngle, startAngle, !anticlockwise);
    }
  }
  shape.close();
  return shape;
};
var ShapesUpdateMethods_default3 = {
  buildShapes() {
    var iterations = this.iterations;
    this.addShape(new Lines_default().setIterations(iterations).setName("track")).addShape(new Lines_default().setIterations(iterations).setName("bar")).addShape(new Circle_default().setIterations(iterations).setName("center"));
  },
  updateShapes() {
    var x = this.radius;
    var barWidth = this.thickness * this.radius;
    var barOuterRadius = this.radius;
    var barInnerRadius = barOuterRadius - barWidth;
    var trackShape = this.getShape("track");
    if (this.trackColor != null && this.thickness > 0) {
      trackShape.fillStyle(this.trackColor);
      FillArc(trackShape, x, x, barOuterRadius, barInnerRadius, 0, 360, false);
    } else {
      trackShape.reset();
    }
    var barShape = this.getShape("bar");
    if (this.barColor != null && this.thickness > 0) {
      var anticlockwise, startAngle, endAngle;
      if (this.value === 1) {
        anticlockwise = false;
        startAngle = 0;
        endAngle = 360;
      } else {
        anticlockwise = this.anticlockwise;
        startAngle = RadToDeg3(this.startAngle);
        var deltaAngle = 360 * (anticlockwise ? 1 - this.value : this.value);
        endAngle = deltaAngle + startAngle;
      }
      barShape.fillStyle(this.barColor);
      FillArc(barShape, x, x, barOuterRadius + 1, barInnerRadius - 1, startAngle, endAngle, false);
    } else {
      barShape.reset();
    }
    var centerShape = this.getShape("center");
    if (this.centerColor && barInnerRadius > 0) {
      centerShape.setCenterPosition(x, x).setRadius(barInnerRadius).fillStyle(this.centerColor);
    } else {
      centerShape.reset();
    }
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/circularprogress/CircularProgress.js
var GetValue62 = Phaser.Utils.Objects.GetValue;
var IsPlainObject15 = Phaser.Utils.Objects.IsPlainObject;
var Clamp5 = Phaser.Math.Clamp;
var DefaultStartAngle = Phaser.Math.DegToRad(270);
var CircularProgress = class extends ProgressBase_default(BaseShapes_default) {
  constructor(scene, x, y, radius, barColor, value, config) {
    if (IsPlainObject15(x)) {
      config = x;
      x = GetValue62(config, "x", 0);
      y = GetValue62(config, "y", 0);
      radius = GetValue62(config, "radius", 1);
      barColor = GetValue62(config, "barColor", void 0);
      value = GetValue62(config, "value", 0);
    }
    if (radius === void 0) {
      radius = 1;
    }
    var width = radius * 2;
    super(scene, x, y, width, width);
    this.type = "rexCircularProgress";
    this.bootProgressBase(config);
    this.setRadius(radius);
    this.setTrackColor(GetValue62(config, "trackColor", void 0));
    this.setBarColor(barColor);
    this.setCenterColor(GetValue62(config, "centerColor", void 0));
    this.setThickness(GetValue62(config, "thickness", 0.2));
    this.setStartAngle(GetValue62(config, "startAngle", DefaultStartAngle));
    this.setAnticlockwise(GetValue62(config, "anticlockwise", false));
    this.iterations = GetValue62(config, "iterations", 128);
    this.buildShapes();
    this.setValue(value);
  }
  resize(width, height) {
    width = Math.floor(Math.min(width, height));
    if (width === this.width) {
      return this;
    }
    super.resize(width, width);
    this.setRadius(width / 2);
    return this;
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this.dirty = this.dirty || this._radius != value;
    this._radius = value;
    var width = value * 2;
    this.resize(width, width);
  }
  setRadius(radius) {
    this.radius = radius;
    return this;
  }
  get trackColor() {
    return this._trackColor;
  }
  set trackColor(value) {
    this.dirty = this.dirty || this._trackColor != value;
    this._trackColor = value;
  }
  setTrackColor(color) {
    this.trackColor = color;
    return this;
  }
  get barColor() {
    return this._barColor;
  }
  set barColor(value) {
    this.dirty = this.dirty || this._barColor != value;
    this._barColor = value;
  }
  setBarColor(color) {
    this.barColor = color;
    return this;
  }
  get startAngle() {
    return this._startAngle;
  }
  set startAngle(value) {
    this.dirty = this.dirty || this._startAngle != value;
    this._startAngle = value;
  }
  setStartAngle(angle) {
    this.startAngle = angle;
    return this;
  }
  get anticlockwise() {
    return this._anticlockwise;
  }
  set anticlockwise(value) {
    this.dirty = this.dirty || this._anticlockwise != value;
    this._anticlockwise = value;
  }
  setAnticlockwise(anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = true;
    }
    this.anticlockwise = anticlockwise;
    return this;
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    value = Clamp5(value, 0, 1);
    this.dirty = this.dirty || this._thickness != value;
    this._thickness = value;
  }
  setThickness(thickness) {
    this.thickness = thickness;
    return this;
  }
  get centerColor() {
    return this._centerColor;
  }
  set centerColor(value) {
    this.dirty = this.dirty || this._centerColor != value;
    this._centerColor = value;
  }
  setCenterColor(color) {
    this.centerColor = color;
    return this;
  }
};
Object.assign(
  CircularProgress.prototype,
  ShapesUpdateMethods_default3
);
var CircularProgress_default = CircularProgress;

// node_modules/phaser3-rex-plugins/plugins/circularprogress.js
var circularprogress_default = CircularProgress_default;

// node_modules/phaser3-rex-plugins/templates/ui/circularprogress/CircularProgress.js
var CircularProgress_default2 = circularprogress_default;

// node_modules/phaser3-rex-plugins/templates/ui/circularprogress/Factory.js
ObjectFactory_default.register("circularProgress", function(x, y, radius, barColor, value, config) {
  var gameObject2 = new CircularProgress_default2(this.scene, x, y, radius, barColor, value, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.CircularProgress", CircularProgress_default2);

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/DrawCircle.js
var DrawCircle = function(canvas, context, x, y, rx, ry, fillStyle, strokeStyle, lineWidth, startAngle, endAngle, anticlockwise) {
  if (startAngle === void 0) {
    startAngle = 0;
  }
  if (endAngle === void 0) {
    endAngle = 2 * Math.PI;
  }
  if (anticlockwise === void 0) {
    anticlockwise = false;
  }
  context.beginPath();
  context.ellipse(x, y, rx, ry, 0, startAngle, endAngle, anticlockwise);
  if (fillStyle != null) {
    context.fillStyle = fillStyle;
    context.fill();
  }
  if (strokeStyle != null) {
    context.strokeStyle = strokeStyle;
    context.lineWidth = lineWidth;
    context.stroke();
  }
};
var DrawCircle_default = DrawCircle;

// node_modules/phaser3-rex-plugins/plugins/utils/color/ColorNameToInteger.js
var ColorNames = ["AliceBlue", "AntiqueWhite", "Aqua", "Aquamarine", "Azure", "Beige", "Bisque", "Black", "BlanchedAlmond", "Blue", "BlueViolet", "Brown", "BurlyWood", "CadetBlue", "Chartreuse", "Chocolate", "Coral", "CornflowerBlue", "Cornsilk", "Crimson", "Cyan", "DarkBlue", "DarkCyan", "DarkGoldenRod", "DarkGray", "DarkGrey", "DarkGreen", "DarkKhaki", "DarkMagenta", "DarkOliveGreen", "DarkOrange", "DarkOrchid", "DarkRed", "DarkSalmon", "DarkSeaGreen", "DarkSlateBlue", "DarkSlateGray", "DarkSlateGrey", "DarkTurquoise", "DarkViolet", "DeepPink", "DeepSkyBlue", "DimGray", "DimGrey", "DodgerBlue", "FireBrick", "FloralWhite", "ForestGreen", "Fuchsia", "Gainsboro", "GhostWhite", "Gold", "GoldenRod", "Gray", "Grey", "Green", "GreenYellow", "HoneyDew", "HotPink", "IndianRed", "Indigo", "Ivory", "Khaki", "Lavender", "LavenderBlush", "LawnGreen", "LemonChiffon", "LightBlue", "LightCoral", "LightCyan", "LightGoldenRodYellow", "LightGray", "LightGrey", "LightGreen", "LightPink", "LightSalmon", "LightSeaGreen", "LightSkyBlue", "LightSlateGray", "LightSlateGrey", "LightSteelBlue", "LightYellow", "Lime", "LimeGreen", "Linen", "Magenta", "Maroon", "MediumAquaMarine", "MediumBlue", "MediumOrchid", "MediumPurple", "MediumSeaGreen", "MediumSlateBlue", "MediumSpringGreen", "MediumTurquoise", "MediumVioletRed", "MidnightBlue", "MintCream", "MistyRose", "Moccasin", "NavajoWhite", "Navy", "OldLace", "Olive", "OliveDrab", "Orange", "OrangeRed", "Orchid", "PaleGoldenRod", "PaleGreen", "PaleTurquoise", "PaleVioletRed", "PapayaWhip", "PeachPuff", "Peru", "Pink", "Plum", "PowderBlue", "Purple", "RebeccaPurple", "Red", "RosyBrown", "RoyalBlue", "SaddleBrown", "Salmon", "SandyBrown", "SeaGreen", "SeaShell", "Sienna", "Silver", "SkyBlue", "SlateBlue", "SlateGray", "SlateGrey", "Snow", "SpringGreen", "SteelBlue", "Tan", "Teal", "Thistle", "Tomato", "Turquoise", "Violet", "Wheat", "White", "WhiteSmoke", "Yellow", "YellowGreen"];
var ColorValues = [15792383, 16444375, 65535, 8388564, 15794175, 16119260, 16770244, 0, 16772045, 255, 9055202, 10824234, 14596231, 6266528, 8388352, 13789470, 16744272, 6591981, 16775388, 14423100, 65535, 139, 35723, 12092939, 11119017, 11119017, 25600, 12433259, 9109643, 5597999, 16747520, 10040012, 9109504, 15308410, 9419919, 4734347, 3100495, 3100495, 52945, 9699539, 16716947, 49151, 6908265, 6908265, 2003199, 11674146, 16775920, 2263842, 16711935, 14474460, 16316671, 16766720, 14329120, 8421504, 8421504, 32768, 11403055, 15794160, 16738740, 13458524, 4915330, 16777200, 15787660, 15132410, 16773365, 8190976, 16775885, 11393254, 15761536, 14745599, 16448210, 13882323, 13882323, 9498256, 16758465, 16752762, 2142890, 8900346, 7833753, 7833753, 11584734, 16777184, 65280, 3329330, 16445670, 16711935, 8388608, 6737322, 205, 12211667, 9662683, 3978097, 8087790, 64154, 4772300, 13047173, 1644912, 16121850, 16770273, 16770229, 16768685, 128, 16643558, 8421376, 7048739, 16753920, 16729344, 14315734, 15657130, 10025880, 11529966, 14381203, 16773077, 16767673, 13468991, 16761035, 14524637, 11591910, 8388736, 6697881, 16711680, 12357519, 4286945, 9127187, 16416882, 16032864, 3050327, 16774638, 10506797, 12632256, 8900331, 6970061, 7372944, 7372944, 16775930, 65407, 4620980, 13808780, 32896, 14204888, 16737095, 4251856, 15631086, 16113331, 16777215, 16119285, 16776960, 10145074];
var ColorNameToIntegerDict = {};
var name;
for (i = 0, cnt = ColorNames.length; i < cnt; i++) {
  name = ColorNames[i].toLowerCase();
  ColorNameToIntegerDict[name] = ColorValues[i];
}
var i;
var cnt;
var ColorNameToInteger = function(colorName) {
  colorName = colorName.toLowerCase();
  if (ColorNameToIntegerDict.hasOwnProperty(colorName)) {
    return ColorNameToIntegerDict[colorName];
  } else {
    return null;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/color/ColorStringToInteger.js
var ColorStringToInteger = function(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.startsWith("#")) {
    value = parseInt(value.substring(1), 16);
  } else if (value.startsWith("0x")) {
    value = parseInt(value.substring(2), 16);
  } else {
    value = ColorNameToInteger(value);
  }
  return value;
};
var ColorStringToInteger_default = ColorStringToInteger;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/DrawGradientArc.js
var DegToRad9 = Phaser.Math.DegToRad;
var Linear8 = Phaser.Math.Linear;
var DrawGradientArc = function(canvas, context, x, y, rx, ry, startColor, endColor, lineWidth, startAngle, endAngle, anticlockwise, AngleStepDeg) {
  if (startAngle === void 0) {
    startAngle = 0;
  }
  if (endAngle === void 0) {
    endAngle = 2 * Math.PI;
  }
  if (anticlockwise === void 0) {
    anticlockwise = false;
  }
  if (AngleStepDeg === void 0) {
    AngleStepDeg = 2;
  }
  startColor = ColorStringToInteger_default(startColor);
  endColor = ColorStringToInteger_default(endColor);
  StartRGB = GetRGB(startColor, StartRGB);
  EndRGB = GetRGB(endColor, EndRGB);
  var angleStep = DegToRad9(AngleStepDeg);
  var totalAngle;
  if (anticlockwise) {
    totalAngle = startAngle - endAngle;
  } else {
    totalAngle = endAngle - startAngle;
  }
  if (totalAngle < 0) {
    totalAngle += 2 * Math.PI;
  }
  var segments = Math.ceil(totalAngle / angleStep);
  var deltaAngle = totalAngle / segments;
  if (anticlockwise) {
    deltaAngle = -deltaAngle;
  }
  for (var i = 0; i < segments; i++) {
    var t = i / segments;
    var r = Math.round(Linear8(StartRGB.r, EndRGB.r, t));
    var g = Math.round(Linear8(StartRGB.g, EndRGB.g, t));
    var b = Math.round(Linear8(StartRGB.b, EndRGB.b, t));
    var segmentStartAngle = startAngle + i * deltaAngle;
    var segmentEndAngle = segmentStartAngle + deltaAngle;
    if (i < segments - 1) {
      segmentEndAngle += deltaAngle / 2;
    }
    context.beginPath();
    context.ellipse(x, y, rx, ry, 0, segmentStartAngle, segmentEndAngle, anticlockwise);
    context.strokeStyle = `rgb(${r},${g},${b})`;
    context.lineWidth = lineWidth;
    context.stroke();
  }
};
var StartRGB;
var EndRGB;
var DrawGradientArc_default = DrawGradientArc;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/DrawText.js
var DrawText = function(canvas, context, x, y, text, font, fillStyle, strokeStyle, lineWidth, textAlign, textBaseline) {
  if (lineWidth === void 0 && strokeStyle != null) {
    lineWidth = 2;
  }
  if (textAlign === void 0) {
    textAlign = "start";
  }
  if (textBaseline === void 0) {
    textBaseline = "alphabetic";
  }
  context.font = font;
  context.textAlign = textAlign;
  context.textBaseline = textBaseline;
  context.fillStyle = fillStyle;
  context.strokeStyle = strokeStyle;
  context.lineWidth = lineWidth;
  context.lineCap = "round";
  context.lineJoin = "round";
  if (strokeStyle != null && strokeStyle !== "none" && lineWidth > 0) {
    context.strokeText(text, x, y);
  }
  if (fillStyle != null && fillStyle !== "none") {
    context.fillText(text, x, y);
  }
};
var DrawText_default = DrawText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/circularprogress/DrawContent.js
var PI2 = Phaser.Math.PI2;
var DrawContent2 = function() {
  var x = this.radius;
  var lineWidth = this.thickness * this.radius;
  var barRadius = this.radius - lineWidth / 2;
  var centerRadius = this.radius - lineWidth;
  var canvas = this.canvas, context = this.context;
  var anticlockwise = this.anticlockwise, startAngle = this.startAngle, endAngle = this.endAngle, deltaAngle = this._deltaAngle;
  if (this.trackColor && lineWidth > 0) {
    context.save();
    DrawCircle_default(
      canvas,
      context,
      x,
      x,
      barRadius,
      barRadius,
      void 0,
      this.trackColor,
      lineWidth,
      startAngle,
      endAngle,
      anticlockwise
    );
    context.restore();
  }
  if (this.barColor && barRadius > 0) {
    var barEndAngle;
    if (this.value >= 1) {
      barEndAngle = endAngle;
    } else {
      if (anticlockwise) {
        barEndAngle = (startAngle - deltaAngle * this.value + PI2) % PI2;
      } else {
        barEndAngle = (startAngle + deltaAngle * this.value) % PI2;
      }
    }
    context.save();
    if (this.barColor2) {
      DrawGradientArc_default(
        canvas,
        context,
        x,
        x,
        barRadius,
        barRadius,
        this.barColor2,
        this.barColor,
        lineWidth,
        startAngle,
        barEndAngle,
        anticlockwise
      );
    } else {
      DrawCircle_default(
        canvas,
        context,
        x,
        x,
        barRadius,
        barRadius,
        void 0,
        this.barColor,
        lineWidth,
        startAngle,
        barEndAngle,
        anticlockwise
      );
    }
    context.restore();
  }
  if (this.centerColor && centerRadius > 0) {
    var fillStyle;
    if (this.centerColor2) {
      fillStyle = this.context.createRadialGradient(x, x, 0, x, x, centerRadius);
      fillStyle.addColorStop(0, this.centerColor);
      fillStyle.addColorStop(1, this.centerColor2);
    } else {
      fillStyle = this.centerColor;
    }
    context.save();
    DrawCircle_default(
      canvas,
      context,
      x,
      x,
      centerRadius,
      centerRadius,
      fillStyle
    );
    context.restore();
  }
  if (this.textFormatCallback && (this.textColor || this.textStrokeColor)) {
    context.save();
    DrawText_default(
      canvas,
      context,
      x,
      x,
      this.getFormatText(),
      this.textFont,
      this.textColor,
      this.textStrokeColor,
      this.textStrokeThickness,
      "center",
      // textAlign
      "middle"
      // textBaseline
    );
    context.restore();
  }
};
var DrawContent_default2 = DrawContent2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/circularprogress/CircularProgress.js
var GetValue63 = Phaser.Utils.Objects.GetValue;
var IsPlainObject16 = Phaser.Utils.Objects.IsPlainObject;
var Clamp6 = Phaser.Math.Clamp;
var DefaultStartAngle2 = Phaser.Math.DegToRad(270);
var PI22 = Phaser.Math.PI2;
var CircularProgress2 = class extends ProgressBase_default(Canvas_default) {
  constructor(scene, x, y, radius, barColor, value, config) {
    if (IsPlainObject16(x)) {
      config = x;
      x = GetValue63(config, "x", 0);
      y = GetValue63(config, "y", 0);
      radius = GetValue63(config, "radius", 1);
      barColor = GetValue63(config, "barColor", void 0);
      value = GetValue63(config, "value", 0);
    }
    var width = radius * 2;
    var resolution = GetValue63(config, "resolution", 1);
    super(scene, x, y, width, width, resolution);
    this.type = "rexCircularProgressCanvas";
    this.bootProgressBase(config);
    this.setRadius(radius);
    this.setTrackColor(GetValue63(config, "trackColor", void 0));
    this.setBarColor(barColor);
    this.setBarColor2(GetValue63(config, "barColor2", void 0));
    this.setCenterColor(GetValue63(config, "centerColor", void 0));
    this.setThickness(GetValue63(config, "thickness", 0.2));
    this.setAnticlockwise(GetValue63(config, "anticlockwise", false));
    this.setStartAngle(GetValue63(config, "startAngle", DefaultStartAngle2));
    var endAngle = GetValue63(config, "endAngle");
    if (endAngle === void 0) {
      if (this.anticlockwise) {
        endAngle = this.startAngle - PI22;
      } else {
        endAngle = this.startAngle + PI22;
      }
    }
    this.setEndAngle(GetValue63(config, "endAngle", endAngle));
    this.setTextColor(GetValue63(config, "textColor", void 0));
    this.setTextStrokeColor(
      GetValue63(config, "textStrokeColor", void 0),
      GetValue63(config, "textStrokeThickness", void 0)
    );
    var textFont = GetValue63(config, "textFont", void 0);
    if (textFont) {
      this.setTextFont(textFont);
    } else {
      this.setTextFont(
        GetValue63(config, "textSize", "16px"),
        GetValue63(config, "textFamily", "Courier"),
        GetValue63(config, "textStyle", "")
      );
    }
    this.setTextFormatCallback(
      GetValue63(config, "textFormatCallback", void 0),
      GetValue63(config, "textFormatCallbackScope", void 0)
    );
    this.setValue(value);
  }
  resize(width, height) {
    width = Math.floor(Math.min(width, height));
    if (width === this.width) {
      return this;
    }
    super.resize(width, width);
    this.setRadius(width / 2);
    return this;
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this.dirty = this.dirty || this._radius != value;
    this._radius = value;
    var width = value * 2;
    this.resize(width, width);
  }
  setRadius(radius) {
    this.radius = radius;
    return this;
  }
  get trackColor() {
    return this._trackColor;
  }
  set trackColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._trackColor != value;
    this._trackColor = value;
  }
  setTrackColor(color) {
    this.trackColor = color;
    return this;
  }
  get barColor() {
    return this._barColor;
  }
  set barColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._barColor != value;
    this._barColor = value;
  }
  setBarColor(color) {
    this.barColor = color;
    return this;
  }
  get barColor2() {
    return this._barColor2;
  }
  set barColor2(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._barColor2 != value;
    this._barColor2 = value;
  }
  setBarColor2(color) {
    this.barColor2 = color;
    return this;
  }
  get startAngle() {
    return this._startAngle;
  }
  set startAngle(value) {
    this.dirty = this.dirty || this._startAngle != value;
    this._startAngle = value;
    this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
  }
  setStartAngle(angle) {
    this.startAngle = angle;
    return this;
  }
  get endAngle() {
    return this._endAngle;
  }
  set endAngle(value) {
    this.dirty = this.dirty || this._endAngle != value;
    this._endAngle = value;
    this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
  }
  setEndAngle(angle) {
    this.endAngle = angle;
    return this;
  }
  get anticlockwise() {
    return this._anticlockwise;
  }
  set anticlockwise(value) {
    this.dirty = this.dirty || this._anticlockwise != value;
    this._anticlockwise = value;
    this._deltaAngle = GetDeltaAngle(this._startAngle, this._endAngle, this._anticlockwise);
  }
  setAnticlockwise(anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = true;
    }
    this.anticlockwise = anticlockwise;
    return this;
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    value = Clamp6(value, 0, 1);
    this.dirty = this.dirty || this._thickness != value;
    this._thickness = value;
  }
  setThickness(thickness) {
    this.thickness = thickness;
    return this;
  }
  get centerColor() {
    return this._centerColor;
  }
  set centerColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._centerColor != value;
    this._centerColor = value;
  }
  get centerColor2() {
    return this._centerColor2;
  }
  set centerColor2(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._centerColor2 != value;
    this._centerColor2 = value;
  }
  setCenterColor(color, color2) {
    this.centerColor = color;
    this.centerColor2 = color2;
    return this;
  }
  get textColor() {
    return this._textColor;
  }
  set textColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._textColor != value;
    this._textColor = value;
  }
  setTextColor(color) {
    this.textColor = color;
    return this;
  }
  get textStrokeColor() {
    return this._textStrokeColor;
  }
  set textStrokeColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._textStrokeColor != value;
    this._textStrokeColor = value;
  }
  get textStrokeThickness() {
    return this._textStrokeThickness;
  }
  set textStrokeThickness(value) {
    this.dirty = this.dirty || this._textStrokeThickness != value;
    this._textStrokeThickness = value;
  }
  setTextStrokeColor(color, thickness) {
    if (thickness === void 0) {
      thickness = 2;
    }
    this.textStrokeColor = color;
    this.textStrokeThickness = thickness;
    return this;
  }
  get textFont() {
    return this._textFont;
  }
  set textFont(value) {
    this.dirty = this.dirty || this._textFont != value;
    this._textFont = value;
  }
  setTextFont(fontSize, fontFamily, fontStyle) {
    var font;
    if (fontFamily === void 0) {
      font = fontSize;
    } else {
      font = fontStyle + " " + fontSize + " " + fontFamily;
    }
    this.textFont = font;
    return this;
  }
  setTextFormatCallback(callback, scope) {
    this.textFormatCallback = callback;
    this.textFormatCallbackScope = scope;
    return this;
  }
  updateTexture() {
    super.updateTexture(function() {
      this.clear();
      DrawContent_default2.call(this);
    }, this);
    return this;
  }
  getFormatText(value) {
    if (value === void 0) {
      value = this.value;
    }
    var text;
    if (this.textFormatCallbackScope) {
      text = this.textFormatCallback(value);
    } else {
      text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
    }
    return text;
  }
};
var GetDeltaAngle = function(startAngle, endAngle, anticlockwise) {
  if (anticlockwise) {
    if (startAngle <= endAngle) {
      return PI22 + startAngle - endAngle;
    } else {
      return startAngle - endAngle;
    }
  } else {
    if (startAngle >= endAngle) {
      return PI22 + endAngle - startAngle;
    } else {
      return endAngle - startAngle;
    }
  }
};
var CircularProgress_default3 = CircularProgress2;

// node_modules/phaser3-rex-plugins/plugins/circularprogresscanvas.js
var circularprogresscanvas_default = CircularProgress_default3;

// node_modules/phaser3-rex-plugins/templates/ui/circularprogresscanvas/CircularProgressCanvas.js
var CircularProgressCanvas_default = circularprogresscanvas_default;

// node_modules/phaser3-rex-plugins/templates/ui/circularprogresscanvas/Factory.js
ObjectFactory_default.register("circularProgressCanvas", function(x, y, radius, barColor, value, config) {
  var gameObject2 = new CircularProgressCanvas_default(this.scene, x, y, radius, barColor, value, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.CircularProgressCanvas", CircularProgressCanvas_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/lineprogress/UpdateShapes.js
var UpdateShapes = function() {
  var skewX = this.skewX;
  var width = this.width - Math.abs(skewX);
  var height = this.height;
  var trackFill = this.getShape("trackFill");
  trackFill.fillStyle(this.trackColor);
  if (trackFill.isFilled) {
    BuildRectangle(
      trackFill,
      // lines
      0,
      0,
      // x0, y0
      width,
      height,
      // x1, y1
      skewX
      // skewX
    );
  }
  var bar = this.getShape("bar");
  bar.fillStyle(this.barColor);
  if (bar.isFilled) {
    var barX0, barX1;
    if (!this.rtl) {
      barX0 = 0;
      barX1 = width * this.value;
    } else {
      barX0 = width * (1 - this.value);
      barX1 = width;
    }
    BuildRectangle(
      bar,
      // lines
      barX0,
      0,
      // x0, y0
      barX1,
      height,
      // x1, y1
      skewX
      // skew
    );
  }
  var trackStroke = this.getShape("trackStroke");
  trackStroke.lineStyle(this.trackStrokeThickness, this.trackStrokeColor);
  if (trackStroke.isStroked) {
    BuildRectangle(
      trackStroke,
      // lines            
      0,
      0,
      // x0, y0
      width,
      height,
      // x1, y1
      skewX
      // skewX
    );
  }
};
var BuildRectangle = function(lines, x0, y0, x1, y1, skewX) {
  var startX = (x0 + x1) / 2;
  if (skewX >= 0) {
    lines.startAt(startX + skewX, y0).lineTo(x1 + skewX, y0).lineTo(x1, y1).lineTo(x0, y1).lineTo(x0 + skewX, y0).lineTo(startX + skewX, y0);
  } else {
    lines.startAt(startX, y0).lineTo(x1, y0).lineTo(x1 - skewX, y1).lineTo(x0 - skewX, y1).lineTo(x0, y0).lineTo(startX, y0);
  }
  lines.close();
  return lines;
};
var UpdateShapes_default = UpdateShapes;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/lineprogress/LineProgress.js
var GetValue64 = Phaser.Utils.Objects.GetValue;
var IsPlainObject17 = Phaser.Utils.Objects.IsPlainObject;
var LineProgress = class extends ProgressBase_default(BaseShapes_default) {
  constructor(scene, x, y, width, height, barColor, value, config) {
    if (IsPlainObject17(x)) {
      config = x;
      x = config.x;
      y = config.y;
      width = config.width;
      height = config.height;
      barColor = config.barColor;
      value = config.value;
    } else if (IsPlainObject17(width)) {
      config = width;
      width = config.width;
      height = config.height;
      barColor = config.barColor;
      value = config.value;
    } else if (IsPlainObject17(barColor)) {
      config = barColor;
      barColor = config.barColor;
      value = config.value;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 2;
    }
    if (height === void 0) {
      height = width;
    }
    if (value === void 0) {
      value = 0;
    }
    super(scene, x, y, width, height, config);
    this.type = "rexLineProgress";
    this.bootProgressBase(config);
    this.addShape(new Lines_default().setName("trackFill")).addShape(new Lines_default().setName("bar")).addShape(new Lines_default().setName("trackStroke"));
    this.setTrackColor(GetValue64(config, "trackColor", void 0));
    this.setBarColor(barColor);
    this.setTrackStroke(GetValue64(config, "trackStrokeThickness", 2), GetValue64(config, "trackStrokeColor", void 0));
    this.setSkewX(GetValue64(config, "skewX", 0));
    this.setRTL(GetValue64(config, "rtl", false));
    this.setValue(value);
  }
  get trackColor() {
    return this._trackColor;
  }
  set trackColor(value) {
    this.dirty = this.dirty || this._trackColor != value;
    this._trackColor = value;
  }
  setTrackColor(color) {
    this.trackColor = color;
    return this;
  }
  get trackStrokeColor() {
    return this._trackStrokeColor;
  }
  set trackStrokeColor(value) {
    this.dirty = this.dirty || this._trackStrokeColor != value;
    this._trackStrokeColor = value;
  }
  get trackStrokeThickness() {
    return this._trackStrokeThickness;
  }
  set trackStrokeThickness(value) {
    this.dirty = this.dirty || this._trackStrokeThickness != value;
    this._trackStrokeThickness = value;
  }
  setTrackStroke(lineWidth, color) {
    this.trackStrokeThickness = lineWidth;
    this.trackStrokeColor = color;
    return this;
  }
  get barColor() {
    return this._barColor;
  }
  set barColor(value) {
    this.dirty = this.dirty || this._barColor != value;
    this._barColor = value;
  }
  setBarColor(color) {
    this.barColor = color;
    return this;
  }
  get skewX() {
    return this._skewX;
  }
  set skewX(value) {
    this.dirty = this.dirty || this._skewX != value;
    this._skewX = value;
  }
  setSkewX(value) {
    this.skewX = value;
    return this;
  }
  get rtl() {
    return this._rtl;
  }
  set rtl(value) {
    value = !!value;
    this.dirty = this.dirty || this._rtl != value;
    this._rtl = value;
  }
  setRTL(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.rtl = enable;
    return this;
  }
};
var Methods10 = {
  updateShapes: UpdateShapes_default
};
Object.assign(
  LineProgress.prototype,
  Methods10
);
var LineProgress_default = LineProgress;

// node_modules/phaser3-rex-plugins/plugins/lineprogress.js
var lineprogress_default = LineProgress_default;

// node_modules/phaser3-rex-plugins/templates/ui/lineprogress/LineProgress.js
var LineProgress_default2 = lineprogress_default;

// node_modules/phaser3-rex-plugins/templates/ui/lineprogress/Factory.js
ObjectFactory_default.register("lineProgress", function(x, y, width, height, barColor, value, config) {
  var gameObject2 = new LineProgress_default2(this.scene, x, y, width, height, barColor, value, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.LineProgress", LineProgress_default2);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/methods/BuildRoundRectangle.js
var BuildRoundRectangle = function(lines, width, height, cornerRadius, iteration) {
  lines.setIterations(iteration).start();
  var radius = cornerRadius.tl;
  if (IsArcCorner_default(radius)) {
    if (radius.convex) {
      var centerX = radius.x;
      var centerY = radius.y;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 270, false);
    } else {
      var centerX = 0;
      var centerY = 0;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 0, true);
    }
  } else {
    lines.lineTo(0, 0);
  }
  var radius = cornerRadius.tr;
  if (IsArcCorner_default(radius)) {
    if (radius.convex) {
      var centerX = width - radius.x;
      var centerY = radius.y;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 360, false);
    } else {
      var centerX = width;
      var centerY = 0;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 90, true);
    }
  } else {
    lines.lineTo(width, 0);
  }
  var radius = cornerRadius.br;
  if (IsArcCorner_default(radius)) {
    if (radius.convex) {
      var centerX = width - radius.x;
      var centerY = height - radius.y;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 0, 90, false);
    } else {
      var centerX = width;
      var centerY = height;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 180, true);
    }
  } else {
    lines.lineTo(width, height);
  }
  var radius = cornerRadius.bl;
  if (IsArcCorner_default(radius)) {
    if (radius.convex) {
      var centerX = radius.x;
      var centerY = height - radius.y;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 180, false);
    } else {
      var centerX = 0;
      var centerY = height;
      lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 360, 270, true);
    }
  } else {
    lines.lineTo(0, height);
  }
  lines.close();
  return lines;
};
var BuildRoundRectangle_default = BuildRoundRectangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/methods/BuildRoundRectangleBarDirection0.js
var RadToDeg4 = Phaser.Math.RadToDeg;
var BuildRoundRectangleBarDirection0 = function(lines, width, height, cornerRadius, value) {
  var barWidth = width * value;
  var radius = cornerRadius.tl;
  if (IsArcCorner_default(radius)) {
    var theta;
    if (barWidth > radius.x) {
      theta = 90;
    } else {
      theta = RadToDeg4(Math.acos((radius.x - barWidth) / radius.x));
    }
    var centerX = radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 180 + theta, false);
  } else {
    lines.lineTo(0, 0);
  }
  var radius = cornerRadius.tr;
  if (IsArcCorner_default(radius) && barWidth > width - radius.x) {
    var theta = 90 - RadToDeg4(Math.acos((barWidth - (width - radius.x)) / radius.x));
    var centerX = width - radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 270 + theta, false);
  } else {
    lines.lineTo(barWidth, 0);
  }
  var radius = cornerRadius.br;
  if (IsArcCorner_default(radius) && barWidth > width - radius.x) {
    var theta = 90 - RadToDeg4(Math.acos((barWidth - (width - radius.x)) / radius.x));
    var centerX = width - radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90 - theta, 90, false);
  } else {
    lines.lineTo(barWidth, height);
  }
  var radius = cornerRadius.bl;
  if (IsArcCorner_default(radius)) {
    var theta;
    if (barWidth > radius.x) {
      theta = 90;
    } else {
      theta = RadToDeg4(Math.acos((radius.x - barWidth) / radius.x));
    }
    var centerX = radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180 - theta, 180, false);
  } else {
    lines.lineTo(0, height);
  }
};
var BuildRoundRectangleBarDirection0_default = BuildRoundRectangleBarDirection0;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/methods/BuildRoundRectangleBarDirection1.js
var RadToDeg5 = Phaser.Math.RadToDeg;
var BuildRoundRectangleBarDirection1 = function(lines, width, height, cornerRadius, value) {
  var barHeight = height * value;
  var radius = cornerRadius.tl;
  if (IsArcCorner_default(radius)) {
    var theta;
    if (barHeight > radius.y) {
      theta = 90;
    } else {
      theta = RadToDeg5(Math.acos((radius.y - barHeight) / radius.y));
    }
    var centerX = radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270 - theta, 270, false);
  } else {
    lines.lineTo(0, 0);
  }
  var radius = cornerRadius.tr;
  if (IsArcCorner_default(radius)) {
    var theta;
    if (barHeight > radius.y) {
      theta = 90;
    } else {
      theta = RadToDeg5(Math.acos((radius.y - barHeight) / radius.y));
    }
    var centerX = width - radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270, 270 + theta, false);
  } else {
    lines.lineTo(width, 0);
  }
  var radius = cornerRadius.br;
  if (IsArcCorner_default(radius) && barHeight > height - radius.y) {
    var theta = 90 - RadToDeg5(Math.acos((barHeight - (height - radius.y)) / radius.y));
    var centerX = width - radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 0, 0 + theta, false);
  } else {
    lines.lineTo(width, barHeight);
  }
  var radius = cornerRadius.bl;
  if (IsArcCorner_default(radius) && barHeight > height - radius.y) {
    var theta = 90 - RadToDeg5(Math.acos((barHeight - (height - radius.y)) / radius.y));
    var centerX = radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180 - theta, 180, false);
  } else {
    lines.lineTo(0, barHeight);
  }
};
var BuildRoundRectangleBarDirection1_default = BuildRoundRectangleBarDirection1;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/methods/BuildRoundRectangleBarDirection2.js
var RadToDeg6 = Phaser.Math.RadToDeg;
var BuildRoundRectangleBarDirection2 = function(lines, width, height, cornerRadius, value) {
  var barWidth = width * value;
  var radius = cornerRadius.tr;
  if (IsArcCorner_default(radius)) {
    var theta;
    if (barWidth > radius.x) {
      theta = 90;
    } else {
      theta = RadToDeg6(Math.acos((radius.x - barWidth) / radius.x));
    }
    var centerX = width - radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 360 - theta, 360, false);
  } else {
    lines.lineTo(width, 0);
  }
  var radius = cornerRadius.br;
  if (IsArcCorner_default(radius)) {
    var theta;
    if (barWidth > radius.x) {
      theta = 90;
    } else {
      theta = RadToDeg6(Math.acos((radius.x - barWidth) / radius.x));
    }
    var centerX = width - radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 0, 0 + theta, false);
  } else {
    lines.lineTo(width, height);
  }
  var radius = cornerRadius.bl;
  if (IsArcCorner_default(radius) && barWidth > width - radius.x) {
    var theta = 90 - RadToDeg6(Math.acos((barWidth - (width - radius.x)) / radius.x));
    var centerX = radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 90 + theta, false);
  } else {
    lines.lineTo(width - barWidth, height);
  }
  var radius = cornerRadius.tl;
  if (IsArcCorner_default(radius) && barWidth > width - radius.x) {
    var theta = 90 - RadToDeg6(Math.acos((barWidth - (width - radius.x)) / radius.x));
    var centerX = radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 270 - theta, 270, false);
  } else {
    lines.lineTo(width - barWidth, 0);
  }
};
var BuildRoundRectangleBarDirection2_default = BuildRoundRectangleBarDirection2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/methods/BuildRoundRectangleBarDirection3.js
var RadToDeg7 = Phaser.Math.RadToDeg;
var BuildRoundRectangleBarDirection3 = function(lines, width, height, cornerRadius, value) {
  var barHeight = height * value;
  var radius = cornerRadius.br;
  if (IsArcCorner_default(radius)) {
    if (barHeight > radius.y) {
      theta = 90;
    } else {
      theta = RadToDeg7(Math.acos((radius.y - barHeight) / radius.y));
    }
    var centerX = width - radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90 - theta, 90, false);
  } else {
    lines.lineTo(width, height);
  }
  var radius = cornerRadius.bl;
  if (IsArcCorner_default(radius)) {
    if (barHeight > radius.y) {
      theta = 90;
    } else {
      theta = RadToDeg7(Math.acos((radius.y - barHeight) / radius.y));
    }
    var centerX = radius.x;
    var centerY = height - radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 90, 90 + theta, false);
  } else {
    lines.lineTo(0, height);
  }
  var radius = cornerRadius.tl;
  if (IsArcCorner_default(radius) && barHeight > height - radius.y) {
    var theta = 90 - RadToDeg7(Math.acos((barHeight - (height - radius.y)) / radius.y));
    var centerX = radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 180, 180 + theta, false);
  } else {
    lines.lineTo(0, height - barHeight);
  }
  var radius = cornerRadius.tr;
  if (IsArcCorner_default(radius) && barHeight > height - radius.y) {
    var theta = 90 - RadToDeg7(Math.acos((barHeight - (height - radius.y)) / radius.y));
    var centerX = width - radius.x;
    var centerY = radius.y;
    lines.ellipticalArc(centerX, centerY, radius.x, radius.y, 360 - theta, 360, false);
  } else {
    lines.lineTo(width, height - barHeight);
  }
};
var BuildRoundRectangleBarDirection3_default = BuildRoundRectangleBarDirection3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/methods/BuildRoundRectangleBar.js
var BuildRoundRectangleBar = function(lines, width, height, cornerRadius, value, orientation, rtl, iteration) {
  lines.setIterations(iteration).start();
  if (value === 0) {
    return lines;
  } else if (value === 1) {
    return BuildRoundRectangle_default(lines, width, height, cornerRadius, iteration);
  }
  var callback;
  if (orientation === 0) {
    callback = rtl ? BuildRoundRectangleBarDirection2_default : BuildRoundRectangleBarDirection0_default;
  } else {
    callback = rtl ? BuildRoundRectangleBarDirection3_default : BuildRoundRectangleBarDirection1_default;
  }
  callback(lines, width, height, cornerRadius, value);
  lines.close();
  return lines;
};
var BuildRoundRectangleBar_default = BuildRoundRectangleBar;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/methods/UpdateShapes.js
var UpdateShapes2 = function() {
  var width = this.width;
  var height = this.height;
  var cornerRadius = this.rrGeom.cornerRadius;
  var value = this.value;
  var orientation = this.orientation;
  var rtl = this.rtl;
  var iteration = this.iteration + 1;
  var trackFill = this.getShape("trackFill");
  trackFill.fillStyle(this.trackColor);
  if (trackFill.isFilled) {
    BuildRoundRectangle_default(
      trackFill,
      width,
      height,
      cornerRadius,
      iteration
    );
  }
  var bar = this.getShape("bar");
  bar.fillStyle(this.barColor);
  if (bar.isFilled) {
    BuildRoundRectangleBar_default(
      bar,
      width,
      height,
      cornerRadius,
      value,
      orientation,
      rtl,
      iteration
    );
  }
  var trackStroke = this.getShape("trackStroke");
  trackStroke.lineStyle(this.trackStrokeThickness, this.trackStrokeColor);
  if (trackStroke.isStroked) {
    BuildRoundRectangle_default(
      trackStroke,
      // lines  
      width,
      height,
      cornerRadius,
      iteration
    );
  }
};
var UpdateShapes_default2 = UpdateShapes2;

// node_modules/phaser3-rex-plugins/plugins/utils/orientation/GetOrientationMode.js
var OrientationMode = {
  x: 0,
  h: 0,
  horizontal: 0,
  "left-to-right": 0,
  y: 1,
  v: 1,
  vertical: 1,
  "top-to-bottom": 1
};
var GetOrientationMode = function(orientation) {
  if (typeof orientation === "string") {
    orientation = OrientationMode[orientation];
  }
  return orientation;
};
var GetOrientationMode_default = GetOrientationMode;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/roundrectangleprogress/RoundRectangleProgress.js
var GetValue65 = Phaser.Utils.Objects.GetValue;
var IsPlainObject18 = Phaser.Utils.Objects.IsPlainObject;
var RoundRectangleProgress = class extends ProgressBase_default(BaseShapes_default) {
  constructor(scene, x, y, width, height, radiusConfig, barColor, value, config) {
    if (IsPlainObject18(x)) {
      config = x;
      x = config.x;
      y = config.y;
      width = config.width;
      height = config.height;
      radiusConfig = config.radius;
      barColor = config.barColor;
      value = config.value;
    } else if (IsPlainObject18(width)) {
      config = width;
      width = config.width;
      height = config.height;
      radiusConfig = config.radius;
      barColor = config.barColor;
      value = config.value;
    } else if (IsPlainObject18(radiusConfig)) {
      config = radiusConfig;
      radiusConfig = config.radius;
      barColor = config.barColor;
      value = config.value;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = width;
    }
    if (radiusConfig === void 0) {
      radiusConfig = 0;
    }
    if (value === void 0) {
      value = 0;
    }
    super(scene, x, y, width, height, config);
    this.type = "rexRoundRectangleProgress";
    this.rrGeom = new RoundRectangle_default();
    this.bootProgressBase(config);
    this.addShape(new Lines_default().setName("trackFill")).addShape(new Lines_default().setName("bar")).addShape(new Lines_default().setName("trackStroke"));
    this.setTrackColor(GetValue65(config, "trackColor", void 0));
    this.setBarColor(barColor);
    this.setTrackStroke(GetValue65(config, "trackStrokeThickness", 2), GetValue65(config, "trackStrokeColor", void 0));
    this.setOrientation(GetValue65(config, "orientation", 0));
    this.setRTL(GetValue65(config, "rtl", false));
    this.setRadius(radiusConfig);
    this.setIteration(GetValue65(radiusConfig, "iteration", void 0));
    this.setValue(value);
  }
  get trackColor() {
    return this._trackColor;
  }
  set trackColor(value) {
    this.dirty = this.dirty || this._trackColor != value;
    this._trackColor = value;
  }
  setTrackColor(color) {
    this.trackColor = color;
    return this;
  }
  get trackStrokeColor() {
    return this._trackStrokeColor;
  }
  set trackStrokeColor(value) {
    this.dirty = this.dirty || this._trackStrokeColor != value;
    this._trackStrokeColor = value;
  }
  get trackStrokeThickness() {
    return this._trackStrokeThickness;
  }
  set trackStrokeThickness(value) {
    this.dirty = this.dirty || this._trackStrokeThickness != value;
    this._trackStrokeThickness = value;
  }
  setTrackStroke(lineWidth, color) {
    this.trackStrokeThickness = lineWidth;
    this.trackStrokeColor = color;
    return this;
  }
  get barColor() {
    return this._barColor;
  }
  set barColor(value) {
    this.dirty = this.dirty || this._barColor != value;
    this._barColor = value;
  }
  setBarColor(color) {
    this.barColor = color;
    return this;
  }
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    value = GetOrientationMode_default(value);
    this.dirty = this.dirty || this._orientation != value;
    this._orientation = value;
  }
  setOrientation(value) {
    this.orientation = value;
    return this;
  }
  get rtl() {
    return this._rtl;
  }
  set rtl(value) {
    value = !!value;
    this.dirty = this.dirty || this._rtl != value;
    this._rtl = value;
  }
  setRTL(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.rtl = enable;
    return this;
  }
  get radius() {
    return this.rrGeom.radius;
  }
  set radius(value) {
    this.rrGeom.setRadius(value);
    this.dirty = true;
  }
  get radiusTL() {
    return this.rrGeom.radiusTL;
  }
  set radiusTL(value) {
    this.rrGeom.radiusTL = value;
    this.dirty = true;
  }
  get radiusTR() {
    return this.rrGeom.radiusTR;
  }
  set radiusTR(value) {
    this.rrGeom.radiusTR = value;
    this.dirty = true;
  }
  get radiusBL() {
    return this.rrGeom.radiusBL;
  }
  set radiusBL(value) {
    this.rrGeom.radiusBL = value;
    this.dirty = true;
  }
  get radiusBR() {
    return this.rrGeom.radiusBR;
  }
  set radiusBR(value) {
    this.rrGeom.radiusBR = value;
    this.dirty = true;
  }
  setRadius(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radius = value;
    return this;
  }
  setRadiusTL(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusTL = value;
    return this;
  }
  setRadiusTR(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusTR = value;
    return this;
  }
  setRadiusBL(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusBL = value;
    return this;
  }
  setRadiusBR(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radiusBR = value;
    return this;
  }
  get cornerRadius() {
    return this.rrGeom.cornerRadius;
  }
  set cornerRadius(value) {
    this.radius = value;
  }
  setCornerRadius(value) {
    return this.setRadius(value);
  }
  get iteration() {
    return this._iteration;
  }
  set iteration(value) {
    if (this._iteration === void 0) {
      this._iteration = value;
      return;
    }
    if (this._iteration === value) {
      return;
    }
    this._iteration = value;
    this.dirty = true;
  }
  setIteration(iteration) {
    if (iteration === void 0) {
      iteration = 6;
    }
    this.iteration = iteration;
    return this;
  }
};
var Methods11 = {
  updateShapes: UpdateShapes_default2
};
Object.assign(
  RoundRectangleProgress.prototype,
  Methods11
);
var RoundRectangleProgress_default = RoundRectangleProgress;

// node_modules/phaser3-rex-plugins/plugins/roundrectangleprogress.js
var roundrectangleprogress_default = RoundRectangleProgress_default;

// node_modules/phaser3-rex-plugins/templates/ui/roundrectangleprogress/RoundRectangleProgress.js
var RoundRectangleProgress_default2 = roundrectangleprogress_default;

// node_modules/phaser3-rex-plugins/templates/ui/roundrectangleprogress/Factory.js
ObjectFactory_default.register("roundRectanleProgress", function(x, y, width, height, radiusConfig, barColor, value, config) {
  var gameObject2 = new RoundRectangleProgress_default2(this.scene, x, y, width, height, radiusConfig, barColor, value, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.RoundRectangleProgress", RoundRectangleProgress_default2);

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/AddPolygonPath.js
var AddPolygonPath = function(context, points) {
  context.save();
  context.beginPath();
  var point = points[0];
  context.moveTo(point.x, point.y);
  for (var i = 1, cnt = points.length; i < cnt; i++) {
    point = points[i];
    context.lineTo(point.x, point.y);
  }
  context.closePath();
  context.restore();
};
var AddPolygonPath_default = AddPolygonPath;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/DrawPolygon.js
var DrawPolygon = function(canvas, context, points, fillStyle, strokeStyle, lineWidth, lineJoin) {
  if (lineJoin === void 0) {
    lineJoin = "round";
  }
  AddPolygonPath_default(context, points);
  context.lineJoin = lineJoin;
  if (fillStyle != null) {
    context.fillStyle = fillStyle;
    context.fill();
  }
  if (strokeStyle != null) {
    context.strokeStyle = strokeStyle;
    context.lineWidth = lineWidth;
    context.stroke();
  }
};
var DrawPolygon_default = DrawPolygon;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/lineprogress/DrawContent.js
var DrawContent3 = function() {
  var skewX = this.skewX;
  var width = this.width - Math.abs(skewX);
  var height = this.height;
  var canvas = this.canvas, context = this.context;
  if (this.trackColor || this.trackStrokeColor) {
    BuildPolygon(
      0,
      0,
      // x0, y0
      width,
      height,
      // x1, y1
      skewX,
      // skewX
      this.trackPoints
    );
  }
  var barX0, barX1;
  if (this.barColor) {
    if (!this.rtl) {
      barX0 = 0;
      barX1 = width * this.value;
    } else {
      barX0 = width * (1 - this.value);
      barX1 = width;
    }
    BuildPolygon(
      barX0,
      0,
      // x0, y0
      barX1,
      height,
      // x1, y1
      skewX,
      // skewX
      this.barPoints
    );
  }
  if (this.trackColor) {
    context.save();
    DrawPolygon_default(
      canvas,
      context,
      this.trackPoints,
      this.trackColor
    );
    context.restore();
  }
  if (this.barColor) {
    context.save();
    var style;
    if (this.barColor2) {
      var grd;
      if (this.isHorizontalGradient) {
        var helfHeight = height / 2;
        grd = context.createLinearGradient(barX0, helfHeight, barX1, helfHeight);
      } else {
        var helfWidth = width / 2;
        grd = context.createLinearGradient(helfWidth, 0, helfWidth, height);
      }
      grd.addColorStop(0, this.rtl ? this.barColor : this.barColor2);
      grd.addColorStop(1, this.rtl ? this.barColor2 : this.barColor);
      style = grd;
    } else {
      style = this.barColor;
    }
    DrawPolygon_default(
      canvas,
      context,
      this.barPoints,
      style
    );
    context.restore();
  }
  if (this.trackStrokeColor && this.trackStrokeThickness > 0) {
    context.save();
    DrawPolygon_default(
      canvas,
      context,
      this.trackPoints,
      void 0,
      this.trackStrokeColor,
      this.trackStrokeThickness
    );
    context.restore();
  }
};
var BuildPolygon = function(x0, y0, x1, y1, skewX, out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  out2.length = 4;
  for (var i = 0; i < 4; i++) {
    if (!out2[i]) {
      out2[i] = {};
    }
  }
  var p;
  if (skewX >= 0) {
    p = out2[0];
    p.x = x0 + skewX;
    p.y = y0;
    p = out2[1];
    p.x = x1 + skewX;
    p.y = y0;
    p = out2[2];
    p.x = x1;
    p.y = y1;
    p = out2[3];
    p.x = x0;
    p.y = y1;
  } else {
    p = out2[0];
    p.x = x0;
    p.y = y0;
    p = out2[1];
    p.x = x1;
    p.y = y0;
    p = out2[2];
    p.x = x1 - skewX;
    p.y = y1;
    p = out2[3];
    p.x = x0 - skewX;
    p.y = y1;
  }
  return out2;
};
var DrawContent_default3 = DrawContent3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/lineprogress/LineProgress.js
var GetValue66 = Phaser.Utils.Objects.GetValue;
var IsPlainObject19 = Phaser.Utils.Objects.IsPlainObject;
var LineProgress2 = class extends ProgressBase_default(Canvas_default) {
  constructor(scene, x, y, width, height, barColor, value, config) {
    if (IsPlainObject19(x)) {
      config = x;
      x = GetValue66(config, "x", 0);
      y = GetValue66(config, "y", 0);
      width = GetValue66(config, "width", 2);
      height = GetValue66(config, "height", 2);
      barColor = GetValue66(config, "barColor", void 0);
      value = GetValue66(config, "value", 0);
    } else if (IsPlainObject19(width)) {
      config = width;
      width = GetValue66(config, "width", 2);
      height = GetValue66(config, "height", 2);
      barColor = GetValue66(config, "barColor", void 0);
      value = GetValue66(config, "value", 0);
    } else if (IsPlainObject19(barColor)) {
      config = barColor;
      barColor = GetValue66(config, "barColor", void 0);
      value = GetValue66(config, "value", 0);
    }
    var resolution = GetValue66(config, "resolution", 1);
    super(scene, x, y, width, height, resolution);
    this.type = "rexLineProgressCanvas";
    this.trackPoints = [];
    this.barPoints = [];
    this.bootProgressBase(config);
    this.setTrackColor(GetValue66(config, "trackColor", void 0));
    this.setBarColor(
      barColor,
      GetValue66(config, "barColor2", void 0),
      GetValue66(config, "isHorizontalGradient", void 0)
    );
    this.setTrackStroke(GetValue66(config, "trackStrokeThickness", 2), GetValue66(config, "trackStrokeColor", void 0));
    this.setSkewX(GetValue66(config, "skewX", 0));
    this.setRTL(GetValue66(config, "rtl", false));
    this.setValue(value);
  }
  get trackColor() {
    return this._trackColor;
  }
  set trackColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._trackColor != value;
    this._trackColor = value;
  }
  setTrackColor(color) {
    this.trackColor = color;
    return this;
  }
  get trackStrokeColor() {
    return this._trackStrokeColor;
  }
  set trackStrokeColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._trackStrokeColor != value;
    this._trackStrokeColor = value;
  }
  get trackStrokeThickness() {
    return this._trackStrokeThickness;
  }
  set trackStrokeThickness(value) {
    this.dirty = this.dirty || this._trackStrokeThickness != value;
    this._trackStrokeThickness = value;
  }
  setTrackStroke(lineWidth, color) {
    this.trackStrokeThickness = lineWidth;
    this.trackStrokeColor = color;
    return this;
  }
  get barColor() {
    return this._barColor;
  }
  set barColor(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._barColor != value;
    this._barColor = value;
  }
  get barColor2() {
    return this._barColor2;
  }
  set barColor2(value) {
    value = GetStyle_default(value, this.canvas, this.context);
    this.dirty = this.dirty || this._barColor2 != value;
    this._barColor2 = value;
  }
  get isHorizontalGradient() {
    return this._isHorizontalGradient;
  }
  set isHorizontalGradient(value) {
    this.dirty |= this._isHorizontalGradient != value;
    this._isHorizontalGradient = value;
  }
  setBarColor(color, color2, isHorizontalGradient) {
    if (isHorizontalGradient === void 0) {
      isHorizontalGradient = true;
    }
    this.barColor = color;
    this.barColor2 = color2;
    this.isHorizontalGradient = isHorizontalGradient;
    return this;
  }
  get skewX() {
    return this._skewX;
  }
  set skewX(value) {
    this.dirty = this.dirty || this._skewX != value;
    this._skewX = value;
  }
  setSkewX(value) {
    this.skewX = value;
    return this;
  }
  get rtl() {
    return this._rtl;
  }
  set rtl(value) {
    value = !!value;
    this.dirty = this.dirty || this._rtl != value;
    this._rtl = value;
  }
  setRTL(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.rtl = enable;
    return this;
  }
  updateTexture() {
    super.updateTexture(function() {
      this.clear();
      DrawContent_default3.call(this);
    }, this);
    return this;
  }
};
var LineProgress_default3 = LineProgress2;

// node_modules/phaser3-rex-plugins/plugins/lineprogresscanvas.js
var lineprogresscanvas_default = LineProgress_default3;

// node_modules/phaser3-rex-plugins/templates/ui/lineprogresscanvas/LineProgressCanvas.js
var LineProgressCanvas_default = lineprogresscanvas_default;

// node_modules/phaser3-rex-plugins/templates/ui/lineprogresscanvas/Factory.js
ObjectFactory_default.register("circularProgressCanvas", function(x, y, width, height, barColor, value, config) {
  var gameObject2 = new LineProgressCanvas_default(this.scene, x, y, width, height, barColor, value, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.LineProgressCanvas", LineProgressCanvas_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/triangle/methods/DrawFitTriangle.js
var Wrap3 = Phaser.Math.Wrap;
var Linear9 = Phaser.Math.Linear;
var DrawFitTriangle = function() {
  var triangle = this.getShape("triangle");
  var padding = this.padding;
  var right = this.width - padding.right;
  var left = 0 + padding.left;
  var bottom = this.height - padding.bottom;
  var top = 0 + padding.top;
  var centerX = (left + right) / 2;
  var centerY = (top + bottom) / 2;
  var points = {
    0: {
      // right
      a: { x: left, y: top },
      b: { x: right, y: centerY },
      c: { x: left, y: bottom }
    },
    1: {
      // down
      a: { x: left, y: top },
      b: { x: centerX, y: bottom },
      c: { x: right, y: top }
    },
    2: {
      // left
      a: { x: right, y: top },
      b: { x: left, y: centerY },
      c: { x: right, y: bottom }
    },
    3: {
      // up
      a: { x: left, y: bottom },
      b: { x: centerX, y: top },
      c: { x: right, y: bottom }
    }
  };
  var pax, pay, pbx, pby, pcx, pcy;
  if (this.previousDirection === void 0) {
    var currentTrianglePoints = points[this.direction];
    var pa = currentTrianglePoints.a, pb = currentTrianglePoints.b, pc = currentTrianglePoints.c;
    pax = pa.x;
    pay = pa.y;
    pbx = pb.x;
    pby = pb.y;
    pcx = pc.x;
    pcy = pc.y;
  } else {
    var p0 = points[this.previousDirection];
    var p1 = points[this.direction];
    var t = this.easeDirectionProgress;
    pax = Linear9(p0.a.x, p1.a.x, t);
    pay = Linear9(p0.a.y, p1.a.y, t);
    pbx = Linear9(p0.b.x, p1.b.x, t);
    pby = Linear9(p0.b.y, p1.b.y, t);
    pcx = Linear9(p0.c.x, p1.c.x, t);
    pcy = Linear9(p0.c.y, p1.c.y, t);
  }
  triangle.startAt(pax, pay).lineTo(pbx, pby).lineTo(pcx, pcy);
  if (!this.arrowOnly) {
    triangle.close();
  } else {
    triangle.end();
  }
};
var DrawFitTriangle_default = DrawFitTriangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/triangle/methods/DrawCircleVerticesTriangle.js
var DegToRad10 = Phaser.Math.DegToRad;
var Rad120 = DegToRad10(120);
var DrawCircleVerticesTriangle = function(triangle) {
  var triangle = this.getShape("triangle");
  var centerX = this.width / 2, centerY = this.height / 2;
  var radius = Math.min(centerX, centerY) * this.radius, verticeRotation = this.verticeRotation;
  triangle.startAt(
    centerX + radius * Math.cos(verticeRotation + Rad120),
    centerY + radius * Math.sin(verticeRotation + Rad120)
  ).lineTo(
    centerX + radius * Math.cos(verticeRotation),
    centerY + radius * Math.sin(verticeRotation)
  ).lineTo(
    centerX + radius * Math.cos(verticeRotation - Rad120),
    centerY + radius * Math.sin(verticeRotation - Rad120)
  );
  if (!this.arrowOnly) {
    triangle.close();
  } else {
    triangle.end();
  }
};
var DrawCircleVerticesTriangle_default = DrawCircleVerticesTriangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/triangle/methods/ShapesUpdateMethods.js
var ShapesUpdateMethods_default4 = {
  buildShapes() {
    this.addShape(new Lines_default().setName("triangle"));
  },
  updateShapes() {
    var triangle = this.getShape("triangle");
    if (!this.arrowOnly) {
      triangle.fillStyle(this.fillColor, this.fillAlpha).lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
    } else {
      triangle.fillStyle().lineStyle(this.lineWidth, this.strokeColor, this.strokeAlpha);
    }
    if (this.shapeMode === 0) {
      DrawFitTriangle_default.call(this);
    } else {
      DrawCircleVerticesTriangle_default.call(this);
    }
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/triangle/methods/EaseDirectionMethods.js
var EaseDirectionMethods_default = {
  setEaseDuration(duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.easeDuration = duration;
    return this;
  },
  playEaseDirectionation() {
    if (this.easeDirectionProgressTask === void 0) {
      this.easeDirectionProgressTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.easeDirectionProgressTask.restart({
      key: "easeDirectionProgress",
      from: 0,
      to: 1,
      duration: this.easeDuration
    });
    return this;
  },
  stopEaseDirection() {
    if (this.easeDirectionProgressTask === void 0) {
      return this;
    }
    this.easeDirectionProgressTask.stop();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/triangle/Triangle.js
var GetValue67 = Phaser.Utils.Objects.GetValue;
var IsPlainObject20 = Phaser.Utils.Objects.IsPlainObject;
var DegToRad11 = Phaser.Math.DegToRad;
var RadToDeg8 = Phaser.Math.RadToDeg;
var Triangle2 = class extends BaseShapes_default {
  constructor(scene, x, y, width, height, fillColor, fillAlpha) {
    var strokeColor, strokeAlpha, strokeWidth, arrowOnly;
    var direction, easeDuration, padding;
    var radius;
    if (IsPlainObject20(x)) {
      var config = x;
      x = config.x;
      y = config.y;
      width = config.width;
      height = config.height;
      fillColor = config.color;
      fillAlpha = config.alpha;
      strokeColor = config.strokeColor;
      strokeAlpha = config.strokeAlpha;
      strokeWidth = config.strokeWidth;
      arrowOnly = config.arrowOnly;
      direction = config.direction;
      easeDuration = config.easeDuration;
      padding = config.padding;
      radius = config.radius;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = width;
    }
    if (arrowOnly === void 0) {
      arrowOnly = false;
    }
    if (direction === void 0) {
      direction = 0;
    }
    if (easeDuration === void 0) {
      easeDuration = 0;
    }
    if (padding === void 0) {
      padding = 0;
    }
    if (radius === void 0) {
      radius = void 0;
    }
    super(scene, x, y, width, height);
    this.type = "rexTriangle";
    this.setFillStyle(fillColor, fillAlpha);
    if (strokeColor !== void 0 && strokeWidth === void 0) {
      strokeWidth = 2;
    }
    this.setStrokeStyle(strokeWidth, strokeColor, strokeAlpha);
    this.setArrowOnly(arrowOnly);
    this.setDirection(direction, easeDuration);
    this.setPadding(padding);
    this.setRadius(radius);
    this.buildShapes();
  }
  get arrowOnly() {
    return this._arrowOnly;
  }
  set arrowOnly(value) {
    this.dirty = this.dirty || this._arrowOnly != value;
    this._arrowOnly = value;
  }
  setArrowOnly(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.arrowOnly = enable;
    return this;
  }
  get direction() {
    return this._direction;
  }
  set direction(value) {
    value = ParseDirection(value);
    if (this._direction === value) {
      return;
    }
    if (this.easeDuration > 0 && this._direction !== void 0) {
      this.previousDirection = this._direction;
    } else {
      this.previousDirection = void 0;
    }
    this._direction = value;
    this.verticeAngle = value * 90;
    this.dirty = true;
    if (this.previousDirection !== void 0) {
      this.playEaseDirectionation();
    } else {
      this.stopEaseDirection();
    }
  }
  setDirection(direction, easeDuration) {
    if (easeDuration !== void 0) {
      this.setEaseDuration(easeDuration);
    }
    this.direction = direction;
    return this;
  }
  toggleDirection(easeDuration) {
    this.setDirection(this.direction + 2, easeDuration);
    return this;
  }
  get easeDirectionProgress() {
    return this._easeDirectionProgress;
  }
  set easeDirectionProgress(value) {
    if (this._easeDirectionProgress === value) {
      return;
    }
    this._easeDirectionProgress = value;
    this.dirty = true;
  }
  setPadding(left, top, right, bottom) {
    if (typeof left === "object") {
      var config = left;
      var x = GetValue67(config, "x", null);
      if (x !== null) {
        left = x;
        right = x;
      } else {
        left = GetValue67(config, "left", 0);
        right = GetValue67(config, "right", left);
      }
      var y = GetValue67(config, "y", null);
      if (y !== null) {
        top = y;
        bottom = y;
      } else {
        top = GetValue67(config, "top", 0);
        bottom = GetValue67(config, "bottom", top);
      }
    } else {
      if (left === void 0) {
        left = 0;
      }
      if (top === void 0) {
        top = left;
      }
      if (right === void 0) {
        right = left;
      }
      if (bottom === void 0) {
        bottom = top;
      }
    }
    if (this.padding === void 0) {
      this.padding = {};
    }
    this.dirty = this.dirty || this.padding.left != left || this.padding.top != top || this.padding.right != right || this.padding.bottom != bottom;
    this.padding.left = left;
    this.padding.top = top;
    this.padding.right = right;
    this.padding.bottom = bottom;
    this.setRadius();
    return this;
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    this.dirty = this.dirty || this._radius != value;
    this._radius = value;
  }
  setRadius(radius) {
    this.radius = radius;
    this.shapeMode = radius == null ? 0 : 1;
    return this;
  }
  get verticeRotation() {
    return this._verticeRotation;
  }
  set verticeRotation(value) {
    this.dirty = this.dirty || this._verticeRotation != value;
    this._verticeRotation = value;
  }
  setVerticeRotation(rotation) {
    this.verticeRotation = rotation;
    return this;
  }
  get verticeAngle() {
    return RadToDeg8(this.verticeRotation);
  }
  set verticeAngle(value) {
    this.verticeRotation = DegToRad11(value);
  }
  setVerticeAngle(angle) {
    this.verticeAngle = angle;
    return this;
  }
};
var DirectionNameMap = {
  right: 0,
  down: 1,
  left: 2,
  up: 3
};
var ParseDirection = function(direction) {
  if (typeof direction === "string") {
    direction = DirectionNameMap[direction];
  }
  direction = direction % 4;
  return direction;
};
Object.assign(
  Triangle2.prototype,
  ShapesUpdateMethods_default4,
  EaseDirectionMethods_default
);
var Triangle_default2 = Triangle2;

// node_modules/phaser3-rex-plugins/plugins/triangle.js
var triangle_default = Triangle_default2;

// node_modules/phaser3-rex-plugins/templates/ui/triangle/Triangle.js
var Triangle_default3 = triangle_default;

// node_modules/phaser3-rex-plugins/templates/ui/triangle/Factory.js
ObjectFactory_default.register("triangle", function(x, y, width, height, fillColor, fillAlpha) {
  var gameObject2 = new Triangle_default3(this.scene, x, y, width, height, fillColor, fillAlpha);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Triangle", Triangle_default3);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Base.js
CheckP3Version_default();
var Zone2 = Phaser.GameObjects.Zone;
var AddItem = Phaser.Utils.Array.Add;
var RemoveItem9 = Phaser.Utils.Array.Remove;
var Base3 = class extends Zone2 {
  constructor(scene, x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    super(scene, x, y, width, height);
    this.children = [];
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (fromScene) {
      var child;
      for (var i = this.children.length - 1; i >= 0; i--) {
        child = this.children[i];
        if (!child.parentContainer && // Not in container
        !child.displayList) {
          child.destroy(fromScene);
        }
      }
    }
    this.clear(!fromScene);
    super.destroy(fromScene);
  }
  contains(gameObject2) {
    return this.children.indexOf(gameObject2) !== -1;
  }
  add(gameObjects) {
    var parent = this;
    AddItem(
      this.children,
      gameObjects,
      0,
      // Callback of item added
      function(gameObject2) {
        gameObject2.once("destroy", parent.onChildDestroy, parent);
      },
      this
    );
    return this;
  }
  remove(gameObjects, destroyChild) {
    var parent = this;
    RemoveItem9(
      this.children,
      gameObjects,
      // Callback of item removed
      function(gameObject2) {
        gameObject2.off("destroy", parent.onChildDestroy, parent);
        if (destroyChild) {
          gameObject2.destroy();
        }
      }
    );
    return this;
  }
  onChildDestroy(child, fromScene) {
    this.remove(child, false);
  }
  clear(destroyChild) {
    var parent = this;
    var gameObject2;
    for (var i = 0, cnt = this.children.length; i < cnt; i++) {
      gameObject2 = this.children[i];
      gameObject2.off("destroy", parent.onChildDestroy, parent);
      if (destroyChild) {
        gameObject2.destroy();
      }
    }
    this.children.length = 0;
    return this;
  }
};
var Components5 = Phaser.GameObjects.Components;
Phaser.Class.mixin(
  Base3,
  [
    Components5.Alpha,
    Components5.Flip
  ]
);
var Base_default3 = Base3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/GetParent.js
var GetParent = function(gameObject2, name2) {
  var parent;
  if (name2 === void 0) {
    if (gameObject2.hasOwnProperty("rexContainer")) {
      parent = gameObject2.rexContainer.parent;
    }
  } else {
    parent = GetParent(gameObject2);
    while (parent) {
      if (parent.name === name2) {
        break;
      }
      parent = GetParent(parent);
    }
  }
  return parent;
};
var GetTopmostParent = function(gameObject2) {
  var parent = GetParent(gameObject2);
  while (parent) {
    gameObject2 = parent;
    parent = GetParent(parent);
  }
  return gameObject2;
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/utils/GetLocalState.js
var DegToRad12 = Phaser.Math.DegToRad;
var RadToDeg9 = Phaser.Math.RadToDeg;
var GetLocalState = function(gameObject2) {
  if (!gameObject2.hasOwnProperty("rexContainer")) {
    var rexContainer = {
      parent: null,
      self: null,
      layer: null,
      x: 0,
      y: 0,
      syncPosition: true,
      rotation: 0,
      syncRotation: true,
      scaleX: 0,
      scaleY: 0,
      syncScale: true,
      alpha: 0,
      syncAlpha: true,
      syncScrollFactor: true,
      syncCameraFilter: true,
      syncDisplayList: true,
      visible: true,
      active: true
    };
    Object.defineProperty(rexContainer, "angle", {
      get: function() {
        return RadToDeg9(this.rotation);
      },
      set: function(value) {
        this.rotation = DegToRad12(value);
      }
    });
    Object.defineProperty(rexContainer, "displayWidth", {
      get: function() {
        return gameObject2.width * this.scaleX;
      },
      set: function(width) {
        this.scaleX = width / gameObject2.width;
      }
    });
    Object.defineProperty(rexContainer, "displayHeight", {
      get: function() {
        return gameObject2.height * this.scaleY;
      },
      set: function(height) {
        this.scaleY = height / gameObject2.height;
      }
    });
    gameObject2.rexContainer = rexContainer;
  }
  return gameObject2.rexContainer;
};
var GetLocalState_default = GetLocalState;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Parent.js
var Parent_default = {
  setParent(gameObject2, parent) {
    if (parent === void 0) {
      parent = this;
    }
    var localState = GetLocalState_default(gameObject2);
    if (parent) {
      localState.parent = parent;
      localState.self = gameObject2;
    } else {
      localState.parent = null;
      localState.self = null;
    }
    return this;
  },
  getParent(gameObject2, name2) {
    if (typeof gameObject2 === "string") {
      name2 = gameObject2;
      gameObject2 = void 0;
    }
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    return GetParent(gameObject2, name2);
  },
  getTopmostParent(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    return GetTopmostParent(gameObject2);
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/AddChild.js
var GetValue68 = Phaser.Utils.Objects.GetValue;
var BaseAdd = Base_default3.prototype.add;
var Add = function(gameObject2, config) {
  this.setParent(gameObject2);
  var state = GetLocalState_default(gameObject2);
  SetupSyncFlags(state, config);
  this.resetChildState(gameObject2).updateChildVisible(gameObject2).updateChildActive(gameObject2).updateChildScrollFactor(gameObject2).updateChildMask(gameObject2).updateCameraFilter(gameObject2);
  BaseAdd.call(this, gameObject2);
  SyncDisplayList.call(this, gameObject2, state);
  return this;
};
var AddLocal = function(gameObject2, config) {
  this.setParent(gameObject2);
  var state = GetLocalState_default(gameObject2);
  SetupSyncFlags(state, config);
  state.x = gameObject2.x;
  state.y = gameObject2.y;
  state.rotation = gameObject2.rotation;
  state.scaleX = gameObject2.scaleX;
  state.scaleY = gameObject2.scaleY;
  state.alpha = gameObject2.alpha;
  state.visible = gameObject2.visible;
  state.active = gameObject2.active;
  this.updateChildPosition(gameObject2).updateChildAlpha(gameObject2).updateChildVisible(gameObject2).updateChildActive(gameObject2).updateChildScrollFactor(gameObject2).updateChildMask(gameObject2);
  BaseAdd.call(this, gameObject2);
  SyncDisplayList.call(this, gameObject2, state);
  return this;
};
var SetupSyncFlags = function(state, config) {
  if (config === void 0) {
    config = true;
  }
  if (typeof config === "boolean") {
    state.syncPosition = config;
    state.syncRotation = config;
    state.syncScale = config;
    state.syncAlpha = config;
    state.syncScrollFactor = config;
    state.syncCameraFilter = config;
    state.syncDisplayList = config;
  } else {
    state.syncPosition = GetValue68(config, "syncPosition", true);
    state.syncRotation = GetValue68(config, "syncRotation", true);
    state.syncScale = GetValue68(config, "syncScale", true);
    state.syncAlpha = GetValue68(config, "syncAlpha", true);
    state.syncScrollFactor = GetValue68(config, "syncScrollFactor", true);
    state.syncCameraFilter = GetValue68(config, "syncCameraFilter", true);
    state.syncDisplayList = GetValue68(config, "syncDisplayList", true);
  }
};
var SyncDisplayList = function(gameObject2, state) {
  this.addToParentContainer(gameObject2);
  if (state.syncDisplayList) {
    this.addToPatentLayer(gameObject2);
  }
  this.addToRenderLayer(gameObject2);
};
var AddChild_default3 = {
  // Can override this method
  add(gameObject2) {
    if (Array.isArray(gameObject2)) {
      this.addMultiple(gameObject2);
    } else {
      Add.call(this, gameObject2);
    }
    return this;
  },
  // Don't override this method
  pin(gameObject2, config) {
    if (Array.isArray(gameObject2)) {
      this.addMultiple(gameObject2, config);
    } else {
      Add.call(this, gameObject2, config);
    }
    return this;
  },
  // Can override this method
  addMultiple(gameObjects) {
    var args = Array.from(arguments);
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      args[0] = gameObjects[i];
      this.add.apply(this, args);
    }
    return this;
  },
  addLocal(gameObject2) {
    if (Array.isArray(gameObject2)) {
      this.addMultiple(gameObject2);
    } else {
      AddLocal.call(this, gameObject2);
    }
    return this;
  },
  // Don't override this method
  pinLocal(gameObject2, config) {
    if (Array.isArray(gameObject2)) {
      this.addMultiple(gameObject2, config);
    } else {
      AddLocal.call(this, gameObject2, config);
    }
    return this;
  },
  addLocalMultiple(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      AddLocal.call(this, gameObjects[i]);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/RemoveChild.js
var BaseRemove = Base_default3.prototype.remove;
var BaseClear = Base_default3.prototype.clear;
var RemoveChild_default3 = {
  // Can override this method
  remove(gameObject2, destroyChild) {
    if (GetParent(gameObject2) !== this) {
      return this;
    }
    this.setParent(gameObject2, null);
    if (!destroyChild) {
      this.removeFromRenderLayer(gameObject2);
    }
    BaseRemove.call(this, gameObject2, destroyChild);
    return this;
  },
  // Don't override this method
  unpin(gameObject2, destroyChild) {
    if (GetParent(gameObject2) !== this) {
      return this;
    }
    this.setParent(gameObject2, null);
    if (!destroyChild) {
      this.removeFromRenderLayer(gameObject2);
    }
    BaseRemove.call(this, gameObject2, destroyChild);
    return this;
  },
  clear(destroyChild) {
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      this.setParent(child, null);
      if (!destroyChild) {
        this.removeFromRenderLayer(child);
      }
    }
    BaseClear.call(this, destroyChild);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ChildState.js
var ChildState_default = {
  getLocalState(gameObject2) {
    return GetLocalState_default(gameObject2);
  },
  resetChildState(gameObject2) {
    this.resetChildPositionState(gameObject2).resetChildVisibleState(gameObject2).resetChildAlphaState(gameObject2).resetChildActiveState(gameObject2);
    return this;
  },
  resetChildrenState(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      this.resetChildState(gameObjects[i]);
    }
    return this;
  },
  syncProperties() {
    this.syncPosition().syncVisible().syncAlpha().syncActive().syncScrollFactor().syncMask();
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Transform.js
var Transform_default = {
  worldToLocal(point) {
    point.x -= this.x;
    point.y -= this.y;
    var c = Math.cos(-this.rotation);
    var s = Math.sin(-this.rotation);
    var tx = point.x;
    var ty = point.y;
    point.x = tx * c - ty * s;
    point.y = tx * s + ty * c;
    point.x /= this.scaleX;
    point.y /= this.scaleY;
    return point;
  },
  localToWorld(point) {
    point.x *= this.scaleX;
    point.y *= this.scaleY;
    var c = Math.cos(this.rotation);
    var s = Math.sin(this.rotation);
    var tx = point.x;
    var ty = point.y;
    point.x = tx * c - ty * s;
    point.y = tx * s + ty * c;
    point.x += this.x;
    point.y += this.y;
    return point;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/utils/GetScale.js
var GetScale = function(a, b) {
  if (a === b) {
    return 1;
  } else {
    return a / b;
  }
};
var GetScale_default = GetScale;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Position.js
var Position_default = {
  updateChildPosition(child) {
    if (child.isRexContainerLite) {
      child.syncChildrenEnable = false;
    }
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    if (localState.syncPosition) {
      child.x = localState.x;
      child.y = localState.y;
      parent.localToWorld(child);
    }
    if (localState.syncRotation) {
      child.rotation = localState.rotation + parent.rotation;
    }
    if (localState.syncScale) {
      child.scaleX = localState.scaleX * parent.scaleX;
      child.scaleY = localState.scaleY * parent.scaleY;
    }
    if (child.isRexContainerLite) {
      child.syncChildrenEnable = true;
      child.syncPosition();
    }
    return this;
  },
  syncPosition() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildPosition, this);
    }
    return this;
  },
  resetChildPositionState(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    localState.x = child.x;
    localState.y = child.y;
    parent.worldToLocal(localState);
    localState.scaleX = GetScale_default(child.scaleX, parent.scaleX);
    localState.scaleY = GetScale_default(child.scaleY, parent.scaleY);
    localState.rotation = child.rotation - parent.rotation;
    return this;
  },
  setChildPosition(child, x, y) {
    child.x = x;
    child.y = y;
    this.resetChildPositionState(child);
    return this;
  },
  setChildLocalPosition(child, x, y) {
    var localState = GetLocalState_default(child);
    localState.x = x;
    localState.y = y;
    this.updateChildPosition(child);
    return this;
  },
  resetLocalPositionState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildPositionState(this);
    }
    return this;
  },
  getChildLocalX(child) {
    var localState = GetLocalState_default(child);
    return localState.x;
  },
  getChildLocalY(child) {
    var localState = GetLocalState_default(child);
    return localState.y;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Rotation.js
var DegToRad13 = Phaser.Math.DegToRad;
var Rotation_default = {
  updateChildRotation(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    if (localState.syncRotation) {
      child.rotation = parent.rotation + localState.rotation;
    }
    return this;
  },
  syncRotation() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildRotation, this);
    }
    return this;
  },
  resetChildRotationState(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    localState.rotation = child.rotation - parent.rotation;
    return this;
  },
  setChildRotation(child, rotation) {
    child.rotation = rotation;
    this.resetChildRotationState(child);
    return this;
  },
  setChildAngle(child, angle) {
    child.angle = angle;
    this.resetChildRotationState(child);
    return this;
  },
  setChildLocalRotation(child, rotation) {
    var localState = GetLocalState_default(child);
    localState.rotation = rotation;
    this.updateChildRotation(child);
    return this;
  },
  setChildLocalAngle(child, angle) {
    var localState = GetLocalState_default(child);
    localState.rotation = DegToRad13(angle);
    this.updateChildRotation(child);
    return this;
  },
  resetLocalRotationState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildRotationState(this);
    }
    return this;
  },
  getChildLocalRotation(child) {
    var localState = GetLocalState_default(child);
    return localState.rotation;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Scale.js
var Scale_default2 = {
  updateChildScale(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    if (state.syncScale) {
      child.scaleX = parent.scaleX * state.scaleX;
      child.scaleY = parent.scaleY * state.scaleY;
    }
    return this;
  },
  syncScale() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildScale, this);
    }
    return this;
  },
  resetChildScaleState(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    state.scaleX = GetScale_default(child.scaleX, parent.scaleX);
    state.scaleY = GetScale_default(child.scaleY, parent.scaleY);
    return this;
  },
  setChildScale(child, scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    child.scaleX = scaleX;
    child.scaleY = scaleY;
    this.resetChildScaleState(child);
    return this;
  },
  setChildLocalScale(child, scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    var state = GetLocalState_default(child);
    state.scaleX = scaleX;
    state.scaleY = scaleY;
    this.updateChildScale(child);
    return this;
  },
  setChildDisplaySize(child, width, height) {
    child.setDisplaySize(width, height);
    this.resetChildScaleState(child);
    return this;
  },
  resetLocalScaleState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildScaleState(this);
    }
    return this;
  },
  getChildLocalScaleX(child) {
    var localState = GetLocalState_default(child);
    return localState.scaleX;
  },
  getChildLocalScaleY(child) {
    var localState = GetLocalState_default(child);
    return localState.scaleY;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Visible.js
var Visible_default = {
  updateChildVisible(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    var maskVisible = localState.hasOwnProperty("maskVisible") ? localState.maskVisible : true;
    var parentVisible = parent ? parent.visible : true;
    child.visible = parentVisible && localState.visible && maskVisible;
    return this;
  },
  syncVisible() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildVisible, this);
    }
    return this;
  },
  resetChildVisibleState(child) {
    var localState = GetLocalState_default(child);
    if (localState.hasOwnProperty("maskVisible")) {
      delete localState.maskVisible;
    }
    localState.visible = child.visible;
    return this;
  },
  setChildVisible(child, visible) {
    this.setChildLocalVisible(child, visible);
    return this;
  },
  // Internal method
  setChildLocalVisible(child, visible) {
    if (visible === void 0) {
      visible = true;
    }
    var localState = GetLocalState_default(child);
    localState.visible = visible;
    this.updateChildVisible(child);
    return this;
  },
  // Internal method
  setChildMaskVisible(child, visible) {
    if (visible === void 0) {
      visible = true;
    }
    var localState = GetLocalState_default(child);
    localState.maskVisible = visible;
    this.updateChildVisible(child);
    return this;
  },
  resetLocalVisibleState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildVisibleState(this);
    }
    return this;
  },
  getChildLocalVisible(child) {
    var localState = GetLocalState_default(child);
    return localState.visible;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Alpha.js
var Alpha_default = {
  updateChildAlpha(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    if (state.syncAlpha) {
      child.alpha = parent.alpha * state.alpha;
    }
    return this;
  },
  syncAlpha() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildAlpha, this);
    }
    return this;
  },
  resetChildAlphaState(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    state.alpha = GetScale_default(child.alpha, parent.alpha);
    return this;
  },
  setChildAlpha(child, alpha) {
    child.alpha = alpha;
    this.resetChildAlphaState(child);
    return this;
  },
  setChildLocalAlpha(child, alpha) {
    var state = GetLocalState_default(child);
    state.alpha = alpha;
    this.updateChildAlpha(child);
    return this;
  },
  resetLocalAlphaState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildAlphaState(this);
    }
    return this;
  },
  getChildLocalAlpha(child) {
    var localState = GetLocalState_default(child);
    return localState.alpha;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Active.js
var Active_default = {
  updateChildActive(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    child.active = parent.active && localState.active;
    return this;
  },
  syncActive() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildActive, this);
    }
    return this;
  },
  resetChildActiveState(child) {
    var localState = GetLocalState_default(child);
    localState.active = child.active;
    return this;
  },
  setChildActive(child, active) {
    child.active = active;
    this.resetChildActiveState(child);
    return this;
  },
  setChildLocalActive(child, active) {
    if (active === void 0) {
      active = true;
    }
    var localState = GetLocalState_default(child);
    localState.active = active;
    this.updateChildActive(child);
    return this;
  },
  resetLocalActiveState() {
    var parent = GetLocalState_default(this).parent;
    if (parent) {
      parent.resetChildActiveState(this);
    }
    return this;
  },
  getChildLocalActive(child) {
    var localState = GetLocalState_default(child);
    return localState.active;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ScrollFactor.js
var ScrollFactor_default = {
  updateChildScrollFactor(child) {
    var localState = GetLocalState_default(child);
    var parent = localState.parent;
    if (localState.syncScrollFactor) {
      child.scrollFactorX = parent.scrollFactorX;
      child.scrollFactorY = parent.scrollFactorY;
    }
    return this;
  },
  syncScrollFactor() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildScrollFactor, this);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/CameraFilter.js
var CameraFilter_default = {
  updateCameraFilter(child) {
    var state = GetLocalState_default(child);
    var parent = state.parent;
    if (state.syncCameraFilter) {
      child.cameraFilter = parent.cameraFilter;
    }
    return this;
  },
  syncCameraFilter() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateCameraFilter, this);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Mask.js
var Mask_default = {
  updateChildMask(child) {
    if (this.mask == null) {
      return this;
    }
    var maskGameObject = this.mask.hasOwnProperty("geometryMask") ? this.mask.geometryMask : this.mask.bitmapMask;
    if (maskGameObject !== child) {
      child.mask = this.mask;
    }
    return this;
  },
  syncMask() {
    if (this.syncChildrenEnable) {
      this.children.forEach(this.updateChildMask, this);
    }
    return this;
  },
  setMask(mask) {
    this.mask = mask;
    return this;
  },
  clearMask(destroyMask) {
    if (destroyMask === void 0) {
      destroyMask = false;
    }
    var self = this;
    this._mask = null;
    this.setChildMaskVisible(this);
    this.children.forEach(function(child) {
      if (child.clearMask) {
        child.clearMask(false);
      }
      if (!child.hasOwnProperty("isRexContainerLite")) {
        self.setChildMaskVisible(child);
      }
    });
    if (destroyMask && this.mask) {
      this.mask.destroy();
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/system/FilterDisplayGameObjects.js
var FilterDisplayGameObjects = function(gameObjects) {
  return gameObjects.filter(function(gameObject2) {
    if (gameObject2.displayList) {
      return true;
    } else if (gameObject2.parentContainer) {
      return true;
    }
  });
};
var FilterDisplayGameObjects_default = FilterDisplayGameObjects;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Depth.js
var Depth_default = {
  setDepth(value, containerOnly) {
    this.depth = value;
    if (!containerOnly && this.children) {
      var children = this.getAllChildren();
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].depth = value;
      }
    }
    return this;
  },
  swapDepth(containerB) {
    var depthA = this.depth;
    var depthB = containerB.depth;
    this.setDepth(depthB);
    containerB.setDepth(depthA);
    return this;
  },
  incDepth(inc) {
    this.depth += inc;
    if (this.children) {
      var children = this.getAllChildren();
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].depth += inc;
      }
    }
    return this;
  },
  bringToTop() {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, false);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.bringToTop(child);
      }
    }
    return this;
  },
  bringMeToTop() {
    return this.bringToTop();
  },
  sendToBack() {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, true);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.sendToBack(child);
      }
    }
    return this;
  },
  sendMeToBack() {
    return this.sendToBack();
  },
  moveDepthBelow(gameObject2) {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    if (gameObject2.displayList !== displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, false);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.moveBelow(gameObject2, child);
        break;
      }
    }
    return this;
  },
  moveMyDepthBelow(gameObject2) {
    return this.moveDepthBelow(gameObject2);
  },
  moveDepthAbove(gameObject2) {
    var displayList = this.displayList;
    if (!displayList) {
      return this;
    }
    if (gameObject2.displayList !== displayList) {
      return this;
    }
    var children = this.getAllChildren([this]);
    SortGameObjectsByDepth_default(children, true);
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      if (displayList.exists(child)) {
        displayList.moveAbove(gameObject2, child);
        break;
      }
    }
    return this;
  },
  moveMyDepthAbove(gameObject2) {
    return this.moveDepthAbove(gameObject2);
  },
  bringChildToTop(child) {
    var gameObjects;
    if (child !== this && child.isRexContainerLite) {
      gameObjects = child.getAllChildren([child]);
      gameObjects = FilterDisplayGameObjects_default(gameObjects);
      gameObjects = SortGameObjectsByDepth_default(gameObjects, false);
    } else {
      gameObjects = [child];
    }
    var children = this.getAllChildren([this]);
    children = FilterDisplayGameObjects_default(children);
    children = SortGameObjectsByDepth_default(children, false);
    var topChild = children[children.length - 1];
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject2 = gameObjects[i];
      if (topChild === gameObject2) {
        continue;
      }
      if (gameObject2 !== this && topChild.displayList !== gameObject2.displayList) {
        continue;
      }
      topChild.displayList.moveAbove(gameObject2, topChild);
      topChild = gameObject2;
    }
    return this;
  },
  sendChildToBack(child) {
    var gameObjects;
    if (child !== this && child.isRexContainerLite) {
      gameObjects = child.getAllChildren([child]);
      gameObjects = FilterDisplayGameObjects_default(gameObjects);
      gameObjects = SortGameObjectsByDepth_default(gameObjects, false);
    } else {
      gameObjects = [child];
    }
    var children = this.getAllChildren([this]);
    children = FilterDisplayGameObjects_default(children);
    children = SortGameObjectsByDepth_default(children, false);
    var bottomChild = children[0];
    for (var i = gameObjects.length - 1; i >= 0; i--) {
      var gameObject2 = gameObjects[i];
      if (bottomChild === gameObject2) {
        continue;
      }
      if (gameObject2 !== this && bottomChild.displayList !== gameObject2.displayList) {
        continue;
      }
      bottomChild.displayList.moveBelow(gameObject2, bottomChild);
      bottomChild = gameObject2;
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/utils/Traversal.js
var DepthFirstSearch = function(root, callback) {
  var skip = callback(root);
  if (!skip && root.isRexContainerLite) {
    var children = root.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      DepthFirstSearch(children[i], callback);
    }
  }
};
var BreadthFirstSearch = function(root, callback) {
  var queue = [root];
  while (queue.length > 0) {
    var current = queue.shift();
    var skip = callback(current);
    if (!skip && current.isRexContainerLite) {
      queue.push(...current.children);
    }
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Children.js
var ArrayUtils2 = Phaser.Utils.Array;
var Children_default = {
  getChildren(out2) {
    if (!out2) {
      out2 = this.children;
    } else {
      for (var i = 0, cnt = this.children.length; i < cnt; i++) {
        out2.push(this.children[i]);
      }
    }
    return out2;
  },
  getAllChildren(out2) {
    if (out2 === void 0) {
      out2 = [];
    }
    var root = this;
    BreadthFirstSearch(root, function(child) {
      if (child === root) {
        return;
      }
      out2.push(child);
    });
    return out2;
  },
  getAllVisibleChildren(out2) {
    if (out2 === void 0) {
      out2 = [];
    }
    var root = this;
    BreadthFirstSearch(root, function(child) {
      if (child === root) {
        return;
      }
      if (!child.visible) {
        return true;
      }
      out2.push(child);
    });
    return out2;
  },
  bfs(callback, root) {
    if (root === void 0) {
      root = this;
    }
    BreadthFirstSearch(root, callback);
    return this;
  },
  dfs(callback, root) {
    if (root === void 0) {
      root = this;
    }
    DepthFirstSearch(root, callback);
    return this;
  },
  contains(gameObject2) {
    var parent = GetParent(gameObject2);
    if (!parent) {
      return false;
    } else if (parent === this) {
      return true;
    } else {
      return this.contains(parent);
    }
  },
  getByName(name2, recursive) {
    if (!recursive) {
      return ArrayUtils2.GetFirst(this.children, "name", name2);
    } else {
      var queue = [this];
      var parent, child;
      while (queue.length) {
        parent = queue.shift();
        for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
          child = parent.children[i];
          if (child.name === name2) {
            return child;
          } else if (child.isRexContainerLite) {
            queue.push(child);
          }
        }
      }
      return null;
    }
  },
  getRandom(startIndex, length) {
    return ArrayUtils2.GetRandom(this.children, startIndex, length);
  },
  getFirst(property, value, startIndex, endIndex) {
    return ArrayUtils2.GetFirstElement(this.children, property, value, startIndex, endIndex);
  },
  getAll(property, value, startIndex, endIndex) {
    return ArrayUtils2.GetAll(this.children, property, value, startIndex, endIndex);
  },
  count(property, value, startIndex, endIndex) {
    return ArrayUtils2.CountAllMatching(this.children, property, value, startIndex, endIndex);
  },
  swap(child1, child2) {
    ArrayUtils2.Swap(this.children, child1, child2);
    return this;
  },
  setAll(property, value, startIndex, endIndex) {
    ArrayUtils2.SetAll(this.children, property, value, startIndex, endIndex);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Tween.js
var GetLocalStates = function(gameObjects) {
  var localStates = [];
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var gameObject2 = gameObjects[i];
    if (!gameObject2.hasOwnProperty("rexContainer")) {
      continue;
    }
    localStates.push(gameObject2.rexContainer);
  }
  return localStates;
};
var GetScene = function(gameObjects) {
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var scene = gameObjects[i].scene;
    if (scene) {
      return scene;
    }
  }
  return null;
};
var UpdateChild = function(tween, key2, target) {
  if (!target.parent) {
    tween.remove();
    return;
  }
  var parent = target.parent;
  var child = target.self;
  switch (key2) {
    case "x":
    case "y":
      parent.updateChildPosition(child);
      break;
    case "angle":
    case "rotation":
      parent.updateChildRotation(child);
      break;
    case "scaleX":
    case "scaleY":
    case "displayWidth":
    case "displayHeight":
      parent.updateChildScale(child);
      break;
    case "alpha":
      parent.updateChildAlpha(child);
      break;
    default:
      parent.updateChildPosition(child);
      parent.updateChildRotation(child);
      parent.updateChildScale(child);
      parent.updateChildAlpha(child);
      break;
  }
};
var Tween_default = {
  tweenChild(tweenConfig) {
    var targets = tweenConfig.targets;
    if (!Array.isArray(targets)) {
      targets = [targets];
    }
    var scene = this.scene || GetScene(targets);
    if (!scene) {
      return;
    }
    tweenConfig.targets = GetLocalStates(targets);
    var tween = scene.tweens.add(tweenConfig);
    tween.on("update", UpdateChild);
    return tween;
  },
  tweenSelf(tweenConfig) {
    tweenConfig.targets = [this];
    return this.tweenChild(tweenConfig);
  },
  createTweenChildConfig(tweenConfig) {
    var targets = tweenConfig.targets;
    if (targets) {
      if (!Array.isArray(targets)) {
        targets = [targets];
      }
      tweenConfig.targets = GetLocalStates(targets);
    }
    var onUpdate = tweenConfig.onUpdate;
    tweenConfig.onUpdate = function(tween, target) {
      if (onUpdate) {
        onUpdate(tween, target);
      }
      UpdateChild(tween, void 0, target);
    };
    return tweenConfig;
  },
  tween(tweenConfig) {
    var scene = this.scene;
    if (!tweenConfig.targets) {
      tweenConfig.targets = this;
    }
    return scene.tweens.add(tweenConfig);
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/system/IsContainerGameObject.js
var ContainerClass = Phaser.GameObjects.Container;
var IsContainerGameObject = function(gameObject2) {
  return gameObject2 instanceof ContainerClass;
};
var IsContainerGameObject_default = IsContainerGameObject;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/P3Container.js
var GetValidChildren = function(parent) {
  var children = parent.getAllChildren([parent]);
  children = children.filter(function(gameObject2) {
    return !!gameObject2.displayList || // At scene's displayList or at a layer
    !!gameObject2.parentContainer;
  });
  return children;
};
var AddToContainer = function(p3Container) {
  var gameObjects = GetValidChildren(this);
  if (gameObjects.indexOf(this) === -1) {
    gameObjects.push(this);
  }
  SortGameObjectsByDepth_default(gameObjects);
  p3Container.add(gameObjects);
};
var RemoveFromContainer = function(p3Container, descending, addToScene) {
  if (!this.scene) {
    return;
  }
  var gameObjects = GetValidChildren(this);
  SortGameObjectsByDepth_default(gameObjects, descending);
  p3Container.remove(gameObjects);
  if (addToScene) {
    gameObjects.forEach(function(gameObject2) {
      gameObject2.addToDisplayList();
    });
  }
};
var P3Container_default = {
  addToContainer(p3Container) {
    if (!IsContainerGameObject_default(p3Container)) {
      return this;
    }
    this._setParentContainerFlag = true;
    AddToContainer.call(this, p3Container);
    this._setParentContainerFlag = false;
    return this;
  },
  addToLayer(layer) {
    if (!IsLayerGameObject_default(layer)) {
      return this;
    }
    AddToContainer.call(this, layer);
    return this;
  },
  removeFromContainer() {
    if (!this.parentContainer) {
      return this;
    }
    this._setParentContainerFlag = true;
    RemoveFromContainer.call(this, this.parentContainer, true, false);
    this._setParentContainerFlag = false;
    return this;
  },
  removeFromLayer(addToScene) {
    if (addToScene === void 0) {
      addToScene = true;
    }
    if (!IsLayerGameObject_default(this.displayList)) {
      return this;
    }
    RemoveFromContainer.call(this, this.displayList, false, addToScene);
    return this;
  },
  getParentContainer() {
    if (this.parentContainer) {
      return this.parentContainer;
    }
    var parent = this.getParent();
    while (parent) {
      var p3Container = parent.parentContainer;
      if (p3Container) {
        return p3Container;
      }
      parent = parent.getParent();
    }
    return null;
  },
  addToParentContainer(gameObject2) {
    if (!gameObject2.displayList) {
      return this;
    }
    var p3Container = this.getParentContainer();
    if (!p3Container) {
      return this;
    }
    if (gameObject2.isRexContainerLite) {
      gameObject2.addToContainer(p3Container);
    } else {
      p3Container.add(gameObject2);
    }
    return this;
  },
  addToPatentLayer(gameObject2) {
    if (!gameObject2.displayList) {
      return this;
    }
    var parentLayer = this.displayList;
    if (parentLayer === gameObject2.displayList) {
      return this;
    }
    if (IsLayerGameObject_default(parentLayer)) {
      if (gameObject2.isRexContainerLite) {
        gameObject2.addToLayer(parentLayer);
      } else {
        parentLayer.add(gameObject2);
      }
    } else {
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/RenderLayer.js
var RenderLayer_default = {
  hasLayer() {
    return !!this.privateRenderLayer;
  },
  enableLayer() {
    if (this.hasLayer()) {
      return this;
    }
    var layer = this.scene.add.layer();
    this.moveDepthBelow(layer);
    this.addToLayer(layer);
    this.privateRenderLayer = layer;
    return this;
  },
  getLayer() {
    if (!this.hasLayer()) {
      this.enableLayer();
    }
    return this.privateRenderLayer;
  },
  getRenderLayer() {
    if (this.hasLayer()) {
      return this.privateRenderLayer;
    }
    var parent = this.getParent();
    while (parent) {
      var layer = parent.privateRenderLayer;
      if (layer) {
        return layer;
      }
      parent = parent.getParent();
    }
    return null;
  },
  // Internal method for adding child
  addToRenderLayer(gameObject2) {
    if (!gameObject2.displayList) {
      return this;
    }
    var layer = this.getRenderLayer();
    if (!layer) {
      return this;
    }
    if (layer === gameObject2.displayList) {
      return this;
    }
    if (gameObject2.isRexContainerLite) {
      gameObject2.addToLayer(layer);
    } else {
      layer.add(gameObject2);
    }
    var state = GetLocalState_default(gameObject2);
    state.layer = layer;
    return this;
  },
  // Internal method for removing child
  removeFromRenderLayer(gameObject2) {
    var state = GetLocalState_default(gameObject2);
    var layer = state.layer;
    if (!layer) {
      return this;
    }
    if (gameObject2.isRexContainerLite) {
      gameObject2.removeFromLayer(true);
    } else {
      layer.remove(gameObject2);
    }
    state.layer = null;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/GetBoundsOfGameObjects.js
var Rectangle6 = Phaser.Geom.Rectangle;
var Union = Phaser.Geom.Rectangle.Union;
var GetBoundsOfGameObjects = function(gameObjects, out2) {
  if (out2 === void 0) {
    out2 = new Rectangle6();
  } else if (out2 === true) {
    if (GlobRect2 === void 0) {
      GlobRect2 = new Rectangle6();
    }
    out2 = GlobRect2;
  }
  out2.setTo(0, 0, 0, 0);
  var gameObject2;
  var firstClone = true;
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    gameObject2 = gameObjects[i];
    if (!gameObject2.getBounds) {
      continue;
    }
    var boundsRect = GetBounds(gameObject2, true);
    if (firstClone) {
      out2.setTo(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
      firstClone = false;
    } else {
      Union(boundsRect, out2, out2);
    }
  }
  return out2;
};
var GlobRect2;
var GetBoundsOfGameObjects_default = GetBoundsOfGameObjects;

// node_modules/phaser3-rex-plugins/plugins/utils/rendertexture/Snapshot.js
var GetValue69 = Phaser.Utils.Objects.GetValue;
var Snapshot = function(config) {
  if (!config) {
    return;
  }
  var gameObjects = config.gameObjects;
  var renderTexture = config.renderTexture;
  var saveTexture = config.saveTexture;
  var x = GetValue69(config, "x", void 0);
  var y = GetValue69(config, "y", void 0);
  var width = GetValue69(config, "width", void 0);
  var height = GetValue69(config, "height", void 0);
  var originX = GetValue69(config, "originX", 0);
  var originY = GetValue69(config, "originY", 0);
  var padding = GetValue69(config, "padding", 0);
  var scrollX, scrollY;
  if (width === void 0 || height === void 0 || x === void 0 || y === void 0) {
    var bounds = GetBoundsOfGameObjects_default(gameObjects, true);
    var isCenterOrigin = x !== void 0 && y !== void 0;
    if (isCenterOrigin) {
      width = Math.max(x - bounds.left, bounds.right - x) * 2;
      height = Math.max(y - bounds.top, bounds.bottom - y) * 2;
      originX = 0.5;
      originY = 0.5;
    } else {
      x = bounds.x;
      y = bounds.y;
      width = bounds.width;
      height = bounds.height;
      originX = 0;
      originY = 0;
    }
    scrollX = bounds.x;
    scrollY = bounds.y;
  } else {
    scrollX = x + (0 - originX) * width;
    scrollY = y + (0 - originY) * height;
  }
  scrollX -= padding;
  scrollY -= padding;
  width += padding * 2;
  height += padding * 2;
  var scene = gameObjects[0].scene;
  var textureManager = scene.sys.textures;
  if (saveTexture && !renderTexture) {
    renderTexture = textureManager.addDynamicTexture(saveTexture, width, height);
  }
  if (!renderTexture) {
    renderTexture = scene.add.renderTexture(0, 0, width, height);
  }
  if (renderTexture.setPosition) {
    renderTexture.setPosition(x, y);
  }
  if (renderTexture.width !== width || renderTexture.height !== height) {
    renderTexture.setSize(width, height);
  }
  if (renderTexture.setOrigin) {
    renderTexture.setOrigin(originX, originY);
  }
  renderTexture.camera.setScroll(scrollX, scrollY);
  gameObjects = SortGameObjectsByDepth_default(Clone_default(gameObjects));
  renderTexture.draw(gameObjects);
  if (saveTexture) {
    if (IsGameObject_default(renderTexture)) {
      renderTexture.saveTexture(saveTexture);
    } else if (renderTexture.key !== saveTexture) {
      textureManager.renameTexture(renderTexture.key, key);
    }
  }
  return renderTexture;
};
var Snapshot_default = Snapshot;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/RenderTexture.js
var RenderTexture_default = {
  snapshot(config) {
    var scaleXSave = this.scaleX;
    var scaleYSave = this.scaleY;
    var scale1 = scaleXSave === 1 && scaleYSave === 1;
    if (!scale1) {
      this.setScale(1);
    }
    if (config === void 0) {
      config = {};
    }
    config.gameObjects = this.getAllVisibleChildren();
    config.x = this.x;
    config.y = this.y;
    config.originX = this.originX;
    config.originY = this.originY;
    var rt = Snapshot_default(config);
    var isValidRT = !!rt.scene;
    if (!scale1) {
      this.setScale(scaleXSave, scaleYSave);
      if (isValidRT) {
        rt.setScale(scaleXSave, scaleYSave);
      }
    }
    return isValidRT ? rt : this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/DrawBounds.js
var GetValue70 = Phaser.Utils.Objects.GetValue;
var DrawBounds2 = function(graphics, config) {
  var drawContainer = GetValue70(config, "drawContainer", true);
  var gameObjects = GetValue70(config, "children");
  if (gameObjects === void 0) {
    gameObjects = this.getAllVisibleChildren([this]);
  }
  if (!drawContainer) {
    gameObjects = gameObjects.filter(function(gameObject2) {
      return !gameObject2.isRexContainerLite;
    });
  }
  DrawBounds_default(gameObjects, graphics, config);
  return this;
};
var DrawBounds_default2 = DrawBounds2;

// node_modules/phaser3-rex-plugins/plugins/utils/origin/ChangeOrigin.js
var RotateAround5 = Phaser.Math.RotateAround;
var ChangeOrigin = function(gameObject2, originX, originY) {
  if (originY === void 0) {
    originY = originX;
  }
  var deltaXY = {
    x: (originX - gameObject2.originX) * gameObject2.displayWidth,
    y: (originY - gameObject2.originY) * gameObject2.displayHeight
  };
  RotateAround5(deltaXY, 0, 0, gameObject2.rotation);
  gameObject2.originX = originX;
  gameObject2.originY = originY;
  gameObject2.x = gameObject2.x + deltaXY.x;
  gameObject2.y = gameObject2.y + deltaXY.y;
  return gameObject2;
};
var ChangeOrigin_default = ChangeOrigin;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ChangeOrigin.js
var ChangeOrigin2 = function(originX, originY) {
  this.syncChildrenEnable = false;
  ChangeOrigin_default(this, originX, originY);
  this.syncChildrenEnable = true;
  var children = this.getAllChildren();
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    this.resetChildPositionState(children[i]);
  }
  return this;
};
var ChangeOrigin_default2 = ChangeOrigin2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/Methods.js
var methods11 = {
  changeOrigin: ChangeOrigin_default2,
  drawBounds: DrawBounds_default2
};
Object.assign(
  methods11,
  Parent_default,
  AddChild_default3,
  RemoveChild_default3,
  ChildState_default,
  Transform_default,
  Position_default,
  Rotation_default,
  Scale_default2,
  Visible_default,
  Alpha_default,
  Active_default,
  ScrollFactor_default,
  CameraFilter_default,
  Mask_default,
  Depth_default,
  Children_default,
  Tween_default,
  P3Container_default,
  RenderLayer_default,
  RenderTexture_default
);
var Methods_default16 = methods11;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/ContainerLite.js
var ContainerLite = class extends Base_default3 {
  constructor(scene, x, y, width, height, children) {
    if (Array.isArray(width)) {
      children = width;
      width = void 0;
      height = void 0;
    }
    super(scene, x, y, width, height);
    this.type = "rexContainerLite";
    this.isRexContainerLite = true;
    this.syncChildrenEnable = true;
    this._active = true;
    this._mask = null;
    this._scrollFactorX = 1;
    this._scrollFactorY = 1;
    this._cameraFilter = 0;
    this.privateRenderLayer = void 0;
    if (children) {
      this.add(children);
    }
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.syncChildrenEnable = false;
    super.destroy(fromScene);
    if (this.privateRenderLayer && this.privateRenderLayer.scene) {
      this.privateRenderLayer.list.length = 0;
      this.privateRenderLayer.destroy();
    }
  }
  resize(width, height) {
    this.setSize(width, height);
    return this;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x === value) {
      return;
    }
    this._x = value;
    this.syncPosition();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y === value) {
      return;
    }
    this._y = value;
    this.syncPosition();
  }
  // Override
  get rotation() {
    return super.rotation;
  }
  set rotation(value) {
    if (this.rotation === value) {
      return;
    }
    super.rotation = value;
    this.syncPosition();
  }
  // Override
  get scaleX() {
    return super.scaleX;
  }
  set scaleX(value) {
    if (this.scaleX === value) {
      return;
    }
    super.scaleX = value;
    this.syncPosition();
  }
  // Override
  get scaleY() {
    return super.scaleY;
  }
  set scaleY(value) {
    if (this.scaleY === value) {
      return;
    }
    super.scaleY = value;
    this.syncPosition();
  }
  // Override
  get scale() {
    return super.scale;
  }
  set scale(value) {
    if (this.scale === value) {
      return;
    }
    super.scale = value;
    this.syncPosition();
  }
  // Override
  get visible() {
    return super.visible;
  }
  set visible(value) {
    if (super.visible === value) {
      return;
    }
    super.visible = value;
    this.syncVisible();
  }
  // Override
  get alpha() {
    return super.alpha;
  }
  set alpha(value) {
    if (super.alpha === value) {
      return;
    }
    super.alpha = value;
    this.syncAlpha();
  }
  // Override
  get active() {
    return this._active;
  }
  set active(value) {
    if (this._active === value) {
      return;
    }
    this._active = value;
    this.syncActive();
  }
  // Override
  get mask() {
    return this._mask;
  }
  set mask(mask) {
    if (this._mask === mask) {
      return;
    }
    this._mask = mask;
    this.syncMask();
  }
  // Override
  get scrollFactorX() {
    return this._scrollFactorX;
  }
  set scrollFactorX(value) {
    if (this._scrollFactorX === value) {
      return;
    }
    this._scrollFactorX = value;
    this.syncScrollFactor();
  }
  get scrollFactorY() {
    return this._scrollFactorY;
  }
  set scrollFactorY(value) {
    if (this._scrollFactorY === value) {
      return;
    }
    this._scrollFactorY = value;
    this.syncScrollFactor();
  }
  get cameraFilter() {
    return this._cameraFilter;
  }
  set cameraFilter(value) {
    if (this._cameraFilter === value) {
      return;
    }
    this._cameraFilter = value;
    this.syncCameraFilter();
  }
  // Compatiable with container plugin
  get list() {
    return this.children;
  }
  static GetParent(child) {
    return GetParent(child);
  }
  // For p3-container
  get parentContainer() {
    return this._parentContainer;
  }
  set parentContainer(value) {
    if (!this._parentContainer && !value) {
      this._parentContainer = value;
      return;
    }
    if (this.setParentContainerFlag) {
      this._parentContainer = value;
      return;
    }
    if (this._parentContainer && !value) {
      this.removeFromContainer();
      this._parentContainer = value;
    } else if (value) {
      this._parentContainer = value;
      this.addToContainer(value);
    } else {
      this._parentContainer = value;
    }
  }
  get setParentContainerFlag() {
    if (this._setParentContainerFlag) {
      return true;
    }
    var parent = GetParent(this);
    return parent ? parent.setParentContainerFlag : false;
  }
};
Object.assign(
  ContainerLite.prototype,
  Methods_default16
);
var ContainerLite_default = ContainerLite;

// node_modules/phaser3-rex-plugins/plugins/containerlite.js
var containerlite_default = ContainerLite_default;

// node_modules/phaser3-rex-plugins/templates/ui/container/Container.js
var Container_default = containerlite_default;

// node_modules/phaser3-rex-plugins/templates/ui/utils/GetSizerConfig.js
var GetSizerConfig = function(gameObject2) {
  if (!gameObject2.hasOwnProperty("rexSizer")) {
    gameObject2.rexSizer = {};
  }
  return gameObject2.rexSizer;
};
var GetSizerConfig_default = GetSizerConfig;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetSizerConfig.js
function GetSizerConfig_default2(gameObject2) {
  if (gameObject2 === void 0) {
    gameObject2 = this;
  }
  return GetSizerConfig_default(gameObject2);
}

// node_modules/phaser3-rex-plugins/templates/ui/utils/GetChildPrevState.js
var GetChildPrevState = function(child) {
  var childConfig = GetSizerConfig_default(child);
  if (!childConfig.hasOwnProperty("prevState")) {
    childConfig.prevState = {};
  }
  return childConfig.prevState;
};
var GetChildPrevState_default = GetChildPrevState;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/PushIntoBounds.js
var PushIntoBounds = function(bounds) {
  if (bounds === void 0) {
    bounds = GetViewport_default(this.scene);
  }
  this.left = Math.max(this.left, bounds.left);
  this.right = Math.min(this.right, bounds.right);
  this.top = Math.max(this.top, bounds.top);
  this.bottom = Math.min(this.bottom, bounds.bottom);
  return this;
};
var PushIntoBounds_default = PushIntoBounds;

// node_modules/phaser3-rex-plugins/plugins/utils/actions/AlignConst.js
var ALIGN = Phaser.Display.Align;
var AlignConst_default = {
  center: ALIGN.CENTER,
  left: ALIGN.LEFT_CENTER,
  right: ALIGN.RIGHT_CENTER,
  top: ALIGN.TOP_CENTER,
  bottom: ALIGN.BOTTOM_CENTER,
  "left-top": ALIGN.TOP_LEFT,
  "top-left": ALIGN.TOP_LEFT,
  "left-center": ALIGN.LEFT_CENTER,
  "center-left": ALIGN.LEFT_CENTER,
  "left-bottom": ALIGN.BOTTOM_LEFT,
  "bottom-left": ALIGN.BOTTOM_LEFT,
  "center-top": ALIGN.TOP_CENTER,
  "top-center": ALIGN.TOP_CENTER,
  "center-center": ALIGN.CENTER,
  "center-bottom": ALIGN.BOTTOM_CENTER,
  "bottom-center": ALIGN.BOTTOM_CENTER,
  "right-top": ALIGN.TOP_RIGHT,
  "top-right": ALIGN.TOP_RIGHT,
  "right-center": ALIGN.RIGHT_CENTER,
  "center-right": ALIGN.RIGHT_CENTER,
  "right-bottom": ALIGN.BOTTOM_RIGHT,
  "bottom-right": ALIGN.BOTTOM_RIGHT
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/AlignConst.js
var AlignConst_default2 = AlignConst_default;

// node_modules/phaser3-rex-plugins/plugins/utils/actions/GlobZone.js
var globZone = new Phaser.GameObjects.Zone({
  sys: {
    queueDepthSort: NOOP_default,
    events: {
      once: NOOP_default
    }
  }
}, 0, 0, 1, 1);
globZone.setOrigin(0);
var GlobZone_default = globZone;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/const.js
var ALIGN_CONST = {
  /**
  * A constant representing a top-left alignment or position.
  * @constant
  * @name Phaser.Display.Align.TOP_LEFT
  * @since 3.0.0
  * @type {integer}
  */
  TOP_LEFT: 0,
  /**
  * A constant representing a top-center alignment or position.
  * @constant
  * @name Phaser.Display.Align.TOP_CENTER
  * @since 3.0.0
  * @type {integer}
  */
  TOP_CENTER: 1,
  /**
  * A constant representing a top-right alignment or position.
  * @constant
  * @name Phaser.Display.Align.TOP_RIGHT
  * @since 3.0.0
  * @type {integer}
  */
  TOP_RIGHT: 2,
  /**
  * A constant representing a left-top alignment or position.
  * @constant
  * @name Phaser.Display.Align.LEFT_TOP
  * @since 3.0.0
  * @type {integer}
  */
  LEFT_TOP: 3,
  /**
  * A constant representing a left-center alignment or position.
  * @constant
  * @name Phaser.Display.Align.LEFT_CENTER
  * @since 3.0.0
  * @type {integer}
  */
  LEFT_CENTER: 4,
  /**
  * A constant representing a left-bottom alignment or position.
  * @constant
  * @name Phaser.Display.Align.LEFT_BOTTOM
  * @since 3.0.0
  * @type {integer}
  */
  LEFT_BOTTOM: 5,
  /**
  * A constant representing a center alignment or position.
  * @constant
  * @name Phaser.Display.Align.CENTER
  * @since 3.0.0
  * @type {integer}
  */
  CENTER: 6,
  /**
  * A constant representing a right-top alignment or position.
  * @constant
  * @name Phaser.Display.Align.RIGHT_TOP
  * @since 3.0.0
  * @type {integer}
  */
  RIGHT_TOP: 7,
  /**
  * A constant representing a right-center alignment or position.
  * @constant
  * @name Phaser.Display.Align.RIGHT_CENTER
  * @since 3.0.0
  * @type {integer}
  */
  RIGHT_CENTER: 8,
  /**
  * A constant representing a right-bottom alignment or position.
  * @constant
  * @name Phaser.Display.Align.RIGHT_BOTTOM
  * @since 3.0.0
  * @type {integer}
  */
  RIGHT_BOTTOM: 9,
  /**
  * A constant representing a bottom-left alignment or position.
  * @constant
  * @name Phaser.Display.Align.BOTTOM_LEFT
  * @since 3.0.0
  * @type {integer}
  */
  BOTTOM_LEFT: 10,
  /**
  * A constant representing a bottom-center alignment or position.
  * @constant
  * @name Phaser.Display.Align.BOTTOM_CENTER
  * @since 3.0.0
  * @type {integer}
  */
  BOTTOM_CENTER: 11,
  /**
  * A constant representing a bottom-right alignment or position.
  * @constant
  * @name Phaser.Display.Align.BOTTOM_RIGHT
  * @since 3.0.0
  * @type {integer}
  */
  BOTTOM_RIGHT: 12
};
var const_default2 = ALIGN_CONST;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/GetBottom.js
var GetBottom = function(gameObject2) {
  var height = GetDisplayHeight(gameObject2);
  return gameObject2.y + height - height * gameObject2.originY;
};
var GetBottom_default = GetBottom;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/GetCenterX.js
var GetCenterX = function(gameObject2) {
  var width = GetDisplayWidth(gameObject2);
  return gameObject2.x - width * gameObject2.originX + width * 0.5;
};
var GetCenterX_default = GetCenterX;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/SetBottom.js
var SetBottom = function(gameObject2, value) {
  var height = GetDisplayHeight(gameObject2);
  gameObject2.y = value - height + height * gameObject2.originY;
  return gameObject2;
};
var SetBottom_default = SetBottom;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/SetCenterX.js
var SetCenterX = function(gameObject2, x) {
  var width = GetDisplayWidth(gameObject2);
  var offsetX = width * gameObject2.originX;
  gameObject2.x = x + offsetX - width * 0.5;
  return gameObject2;
};
var SetCenterX_default = SetCenterX;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/BottomCenter.js
var BottomCenter = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetCenterX_default(gameObject2, GetCenterX_default(alignIn) + offsetX);
  SetBottom_default(gameObject2, GetBottom_default(alignIn) + offsetY);
  return gameObject2;
};
var BottomCenter_default = BottomCenter;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/GetLeft.js
var GetLeft = function(gameObject2) {
  var width = GetDisplayWidth(gameObject2);
  return gameObject2.x - width * gameObject2.originX;
};
var GetLeft_default = GetLeft;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/SetLeft.js
var SetLeft = function(gameObject2, value) {
  var width = GetDisplayWidth(gameObject2);
  gameObject2.x = value + width * gameObject2.originX;
  return gameObject2;
};
var SetLeft_default = SetLeft;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/BottomLeft.js
var BottomLeft = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetLeft_default(gameObject2, GetLeft_default(alignIn) - offsetX);
  SetBottom_default(gameObject2, GetBottom_default(alignIn) + offsetY);
  return gameObject2;
};
var BottomLeft_default = BottomLeft;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/GetRight.js
var GetRight = function(gameObject2) {
  var width = GetDisplayWidth(gameObject2);
  return gameObject2.x + width - width * gameObject2.originX;
};
var GetRight_default = GetRight;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/SetRight.js
var SetRight = function(gameObject2, value) {
  var width = GetDisplayWidth(gameObject2);
  gameObject2.x = value - width + width * gameObject2.originX;
  return gameObject2;
};
var SetRight_default = SetRight;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/BottomRight.js
var BottomRight = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetRight_default(gameObject2, GetRight_default(alignIn) + offsetX);
  SetBottom_default(gameObject2, GetBottom_default(alignIn) + offsetY);
  return gameObject2;
};
var BottomRight_default = BottomRight;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/SetCenterY.js
var SetCenterY = function(gameObject2, y) {
  var height = GetDisplayHeight(gameObject2);
  var offsetY = height * gameObject2.originY;
  gameObject2.y = y + offsetY - height * 0.5;
  return gameObject2;
};
var SetCenterY_default = SetCenterY;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/CenterOn.js
var CenterOn = function(gameObject2, x, y) {
  SetCenterX_default(gameObject2, x);
  return SetCenterY_default(gameObject2, y);
};
var CenterOn_default = CenterOn;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/GetCenterY.js
var GetCenterY = function(gameObject2) {
  var height = GetDisplayHeight(gameObject2);
  return gameObject2.y - height * gameObject2.originY + height * 0.5;
};
var GetCenterY_default = GetCenterY;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/Center.js
var Center = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  CenterOn_default(gameObject2, GetCenterX_default(alignIn) + offsetX, GetCenterY_default(alignIn) + offsetY);
  return gameObject2;
};
var Center_default = Center;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/LeftCenter.js
var LeftCenter = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetLeft_default(gameObject2, GetLeft_default(alignIn) - offsetX);
  SetCenterY_default(gameObject2, GetCenterY_default(alignIn) + offsetY);
  return gameObject2;
};
var LeftCenter_default = LeftCenter;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/RightCenter.js
var RightCenter = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetRight_default(gameObject2, GetRight_default(alignIn) + offsetX);
  SetCenterY_default(gameObject2, GetCenterY_default(alignIn) + offsetY);
  return gameObject2;
};
var RightCenter_default = RightCenter;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/GetTop.js
var GetTop = function(gameObject2) {
  var height = GetDisplayHeight(gameObject2);
  return gameObject2.y - height * gameObject2.originY;
};
var GetTop_default = GetTop;

// node_modules/phaser3-rex-plugins/plugins/utils/align/bounds/SetTop.js
var SetTop = function(gameObject2, value) {
  var height = GetDisplayHeight(gameObject2);
  gameObject2.y = value + height * gameObject2.originY;
  return gameObject2;
};
var SetTop_default = SetTop;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/TopCenter.js
var TopCenter = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetCenterX_default(gameObject2, GetCenterX_default(alignIn) + offsetX);
  SetTop_default(gameObject2, GetTop_default(alignIn) - offsetY);
  return gameObject2;
};
var TopCenter_default = TopCenter;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/TopLeft.js
var TopLeft = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetLeft_default(gameObject2, GetLeft_default(alignIn) - offsetX);
  SetTop_default(gameObject2, GetTop_default(alignIn) - offsetY);
  return gameObject2;
};
var TopLeft_default = TopLeft;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/TopRight.js
var TopRight = function(gameObject2, alignIn, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  SetRight_default(gameObject2, GetRight_default(alignIn) + offsetX);
  SetTop_default(gameObject2, GetTop_default(alignIn) - offsetY);
  return gameObject2;
};
var TopRight_default = TopRight;

// node_modules/phaser3-rex-plugins/plugins/utils/align/align/in/QuickSet.js
var AlignInMap = [];
AlignInMap[const_default2.BOTTOM_CENTER] = BottomCenter_default;
AlignInMap[const_default2.BOTTOM_LEFT] = BottomLeft_default;
AlignInMap[const_default2.BOTTOM_RIGHT] = BottomRight_default;
AlignInMap[const_default2.CENTER] = Center_default;
AlignInMap[const_default2.LEFT_CENTER] = LeftCenter_default;
AlignInMap[const_default2.RIGHT_CENTER] = RightCenter_default;
AlignInMap[const_default2.TOP_CENTER] = TopCenter_default;
AlignInMap[const_default2.TOP_LEFT] = TopLeft_default;
AlignInMap[const_default2.TOP_RIGHT] = TopRight_default;
var QuickSet = function(child, alignIn, position, offsetX, offsetY) {
  return AlignInMap[position](child, alignIn, offsetX, offsetY);
};
var QuickSet_default = QuickSet;

// node_modules/phaser3-rex-plugins/plugins/utils/actions/AlignIn.js
var AlignIn = function(child, x, y, width, height, align) {
  GlobZone_default.setPosition(x, y).setSize(width, height);
  QuickSet_default(child, GlobZone_default, align);
};
var AlignIn_default = AlignIn;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/DrawBounds.js
var GetValue71 = Phaser.Utils.Objects.GetValue;
var Group = Phaser.GameObjects.Group;
var P3Container2 = Phaser.GameObjects.Container;
var DrawBounds3 = function(graphics, config) {
  var scene = graphics.scene;
  var color, lineWidth;
  var createTextCallback, createTextCallbackScope, textAlign;
  if (typeof config === "number") {
    color = config;
  } else {
    color = GetValue71(config, "color");
    lineWidth = GetValue71(config, "lineWidth");
    var nameTextConfig = GetValue71(config, "name", false);
    if (nameTextConfig) {
      createTextCallback = GetValue71(nameTextConfig, "createTextCallback", DefaultCreateTextCallback);
      createTextCallbackScope = GetValue71(nameTextConfig, "createTextCallbackScope", void 0);
      textAlign = GetValue71(nameTextConfig, "align", "left-top");
      if (typeof textAlign === "string") {
        textAlign = AlignConst_default2[textAlign];
      }
    }
  }
  if (color === void 0) {
    color = 16777215;
  }
  if (lineWidth === void 0) {
    lineWidth = 1;
  }
  if (createTextCallback && !graphics.children) {
    graphics.children = new Group(scene);
    graphics.once("destroy", function(graphics2, fromScene) {
      graphics2.children.destroy(!fromScene);
      graphics2.children = void 0;
    });
    var graphicsClear = graphics.clear.bind(graphics);
    graphics.clear = function() {
      graphicsClear();
      graphics.children.clear(false, true);
    };
  }
  var children = this.getAllShownChildren([this]);
  GetP3ContainerChildren(children, children);
  var child;
  var nameText;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child.getBounds || child.width !== void 0 && child.height !== void 0) {
      GlobRect3 = GetBounds(child, GlobRect3);
    } else {
      continue;
    }
    if (color != null) {
      graphics.lineStyle(lineWidth, color).strokeRectShape(GlobRect3);
    }
    if (child.name && createTextCallback) {
      if (createTextCallbackScope) {
        nameText = createTextCallback.call(createTextCallbackScope, scene);
      } else {
        nameText = createTextCallback(scene);
      }
      if (nameText) {
        nameText.setText(child.name);
        graphics.children.add(nameText);
        AlignIn_default(nameText, GlobRect3.x, GlobRect3.y, GlobRect3.width, GlobRect3.height, textAlign);
      }
    }
  }
  return this;
};
var DefaultCreateTextCallback = function(scene, child, childBoundsRect) {
  return scene.add.text(0, 0, "");
};
var GetP3ContainerChildren = function(gameObjects, output) {
  if (!Array.isArray(gameObjects)) {
    gameObjects = [gameObjects];
  }
  if (output === void 0) {
    output = [];
  }
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var gameObject2 = gameObjects[i];
    if (gameObject2 instanceof P3Container2) {
      output.push(...gameObject2.list);
      GetP3ContainerChildren(gameObject2.list, output);
    }
  }
  return output;
};
var GlobRect3 = void 0;
var DrawBounds_default3 = DrawBounds3;

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/GetBoundsConfig.js
var GetValue72 = Phaser.Utils.Objects.GetValue;
var GetBoundsConfig2 = function(config, out2) {
  if (config === void 0) {
    config = 0;
  }
  if (out2 === void 0) {
    out2 = {};
  }
  if (typeof config === "number") {
    out2.left = config;
    out2.right = config;
    out2.top = config;
    out2.bottom = config;
  } else {
    out2.left = GetValue72(config, "left", 0);
    out2.right = GetValue72(config, "right", 0);
    out2.top = GetValue72(config, "top", 0);
    out2.bottom = GetValue72(config, "bottom", 0);
  }
  return out2;
};
var GetBoundsConfig_default = GetBoundsConfig2;

// node_modules/phaser3-rex-plugins/templates/ui/utils/GetBoundsConfig.js
var GetBoundsConfig_default2 = GetBoundsConfig_default;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/utils/AddChild.js
var ContainerAdd = Container_default.prototype.add;
var AddChild3 = function(gameObject2) {
  ContainerAdd.call(this, gameObject2);
  if (this.sizerEventsEnable) {
    gameObject2.emit("sizer.add", gameObject2, this);
    this.emit("add", gameObject2, this);
  }
  return this;
};
var AddChild_default4 = AddChild3;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/AddChildMethods.js
var AddChildMethods_default = {
  addBackground(gameObject2, paddingConfig, childKey) {
    if (this.backgroundChildren === void 0) {
      this.backgroundChildren = [];
    }
    if (typeof paddingConfig === "string") {
      childKey = paddingConfig;
      paddingConfig = void 0;
    }
    if (paddingConfig === void 0) {
      paddingConfig = 0;
    }
    AddChild_default4.call(this, gameObject2);
    this.backgroundChildren.push(gameObject2);
    var config = this.getSizerConfig(gameObject2);
    config.padding = GetBoundsConfig_default2(paddingConfig);
    if (childKey !== void 0) {
      this.addChildrenMap(childKey, gameObject2);
    }
    return this;
  },
  isBackground(gameObject2) {
    if (this.backgroundChildren === void 0) {
      return false;
    }
    return this.backgroundChildren.indexOf(gameObject2) !== -1;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetParentSizerMethods.js
var GetParent2 = function(gameObject2, name2) {
  var parent = null;
  if (name2 === void 0) {
    if (gameObject2.hasOwnProperty("rexContainer")) {
      parent = gameObject2.rexContainer.parent;
      if (parent) {
        if (!parent.isRexSizer) {
          parent = GetParent2(parent);
        }
      } else {
        parent = null;
      }
    }
  } else {
    parent = GetParent2(gameObject2);
    while (parent) {
      if (parent.name === name2) {
        break;
      }
      parent = GetParent2(parent);
    }
  }
  return parent;
};
var GetTopmostParent2 = function(gameObject2) {
  var parent = GetParent2(gameObject2);
  while (parent) {
    gameObject2 = parent;
    parent = GetParent2(parent);
  }
  return gameObject2;
};
var GetParentSizerMethods_default = {
  getParentSizer(gameObject2, name2) {
    if (typeof gameObject2 === "string") {
      name2 = gameObject2;
      gameObject2 = void 0;
    }
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    return GetParent2(gameObject2, name2);
  },
  getTopmostSizer(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    return GetTopmostParent2(gameObject2);
  },
  hasParentSizer(parentGameObject, gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    var parent = GetParent2(gameObject2);
    while (parent) {
      if (parent === parentGameObject) {
        return true;
      }
      parent = GetParent2(parent);
    }
    return false;
  },
  hasChild(child, gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    return this.hasParentSizer(gameObject2, child);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/utils/RemoveChild.js
var RemoveItem10 = Phaser.Utils.Array.Remove;
var ContainerRemove = Container_default.prototype.remove;
var GetParentSizer = GetParentSizerMethods_default.getParentSizer;
var RemoveChild3 = function(gameObject2, destroyChild) {
  var parent = GetParentSizer(gameObject2);
  while (parent) {
    if (parent.removeChildCallback) {
      parent.removeChildCallback(gameObject2, destroyChild);
    }
    parent = GetParentSizer(parent);
  }
  if (this.isBackground(gameObject2)) {
    RemoveItem10(this.backgroundChildren, gameObject2);
  }
  ContainerRemove.call(this, gameObject2, destroyChild);
  if (!destroyChild && this.sizerEventsEnable) {
    gameObject2.emit("sizer.remove", gameObject2, this);
    this.emit("remove", gameObject2, this);
  }
  return this;
};
var RemoveChild_default4 = RemoveChild3;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/RemoveChildMethods.js
var RemoveItem11 = Phaser.Utils.Array.Remove;
var GetParentSizer2 = GetParentSizerMethods_default.getParentSizer;
var RemoveChildMethods_default = {
  removeFromParentSizer() {
    var parent = GetParentSizer2(gameObject);
    if (parent) {
      parent.remove(this);
    }
    return this;
  },
  removeBackground(gameObject2, destroyChild) {
    if (this.backgroundChildren === void 0) {
      return this;
    }
    if (this.getParentSizer(gameObject2) !== this) {
      return this;
    }
    RemoveItem11(this.backgroundChildren, gameObject2);
    RemoveChild_default4.call(this, gameObject2, destroyChild);
    return this;
  },
  removeAllBackgrounds(destroyChild) {
    if (this.backgroundChildren === void 0) {
      return this;
    }
    for (var i = this.backgroundChildren.length - 1; i >= 0; i--) {
      this.remove(this.backgroundChildren[i], destroyChild);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/AddChildrenMap.js
var AddChildrenMap = function(key2, gameObject2) {
  if (typeof key2 === "string") {
    this.childrenMap[key2] = gameObject2;
  } else {
    var config = key2;
    for (key2 in config) {
      this.childrenMap[key2] = config[key2];
    }
  }
  return this;
};
var AddChildrenMap_default = AddChildrenMap;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/RemoveChildrenMap.js
var RemoveChildrenMap = function(key2) {
  if (typeof key2 === "object") {
    var gameObject2 = key2;
    for (var key2 in this.childrenMap) {
      if (this.childrenMap[key2] === gameObject2) {
        delete this.childrenMap[key2];
        return this;
      }
    }
  }
  delete this.childrenMap[key2];
  return this;
};
var RemoveChildrenMap_default = RemoveChildrenMap;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetElement.js
var GetElement = function(mapNameList, recursive) {
  if (typeof mapNameList === "string") {
    mapNameList = mapNameList.split(".");
  }
  if (mapNameList.length === 0) {
    return void 0;
  }
  if (recursive === void 0) {
    recursive = false;
  }
  var name2 = mapNameList.shift(), element = null;
  if (name2.charAt(0) === "#") {
    name2 = name2.substring(1);
    element = this.getByName(name2, recursive);
  } else if (mapNameList.length === 0 && recursive) {
    var childrenMap = this.childrenMap;
    if (childrenMap) {
      var queue = [childrenMap];
      var child;
      while (queue.length) {
        childrenMap = queue.shift();
        for (var key2 in childrenMap) {
          child = childrenMap[key2];
          if (key2 === name2) {
            element = child;
            break;
          } else if (child && typeof child === "object" && child.childrenMap) {
            queue.push(child.childrenMap);
          }
        }
        if (element) {
          break;
        }
      }
    }
  } else if (name2.indexOf("[") === -1) {
    if (this.childrenMap) {
      element = this.childrenMap[name2];
    }
  } else {
    var innerMatch = name2.match(RE_OBJ);
    if (innerMatch != null) {
      if (this.childrenMap) {
        var elements = this.childrenMap[innerMatch[1]];
        if (elements) {
          element = elements[innerMatch[2]];
        }
      }
    }
  }
  if (mapNameList.length === 0) {
    return element;
  } else if (element && element.childrenMap) {
    return element.getElement(mapNameList);
  } else {
    return null;
  }
};
var RE_OBJ = /(\S+)\[(\d+)\]/i;
var GetElement_default = GetElement;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetChildIndex.js
var GetChildIndex = function(child) {
  if (Array.isArray(this.sizerChildren)) {
    var index = this.sizerChildren.indexOf(child);
    if (index === -1) {
      index = null;
    }
    return index;
  } else {
    if (this.getParentSizer(child) !== this) {
      return null;
    }
    for (var key2 in this.sizerChildren) {
      if (this.sizerChildre[key2] === child) {
        return key2;
      }
    }
    return null;
  }
};
var GetChildIndex_default = GetChildIndex;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/PaddingMethods.js
var PaddingMethods_default = {
  getInnerPadding(key2) {
    return GetPadding(this.space, key2);
  },
  setInnerPadding(key2, value) {
    SetPadding(this.space, key2, value);
    return this;
  },
  getOuterPadding(key2) {
    return GetPadding(this.getSizerConfig(this).padding, key2);
  },
  setOuterPadding(key2, value) {
    SetPadding(this.getSizerConfig(this).padding, key2, value);
    return this;
  },
  getChildOuterPadding(child, key2) {
    if (typeof child === "string") {
      child = this.getElement(child);
    }
    return GetPadding(this.getSizerConfig(child).padding, key2);
  },
  setChildOuterPadding(child, key2, value) {
    if (typeof child === "string") {
      child = this.getElement(child);
    }
    SetPadding(this.getSizerConfig(child).padding, key2, value);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ResolveWidth.js
var ResolveWidth = function(width) {
  var childrenWidth = this.childrenWidth;
  if (childrenWidth === void 0) {
    return void 0;
  }
  var minWidth = this.minWidth !== void 0 ? this.minWidth * this.scaleX : 0;
  if (width === void 0) {
    width = Math.max(minWidth, childrenWidth);
    if (this.layoutWarnEnable) {
      if (minWidth > 0 && childrenWidth > minWidth) {
        console.warn(`Layout width warn: ${this.constructor.name}'s minWidth (${minWidth}) < childrenWidth (${childrenWidth})`);
      }
    }
  } else {
    if (this.layoutWarnEnable) {
      if (minWidth > width || childrenWidth > width) {
        console.warn(`Layout width warn: ${this.constructor.name}'s minWidth (${minWidth}) or childrenWidth (${childrenWidth} > targetWidth ${width})`);
      }
    }
  }
  return width;
};
var ResolveWidth_default = ResolveWidth;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/HasWidthWrap.js
var HasWidthWrap = function() {
  var child;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
      continue;
    }
    if (!child.hasWidthWrap || child.hasWidthWrap()) {
      return true;
    }
  }
  return false;
};
var HasWidthWrap_default = HasWidthWrap;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ResolveChildrenWidth.js
var ResolveChildrenWidth = function(parentWidth) {
  var child, expandedChildWidth, childWidth;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (child && child.isRexSizer && !child.ignoreLayout) {
      expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
      childWidth = child.resolveWidth(expandedChildWidth);
      if (childWidth === void 0) {
        childWidth = expandedChildWidth;
      }
      child.resolveChildrenWidth(childWidth);
    }
  }
};
var ResolveChildrenWidth_default = ResolveChildrenWidth;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/RunWidthWrap.js
var RunWidthWrap = function(parentWidth) {
  var child, expandedChildWidth, childWidth;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
      continue;
    }
    expandedChildWidth = this.getExpandedChildWidth(child, parentWidth);
    if (child.isRexSizer) {
      childWidth = child.resolveWidth(expandedChildWidth);
      if (childWidth === void 0) {
        childWidth = expandedChildWidth;
      }
    } else {
      childWidth = expandedChildWidth;
    }
    child.runWidthWrap(childWidth);
  }
  return this;
};
var RunWidthWrap_default = RunWidthWrap;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ResolveHeight.js
var ResolveHeight = function(height) {
  var childrenHeight = this.childrenHeight;
  if (childrenHeight === void 0) {
    return void 0;
  }
  var minHeight = this.minHeight !== void 0 ? this.minHeight * this.scaleY : 0;
  if (height === void 0) {
    height = Math.max(minHeight, childrenHeight);
    if (this.layoutWarnEnable) {
      if (minHeight > 0 && childrenHeight > minHeight) {
        console.warn(`Layout height warn: ${this.constructor.name}'s minHeight (${minHeight}) < childrenHeight (${childrenHeight})`);
      }
    }
  } else {
    if (this.layoutWarnEnable) {
      if (minHeight > height || childrenHeight > height) {
        console.warn(`Layout height warn: ${this.constructor.name}'s minHeight (${minHeight}) or childrenHeight (${childrenHeight}) > targetHeight (${height})`);
      }
    }
  }
  return height;
};
var ResolveHeight_default = ResolveHeight;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/HasHeightWrap.js
var HasHeightWrap = function() {
  var child;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
      continue;
    }
    if (!child.hasHeightWrap || child.hasHeightWrap()) {
      return true;
    }
  }
  return false;
};
var HasHeightWrap_default = HasHeightWrap;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ResolveChildrenHeight.js
var ResolveChildrenHeight = function(parentHeight) {
  var child, expandedChildHeight, childHeight;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (child && child.isRexSizer && !child.ignoreLayout) {
      expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
      childHeight = child.resolveHeight(expandedChildHeight);
      if (childHeight === void 0) {
        childHeight = expandedChildHeight;
      }
      child.resolveChildrenHeight(childHeight);
    }
  }
};
var ResolveChildrenHeight_default = ResolveChildrenHeight;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/RunHeightWrap.js
var RunHeightWrap = function(parentHeight) {
  var child, expandedChildHeight, childHeight;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
      continue;
    }
    expandedChildHeight = this.getExpandedChildHeight(child, parentHeight);
    if (child.isRexSizer) {
      childHeight = child.resolveHeight(expandedChildHeight);
      if (childHeight === void 0) {
        childHeight = expandedChildHeight;
      }
    } else {
      childHeight = expandedChildHeight;
    }
    child.runHeightWrap(childHeight);
  }
  return this;
};
var RunHeightWrap_default = RunHeightWrap;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetChildWidth.js
var GetChildWidth = function(child) {
  var childWidth;
  if (child.isRexSizer) {
    var childrenWidth = child.childrenWidth;
    if (childrenWidth == void 0) {
      return void 0;
    }
    var childMinWidth = child.minWidth * child.scaleX;
    childWidth = Math.max(childMinWidth, childrenWidth);
  } else {
    if (child.minWidth !== void 0) {
      childWidth = child.minWidth;
    } else if (child._minWidth !== void 0) {
      childWidth = child._minWidth;
    } else {
      childWidth = GetDisplayWidth(child);
    }
  }
  return childWidth;
};
var GetChildWidth_default = GetChildWidth;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetChildHeight.js
var GetChildHeight = function(child) {
  var childHeight;
  if (child.isRexSizer) {
    var childrenHeight = child.childrenHeight;
    if (childrenHeight === void 0) {
      return void 0;
    }
    var childMinHeight = child.minHeight * child.scaleY;
    childHeight = Math.max(childMinHeight, childrenHeight);
  } else {
    if (child.minHeight !== void 0) {
      childHeight = child.minHeight;
    } else if (child._minHeight !== void 0) {
      childHeight = child._minHeight;
    } else {
      childHeight = GetDisplayHeight(child);
    }
  }
  return childHeight;
};
var GetChildHeight_default = GetChildHeight;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetExpandedChildWidth.js
var GetExpandedChildWidth = function(child, parentWidth) {
  return parentWidth;
};
var GetExpandedChildWidth_default = GetExpandedChildWidth;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetExpandedChildHeight.js
var GetExpandedChildHeight = function(child, parentHeight) {
  return parentHeight;
};
var GetExpandedChildHeight_default = GetExpandedChildHeight;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetChildrenWidth.js
var GetChildrenWidth = function() {
  return 0;
};
var GetChildrenWidth_default = GetChildrenWidth;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetChildrenHeight.js
var GetChildrenHeight = function() {
  return 0;
};
var GetChildrenHeight_default = GetChildrenHeight;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetAllChildrenSizers.js
var GetAllChildrenSizers = function(out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  var startIdx = out2.length;
  var children = this.getChildrenSizers(out2);
  var endIdx = out2.length;
  for (var i = startIdx; i < endIdx; i++) {
    children[i].getAllChildrenSizers(out2);
  }
  return out2;
};
var GetAllChildrenSizers_default = GetAllChildrenSizers;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetChildrenSizers.js
var GetChildrenSizers = function(out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  return out2;
};
var GetChildrenSizers_default = GetChildrenSizers;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/GetShownChildrenMethods.js
var GetShownChildrenMethods_default = {
  getShownChildren(out2) {
    if (out2 === void 0) {
      out2 = [];
    }
    var children = this.children, child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child.rexSizer && child.rexSizer.hidden) {
        continue;
      }
      out2.push(child);
    }
    return out2;
  },
  getAllShownChildren(out2) {
    if (out2 === void 0) {
      out2 = [];
    }
    var queue = [this];
    while (queue.length > 0) {
      var current = queue.shift();
      if (current.rexSizer && current.rexSizer.hidden) {
        continue;
      }
      if (current !== this) {
        out2.push(current);
      }
      if (current.isRexContainerLite) {
        queue.push(...current.children);
      }
    }
    return out2;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/PreLayout.js
var PreLayout = function() {
  this._childrenWidth = void 0;
  this._childrenHeight = void 0;
  var children = this.getChildrenSizers(), child;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child.ignoreLayout) {
      continue;
    }
    child.preLayout();
  }
};
var PreLayout_default = PreLayout;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/Layout.js
var Layout = function() {
  this.runLayout();
  return this;
};
var Layout_default = Layout;

// node_modules/phaser3-rex-plugins/plugins/utils/size/HasResizeMethod.js
var HasResizeMethod = function(gameObject2) {
  if (gameObject2.resize) {
    return true;
  }
  if (!gameObject2.setSize) {
    return false;
  }
  for (var i = 0, cnt = ExcludeClassList.length; i < cnt; i++) {
    var excludeClass = ExcludeClassList[i];
    if (excludeClass && gameObject2 instanceof excludeClass) {
      return false;
    }
  }
  return true;
};
var ExcludeClassList = [
  Phaser.GameObjects.Image,
  Phaser.GameObjects.Sprite,
  Phaser.GameObjects.Mesh,
  Phaser.GameObjects.Shader,
  Phaser.GameObjects.Video
];
var HasResizeMethod_default = HasResizeMethod;

// node_modules/phaser3-rex-plugins/plugins/utils/size/CanSetDisplaySize.js
var CanSetDisplaySize = function(gameObject2) {
  if (gameObject2.displayWidth === void 0) {
    return false;
  }
  for (var i = 0, cnt = ExcludeClassList2.length; i < cnt; i++) {
    var excludeClass = ExcludeClassList2[i];
    if (excludeClass && gameObject2 instanceof excludeClass) {
      return false;
    }
  }
  return true;
};
var ExcludeClassList2 = [
  Phaser.GameObjects.BitmapText
];
var CanSetDisplaySize_default = CanSetDisplaySize;

// node_modules/phaser3-rex-plugins/plugins/utils/size/ResizeGameObject.js
var ResizeGameObject = function(gameObject2, newDisplayWidth, newDisplayHeight) {
  if (!gameObject2 || newDisplayWidth === void 0 && newDisplayHeight === void 0) {
    return;
  }
  if (HasResizeMethod_default(gameObject2)) {
    var newWidth, newHeight;
    if (newDisplayWidth === void 0) {
      newWidth = gameObject2.width;
    } else {
      newWidth = newDisplayWidth / gameObject2.scaleX;
    }
    if (newDisplayHeight === void 0) {
      newHeight = gameObject2.height;
    } else {
      newHeight = newDisplayHeight / gameObject2.scaleY;
    }
    if (gameObject2.resize) {
      gameObject2.resize(newWidth, newHeight);
    } else {
      gameObject2.setSize(newWidth, newHeight);
    }
  } else {
    var canSetDisplaySize = CanSetDisplaySize_default(gameObject2);
    if (newDisplayWidth !== void 0) {
      if (canSetDisplaySize) {
        gameObject2.displayWidth = newDisplayWidth;
      } else {
        gameObject2.scaleX = newDisplayWidth / gameObject2.width;
      }
    }
    if (newDisplayHeight !== void 0) {
      if (canSetDisplaySize) {
        gameObject2.displayHeight = newDisplayHeight;
      } else {
        gameObject2.scaleY = newDisplayHeight / gameObject2.height;
      }
    }
  }
};
var ResizeGameObject_default = ResizeGameObject;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/RunLayout.js
var RunLayout = function(parent, newWidth, newHeight) {
  if (this.ignoreLayout) {
    return this;
  }
  var isTopmostParent = !parent;
  if (isTopmostParent) {
    this.preLayout();
  }
  var runWidthWrap, runHeightWrap;
  if (isTopmostParent || parent.runChildrenWrapFlag) {
    runWidthWrap = this.hasWidthWrap();
    runHeightWrap = this.hasHeightWrap();
  } else {
    runWidthWrap = false;
    runHeightWrap = false;
  }
  var size = ResolveSize(this, newWidth, newHeight, runWidthWrap, runHeightWrap);
  if (!size) {
    console.error("Can't resolve size of ", this);
  }
  var width = size.width;
  var height = size.height;
  ResizeGameObject_default(this, width, height);
  if (this.sizerEventsEnable) {
    if (this.layoutedChildren === void 0) {
      this.layoutedChildren = [];
    }
  }
  this.layoutChildren();
  this.layoutBackgrounds();
  if (this.sizerEventsEnable) {
    this.emit("postlayout", this.layoutedChildren, this);
    this.layoutedChildren.length = 0;
  }
  this.postLayout(parent, width, height);
  if (isTopmostParent) {
    if (this._anchor) {
      this._anchor.updatePosition();
    }
  }
  return this;
};
var ResolveSize = function(self, width, height, runWidthWrap, runHeightWrap) {
  var newWidth = ResolveWidth2(self, width, runWidthWrap);
  var newHeight = ResolveHeight2(self, height, runHeightWrap);
  if (newWidth === void 0) {
    newWidth = ResolveWidth2(self, width, runWidthWrap);
  }
  if (newWidth !== void 0 && newHeight !== void 0) {
    return {
      width: newWidth,
      height: newHeight
    };
  }
  return false;
};
var ResolveWidth2 = function(self, width, runWidthWrap) {
  var width = self.resolveWidth(width);
  if (width !== void 0) {
    if (runWidthWrap) {
      self.resolveChildrenWidth(width);
      self.runWidthWrap(width);
    }
  }
  return width;
};
var ResolveHeight2 = function(self, height, runHeightWrap) {
  var height = self.resolveHeight(height);
  if (height !== void 0) {
    if (runHeightWrap) {
      self.resolveChildrenHeight(height);
      self.runHeightWrap(height);
    }
  }
  return height;
};
var RunLayout_default = RunLayout;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/LayoutChildren.js
var LayoutChildren = function() {
};
var LayoutChildren_default = LayoutChildren;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/PostLayout.js
var PostLayout = function(parent, newWidth, newHeight) {
  return this;
};
var PostLayout_default = PostLayout;

// node_modules/phaser3-rex-plugins/plugins/behaviors/anchor/DefaultResizeCallback.js
var DefaultResizeCallback = function(width, height, gameObject2, anchor) {
  ResizeGameObject_default(gameObject2, width, height);
};
var DefaultResizeCallback_default = DefaultResizeCallback;

// node_modules/phaser3-rex-plugins/plugins/behaviors/anchor/Anchor.js
var GetValue73 = Phaser.Utils.Objects.GetValue;
var Anchor = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, { eventEmitter: false });
    this.viewport = void 0;
    this.resetFromJSON(config);
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.autoAnchor(false);
    this.viewport = void 0;
    this.onUpdateViewportCallback = void 0;
    this.onUpdateViewportCallbackScope = void 0;
    this.onResizeCallback = void 0;
    this.onResizeCallbackScope = void 0;
    super.shutdown(fromScene);
  }
  resetFromJSON(o) {
    if (o === void 0) {
      o = {};
    }
    var alignX, configX;
    if (o.x !== void 0) {
      alignX = null;
      configX = o.x;
    } else if (o.left !== void 0) {
      alignX = 0;
      configX = o.left;
    } else if (o.right !== void 0) {
      alignX = 1;
      configX = o.right;
    } else if (o.centerX !== void 0) {
      alignX = 0.5;
      configX = o.centerX;
    }
    var alignY, configY;
    if (o.y !== void 0) {
      alignY = null;
      configY = o.y;
    } else if (o.top !== void 0) {
      alignY = 0;
      configY = o.top;
    } else if (o.bottom !== void 0) {
      alignY = 1;
      configY = o.bottom;
    } else if (o.centerY !== void 0) {
      alignY = 0.5;
      configY = o.centerY;
    }
    var percentageX, offsetX;
    if (configX !== void 0) {
      configX = configX.replace("left", "0%").replace("right", "100%").replace("center", "50%").split("%");
      percentageX = parseFloat(configX[0]) / 100;
      offsetX = configX[1] === "" ? 0 : parseFloat(configX[1]);
    }
    var percentageY, offsetY;
    if (configY !== void 0) {
      configY = configY.replace("top", "0%").replace("bottom", "100%").replace("center", "50%").split("%");
      percentageY = parseFloat(configY[0]) / 100;
      offsetY = configY[1] === "" ? 0 : parseFloat(configY[1]);
    }
    var configWidth = o.width;
    var percentageWidth, paddingWidth;
    if (configWidth !== void 0) {
      configWidth = configWidth.split("%");
      percentageWidth = parseFloat(configWidth[0]) / 100;
      paddingWidth = configWidth[1] === "" ? 0 : parseFloat(configWidth[1]);
    }
    var configHeight = o.height;
    var percentageHeight, paddingHeight;
    if (configHeight !== void 0) {
      configHeight = configHeight.split("%");
      percentageHeight = parseFloat(configHeight[0]) / 100;
      paddingHeight = configHeight[1] === "" ? 0 : parseFloat(configHeight[1]);
    }
    this.setAlign(alignX, alignY);
    this.setPercentage(percentageX, percentageY);
    this.setOffset(offsetX, offsetY);
    this.setSizePercentage(percentageWidth, percentageHeight);
    this.setSizePadding(paddingWidth, paddingHeight);
    var onResizeCallback = GetValue73(o, "onResizeCallback", DefaultResizeCallback_default);
    var onResizeCallbackScope = GetValue73(o, "onResizeCallbackScope");
    this.setResizeCallback(onResizeCallback, onResizeCallbackScope);
    var onUpdateViewportCallback = GetValue73(o, "onUpdateViewportCallback");
    var onUpdateViewportCallbackScope = GetValue73(o, "onUpdateViewportCallbackScope");
    this.setUpdateViewportCallback(onUpdateViewportCallback, onUpdateViewportCallbackScope);
    this.autoAnchor(o.enable);
    return this;
  }
  autoAnchor(enable) {
    if (enable === void 0) {
      enable = true;
    }
    enable = !!enable;
    if (this.autoAnchorEnable === enable) {
      return this;
    }
    if (enable) {
      this.scene.sys.scale.on("resize", this.anchor, this);
      this.anchor();
    } else {
      this.scene.sys.scale.off("resize", this.anchor, this);
    }
    this.autoAnchorEnable = enable;
    return this;
  }
  // Position
  setAlign(x, y) {
    this.alignX = x;
    this.alignY = y;
    return this;
  }
  setPercentage(x, y) {
    this.percentageX = x;
    this.percentageY = y;
    return this;
  }
  setOffset(x, y) {
    this.offsetX = x;
    this.offsetY = y;
    return this;
  }
  // Size
  setSizePercentage(width, height) {
    this.percentageWidth = width;
    this.percentageHeight = height;
    return this;
  }
  setSizePadding(width, height) {
    this.paddingWidth = width;
    this.paddingHeight = height;
    return this;
  }
  setResizeCallback(callback, scope) {
    this.onResizeCallback = callback;
    this.onResizeCallbackScope = scope;
    return this;
  }
  setUpdateViewportCallback(callback, scope) {
    this.onUpdateViewportCallback = callback;
    this.onUpdateViewportCallbackScope = scope;
    return this;
  }
  anchor() {
    this.updateViewport();
    this.updateSize();
    this.updatePosition();
    return this;
  }
  updateSize() {
    var callback = this.onResizeCallback, scope = this.onResizeCallbackScope;
    var newWidth = this.anchorWidth, newHeight = this.anchorHeight;
    if (newWidth === void 0 && newHeight === void 0 || !callback) {
      return;
    }
    var gameObject2 = this.parent;
    if (newWidth === void 0) {
      newWidth = gameObject2.width;
    }
    if (newHeight === void 0) {
      newHeight = gameObject2.height;
    }
    if (scope) {
      callback.call(scope, newWidth, newHeight, gameObject2, this);
    } else {
      callback(newWidth, newHeight, gameObject2, this);
    }
  }
  updatePosition() {
    var gameObject2 = this.parent;
    if (this.alignX === null) {
      gameObject2.x = this.anchorX;
    } else if (this.alignX !== void 0) {
      gameObject2.x = this.anchorX + gameObject2.displayWidth * (gameObject2.originX - this.alignX);
    }
    if (this.alignY === null) {
      gameObject2.y = this.anchorY;
    } else if (this.alignY !== void 0) {
      gameObject2.y = this.anchorY + gameObject2.displayHeight * (gameObject2.originY - this.alignY);
    }
    return this;
  }
  get anchorX() {
    return this.viewport.x + this.viewport.width * this.percentageX + this.offsetX;
  }
  get anchorY() {
    return this.viewport.y + this.viewport.height * this.percentageY + this.offsetY;
  }
  get anchorWidth() {
    if (this.percentageWidth === void 0) {
      return void 0;
    }
    return this.viewport.width * this.percentageWidth + this.paddingWidth;
  }
  get anchorHeight() {
    if (this.percentageHeight === void 0) {
      return void 0;
    }
    return this.viewport.height * this.percentageHeight + this.paddingHeight;
  }
  updateViewport() {
    var camera = this.parent.scene.cameras.main;
    this.viewport = GetViewport_default(this.scene, camera, this.viewport);
    var viewport = this.viewport;
    var callback = this.onUpdateViewportCallback, scope = this.onUpdateViewportCallbackScope;
    if (callback) {
      if (scope) {
        callback.call(scope, viewport, this.parent, this);
      } else {
        callback(viewport, this.parent, this);
      }
    }
  }
};
var Anchor_default = Anchor;

// node_modules/phaser3-rex-plugins/templates/ui/anchor/Anchor.js
var Anchor_default2 = Anchor_default;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/SetAnchor.js
var SetAnchor = function(config) {
  if (config === void 0) {
    config = {};
  }
  var hasMinWidth = config.hasOwnProperty("width");
  var hasMinHeight = config.hasOwnProperty("height");
  var hasOnResizeCallback = config.hasOwnProperty("onResizeCallback");
  if ((hasMinWidth || hasMinHeight) && !hasOnResizeCallback) {
    config.onResizeCallback = function(width, height, sizer) {
      if (hasMinWidth) {
        sizer.setMinWidth(width);
      }
      if (hasMinHeight) {
        sizer.setMinHeight(height);
      }
      sizer.layout();
    };
  }
  if (this._anchor === void 0) {
    this._anchor = new Anchor_default2(this, config);
  } else {
    this._anchor.resetFromJSON(config);
  }
  return this;
};
var SetAnchor_default = SetAnchor;

// node_modules/phaser3-rex-plugins/plugins/behaviors/scale/Scale.js
var GetValue74 = Phaser.Utils.Objects.GetValue;
var GetAdvancedValue4 = Phaser.Utils.Objects.GetAdvancedValue;
var Linear10 = Phaser.Math.Linear;
var Scale2 = class extends EaseValueTaskBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.scaleStart = {};
    this.scaleEnd = {};
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setMode(GetValue74(o, "mode", 0));
    this.setScaleRange(
      GetAdvancedValue4(o, "start", void 0),
      GetAdvancedValue4(o, "end", 0)
    );
    return this;
  }
  setMode(m) {
    if (typeof m === "string") {
      m = MODE2[m];
    }
    this.mode = m;
    return this;
  }
  setScaleRange(start, end) {
    if (typeof start === "number") {
      this.startX = start;
      this.startY = start;
    } else {
      this.startX = GetAdvancedValue4(start, "x", this.parent.scaleX);
      this.startY = GetAdvancedValue4(start, "y", this.parent.scaleY);
    }
    if (typeof end === "number") {
      this.endX = end;
      this.endY = end;
    } else {
      this.endX = GetAdvancedValue4(end, "x", void 0);
      this.endY = GetAdvancedValue4(end, "y", void 0);
    }
    this.hasScaleX = this.startX !== void 0 && this.endX !== void 0;
    this.hasScaleY = this.startY !== void 0 && this.endY !== void 0;
    return this;
  }
  start() {
    if (this.timer.isRunning) {
      return this;
    }
    var gameObject2 = this.parent;
    if (this.hasScaleX) {
      gameObject2.scaleX = this.startX;
    }
    if (this.hasScaleY) {
      gameObject2.scaleY = this.startY;
    }
    var repeat = this.repeat;
    if (this.mode === 2) {
      if (repeat !== -1) {
        repeat = (repeat + 1) * 2 - 1;
      }
    }
    this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(repeat);
    super.start();
    return this;
  }
  updateTarget(gameObject2, timer) {
    var t = timer.t;
    if (timer.isOddIteration) {
      t = 1 - t;
    }
    t = this.easeFn(t);
    if (this.hasScaleX) {
      gameObject2.scaleX = Linear10(this.startX, this.endX, t);
    }
    if (this.hasScaleY) {
      gameObject2.scaleY = Linear10(this.startY, this.endY, t);
    }
  }
  complete() {
    super.complete();
    if (this.mode === 1) {
      this.parent.destroy();
    }
    return this;
  }
};
var MODE2 = {
  stop: 0,
  destroy: 1,
  yoyo: 2
};
var Scale_default3 = Scale2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/scale/PopUp.js
var PopUp = function(gameObject2, duration, orientation, ease, scale) {
  if (ease === void 0) {
    ease = "Cubic";
  }
  var start, end;
  switch (orientation) {
    case 0:
    case "x":
      start = { x: 0 };
      end = { x: gameObject2.scaleX };
      break;
    case 1:
    case "y":
      start = { y: 0 };
      end = { y: gameObject2.scaleY };
      break;
    default:
      start = 0;
      end = gameObject2.scale;
      break;
  }
  var config = {
    mode: 0,
    start,
    end,
    duration,
    ease
  };
  if (scale === void 0) {
    scale = new Scale_default3(gameObject2, config);
  } else {
    scale.resetFromJSON(config);
  }
  scale.restart();
  return scale;
};
var PopUp_default = PopUp;

// node_modules/phaser3-rex-plugins/plugins/popup.js
var popup_default = PopUp_default;

// node_modules/phaser3-rex-plugins/plugins/behaviors/scale/ScaleDownDestroy.js
var ScaleDownDestroy = function(gameObject2, duration, orientation, ease, destroyMode, scale) {
  if (ease === void 0) {
    ease = "Linear";
  }
  if (destroyMode instanceof Scale_default3) {
    scale = destroyMode;
    destroyMode = void 0;
  }
  if (destroyMode === void 0) {
    destroyMode = true;
  }
  var config = {};
  config.mode = destroyMode ? 1 : 0;
  switch (orientation) {
    case 0:
    case "x":
      config.end = {
        x: 0
      };
      break;
    case 1:
    case "y":
      config.end = {
        y: 0
      };
      break;
    default:
      config.end = 0;
      break;
  }
  config.duration = duration;
  config.ease = ease;
  if (scale === void 0) {
    scale = new Scale_default3(gameObject2, config);
  } else {
    scale.resetFromJSON(config);
  }
  scale.restart();
  return scale;
};
var ScaleDownDestroy_default = ScaleDownDestroy;

// node_modules/phaser3-rex-plugins/plugins/scale-down-destroy.js
var scale_down_destroy_default = ScaleDownDestroy_default;

// node_modules/phaser3-rex-plugins/plugins/behaviors/scale/Yoyo.js
var Yoyo2 = function(gameObject2, duration, peakValue, repeat, orientation, ease, scale) {
  if (peakValue === void 0) {
    peakValue = 1.2;
  }
  if (repeat === void 0) {
    repeat = 0;
  }
  if (ease === void 0) {
    ease = "Cubic";
  }
  var start, end;
  switch (orientation) {
    case 0:
    case "x":
      start = { x: gameObject2.scaleX };
      end = { x: peakValue };
      break;
    case 1:
    case "y":
      start = { y: gameObject2.scaleX };
      end = { y: peakValue };
      break;
    default:
      start = gameObject2.scaleX;
      end = peakValue;
      break;
  }
  var config = {
    mode: 2,
    start,
    end,
    duration: duration / 2,
    ease,
    repeat
  };
  if (scale === void 0) {
    scale = new Scale_default3(gameObject2, config);
  } else {
    scale.resetFromJSON(config);
  }
  scale.restart();
  return scale;
};
var Yoyo_default2 = Yoyo2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/scale/ScaleMethods.js
var IsPlainObject21 = Phaser.Utils.Objects.IsPlainObject;
var ScaleMethods_default = {
  onInitScale() {
    var gameObject2 = this;
    var scale = this._scaleBehavior;
    scale.completeEventName = void 0;
    scale.on("complete", function() {
      if (scale.completeEventName) {
        gameObject2.emit(scale.completeEventName, gameObject2);
        scale.completeEventName = void 0;
      }
    });
  },
  popUp(duration, orientation, ease) {
    if (IsPlainObject21(duration)) {
      var config = duration;
      duration = config.duration;
      orientation = config.orientation;
      ease = config.ease;
    }
    var isInit = this._scaleBehavior === void 0;
    this._scaleBehavior = PopUp_default(this, duration, orientation, ease, this._scaleBehavior);
    if (isInit) {
      this.onInitScale();
    }
    this._scaleBehavior.completeEventName = "popup.complete";
    return this;
  },
  popUpPromise(duration, orientation, ease) {
    this.popUp(duration, orientation, ease);
    return WaitComplete(this._scaleBehavior);
  },
  isRunningPopUp() {
    return this._scaleBehavior && this._scaleBehavior.completeEventName === "popup.complete";
  },
  scaleDownDestroy(duration, orientation, ease, destroyMode) {
    if (IsPlainObject21(duration)) {
      var config = duration;
      duration = config.duration;
      orientation = config.orientation;
      ease = config.ease;
      destroyMode = config.destroy;
    }
    var isInit = this._scaleBehavior === void 0;
    this._scaleBehavior = ScaleDownDestroy_default(this, duration, orientation, ease, destroyMode, this._scaleBehavior);
    if (isInit) {
      this.onInitScale();
    }
    this._scaleBehavior.completeEventName = "scaledown.complete";
    return this;
  },
  scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
    this.scaleDownDestroy(duration, orientation, ease, destroyMode);
    return WaitComplete(this._scaleBehavior);
  },
  scaleDown(duration, orientation, ease) {
    this.scaleDownDestroy(duration, orientation, ease, false);
    return this;
  },
  scaleDownPromise(duration, orientation, ease) {
    this.scaleDown(duration, orientation, ease);
    return WaitComplete(this._scaleBehavior);
  },
  isRunningScaleDown() {
    return this._scaleBehavior && this._scaleBehavior.completeEventName === "scaledown.complete";
  },
  scaleYoyo(duration, peakValue, repeat, orientation, ease) {
    if (IsPlainObject21(duration)) {
      var config = duration;
      duration = config.duration;
      peakValue = config.peakValue;
      repeat = config.repeat;
      orientation = config.orientation;
      ease = config.ease;
    }
    var isInit = this._scaleBehavior === void 0;
    this._scaleBehavior = Yoyo_default2(this, duration, peakValue, repeat, orientation, ease, this._scaleBehavior);
    if (isInit) {
      this.onInitScale();
    }
    this._scaleBehavior.completeEventName = "scaleyoyo.complete";
    return this;
  },
  scaleYoyoPromise(duration, peakValue, repeat, orientation, ease) {
    this.scaleYoyo(duration, peakValue, repeat, orientation, ease);
    return WaitComplete(this._scaleBehavior);
  },
  isRunningScaleYoyo() {
    return this._scaleBehavior && (this._scaleBehavior.completeEventName = "scaleyoyo.complete");
  },
  isRunningEaseScale() {
    return this.isRunningPopUp() || this.isRunningScaleDown() || this.isRunningScaleYoyo();
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ScaleMethods.js
var methods12 = {};
Object.assign(methods12, ScaleMethods_default);
methods12.onInitScale = function() {
  ScaleMethods_default.onInitScale.call(this);
  var gameObject2 = this;
  var scale = this._scaleBehavior;
  scale.on("update", function() {
    var parent = GetParentSizerMethods_default.getParentSizer(gameObject2);
    if (parent) {
      parent.resetChildPositionState(gameObject2);
    }
  });
};
var ScaleMethods_default2 = methods12;

// node_modules/phaser3-rex-plugins/plugins/behaviors/fade/Fade.js
var GetValue75 = Phaser.Utils.Objects.GetValue;
var GetAdvancedValue5 = Phaser.Utils.Objects.GetAdvancedValue;
var Linear11 = Phaser.Math.Linear;
var Fade2 = class extends EaseValueTaskBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setMode(GetValue75(o, "mode", 0));
    this.setAlphaRange(
      GetAdvancedValue5(o, "start", this.parent.alpha),
      GetAdvancedValue5(o, "end", 0)
    );
    return this;
  }
  setMode(m) {
    if (typeof m === "string") {
      m = MODE3[m];
    }
    this.mode = m;
    return this;
  }
  setAlphaRange(start, end) {
    this.alphaStart = start;
    this.alphaEnd = end;
    return this;
  }
  start() {
    if (this.timer.isRunning) {
      return this;
    }
    var gameObject2 = this.parent;
    gameObject2.setAlpha(this.alphaStart);
    this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);
    super.start();
    return this;
  }
  updateTarget(gameObject2, timer) {
    var t = timer.t;
    if (timer.isOddIteration) {
      t = 1 - t;
    }
    gameObject2.alpha = Linear11(this.alphaStart, this.alphaEnd, t);
  }
  complete() {
    super.complete();
    if (this.mode === 1) {
      this.parent.destroy();
    }
    return this;
  }
};
var MODE3 = {
  stop: 0,
  destroy: 1,
  yoyo: 2
};
var Fade_default2 = Fade2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/fade/FadeIn.js
var IsPlainObject22 = Phaser.Utils.Objects.IsPlainObject;
var FadeIn2 = function(gameObject2, duration, alpha, fade) {
  var startAlpha, endAlpha;
  if (IsPlainObject22(alpha)) {
    startAlpha = alpha.start;
    endAlpha = alpha.end;
  } else {
    endAlpha = alpha;
  }
  if (startAlpha === void 0) {
    startAlpha = 0;
  }
  if (endAlpha === void 0) {
    endAlpha = 1;
  }
  var config = {
    mode: 0,
    start: startAlpha,
    end: endAlpha,
    duration
  };
  if (fade === void 0) {
    fade = new Fade_default2(gameObject2, config);
  } else {
    fade.resetFromJSON(config);
  }
  fade.restart();
  return fade;
};
var FadeIn_default2 = FadeIn2;

// node_modules/phaser3-rex-plugins/plugins/fade-in.js
var fade_in_default = FadeIn_default2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/fade/FadeOutDestroy.js
var FadeOutDestroy = function(gameObject2, duration, destroyMode, fade) {
  if (destroyMode instanceof Fade_default2) {
    fade = destroyMode;
    destroyMode = void 0;
  }
  if (destroyMode === void 0) {
    destroyMode = true;
  }
  var config = {
    mode: destroyMode ? 1 : 0,
    end: 0,
    duration
  };
  if (fade === void 0) {
    fade = new Fade_default2(gameObject2, config);
  } else {
    fade.resetFromJSON(config);
  }
  fade.restart();
  return fade;
};
var FadeOutDestroy_default = FadeOutDestroy;

// node_modules/phaser3-rex-plugins/plugins/fade-out-destroy.js
var fade_out_destroy_default = FadeOutDestroy_default;

// node_modules/phaser3-rex-plugins/plugins/behaviors/fade/FadeMethods.js
var IsPlainObject23 = Phaser.Utils.Objects.IsPlainObject;
var FadeMethods_default2 = {
  onInitFade() {
    var gameObject2 = this;
    var fade = this._fade;
    fade.completeEventName = void 0;
    fade.on("complete", function() {
      if (fade.completeEventName) {
        gameObject2.emit(fade.completeEventName, gameObject2);
        fade.completeEventName = void 0;
      }
    });
  },
  fadeIn(duration, alpha) {
    if (IsPlainObject23(duration)) {
      var config = duration;
      duration = config.duration;
      alpha = config.alpha;
    }
    var isInit = this._fade === void 0;
    this._fade = FadeIn_default2(this, duration, alpha, this._fade);
    if (isInit) {
      this.onInitFade();
    }
    this._fade.completeEventName = "fadein.complete";
    return this;
  },
  fadeInPromise(duration, alpha) {
    this.fadeIn(duration, alpha);
    return WaitComplete(this._fade);
  },
  isRunningFadeIn() {
    return this._fade && this._fade.completeEventName === "fadein.complete";
  },
  fadeOutDestroy(duration, destroyMode) {
    if (IsPlainObject23(duration)) {
      var config = duration;
      duration = config.duration;
      destroyMode = config.destroy;
    }
    var isInit = this._fade === void 0;
    this._fade = FadeOutDestroy_default(this, duration, destroyMode, this._fade);
    if (isInit) {
      this.onInitFade();
    }
    this._fade.completeEventName = "fadeout.complete";
    return this;
  },
  fadeOutDestroyPromise(duration, destroyMode) {
    this.fadeOutDestroy(duration, destroyMode);
    return WaitComplete(this._fade);
  },
  fadeOut(duration) {
    this.fadeOutDestroy(duration, false);
    return this;
  },
  fadeOutPromise(duration) {
    this.fadeOut(duration);
    return WaitComplete(this._fade);
  },
  isRunningFadeOut() {
    return this._fade && this._fade.completeEventName === "fadeout.complete";
  },
  isRunningEaseFade() {
    return this.isRunningFadeIn() || this.isRunningFadeOut();
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/FadeMethods.js
var methods13 = {};
Object.assign(methods13, FadeMethods_default2);
methods13.onInitFade = function() {
  FadeMethods_default2.onInitFade.call(this);
  var gameObject2 = this;
  var fade = this._fade;
  fade.on("update", function() {
    var parent = GetParentSizerMethods_default.getParentSizer(gameObject2);
    if (parent) {
      parent.resetChildAlphaState(gameObject2);
    }
  });
};
var FadeMethods_default3 = methods13;

// node_modules/phaser3-rex-plugins/plugins/behaviors/easemove/EaseMove.js
var GetValue76 = Phaser.Utils.Objects.GetValue;
var GetAdvancedValue6 = Phaser.Utils.Objects.GetAdvancedValue;
var Linear12 = Phaser.Math.Linear;
var EaseMove = class extends EaseValueTaskBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setMode(GetValue76(o, "mode", 0));
    if (o && (o.hasOwnProperty("x") || o.hasOwnProperty("y"))) {
      var endX = GetAdvancedValue6(o, "x", void 0);
      var endY = GetAdvancedValue6(o, "y", void 0);
      this.setTargetPosition(endX, endY);
    } else {
      this.setTargetPosition(o);
    }
    return this;
  }
  setMode(m) {
    if (typeof m === "string") {
      m = MODE4[m];
    }
    this.mode = m;
    return this;
  }
  setTargetPosition(x, y) {
    if (typeof x === "number" || typeof y === "number") {
      this.startX = this.parent.x;
      this.startY = this.parent.y;
      this.endX = x;
      this.endY = y;
    } else {
      var config = x;
      this.startX = GetAdvancedValue6(config, "startX", void 0);
      this.startY = GetAdvancedValue6(config, "startY", void 0);
      this.endX = GetAdvancedValue6(config, "endX", void 0);
      this.endY = GetAdvancedValue6(config, "endY", void 0);
    }
    this.hasMoveX = this.startX !== void 0 && this.endX !== void 0;
    this.hasMoveY = this.startY !== void 0 && this.endY !== void 0;
    return this;
  }
  start() {
    if (this.timer.isRunning) {
      return this;
    }
    var gameObject2 = this.parent;
    if (this.hasMoveX) {
      gameObject2.x = this.startX;
    }
    if (this.hasMoveY) {
      gameObject2.y = this.startY;
    }
    this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);
    super.start();
    return this;
  }
  updateTarget(gameObject2, timer) {
    var t = timer.t;
    if (timer.isOddIteration) {
      t = 1 - t;
    }
    t = this.easeFn(t);
    if (this.hasMoveX) {
      gameObject2.x = Linear12(this.startX, this.endX, t);
    }
    if (this.hasMoveY) {
      gameObject2.y = Linear12(this.startY, this.endY, t);
    }
  }
  complete() {
    super.complete();
    if (this.mode === 1) {
      this.parent.destroy();
    }
    return this;
  }
};
var MODE4 = {
  stop: 0,
  destroy: 1,
  yoyo: 2
};
var EaseMove_default = EaseMove;

// node_modules/phaser3-rex-plugins/plugins/behaviors/easemove/ParseValue.js
var ParseValue = function(propertyValue, startValue) {
  if (typeof propertyValue === "number") {
    return propertyValue;
  } else {
    var op = propertyValue[0];
    var num = parseFloat(propertyValue.substr(2));
    switch (op) {
      case "+":
        return startValue + num;
      case "-":
        return startValue - num;
      case "*":
        return startValue * num;
      case "/":
        return startValue / num;
    }
  }
};
var ParseValue_default = ParseValue;

// node_modules/phaser3-rex-plugins/plugins/behaviors/easemove/EaseMoveTo.js
var EaseMoveTo = function(gameObject2, duration, endX, endY, ease, destroyMode, easeMove) {
  if (destroyMode instanceof EaseMove_default) {
    easeMove = destroyMode;
    destroyMode = void 0;
  }
  if (destroyMode === void 0) {
    destroyMode = false;
  }
  var config = {};
  config.mode = destroyMode ? 1 : 0;
  if (endX !== void 0) {
    config.startX = gameObject2.x;
    config.endX = ParseValue_default(endX, gameObject2.x);
  }
  if (endY !== void 0) {
    config.startY = gameObject2.y;
    config.endY = ParseValue_default(endY, gameObject2.y);
  }
  config.duration = duration;
  config.ease = ease === void 0 ? "Linear" : ease;
  if (easeMove === void 0) {
    easeMove = new EaseMove_default(gameObject2, config);
  } else {
    easeMove.resetFromJSON(config);
  }
  easeMove.restart();
  return easeMove;
};
var EaseMoveTo_default = EaseMoveTo;

// node_modules/phaser3-rex-plugins/plugins/behaviors/easemove/EaseMoveFrom.js
var EaseMoveFrom = function(gameObject2, duration, startX, startY, ease, destroyMode, easeMove) {
  if (destroyMode instanceof EaseMove_default) {
    easeMove = destroyMode;
    destroyMode = void 0;
  }
  if (destroyMode === void 0) {
    destroyMode = false;
  }
  var config = {};
  config.mode = destroyMode ? 1 : 0;
  if (startX !== void 0) {
    config.startX = ParseValue_default(startX, gameObject2.x);
    config.endX = gameObject2.x;
  }
  if (startY !== void 0) {
    config.startY = ParseValue_default(startY, gameObject2.y);
    config.endY = gameObject2.y;
  }
  config.duration = duration;
  config.ease = ease === void 0 ? "Linear" : ease;
  if (easeMove === void 0) {
    easeMove = new EaseMove_default(gameObject2, config);
  } else {
    easeMove.resetFromJSON(config);
  }
  easeMove.restart();
  return easeMove;
};
var EaseMoveFrom_default = EaseMoveFrom;

// node_modules/phaser3-rex-plugins/plugins/behaviors/easemove/EaseMoveMethods.js
var IsPlainObject24 = Phaser.Utils.Objects.IsPlainObject;
var DistanceBetween2 = Phaser.Math.Distance.Between;
var EaseMoveMethods_default = {
  onInitEaseMove() {
    var gameObject2 = this;
    var easeMove = this._easeMove;
    easeMove.completeEventName = void 0;
    easeMove.on("complete", function() {
      if (easeMove.completeEventName) {
        gameObject2.emit(easeMove.completeEventName, gameObject2);
        easeMove.completeEventName = void 0;
      }
    });
  },
  moveFrom(duration, x, y, ease, destroyMode) {
    if (IsPlainObject24(duration)) {
      var config = duration;
      x = config.x;
      y = config.y;
      if (config.hasOwnProperty("speed")) {
        duration = DistanceBetween2(x, y, this.x, this.y) * 1e3 / config.speed;
      } else {
        duration = config.duration;
      }
      ease = config.ease;
    }
    var isInit = this._easeMove === void 0;
    this._easeMove = EaseMoveFrom_default(this, duration, x, y, ease, destroyMode, this._easeMove);
    if (isInit) {
      this.onInitEaseMove();
    }
    this._easeMove.completeEventName = "movefrom.complete";
    return this;
  },
  moveFromPromise(duration, x, y, ease, destroyMode) {
    this.moveFrom(duration, x, y, ease, destroyMode);
    return WaitComplete(this._easeMove);
  },
  moveFromDestroy(duration, x, y, ease) {
    this.moveFrom(duration, x, y, ease, true);
    return this;
  },
  moveFromDestroyPromise(duration, x, y, ease) {
    this.moveFromDestroy(duration, x, y, ease);
    return WaitComplete(this._easeMove);
  },
  isRunningMoveFrom() {
    return this._easeMove && (this._easeMove.completeEventName = "movefrom.complete");
  },
  moveTo(duration, x, y, ease, destroyMode) {
    if (IsPlainObject24(duration)) {
      var config = duration;
      x = config.x;
      y = config.y;
      if (config.hasOwnProperty("speed")) {
        duration = DistanceBetween2(x, y, this.x, this.y) * 1e3 / config.speed;
      } else {
        duration = config.duration;
      }
      ease = config.ease;
    }
    var isInit = this._easeMove === void 0;
    this._easeMove = EaseMoveTo_default(this, duration, x, y, ease, destroyMode, this._easeMove);
    if (isInit) {
      this.onInitEaseMove();
    }
    this._easeMove.completeEventName === "moveto.complete";
    return this;
  },
  moveToPromise(duration, x, y, ease, destroyMode) {
    this.moveTo(duration, x, y, ease, destroyMode);
    return WaitComplete(this._easeMove);
  },
  moveToDestroy(duration, x, y, ease) {
    this.moveTo(duration, x, y, ease, true);
    return this;
  },
  moveToDestroyPromise(duration, x, y, ease) {
    this.moveToDestroy(duration, x, y, ease, true);
    return WaitComplete(this._easeMove);
  },
  isRunningMoveTo() {
    return this._easeMove && this._easeMove.completeEventName === "moveto.complete";
  },
  isRunningEaseMove() {
    return this.isRunningMoveFrom() || this.isRunningMoveTo();
  },
  moveStop(toEnd) {
    if (!this._easeMove) {
      return this;
    }
    this._easeMove.stop(toEnd);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/EaseMoveMethods.js
var methods14 = {};
Object.assign(methods14, EaseMoveMethods_default);
methods14.onInitEaseMove = function() {
  EaseMoveMethods_default.onInitEaseMove.call(this);
  var gameObject2 = this;
  var easeMove = this._easeMove;
  easeMove.on("update", function() {
    var parent = GetParentSizerMethods_default.getParentSizer(gameObject2);
    if (parent) {
      parent.resetChildPositionState(gameObject2);
    }
  });
};
var EaseMoveMethods_default2 = methods14;

// node_modules/phaser3-rex-plugins/plugins/behaviors/shake/ShakePosition.js
var GetValue77 = Phaser.Utils.Objects.GetValue;
var ShakePosition = class extends TickTask_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.timer = new Timer_default();
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.timer.resetFromJSON(GetValue77(o, "timer"));
    this.setEnable(GetValue77(o, "enable", true));
    this.setMode(GetValue77(o, "mode", 1));
    this.isRunning = GetValue77(o, "isRunning", false);
    this.setMagnitudeMode(GetValue77(o, "magnitudeMode", 1));
    this.setAxisMode(GetValue77(o, "axis", 0));
    this.setDuration(GetValue77(o, "duration", 500));
    this.setMagnitude(GetValue77(o, "magnitude", 10));
    this.ox = GetValue77(o, "ox", void 0);
    this.oy = GetValue77(o, "oy", void 0);
    return this;
  }
  toJSON() {
    return {
      timer: this.timer.toJSON(),
      enable: this.enable,
      mode: this.mode,
      isRunning: this.isRunning,
      magnitudeMode,
      duration: this.duration,
      magnitude: this.magnitude,
      ox: this.ox,
      oy: this.oy
    };
  }
  // override
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    super.shutdown(fromScene);
    this.timer.destroy();
    this.timer = void 0;
  }
  startTicking() {
    super.startTicking();
    if (this.mode === 0) {
      this.scene.game.events.on("poststep", this.update, this);
      this.scene.game.events.on("prestep", this.backToOrigin, this);
    } else {
      this.scene.sys.events.on("preupdate", this.update, this);
    }
  }
  stopTicking() {
    super.stopTicking();
    if (this.scene) {
      if (this.mode === 0) {
        this.scene.game.events.off("poststep", this.update, this);
        this.scene.game.events.off("prestep", this.backToOrigin, this);
      } else {
        this.scene.sys.events.off("preupdate", this.update, this);
      }
    }
  }
  setEnable(e) {
    if (e == void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  setMode(mode) {
    if (typeof mode === "string") {
      mode = MODE5[mode];
    }
    this.mode = mode;
    return this;
  }
  setMagnitudeMode(magnitudeMode2) {
    if (typeof magnitudeMode2 === "string") {
      magnitudeMode2 = MANITUDEMODE[magnitudeMode2];
    }
    this.magnitudeMode = magnitudeMode2;
    return this;
  }
  setAxisMode(m) {
    if (typeof m === "string") {
      m = DIRECTIONNODE[m];
    }
    this.axisMode = m;
    return this;
  }
  setDuration(duration) {
    this.duration = duration;
    return this;
  }
  setMagnitude(magnitude) {
    this.magnitude = magnitude;
    return this;
  }
  start(duration, magnitude) {
    if (typeof duration !== "number") {
      var config = duration;
      magnitude = GetValue77(config, "magnitude", void 0);
      duration = GetValue77(config, "duration", void 0);
    }
    if (magnitude !== void 0) {
      this.setMagnitude(magnitude);
    }
    if (duration !== void 0) {
      this.setDuration(duration);
    }
    this.timer.setDuration(this.duration).start();
    super.start();
    return this;
  }
  shake(duration, magnitude) {
    this.start(duration, magnitude);
    return this;
  }
  update(time, delta) {
    if (!this.isRunning || !this.enable) {
      return this;
    }
    var gameObject2 = this.parent;
    if (!gameObject2.active) {
      return this;
    }
    this.timer.update(time, delta);
    if (this.timer.isDone) {
      this.backToOrigin();
      this.complete();
    } else {
      if (this.ox === void 0) {
        this.ox = gameObject2.x;
        this.oy = gameObject2.y;
      }
      var magnitude = this.magnitude;
      if (this.magnitudeMode === 1) {
        magnitude *= 1 - this.timer.t;
      }
      var a = Math.random() * Math.PI * 2;
      var x = this.ox + Math.cos(a) * magnitude;
      var y = this.oy + Math.sin(a) * magnitude;
      switch (this.axisMode) {
        case 1:
          gameObject2.x = x;
          break;
        case 2:
          gameObject2.y = y;
          break;
        default:
          gameObject2.x = x;
          gameObject2.y = y;
          break;
      }
    }
    return this;
  }
  backToOrigin() {
    if (!this.isRunning || !this.enable) {
      return this;
    }
    if (this.ox === void 0) {
      return this;
    }
    var gameObject2 = this.parent;
    switch (this.axisMode) {
      case 1:
        gameObject2.x = this.ox;
        break;
      case 2:
        gameObject2.y = this.oy;
        break;
      default:
        gameObject2.x = this.ox;
        gameObject2.y = this.oy;
        break;
    }
    this.ox = void 0;
    this.oy = void 0;
    return this;
  }
};
var MODE5 = {
  effect: 0,
  behavior: 1
};
var DIRECTIONNODE = {
  "both": 0,
  "h&v": 0,
  "x&y": 0,
  "horizontal": 1,
  "h": 1,
  "x": 1,
  "vertical": 2,
  "v": 2,
  "y": 2
};
var MANITUDEMODE = {
  constant: 0,
  decay: 1
};
var ShakePosition_default = ShakePosition;

// node_modules/phaser3-rex-plugins/plugins/shakeposition.js
var shakeposition_default = ShakePosition_default;

// node_modules/phaser3-rex-plugins/templates/ui/shake/Shake.js
var Shake_default = shakeposition_default;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ShakeMethods.js
var IsPlainObject25 = Phaser.Utils.Objects.IsPlainObject;
var OnInitShake = function(gameObject2, shake) {
  shake.on("complete", function() {
    gameObject2.emit("shake.complete", gameObject2);
  });
};
var ShakeMethods_default = {
  shake(duration, magnitude, magnitudeMode2) {
    if (IsPlainObject25(duration)) {
      var config = duration;
      duration = config.duration;
      magnitude = config.magnitude;
      magnitudeMode2 = config.magnitudeMode;
    }
    if (this._shake === void 0) {
      this._shake = new Shake_default(this, {
        mode: 0,
        magnitudeMode: 1
      });
      OnInitShake(this, this._shake);
    }
    if (duration !== void 0) {
      this._shake.setDuration(duration);
    }
    if (magnitude !== void 0) {
      this._shake.setMagnitude(magnitude);
    }
    if (magnitudeMode2 !== void 0) {
      this._shake.setMagnitudeMode(magnitudeMode2);
    }
    this._shake.shake();
    return this;
  },
  shakePromise(duration, alpha) {
    this.shake(duration, alpha);
    return WaitComplete(this._shake);
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/easedata/EaseData.js
var IsPlainObject26 = Phaser.Utils.Objects.IsPlainObject;
var EaseData = class extends ComponentBase_default {
  constructor(parent, config) {
    super(parent, config);
    this.parent.setDataEnabled();
    this.easeTasks = {};
  }
  complete(key2) {
    this.emit(`complete-${key2}`, this.parent, this);
    this.emit("complete", key2, this.parent, this);
  }
  getEaseTask(key2) {
    var easeTask = this.easeTasks[key2];
    if (easeTask === void 0) {
      easeTask = new EaseValueTask_default(this.parent);
      this.easeTasks[key2] = easeTask;
      easeTask.setTarget(this.parent.data.values).on("complete", function() {
        this.complete(key2);
      }, this);
    }
    return easeTask;
  }
  easeTo(key2, value, duration, ease) {
    if (IsPlainObject26(key2)) {
      var config = key2;
      key2 = config.key;
      value = config.value;
      duration = config.duration;
      ease = config.ease;
      var speed = config.speed;
      if (duration === void 0 && speed !== void 0) {
        duration = Math.abs(value - this.parent.data.values[key2]) / speed * 1e3;
      }
    }
    if (duration === void 0) {
      duration = 1e3;
    }
    if (ease === void 0) {
      ease = "Linear";
    }
    var easeTask = this.getEaseTask(key2);
    easeTask.restart({
      key: key2,
      to: value,
      duration,
      ease
    });
    return this;
  }
  easeFrom(key2, value, duration, ease) {
    if (IsPlainObject26(key2)) {
      var config = key2;
      key2 = config.key;
      value = config.value;
      duration = config.duration;
      ease = config.ease;
      var speed = config.speed;
      if (duration === void 0 && speed !== void 0) {
        duration = Math.abs(value - this.parent.data.values[key2]) / speed * 1e3;
      }
    }
    if (duration === void 0) {
      duration = 1e3;
    }
    if (ease === void 0) {
      ease = "Linear";
    }
    var easeTask = this.getEaseTask(key2);
    easeTask.restart({
      key: key2,
      from: value,
      duration,
      ease
    });
    return this;
  }
  stopEase(key2, toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }
    var easeTask = this.easeTasks[key2];
    if (easeTask) {
      easeTask.stop(toEnd);
    }
    return this;
  }
  stopAll(toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }
    for (var key2 in this.easeTasks) {
      this.stopEase(key2, toEnd);
    }
    return this;
  }
};
var EaseData_default = EaseData;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/EaseDataMethods.js
var OnInitEaseData = function(gameObject2, easeData) {
  easeData.on("complete", function(key2) {
    gameObject2.emit(`easedata.${key2}.complete`, gameObject2);
    gameObject2.emit("easedata.complete", key2, gameObject2);
  });
};
var EaseDataMethods_default = {
  easeDataTo(key2, value, duration, ease) {
    if (!this._easeData) {
      this._easeData = new EaseData_default(this);
      OnInitEaseData(this, this._easeData);
    }
    this._easeData.easeTo(key2, value, duration, ease);
    return this;
  },
  easeDataToPromise(key2, value, duration, ease) {
    this.easeDataTo(key2, value, duration, ease);
    return WaitEvent2(this._easeData, `complete-${key2}`);
  },
  stopEaseData(key2, toEnd) {
    if (!this._easeData) {
      return this;
    }
    this._easeData.stopEase(key2, toEnd);
    return this;
  },
  stopAllEaseData(toEnd) {
    if (!this._easeData) {
      return this;
    }
    this._easeData.stopAll(toEnd);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/DelayCallMethods.js
var RemoveItem12 = Phaser.Utils.Array.Remove;
var OnInitDelayCallTimers = function(gameObject2) {
  gameObject2._delayCallTimers = [];
  gameObject2.once("destroy", function() {
    var timers = gameObject2._delayCallTimers;
    for (var i = 0, cnt = timers.length; i < cnt; i++) {
      timers[i].remove();
    }
    gameObject2._delayCallTimers = void 0;
  });
};
var DelayCallMethods_default = {
  delayCall(delay, callback, scope) {
    var timers = this._delayCallTimers;
    if (timers === void 0) {
      OnInitDelayCallTimers(this);
    }
    var timer;
    var self = this;
    var OnTimeOut = function() {
      RemoveItem12(self._delayCallTimers, timer);
      if (scope) {
        callback.call(scope);
      } else {
        callback();
      }
    };
    timer = this.scene.time.delayedCall(delay, OnTimeOut);
    this._delayCallTimers.push(timer);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/Hide.js
var Show = function(gameObject2) {
  _hide(gameObject2, false);
};
var Hide = function(gameObject2) {
  _hide(gameObject2, true);
};
var IsShown = function(gameObject2) {
  if (!gameObject2) {
    return false;
  }
  var config = GetSizerConfig_default(gameObject2);
  return !config.hidden;
};
var _hide = function(gameObject2, hidden) {
  if (!gameObject2) {
    return;
  }
  var config = GetSizerConfig_default(gameObject2);
  config.hidden = hidden;
  var parent = GetParent(gameObject2);
  if (parent) {
    parent.setChildVisible(gameObject2, !hidden);
  } else {
    gameObject2.setVisible(!hidden);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/HideMethods.js
var HideMethods_default = {
  show(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    Show(gameObject2, false);
    return this;
  },
  hide(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    Hide(gameObject2, true);
    return this;
  },
  isShow(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    return IsShown(gameObject2);
  }
};

// node_modules/phaser3-rex-plugins/plugins/logic/fsm/FSMBase.js
var StateProperties = ["next", "exit", "enter"];
var FSM = class {
  /*
  var config = {
      start: 'A',   // default: undefined
      states: {
          A: {
              next: 'B',  // function() { return 'B'; }
              enter: function() {},
              exit: function() {},
          },
          // ...
      },        
      extend: {
          i: 0,
          name: 'abc'
          // ...
      },
      init: function() {},
      enable: true,
      eventEmitter: true,
  };
  */
  constructor(config) {
    var states = GetValue_default(config, "states", void 0);
    if (states) {
      this.addStates(states);
    }
    var extend = GetValue_default(config, "extend", void 0);
    if (extend) {
      for (var name2 in extend) {
        if (!this.hasOwnProperty(name2) || this[name2] === void 0) {
          this[name2] = extend[name2];
        }
      }
    }
    var eventEmitter = GetValue_default(config, "eventEmitter", void 0);
    var EventEmitterClass = GetValue_default(config, "EventEmitterClass", void 0);
    this.setEventEmitter(eventEmitter, EventEmitterClass);
    this._stateLock = false;
    this.resetFromJSON(config);
  }
  shutdown() {
    this.destroyEventEmitter();
  }
  destroy() {
    this.shutdown();
  }
  resetFromJSON(o) {
    this.setEnable(GetValue_default(o, "enable", true));
    this.start(GetValue_default(o, "start", void 0));
    var init = GetValue_default(o, "init", void 0);
    if (init) {
      init.call(this);
    }
    return this;
  }
  toJSON() {
    return {
      curState: this.state,
      prevState: this.prevState,
      enable: this.enable,
      start: this._start
    };
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  set state(newState) {
    if (!this.enable || this._stateLock) {
      return;
    }
    if (this._state === newState) {
      return;
    }
    this._prevState = this._state;
    this._state = newState;
    this._stateLock = true;
    this.emit("statechange", this);
    if (this._prevState != null) {
      var exitEventName = "exit_" + this._prevState;
      var exitCallback = this[exitEventName];
      if (exitCallback) {
        exitCallback.call(this);
      }
      this.emit(exitEventName, this);
    }
    this._stateLock = false;
    if (this._state != null) {
      var enterEventName = "enter_" + this._state;
      var enterCallback = this[enterEventName];
      if (enterCallback) {
        enterCallback.call(this);
      }
      this.emit(enterEventName, this);
    }
  }
  get state() {
    return this._state;
  }
  get prevState() {
    return this._prevState;
  }
  start(state) {
    this._start = state;
    this._prevState = void 0;
    this._state = state;
    return this;
  }
  goto(nextState) {
    if (nextState != null) {
      this.state = nextState;
    }
    return this;
  }
  next() {
    var nextState;
    var getNextState = this["next_" + this.state];
    if (getNextState) {
      if (typeof getNextState === "string") {
        nextState = getNextState;
      } else {
        nextState = getNextState.call(this);
      }
    }
    this.goto(nextState);
    return this;
  }
  get stateProperties() {
    return StateProperties;
  }
  addState(name2, state) {
    if (typeof name2 !== "string") {
      state = name2;
      name2 = state.name;
    }
    var stateProperties = this.stateProperties;
    for (var i = 0, cnt = stateProperties.length; i < cnt; i++) {
      var propertyName = stateProperties[i];
      var propertyValue = state[propertyName];
      if (propertyValue) {
        this[`${propertyName}_${name2}`] = propertyValue;
      }
    }
    return this;
  }
  addStates(states) {
    if (Array.isArray(states)) {
      for (var i = 0, cnt = states.length; i < cnt; i++) {
        this.addState(states[i]);
      }
    } else {
      for (var name2 in states) {
        this.addState(name2, states[name2]);
      }
    }
    return this;
  }
  runMethod(methodName, a1, a2, a3, a4, a5) {
    var fn = this[methodName + "_" + this.state];
    if (!fn) {
      return void 0;
    }
    var len = arguments.length;
    switch (len) {
      case 1:
        return fn.call(this);
      case 2:
        return fn.call(this, a1);
      case 3:
        return fn.call(this, a1, a2);
      case 4:
        return fn.call(this, a1, a2, a3);
      case 5:
        return fn.call(this, a1, a2, a3, a4);
      case 6:
        return fn.call(this, a1, a2, a3, a4, a5);
    }
    var args = new Array(len - 1);
    for (var i = 1; i < len; i++) {
      args[i - 1] = arguments[i];
    }
    return fn.apply(this, args);
  }
};
Object.assign(
  FSM.prototype,
  StandAloneEventEmitterMethods_default
);
var FSMBase_default = FSM;

// node_modules/phaser3-rex-plugins/plugins/utils/eventemitter/HasListener.js
var HasListener = function(eventEmitter, eventName, fn, context, once) {
  if (once === void 0) {
    once = false;
  }
  var listeners = eventEmitter._events[eventName];
  if (!listeners) {
    return false;
  }
  for (var i = 0, cnt = listeners.length; i < cnt; i++) {
    var listener = listeners[i];
    if (listener.fn === fn && listener.context === context && listener.once === once) {
      return true;
    }
  }
  return false;
};
var HasListener_default = HasListener;

// node_modules/phaser3-rex-plugins/plugins/logic/fsm/FSM.js
var StateProperties2 = ["next", "exit", "enter", "update", "preupdate", "postupdate"];
var FSM2 = class extends FSMBase_default {
  /*
  var config = {
      start: 'A',   // default: undefined
      states: {
          A: {
              next: 'B',  // function() { return 'B'; }
              enter: function() {},
              exit: function() {},
              update: function(time, delta) {},
              preupdate: function(time, delta) {},
              postupdate: function(time, delta) {},
          },
          // ...
      },        
      extend: {
          i: 0,
          name: 'abc'
          // ...
      },
      init: function() {},
      enable: true,
      scene: undefined,
      eventEmitter: true,
  };
  */
  shutdown() {
    this.stopUpdate();
    this.stopPreUpdate();
    this.stopPostUpdate();
    this._scene = void 0;
    super.shutdown();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this._scene = GetValue_default(o, "scene", void 0);
    return this;
  }
  get stateProperties() {
    return StateProperties2;
  }
  update(time, delta) {
    this.runMethod("update", time, delta);
  }
  preupdate(time, delta) {
    this.runMethod("preupdate", time, delta);
  }
  postupdate(time, delta) {
    this.runMethod("postupdate", time, delta);
  }
  startUpdate(scene) {
    if (!scene) {
      scene = this._scene;
    }
    var eventEmitter = scene.sys.events;
    if (HasListener_default(eventEmitter, "update", this.update, this)) {
      return this;
    }
    this._scene = scene;
    eventEmitter.on("update", this.update, this);
    return this;
  }
  stopUpdate() {
    if (!this._scene) {
      return this;
    }
    this._scene.sys.events.off("update", this.update, this);
    return this;
  }
  startPreUpdate(scene) {
    if (!scene) {
      scene = this._scene;
    }
    var eventEmitter = scene.sys.events;
    if (HasListener_default(eventEmitter, "preupdate", this.preupdate, this)) {
      return this;
    }
    this._scene = scene;
    eventEmitter.on("preupdate", this.preupdate, this);
    return this;
  }
  stopPreUpdate() {
    if (!this._scene) {
      return this;
    }
    this._scene.sys.events.off("preupdate", this.preupdate, this);
    return this;
  }
  startPostUpdate(scene) {
    if (!scene) {
      scene = this._scene;
    }
    var eventEmitter = scene.sys.events;
    if (HasListener_default(eventEmitter, "postupdate", this.postupdate, this)) {
      return this;
    }
    this._scene = scene;
    eventEmitter.on("postupdate", this.postupdate, this);
    return this;
  }
  stopPostUpdate() {
    if (!this._scene) {
      return this;
    }
    this._scene.sys.events.off("postupdate", this.postupdate, this);
    return this;
  }
};
var FSM_default = FSM2;

// node_modules/phaser3-rex-plugins/plugins/fsm.js
var fsm_default = FSM_default;

// node_modules/phaser3-rex-plugins/plugins/behaviors/openclosetransition/State.js
var State = class extends fsm_default {
  constructor(parent, config) {
    super(config);
    this.parent = parent;
    var initState = config.initState || "IDLE";
    this.start(initState);
  }
  init() {
    this.start("IDLE");
  }
  // IDLE -> TRANS_OPNE
  next_IDLE() {
    return "TRANS_OPNE";
  }
  // IDLE
  // TRANS_OPNE -> OPEN
  next_TRANS_OPNE() {
    return "OPEN";
  }
  enter_TRANS_OPNE() {
    var transitionBehavior = this.parent;
    if (transitionBehavior.transitInTime > 0) {
      var delay = transitionBehavior.runTransitionInCallback();
      transitionBehavior.delayCall(delay, this.next, this);
    } else {
      this.next();
    }
  }
  exit_TRANS_OPNE() {
    var transitionBehavior = this.parent;
    transitionBehavior.removeDelayCall();
  }
  // TRANS_OPNE
  // OPEN -> TRANS_CLOSE
  next_OPEN() {
    return "TRANS_CLOSE";
  }
  enter_OPEN() {
    var transitionBehavior = this.parent;
    transitionBehavior.onOpen();
  }
  exit_OPEN() {
    var transitionBehavior = this.parent;
    transitionBehavior.removeDelayCall();
  }
  // OPEN
  // TRANS_CLOSE -> CLOSE
  next_TRANS_CLOSE() {
    return "CLOSE";
  }
  enter_TRANS_CLOSE() {
    var transitionBehavior = this.parent;
    if (transitionBehavior.transitOutTime > 0) {
      var delay = transitionBehavior.runTransitionOutCallback();
      transitionBehavior.delayCall(delay, this.next, this);
    } else {
      this.next();
    }
  }
  exit_TRANS_CLOSE() {
    var transitionBehavior = this.parent;
    transitionBehavior.removeDelayCall();
  }
  // TRANS_CLOSE
  // CLOSE -> TRANS_OPNE
  next_CLOSE() {
    return "TRANS_OPNE";
  }
  enter_CLOSE() {
    var transitionBehavior = this.parent;
    transitionBehavior.onClose();
  }
  exit_CLOSE() {
  }
  // CLOSE
  canOpen() {
    return this.state === "IDLE" || this.state === "CLOSE";
  }
  canClose() {
    return this.state === "IDLE" || this.state === "OPEN";
  }
};
var State_default = State;

// node_modules/phaser3-rex-plugins/plugins/utils/time/PostStepDelayCall.js
var PostStepDelayCall = function(gameObject2, delay, callback, scope, args) {
  var scene = GetSceneObject_default(gameObject2);
  var timer = scene.time.delayedCall(delay, function() {
    scene.game.events.once("poststep", function() {
      callback.call(scope, args);
    });
  });
  return timer;
};
var PostStepDelayCall_default = PostStepDelayCall;

// node_modules/phaser3-rex-plugins/plugins/behaviors/openclosetransition/methods/DelayCallMethods.js
var DelayCallMethods_default2 = {
  delayCall(delay, callback, scope) {
    this.delayCallTimer = PostStepDelayCall_default(this, delay, callback, scope);
    return this;
  },
  removeDelayCall() {
    if (this.delayCallTimer) {
      this.delayCallTimer.remove(false);
      this.delayCallTimer = void 0;
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/openclosetransition/methods/ConfigurationMethods.js
var ConfigurationMethods_default = {
  setTransitInTime(time) {
    this.transitInTime = time;
    return this;
  },
  setTransitOutTime(time) {
    this.transitOutTime = time;
    return this;
  },
  setTransitInCallback(callback) {
    if (!callback) {
      callback = NOOP_default;
    }
    this.transitInCallback = callback;
    return this;
  },
  setTransitOutCallback(callback) {
    if (!callback) {
      callback = NOOP_default;
    }
    this.transitOutCallback = callback;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/openclosetransition/methods/OpenMethods.js
var OpenMethods_default = {
  // Override
  runTransitionInCallback() {
    this.transitInCallback(this.parent, this.transitInTime);
    return this.transitInTime;
  },
  // Override
  onOpen() {
  },
  requestOpen(openEventData, duration) {
    if (!this._state.canOpen()) {
      return this;
    }
    this.openEventData = arguments.length > 0 ? openEventData : this.parent;
    var transitionTimeSave = this.transitInTime;
    if (duration !== void 0) {
      this.transitInTime = duration;
    }
    this._state.goto("TRANS_OPNE");
    this.transitInTime = transitionTimeSave;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/openclosetransition/methods/CloseMethods.js
var CloseMethods_default = {
  // Override
  runTransitionOutCallback() {
    this.transitOutCallback(this.parent, this.transitOutTime);
    return this.transitOutTime;
  },
  // Override
  onClose() {
    if (this.oneShotMode) {
      this.parent.destroy();
    }
  },
  requestClose(closeEventData, duration) {
    if (!this._state.canClose) {
      return this;
    }
    this.closeEventData = arguments.length > 0 ? closeEventData : this.parent;
    var transitionTimeSave = this.transitOutTime;
    if (duration !== void 0) {
      this.transitOutTime = duration;
    }
    this._state.goto("TRANS_CLOSE");
    this.transitOutTime = transitionTimeSave;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/openclosetransition/methods/Methods.js
var methods15 = {};
Object.assign(
  methods15,
  DelayCallMethods_default2,
  ConfigurationMethods_default,
  OpenMethods_default,
  CloseMethods_default
);
var Methods_default17 = methods15;

// node_modules/phaser3-rex-plugins/plugins/behaviors/openclosetransition/OpenCloseTransition.js
var GetValue78 = Phaser.Utils.Objects.GetValue;
var OpenCloseTransition = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.setTransitInTime(GetValue78(config, "duration.in", 200));
    this.setTransitOutTime(GetValue78(config, "duration.out", 200));
    this.setTransitInCallback(GetValue78(config, "transitIn"));
    this.setTransitOutCallback(GetValue78(config, "transitOut"));
    this.oneShotMode = GetValue78(config, "destroy", false);
    this.delayCallTimer = void 0;
    this._state = new State_default(this, {
      eventEmitter: false,
      initState: GetValue78(config, "initState", "IDLE")
    });
    this.openEventData = void 0;
    this.closeEventData = void 0;
  }
  get state() {
    return this._state.state;
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.transitInCallback = void 0;
    this.transitOutCallback = void 0;
    this.openEventData = void 0;
    this.closeEventData = void 0;
    this.removeDelayCall();
    super.shutdown(fromScene);
  }
};
Object.assign(
  OpenCloseTransition.prototype,
  Methods_default17
);
var OpenCloseTransition_default = OpenCloseTransition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/fullwindow/fullwindowrectangle/FullWindowRectangle.js
var Rectangle7 = Phaser.GameObjects.Rectangle;
var FullWindowRectangle2 = class extends Rectangle7 {
  constructor(scene, color, alpha) {
    super(scene, 0, 0, 2, 2, color, 1);
    this.fullWindow = new FullWindow_default(this);
    this.setAlpha(alpha);
  }
  get tint() {
    return this.fillColor;
  }
  set tint(value) {
    this.setFillStyle(value, this.fillAlpha);
  }
};
var FullWindowRectangle_default = FullWindowRectangle2;

// node_modules/phaser3-rex-plugins/plugins/fullwindowrectangle.js
var fullwindowrectangle_default = FullWindowRectangle_default;

// node_modules/phaser3-rex-plugins/plugins/input/toucheventstop/TouchEventStop.js
var GetValue79 = Phaser.Utils.Objects.GetValue;
var TouchEventStop = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, { eventEmitter: false });
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.setHitAreaMode(GetValue79(o, "hitAreaMode", 0));
    this.setEnable(GetValue79(o, "enable", true));
    this.setStopMode(GetValue79(o, "stopAllLevels", true));
    return this;
  }
  boot() {
    this.parent.on("pointerdown", function(pointer, localX, localY, event) {
      if (this.stopAllLevels) {
        event.stopPropagation();
      }
    }, this).on("pointerup", function(pointer, localX, localY, event) {
      if (this.stopAllLevels) {
        event.stopPropagation();
      }
    }, this).on("pointermove", function(pointer, localX, localY, event) {
      if (this.stopAllLevels) {
        event.stopPropagation();
      }
    }, this).on("pointerover", function(pointer, localX, localY, event) {
      if (this.stopAllLevels) {
        event.stopPropagation();
      }
    }, this).on("pointerout", function(pointer, event) {
      if (this.stopAllLevels) {
        event.stopPropagation();
      }
    }, this);
  }
  setHitAreaMode(mode) {
    if (typeof mode === "string") {
      mode = HitAreaMode[mode];
    }
    var gameObject2 = this.parent;
    if (gameObject2.input) {
      gameObject2.removeInteractive();
    }
    if (mode === 0) {
      gameObject2.setInteractive();
    } else {
      gameObject2.setInteractive({
        hitArea: {},
        hitAreaCallback: function() {
          return true;
        }
      });
    }
    return this;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    if (e) {
      this.parent.setInteractive();
    } else {
      this.parent.disableInteractive();
    }
    this.enable = e;
    return this;
  }
  setStopMode(allLevels) {
    if (allLevels === void 0) {
      allLevels = true;
    }
    this.stopAllLevels = allLevels;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
};
var HitAreaMode = {
  default: 0,
  fullWindow: 1
};
var TouchEventStop_default = TouchEventStop;

// node_modules/phaser3-rex-plugins/plugins/toucheventstop.js
var toucheventstop_default = TouchEventStop_default;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/cover/Cover.js
var GetValue80 = Phaser.Utils.Objects.GetValue;
var Cover = class extends fullwindowrectangle_default {
  constructor(scene, config) {
    var fillColor = GetValue80(config, "color", 0);
    var fillAlpha = GetValue80(config, "alpha", 0.8);
    super(scene, fillColor, fillAlpha);
    this.touchEventStop = new toucheventstop_default(this, { hitAreaMode: 1 });
  }
};
var Cover_default = Cover;

// node_modules/phaser3-rex-plugins/plugins/behaviors/modal/CreateCover.js
var CreateCover = function(gameObject2, config) {
  var scene = gameObject2.scene;
  var cover = new Cover_default(scene, config);
  scene.add.existing(cover);
  if (gameObject2.isRexContainerLite) {
    gameObject2.pin(cover, {
      syncPosition: false,
      syncRotation: false,
      syncScale: false,
      syncAlpha: false,
      syncScrollFactor: false
    });
    gameObject2.moveDepthBelow(cover);
  } else {
    scene.children.moveBelow(cover, gameObject2);
  }
  return cover;
};
var CreateCover_default = CreateCover;

// node_modules/phaser3-rex-plugins/plugins/behaviors/modal/DefaultTransitCallbacks.js
var DefaultTransitCallbacks_default = {
  popUp(gameObject2, duration) {
    if (gameObject2._modalScaleSave !== void 0) {
      gameObject2.scaleX = gameObject2._modalScaleSave;
      gameObject2.scaleY = gameObject2._modalScaleSave;
    } else {
      gameObject2._modalScaleSave = gameObject2.scaleX;
    }
    popup_default(gameObject2, duration);
  },
  scaleDown(gameObject2, duration) {
    scale_down_destroy_default(gameObject2, duration, void 0, void 0, false);
  },
  fadeIn(gameObject2, duration) {
    if (gameObject2._modalAlphaSave !== void 0) {
      gameObject2.alpha = gameObject2._modalAlphaSave;
    } else {
      gameObject2._modalAlphaSave = gameObject2.alpha;
    }
    fade_in_default(gameObject2, duration);
  },
  fadeOut(gameObject2, duration) {
    fade_out_destroy_default(gameObject2, duration, false);
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/modal/DefaultCoverTransitCallbacks.js
var DefaultCoverTransitInCallback = function(cover, duration) {
  if (cover._modalAlphaSave !== void 0) {
    cover.alpha = cover._modalAlphaSave;
  } else {
    cover._modalAlphaSave = cover.alpha;
  }
  fade_in_default(cover, duration, cover.alpha);
};
var DefaultCoverTransitOutCallback = function(cover, duration) {
  fade_out_destroy_default(cover, duration, false);
};

// node_modules/phaser3-rex-plugins/plugins/utils/bounds/IsPointInBounds.js
var IsPointInBounds = function(gameObject2, x, y, preTest, postTest) {
  if (!gameObject2) {
    return false;
  }
  if (preTest && !preTest(gameObject2, x, y)) {
    return false;
  }
  var boundsRect = GetBounds(gameObject2, true);
  if (!boundsRect.contains(x, y)) {
    return false;
  }
  if (postTest && !postTest(gameObject2, x, y)) {
    return false;
  }
  return true;
};
var IsPointInBounds_default = IsPointInBounds;

// node_modules/phaser3-rex-plugins/plugins/behaviors/modal/Modal.js
var GetValue81 = Phaser.Utils.Objects.GetValue;
var Modal = class extends OpenCloseTransition_default {
  constructor(gameObject2, config) {
    if (config === void 0) {
      config = {};
    }
    if (config.transitIn == null) {
      config.transitIn = TransitionMode.popUp;
    }
    if (config.transitOut == null) {
      config.transitOut = TransitionMode.scaleDown;
    }
    config.destroy = GetValue81(config, "destroy", true);
    super(gameObject2, config);
    var coverConfig = GetValue81(config, "cover");
    this.cover = coverConfig !== false ? CreateCover_default(gameObject2, coverConfig) : void 0;
    if (this.cover) {
      this.setCoverTransitInCallback(GetValue81(coverConfig, "transitIn", DefaultCoverTransitInCallback));
      this.setCoverTransitOutCallback(GetValue81(coverConfig, "transitOut", DefaultCoverTransitOutCallback));
    }
    var touchOutsideClose = GetValue81(config, "touchOutsideClose", false);
    var timeOutDuration = GetValue81(config, "duration.hold", -1);
    var timeOutClose = GetValue81(config, "timeOutClose", timeOutDuration >= 0);
    var anyTouchClose = GetValue81(config, "anyTouchClose", false);
    var manualClose = GetValue81(config, "manualClose", false);
    if (manualClose) {
      touchOutsideClose = false;
      anyTouchClose = false;
      timeOutClose = false;
    }
    if (anyTouchClose) {
      touchOutsideClose = false;
    }
    if (timeOutClose) {
      this.setDisplayTime(timeOutDuration);
    } else {
      this.setDisplayTime(-1);
    }
    if (anyTouchClose) {
      this.once("open", this.anyTouchClose, this);
    } else if (touchOutsideClose) {
      this.once("open", this.touchOutsideClose, this);
    }
    if (GetValue81(config, "openOnStart", true)) {
      this.delayCall(0, this.requestOpen, this);
    }
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    if (!this.cover) {
      this.scene.input.off("pointerup", this.touchCloseCallback, this);
    }
    if (this.cover && !fromScene) {
      this.cover.destroy();
      this.cover = void 0;
    }
    super.shutdown(fromScene);
  }
  touchOutsideClose() {
    if (this.cover) {
      this.cover.on("pointerup", this.touchCloseCallback, this);
    } else {
      this.scene.input.on("pointerup", this.touchCloseCallback, this);
    }
    this.clickOutsideTest = true;
    return this;
  }
  anyTouchClose() {
    if (this.cover) {
      this.cover.once("pointerup", this.touchCloseCallback, this);
    } else {
      this.scene.input.once("pointerup", this.touchCloseCallback, this);
    }
    return this;
  }
  touchCloseCallback(pointer) {
    if (this.clickOutsideTest && IsPointInBounds_default(this.parent, pointer.worldX, pointer.worldY)) {
      return;
    }
    this.requestClose();
  }
  runTransitionInCallback() {
    var duration = super.runTransitionInCallback();
    var cover = this.cover;
    if (cover && this.coverTransitInCallback) {
      this.coverTransitInCallback(cover, duration);
    }
    return duration;
  }
  runTransitionOutCallback() {
    var duration = super.runTransitionOutCallback();
    var cover = this.cover;
    if (cover && this.coverTransitOutCallback) {
      this.coverTransitOutCallback(cover, duration);
    }
    return duration;
  }
  onOpen() {
    var duration = this.displayTime;
    if (duration >= 0) {
      this.delayCall(
        duration,
        this.requestClose,
        // callback
        this
        // scope
      );
    }
    this.emit("open", this.parent, this);
    super.onOpen();
  }
  onClose() {
    this.emit("close", this.closeEventData);
    super.onClose();
  }
  setDisplayTime(time) {
    this.displayTime = time;
    return this;
  }
  setTransitInCallback(callback) {
    if (typeof callback === "string") {
      callback = TransitionMode[callback];
    }
    switch (callback) {
      case TransitionMode.popUp:
        callback = DefaultTransitCallbacks_default.popUp;
        break;
      case TransitionMode.fadeIn:
        callback = DefaultTransitCallbacks_default.fadeIn;
        break;
    }
    super.setTransitInCallback(callback);
    return this;
  }
  setTransitOutCallback(callback) {
    if (typeof callback === "string") {
      callback = TransitionMode[callback];
    }
    switch (callback) {
      case TransitionMode.scaleDown:
        callback = DefaultTransitCallbacks_default.scaleDown;
        break;
      case TransitionMode.fadeOut:
        callback = DefaultTransitCallbacks_default.fadeOut;
        break;
    }
    super.setTransitOutCallback(callback);
    return this;
  }
  setCoverTransitInCallback(callback) {
    this.coverTransitInCallback = callback;
    return this;
  }
  setCoverTransitOutCallback(callback) {
    this.coverTransitOutCallback = callback;
    return this;
  }
};
var TransitionMode = {
  popUp: 0,
  fadeIn: 1,
  scaleDown: 0,
  fadeOut: 1
};
var Modal_default = Modal;

// node_modules/phaser3-rex-plugins/plugins/behaviors/modal/ModalPromise.js
var Modal2 = function(gameObject2, config) {
  var modalBehavior = new Modal_default(gameObject2, config);
  modalBehavior.on("open", function() {
    gameObject2.emit("modal.open", modalBehavior);
  });
  modalBehavior.on("close", function(closeEventData) {
    gameObject2.emit("modal.close", closeEventData, modalBehavior);
  });
  gameObject2.on("modal.requestClose", modalBehavior.requestClose, modalBehavior);
  return modalBehavior;
};
var ModalPromise = function(gameObject2, config) {
  var modalBehavior = Modal2(gameObject2, config);
  return new Promise(function(resolve, reject) {
    modalBehavior.once("close", function(closeEventData) {
      resolve(closeEventData);
    });
  });
};
var ModalClose = function(gameObject2, closeEventData) {
  gameObject2.emit("modal.requestClose", closeEventData);
};

// node_modules/phaser3-rex-plugins/plugins/utils/object/IsFunction.js
var IsFunction = function(obj) {
  return obj && typeof obj === "function";
};
var IsFunction_default = IsFunction;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ModalMethods.js
var ModalMethods_default = {
  // Override
  // onCreateModalBehavior(self, config) { },
  modal(config, onClose) {
    if (IsFunction_default(config)) {
      onClose = config;
      config = void 0;
    }
    if (this._modalBehavior === void 0) {
      if (this.onCreateModalBehavior) {
        this.onCreateModalBehavior(this, config);
      }
      this._modalBehavior = Modal2(this, config);
    }
    if (onClose) {
      this._modalBehavior.once("close", onClose);
    }
    this._modalBehavior.requestOpen();
    return this;
  },
  modalPromise(config) {
    var self = this;
    return new Promise(function(resolve, reject) {
      self.modal(config, resolve);
    });
  },
  modalClose(closeEventData) {
    ModalClose(this, closeEventData);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/gameobject/addevent/BindEventWithGameObject.js
var BindEventWithGameObject = function(gameObject2, eventEmitter, eventName, callback, scope, once) {
  if (once === void 0) {
    once = false;
  }
  eventEmitter[once ? "once" : "on"](eventName, callback, scope);
  gameObject2.once("destroy", function() {
    eventEmitter.off(eventName, callback, scope);
  });
  return gameObject2;
};
var BindEventWithGameObject_default = BindEventWithGameObject;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/BindEventMethods.js
var BindSceneEvent = function(eventName, gameObject2, callback, scope, once) {
  if (IsFunction_default(gameObject2)) {
    once = scope;
    scope = callback;
    callback = gameObject2;
    gameObject2 = this;
  }
  var eventEmitter = this.scene.events;
  this.bindEvent(gameObject2, eventEmitter, eventName, callback, scope, once);
  return this;
};
var BindEventMethods_default = {
  bindEvent(gameObject2, eventEmitter, eventName, callback, scope, once) {
    if (typeof eventEmitter === "string") {
      once = scope;
      scope = callback;
      callback = eventName;
      eventName = eventEmitter;
      eventEmitter = gameObject2;
      gameObject2 = this;
    }
    BindEventWithGameObject_default(gameObject2, eventEmitter, eventName, callback, scope, once);
    return this;
  },
  bindScenePreupdateEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "preupdate", gameObject2, callback, scope, once);
    return this;
  },
  bindSceneUpdateEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "update", gameObject2, callback, scope, once);
    return this;
  },
  bindScenePostupdateEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "postupdate", gameObject2, callback, scope, once);
    return this;
  },
  bindSceneRenderEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "render", gameObject2, callback, scope, once);
    return this;
  },
  bindScenePauseEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "pause", gameObject2, callback, scope, once);
    return this;
  },
  bindSceneResumeEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "resume", gameObject2, callback, scope, once);
    return this;
  },
  bindSceneSleepEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "sleep", gameObject2, callback, scope, once);
    return this;
  },
  bindSceneWakeEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "wake", gameObject2, callback, scope, once);
    return this;
  },
  bindSceneShutdownEvent(gameObject2, callback, scope, once) {
    BindSceneEvent.call(this, "shutdown", gameObject2, callback, scope, once);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/input/GetPointerWorldXY.js
var GetPointerWorldXY = function(pointer, targetCamera, out2) {
  var camera = pointer.camera;
  if (!camera) {
    return null;
  }
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = globalOut;
  }
  if (camera === targetCamera) {
    out2.x = pointer.worldX;
    out2.y = pointer.worldY;
  } else {
    camera.getWorldPoint(pointer.x, pointer.y, out2);
  }
  return out2;
};
var globalOut = {};
var GetPointerWorldXY_default = GetPointerWorldXY;

// node_modules/phaser3-rex-plugins/plugins/utils/input/PointerTest.js
var PointerTest = function(gameObject2, pointer, mainTest, preTest, postTest) {
  var mainCamera = gameObject2.scene.sys.cameras.main, worldXY;
  var useScreenXY = gameObject2.scrollFactorX === 0 && gameObject2.scrollFactorY === 0;
  if (pointer) {
    if (useScreenXY) {
      return mainTest(gameObject2, pointer.x, pointer.y, preTest, postTest);
    } else {
      worldXY = GetPointerWorldXY_default(pointer, mainCamera, true);
      if (!worldXY) {
        return false;
      }
      return mainTest(gameObject2, worldXY.x, worldXY.y, preTest, postTest);
    }
  } else {
    var inputManager = gameObject2.scene.input.manager;
    var pointersTotal = inputManager.pointersTotal;
    var pointers = inputManager.pointers;
    for (var i = 0; i < pointersTotal; i++) {
      pointer = pointers[i];
      if (useScreenXY) {
        if (mainTest(gameObject2, pointer.x, pointer.y, preTest, postTest)) {
          return true;
        }
      } else {
        worldXY = GetPointerWorldXY_default(pointer, mainCamera, true);
        if (!worldXY) {
          continue;
        }
        if (mainTest(gameObject2, worldXY.x, worldXY.y, preTest, postTest)) {
          return true;
        }
      }
    }
    return false;
  }
  1;
};
var PointerTest_default = PointerTest;

// node_modules/phaser3-rex-plugins/plugins/utils/input/IsPointerInBounds.js
var IsPointerInBounds = function(gameObject2, pointer, preTest, postTest) {
  return PointerTest_default(gameObject2, pointer, IsPointInBounds_default, preTest, postTest);
};
var IsPointerInBounds_default = IsPointerInBounds;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/IsInTouching.js
var IsInTouching = function(pointer, gameObject2) {
  if (IsGameObject_default(pointer) || typeof pointer === "string") {
    gameObject2 = pointer;
    pointer = void 0;
  }
  if (gameObject2 === void 0) {
    gameObject2 = this;
  } else if (typeof gameObject2 === "string") {
    gameObject2 = this.getElement(gameObject2);
  }
  return IsPointerInBounds_default(gameObject2, pointer);
};
var IsInTouching_default = IsInTouching;

// node_modules/phaser3-rex-plugins/plugins/utils/object/IsArray.js
var IsArray = function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};
var IsArray_default = IsArray;

// node_modules/phaser3-rex-plugins/templates/ui/utils/ContainsPoint.js
var ContainsPoint = function(gameObject2, x, y, preTest, postTest) {
  return IsPointInBounds_default(
    gameObject2,
    x,
    y,
    GetPreTestCallback(preTest),
    postTest
  );
};
var IsShownSizer = function(gameObject2) {
  var isHiddenSizer = gameObject2.rexSizer && gameObject2.rexSizer.hidden;
  return !isHiddenSizer;
};
var GetPreTestCallback = function(preTest) {
  if (!preTest) {
    return IsShownSizer;
  }
  return function(gameObject2, x, y) {
    if (!IsShownSizer(gameObject2)) {
      return false;
    }
    preTest(gameObject2, x, y);
    return true;
  };
};
var ContainsPoint_default = ContainsPoint;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/PointToChild.js
var PointToChild = function(x, y, preTest, postTest, children) {
  if (!IsFunction_default(preTest)) {
    children = preTest;
    preTest = void 0;
    postTest = void 0;
  }
  if (children === void 0) {
    if (this.sizerChildren) {
      children = this.sizerChildren;
    } else if (this.isRexContainerLite) {
      children = this.children;
    } else {
      children = this.list;
    }
  }
  if (IsArray_default(children)) {
    var child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (ContainsPoint_default(child, x, y, preTest, postTest)) {
        return child;
      }
    }
  } else {
    var child;
    for (var key2 in children) {
      child = children[key2];
      if (ContainsPoint_default(child, x, y, preTest, postTest)) {
        return child;
      }
    }
  }
  return null;
};
var PointToChild_default = PointToChild;

// node_modules/phaser3-rex-plugins/templates/ui/utils/CopyState.js
var CopyState = function(gamObject, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = GlobState;
  }
  out2.x = gamObject.x;
  out2.y = gamObject.y;
  out2.scaleX = gamObject.scaleX;
  out2.scaleY = gamObject.scaleY;
  out2.width = gamObject.width;
  out2.height = gamObject.height;
  out2.displayWidth = gamObject.displayWidth;
  out2.displayHeight = gamObject.displayHeight;
  return out2;
};
var GlobState = {};
var CopyState_default = CopyState;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/utils/PreLayoutChild.js
var PreLayoutChild = function(child) {
  if (this.sizerEventsEnable) {
    CopyState_default(child, this.getChildPrevState(child));
    this.layoutedChildren.push(child);
  }
};
var PreLayoutChild_default = PreLayoutChild;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/utils/LayoutChild.js
var LayoutChild = function(child, x, y, width, height, align, offsetX, offsetY) {
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  AlignIn_default(child, x, y, width, height, align);
  child.x += offsetX;
  child.y += offsetY;
  this.resetChildPositionState(child);
  if (this.sizerEventsEnable) {
    child.emit("sizer.postlayout", child, this);
  }
};
var LayoutChild_default = LayoutChild;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/LayoutBackgrounds.js
var ALIGN_CENTER = Phaser.Display.Align.CENTER;
var LayoutBackgrounds = function() {
  if (this.backgroundChildren === void 0) {
    return;
  }
  var backgrounds = this.backgroundChildren;
  var startX = this.left, startY = this.top;
  var parentWidth = this.width * this.scaleX, parentHeight = this.height * this.scaleY;
  var child, childConfig, padding, x, y, width, height;
  for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
    child = backgrounds[i];
    childConfig = child.rexSizer;
    if (childConfig.hidden) {
      continue;
    }
    padding = childConfig.padding;
    PreLayoutChild_default.call(this, child);
    x = startX + padding.left * this.scaleX;
    y = startY + padding.top * this.scaleY;
    width = parentWidth - (padding.left + padding.right) * this.scaleX;
    height = parentHeight - (padding.top + padding.bottom) * this.scaleY;
    ResizeGameObject_default(child, width, height);
    LayoutChild_default.call(
      this,
      child,
      x,
      y,
      width,
      height,
      ALIGN_CENTER,
      0,
      0
    );
  }
};
var LayoutBackgrounds_default = LayoutBackgrounds;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/SetDraggable.js
var IsPlainObject27 = Phaser.Utils.Objects.IsPlainObject;
var SetDraggable = function(sensor, draggable, dragTarget) {
  if (IsPlainObject27(sensor)) {
    var config = sensor;
    sensor = config.sensor;
    dragTarget = config.target;
    draggable = config.draggable;
  } else {
    if (typeof draggable !== "boolean") {
      dragTarget = draggable;
      draggable = void 0;
    }
  }
  var sensorType = typeof sensor;
  if (sensorType === "string") {
    var sensorName = sensor;
    sensor = this.getElement(sensorName);
    if (!sensor) {
      console.error(`Can get element '${sensorName}'`);
      return this;
    }
  } else if (sensor === void 0 || sensorType != "object") {
    draggable = sensor;
    sensor = this;
  }
  if (draggable === void 0) {
    draggable = true;
  }
  if (sensor.input && sensor.input._rexUIDragSizer) {
    sensor.input.draggable = draggable;
  } else if (draggable) {
    sensor.setInteractive();
    sensor.scene.input.setDraggable(sensor);
    sensor.on("drag", function(pointer, dragX, dragY) {
      var currentDragTarget = dragTarget === void 0 ? this.getTopmostSizer() : dragTarget;
      currentDragTarget.x += dragX - sensor.x;
      currentDragTarget.y += dragY - sensor.y;
      currentDragTarget.emit("sizer.drag", pointer, dragX, dragY);
    }, this).on("dragstart", function(pointer, dragX, dragY) {
      var currentDragTarget = dragTarget === void 0 ? this.getTopmostSizer() : dragTarget;
      currentDragTarget.emit("sizer.dragstart", pointer, dragX, dragY);
    }, this).on("dragend", function(pointer, dragX, dragY, dropped) {
      var currentDragTarget = dragTarget === void 0 ? this.getTopmostSizer() : dragTarget;
      currentDragTarget.emit("sizer.dragend", pointer, dragX, dragY, dropped);
    }, this).on("drop", function(pointer, dropZone) {
      var currentDragTarget = dragTarget === void 0 ? this.getTopmostSizer() : dragTarget;
      currentDragTarget.emit("sizer.drop", pointer, dropZone);
    });
    sensor.input._rexUIDragSizer = true;
  } else {
  }
  return this;
};
var SetDraggable_default = SetDraggable;

// node_modules/phaser3-rex-plugins/plugins/button.js
var button_default = Button_default;

// node_modules/phaser3-rex-plugins/templates/ui/click/Click.js
var Click_default = button_default;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ClickMethods.js
var ClickMethods_default = {
  onClick(gameObject2, callback, scope, config) {
    if (!gameObject2) {
      return this;
    }
    if (typeof gameObject2 === "function") {
      config = scope;
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._click === void 0) {
      gameObject2._click = new Click_default(gameObject2, config);
    }
    gameObject2._click.on("click", callback, scope);
    return this;
  },
  offClick(gameObject2, callback, scope) {
    if (typeof gameObject2 === "function") {
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._click === void 0) {
      return this;
    }
    gameObject2._click.off("click", callback, scope);
    return this;
  },
  enableClick(gameObject2, enabled) {
    if (typeof gameObject2 === "boolean") {
      enabled = gameObject2;
      gameObject2 = void 0;
    }
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    if (gameObject2._click === void 0) {
      return this;
    }
    gameObject2._click.setEnable(enabled);
    return this;
  },
  disableClick(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    if (gameObject2._click === void 0) {
      return this;
    }
    gameObject2._click.setEnable(false);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/input/clickoutside/ClickOutside.js
var GetValue82 = Phaser.Utils.Objects.GetValue;
var ClickOutside = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this._enable = void 0;
    var inputConfig = GetValue82(config, "inputConfig", void 0);
    if (inputConfig) {
      gameObject2.setInteractive(inputConfig);
    }
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.pointer = void 0;
    this.lastClickTime = void 0;
    this.setEnable(GetValue82(o, "enable", true));
    this.setMode(GetValue82(o, "mode", 1));
    this.setClickInterval(GetValue82(o, "clickInterval", 100));
    this.setDragThreshold(GetValue82(o, "threshold", void 0));
    return this;
  }
  boot() {
    var scene = this.parent.scene;
    scene.input.on("pointerdown", this.onPress, this);
    scene.input.on("pointerup", this.onRelease, this);
    scene.input.on("pointermove", this.onMove, this);
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    var scene = this.parent.scene;
    scene.input.off("pointerdown", this.onPress, this);
    scene.input.off("pointerup", this.onRelease, this);
    scene.input.off("pointermove", this.onMove, this);
    this.pointer = null;
    super.shutdown(fromScene);
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.cancel();
    }
    this._enable = e;
    var eventName = e ? "enable" : "disable";
    this.emit(eventName, this, this.parent);
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  setMode(m) {
    if (typeof m === "string") {
      m = CLICKMODE2[m];
    }
    this.mode = m;
    return this;
  }
  setClickInterval(interval) {
    this.clickInterval = interval;
    return this;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
  isPointerInside(pointer) {
    var gameObject2 = this.parent;
    var isInsideCallback = gameObject2.input ? IsPointerInHitArea_default : IsPointerInBounds_default;
    return isInsideCallback(gameObject2, pointer);
  }
  // internal
  onPress(pointer) {
    if (!this.parent.willRender(pointer.camera)) {
      return;
    }
    if (this.pointer !== void 0) {
      return;
    }
    if (this.isPointerInside(pointer)) {
      return;
    }
    this.pointer = pointer;
    if (this.mode === 0) {
      if (!this.isPointerInside(pointer)) {
        this.click(pointer.downTime, pointer);
      }
    }
  }
  onRelease(pointer) {
    if (!this.parent.willRender(pointer.camera)) {
      return;
    }
    if (this.pointer !== pointer) {
      return;
    }
    if (this.mode === 1) {
      if (!this.isPointerInside(pointer)) {
        this.click(pointer.upTime, pointer);
      }
    }
    this.pointer = void 0;
  }
  onMove(pointer, localX, localY, event) {
    if (this.pointer !== pointer) {
      return;
    }
    if (this.dragThreshold === void 0) {
      return;
    }
    if (this.mode === 1) {
      if (pointer.getDistance() >= this.dragThreshold || this.isPointerInside(pointer)) {
        this.cancel();
      }
    }
  }
  click(nowTime, pointer) {
    if (!this.enable) {
      return this;
    }
    if (nowTime === void 0) {
      this.emit("clickoutside", this, this.parent, pointer);
      return this;
    }
    this.pointer = void 0;
    var lastClickTime = this.lastClickTime;
    if (lastClickTime !== void 0 && nowTime - lastClickTime <= this.clickInterval) {
      return this;
    }
    this.lastClickTime = nowTime;
    this.emit("clickoutside", this, this.parent, pointer);
    return this;
  }
  cancel() {
    this.pointer = void 0;
    return this;
  }
};
var CLICKMODE2 = {
  press: 0,
  pointerdown: 0,
  release: 1,
  pointerup: 1
};
var ClickOutside_default = ClickOutside;

// node_modules/phaser3-rex-plugins/plugins/clickoutside.js
var clickoutside_default = ClickOutside_default;

// node_modules/phaser3-rex-plugins/templates/ui/clickoutside/ClickOutside.js
var ClickOutside_default2 = clickoutside_default;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/ClickOutsideMethods.js
var ClickOutsideMethods_default = {
  onClickOutside(gameObject2, callback, scope, config) {
    if (!gameObject2) {
      return this;
    }
    if (typeof gameObject2 === "function") {
      config = scope;
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._clickOutside === void 0) {
      gameObject2._clickOutside = new ClickOutside_default2(gameObject2, config);
    }
    gameObject2._clickOutside.on("clickoutside", callback, scope);
    return this;
  },
  offClickOutside(gameObject2, callback, scope) {
    if (typeof gameObject2 === "function") {
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._clickOutside === void 0) {
      return this;
    }
    gameObject2._clickOutside.off("clickoutside", callback, scope);
    return this;
  },
  enableClickOutside(gameObject2, enabled) {
    if (typeof gameObject2 === "boolean") {
      enabled = gameObject2;
      gameObject2 = void 0;
    }
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    if (gameObject2._clickOutside === void 0) {
      return this;
    }
    gameObject2._clickOutside.setEnable(enabled);
    return this;
  },
  disableClickOutside(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    if (gameObject2._clickOutside === void 0) {
      return this;
    }
    gameObject2._clickOutside.setEnable(false);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/time/cooldown/Cooldown.js
var Cooldown = class extends FSM_default {
  constructor() {
    super({
      eventEmitter: false
    });
    this.goto("IDLE");
  }
  setCooldownTime(time) {
    this.cooldownTime = time;
    this.cooldownMode = time !== void 0;
    return this;
  }
  request() {
    return this.runMethod("request");
  }
  // IDLE state
  update_IDLE() {
    this.compensationTime = 0;
  }
  request_IDLE() {
    this.next();
    return true;
  }
  next_IDLE() {
    if (this.cooldownMode) {
      return "COOLDOWN";
    }
  }
  // COOLDOWN state
  enter_COOLDOWN() {
    this.remainderTime = this.cooldownTime + this.compensationTime;
  }
  update_COOLDOWN(time, delta) {
    this.remainderTime -= delta;
    if (this.remainderTime < 0) {
      this.compensationTime = this.cooldownTime > delta ? -this.remainderTime : 0;
      this.goto("IDLE");
    }
  }
  request_COOLDOWN() {
    return false;
  }
};
var Cooldown_default = Cooldown;

// node_modules/phaser3-rex-plugins/plugins/input/intouching/InTouching.js
var GetValue83 = Phaser.Utils.Objects.GetValue;
var InTouching = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this._enable = void 0;
    this.cooldown = new Cooldown_default();
    this.parent.setInteractive(GetValue83(config, "inputConfig", void 0));
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.pointer = void 0;
    this.prevIsInTouch = false;
    this.isInTouching = false;
    this.setEnable(GetValue83(o, "enable", true));
    this.setCooldown(GetValue83(o, "cooldown", void 0));
    return this;
  }
  boot() {
    var gameObject2 = this.parent;
    gameObject2.on("pointerdown", this.onPointIn, this);
    gameObject2.on("pointerover", this.onPointIn, this);
    gameObject2.on("pointerup", this.onPointOut, this);
    gameObject2.on("pointerout", this.onPointOut, this);
    this.scene.sys.events.on("preupdate", this.preupdate, this);
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.scene.sys.events.off("preupdate", this.preupdate, this);
    this.pointer = void 0;
    super.shutdown(fromScene);
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.prevIsInTouch = false;
      this.isInTouching = false;
      this.pointer = void 0;
    }
    this._enable = e;
    return this;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  get cooldownTime() {
    return this.cooldown.cooldownTime;
  }
  set cooldownTime(time) {
    this.cooldown.setCooldownTime(time);
  }
  setCooldown(time) {
    this.cooldownTime = time;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  // internal
  onPointIn(pointer, localX, localY) {
    if (!this.enable || !pointer.isDown || this.pointer !== void 0) {
      return;
    }
    this.pointer = pointer;
    this.isInTouching = true;
  }
  onPointOut(pointer) {
    if (!this.enable || this.pointer !== pointer) {
      return;
    }
    this.pointer = void 0;
    this.isInTouching = false;
  }
  preupdate(time, delta) {
    this.cooldown.update(time, delta);
    if (!this.prevIsInTouch && this.isInTouching) {
      this.emit("touchstart", this, this.parent);
    }
    if (this.isInTouching && this.cooldown.request()) {
      this.emit("intouch", this, this.parent, this.pointer);
    }
    if (this.prevIsInTouch && !this.isInTouching) {
      this.emit("touchend", this, this.parent);
    }
    this.prevIsInTouch = this.isInTouching;
  }
};
var InTouching_default = InTouching;

// node_modules/phaser3-rex-plugins/plugins/intouching.js
var intouching_default = InTouching_default;

// node_modules/phaser3-rex-plugins/templates/ui/intouching/InTouching.js
var InTouching_default2 = intouching_default;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/TouchingMethods.js
var TouchingMethods_default = {
  isPointerInBounds(target) {
    if (target === void 0) {
      target = this;
    } else if (typeof target === "string") {
      target = this.getElement(target);
    }
    if (!target) {
      return false;
    }
    return IsPointerInBounds_default(target);
  },
  onTouching(gameObject2, callback, scope, config) {
    if (!gameObject2) {
      return this;
    }
    if (typeof gameObject2 === "function") {
      config = scope;
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._inTouching === void 0) {
      gameObject2._inTouching = new InTouching_default2(gameObject2, config);
    }
    gameObject2._inTouching.on("intouch", callback, scope);
    return this;
  },
  offTouching(gameObject2, callback, scope) {
    if (typeof gameObject2 === "function") {
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._inTouching === void 0) {
      return this;
    }
    gameObject2._inTouching.off("intouch", callback, scope);
    return this;
  },
  onTouchingEnd(gameObject2, callback, scope, config) {
    if (!gameObject2) {
      return this;
    }
    if (typeof gameObject2 === "function") {
      config = scope;
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._inTouching === void 0) {
      gameObject2._inTouching = new InTouching_default2(gameObject2, config);
    }
    gameObject2._inTouching.on("touchend", callback, scope);
    return this;
  },
  offTouchingEnd(gameObject2, callback, scope) {
    if (typeof gameObject2 === "function") {
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    if (gameObject2._inTouching === void 0) {
      return this;
    }
    gameObject2._inTouching.off("touchend", callback, scope);
    return this;
  },
  enableTouching(gameObject2, enabled) {
    if (typeof gameObject2 === "boolean") {
      enabled = gameObject2;
      gameObject2 = void 0;
    }
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    if (gameObject2._inTouching === void 0) {
      return this;
    }
    gameObject2._inTouching.setEnable(enabled);
    return this;
  },
  disableTouching(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    if (gameObject2._inTouching === void 0) {
      return this;
    }
    gameObject2._inTouching.setEnable(false);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/HoverMethods.js
var HoverMethods_default = {
  onOver(gameObject2, callback, scope) {
    if (!gameObject2) {
      return this;
    }
    if (typeof gameObject2 === "function") {
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    gameObject2.setInteractive().on("pointerover", callback, scope);
    return this;
  },
  onOut(gameObject2, callback, scope) {
    if (!gameObject2) {
      return this;
    }
    if (typeof gameObject2 === "function") {
      scope = callback;
      callback = gameObject2;
      gameObject2 = this;
    }
    gameObject2.setInteractive().on("pointerout", callback, scope);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/ContainsPoint.js
var ContainsPoint2 = function(targetMode, gameObjects, x, y) {
  if (targetMode === "parent") {
    var parent;
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      parent = gameObjects[i];
      if (!ContainsPoint_default(parent, x, y)) {
        continue;
      }
      if (parent.pointToChild) {
        return parent.pointToChild(x, y);
      } else {
        return PointToChild_default.call(parent, x, y);
      }
    }
  } else {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var target = gameObjects[i];
      if (ContainsPoint_default(target, x, y)) {
        return target;
      }
    }
  }
  return null;
};
var ContainsPoint_default2 = ContainsPoint2;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/EmitChildEvent.js
var EmitChildEvent = function(eventEmitter, eventName, targets, targetMode, worldX, worldY, pointer, event) {
  var child;
  if (worldY === void 0) {
    child = worldX;
  } else {
    var firstChild = targets[0];
    if (!firstChild) {
      return;
    }
    var camera = pointer.camera;
    var px = worldX + camera.scrollX * (firstChild.scrollFactorX - 1);
    var py = worldY + camera.scrollY * (firstChild.scrollFactorY - 1);
    child = ContainsPoint_default2(targetMode, targets, px, py);
  }
  if (!child) {
    return;
  }
  eventEmitter.emit(eventName, child, pointer, event);
};
var EmitChildEvent_default = EmitChildEvent;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/DownChild.js
var GetValue84 = Phaser.Utils.Objects.GetValue;
var DownChild = function(config) {
  var downConfig = GetValue84(config, "down", void 0);
  if (downConfig === false) {
    return;
  } else if (downConfig === true) {
    downConfig = void 0;
  }
  this.on("pointerdown", OnDown, this);
};
var OnDown = function(pointer, localX, localY, event) {
  var childrenInteractive = this._childrenInteractive;
  EmitChildEvent_default(
    childrenInteractive.eventEmitter,
    `${childrenInteractive.eventNamePrefix}down`,
    childrenInteractive.targetSizers,
    childrenInteractive.targetMode,
    pointer.worldX,
    pointer.worldY,
    pointer,
    event
  );
};
var DownChild_default = DownChild;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/UpChild.js
var GetValue85 = Phaser.Utils.Objects.GetValue;
var UpChild = function(config) {
  var upConfig = GetValue85(config, "up", void 0);
  if (upConfig === false) {
    return;
  } else if (upConfig === true) {
    upConfig = void 0;
  }
  this.on("pointerup", OnUp, this);
};
var OnUp = function(pointer, localX, localY, event) {
  var childrenInteractive = this._childrenInteractive;
  EmitChildEvent_default(
    childrenInteractive.eventEmitter,
    `${childrenInteractive.eventNamePrefix}up`,
    childrenInteractive.targetSizers,
    childrenInteractive.targetMode,
    pointer.worldX,
    pointer.worldY,
    pointer,
    event
  );
};
var UpChild_default = UpChild;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/OverChild.js
var GetValue86 = Phaser.Utils.Objects.GetValue;
var OverChild = function(config) {
  var overConfig = GetValue86(config, "over", void 0);
  if (overConfig === false) {
    return;
  } else if (overConfig === true) {
    overConfig = void 0;
  }
  this.on("pointermove", OnMove, this).on("pointerover", OnMove, this).on("pointerout", OnOut, this);
};
var OnMove = function(pointer, localX, localY, event) {
  var childrenInteractive = this._childrenInteractive;
  var firstChild = childrenInteractive.targetSizers[0];
  if (!firstChild) {
    return;
  }
  var camera = pointer.camera;
  var px = pointer.worldX + camera.scrollX * (firstChild.scrollFactorX - 1);
  var py = pointer.worldY + camera.scrollY * (firstChild.scrollFactorY - 1);
  var child = ContainsPoint_default2(childrenInteractive.targetMode, childrenInteractive.targetSizers, px, py);
  var preChild = childrenInteractive.lastOverChild;
  if (child && preChild && child === preChild) {
    return;
  }
  childrenInteractive.lastOverChild = child;
  EmitChildEvent_default(
    childrenInteractive.eventEmitter,
    `${childrenInteractive.eventNamePrefix}out`,
    childrenInteractive.targetSizers,
    childrenInteractive.targetMode,
    preChild,
    void 0,
    pointer,
    event
  );
  EmitChildEvent_default(
    childrenInteractive.eventEmitter,
    `${childrenInteractive.eventNamePrefix}over`,
    childrenInteractive.targetSizers,
    childrenInteractive.targetMode,
    child,
    void 0,
    pointer,
    event
  );
};
var OnOut = function(pointer, event) {
  var childrenInteractive = this._childrenInteractive;
  var child = childrenInteractive.lastOverChild;
  childrenInteractive.lastOverChild = null;
  EmitChildEvent_default(
    childrenInteractive.eventEmitter,
    `${childrenInteractive.eventNamePrefix}out`,
    childrenInteractive.targetSizers,
    childrenInteractive.targetMode,
    child,
    void 0,
    pointer,
    event
  );
};
var OverChild_default = OverChild;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/ClickChild.js
var GetValue87 = Phaser.Utils.Objects.GetValue;
var ClickChild = function(config) {
  var clickConfig = GetValue87(config, "click", void 0);
  if (clickConfig === false) {
    return;
  } else if (clickConfig === true) {
    clickConfig = void 0;
  }
  if (clickConfig === void 0) {
    clickConfig = {};
  }
  if (!clickConfig.hasOwnProperty("threshold")) {
    clickConfig.threshold = 10;
  }
  var childrenInteractive = this._childrenInteractive;
  this._click = new Button_default(this, clickConfig);
  this._click.on("click", function(button, gameObject2, pointer, event) {
    EmitChildEvent_default(
      childrenInteractive.eventEmitter,
      `${childrenInteractive.eventNamePrefix}click`,
      childrenInteractive.targetSizers,
      childrenInteractive.targetMode,
      pointer.worldX,
      pointer.worldY,
      pointer,
      event
    );
  }, this);
};
var ClickChild_default = ClickChild;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/onepointertracer/OnePointerTracer.js
var GetValue88 = Phaser.Utils.Objects.GetValue;
var OnePointerTracer = class extends TickTask_default {
  constructor(gameObject2, config) {
    var scene = GetSceneObject_default(gameObject2);
    if (scene === gameObject2) {
      gameObject2 = void 0;
    }
    super(scene, config);
    this.gameObject = gameObject2;
    if (gameObject2) {
      gameObject2.setInteractive(GetValue88(config, "inputConfig", void 0));
    }
    this._enable = void 0;
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.setEnable(GetValue88(o, "enable", true));
    this.setDetectBounds();
    if (this.gameObject === void 0) {
      this.setDetectBounds(GetValue88(o, "bounds", void 0));
    } else {
      this.setDetectBounds();
    }
    this.tracerState = TOUCH0;
    this.pointer = void 0;
    this.lastPointer = void 0;
    this.movedState = false;
    this.isTouchingAnyObject = false;
    return this;
  }
  boot() {
    super.boot();
    if (this.gameObject) {
      this.gameObject.on("pointerdown", this.onPointerDown, this);
    } else {
      this.scene.input.on("pointerdown", this.onPointerDown, this);
    }
    this.scene.input.on("pointerup", this.onPointerUp, this);
    this.scene.input.on("gameout", this.dragCancel, this);
    this.scene.input.on("pointermove", this.onPointerMove, this);
    this.scene.sys.events.once("shutdown", this.destroy, this);
  }
  shutdown(fromScene) {
    if (!this.scene) {
      return;
    }
    if (this.gameObject) {
    } else {
      this.scene.input.off("pointerdown", this.onPointerDown, this);
    }
    this.scene.input.off("pointerup", this.onPointerUp, this);
    this.scene.input.off("gameout", this.dragCancel, this);
    this.scene.input.off("pointermove", this.onPointerMove, this);
    this.scene.sys.events.off("shutdown", this.destroy, this);
    this.gameObject = void 0;
    this.bounds = void 0;
    this.pointer = void 0;
    this.lastPointer = void 0;
    this.movedState = false;
    super.shutdown(fromScene);
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.dragCancel();
    }
    this._enable = e;
    return this;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  setDetectBounds(bounds) {
    this.bounds = bounds;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  onPointerDown(pointer, gameObjects) {
    if (!this.enable) {
      return;
    }
    if (this.pointer !== void 0) {
      return;
    }
    var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
    if (!isInsideBounds) {
      return;
    }
    if (this.pointer === pointer) {
      return;
    }
    this.pointer = pointer;
    this.pointerCamera = pointer.camera;
    this.lastPointer = pointer;
    this.movedState = false;
    this.tracerState = TOUCH1;
    if (this.gameObject === void 0) {
      this.isTouchingAnyObject = gameObjects.length > 0;
    }
    this.onDragStart();
  }
  onPointerUp(pointer) {
    if (!this.enable) {
      return;
    }
    var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
    if (!isInsideBounds) {
      return;
    }
    if (this.pointer !== pointer) {
      return;
    }
    this.pointer = void 0;
    this.pointerCamera = void 0;
    this.movedState = false;
    this.tracerState = TOUCH0;
    this.onDragEnd();
  }
  onPointerMove(pointer) {
    if (!this.enable) {
      return;
    }
    if (pointer.isDown) {
      var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
      var isCatchedPointer = this.pointer === pointer;
      if (!isCatchedPointer && isInsideBounds) {
      } else if (isCatchedPointer && !isInsideBounds) {
        this.onPointerUp(pointer);
      } else {
        if (!this.movedState) {
          this.movedState = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
        }
        if (this.movedState) {
          this.onDrag();
        }
      }
    } else {
    }
  }
  dragCancel() {
    if (this.tracerState === TOUCH1) {
      this.onDragEnd();
    }
    this.pointer = void 0;
    this.tracerState = TOUCH0;
    return this;
  }
  onDragStart() {
    this.emit("dragstart", this);
  }
  onDragEnd() {
    this.emit("dragend", this);
  }
  onDrag() {
    this.emit("drag", this);
  }
  // onLastPointerMove() { }
  preUpdate(time, delta) {
  }
  postUpdate(time, delta) {
  }
  startTicking() {
    super.startTicking();
    this.scene.sys.events.on("preupdate", this.preUpdate, this);
    this.scene.sys.events.on("postupdate", this.postUpdate, this);
  }
  stopTicking() {
    super.stopTicking();
    if (this.scene) {
      this.scene.sys.events.off("preupdate", this.preUpdate, this);
      this.scene.sys.events.off("postupdate", this.postUpdate, this);
    }
  }
  setRecongizedStateObject(stateObject) {
    this.recongizedState = stateObject;
    return this;
  }
  get state() {
    return this.recongizedState.state;
  }
  set state(newState) {
    this.recongizedState.state = newState;
  }
  cancel() {
    this.state = IDLE2;
    return this;
  }
  isPointerInGameObject(gameObject2, preTest, postTest) {
    var pointer = this.lastPointer;
    if (!pointer) {
      return false;
    }
    return IsPointerInBounds_default(gameObject2, pointer, preTest, postTest);
  }
};
var TOUCH0 = 0;
var TOUCH1 = 1;
var IDLE2 = "IDLE";
var OnePointerTracer_default = OnePointerTracer;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/tap/Tap.js
var GetValue89 = Phaser.Utils.Objects.GetValue;
var DistanceBetween3 = Phaser.Math.Distance.Between;
var Tap = class extends OnePointerTracer_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    var self = this;
    var stateConfig = {
      states: {
        IDLE: {
          enter: function() {
            self.stop();
            self.tapsCount = 0;
            self.x = 0;
            self.y = 0;
            self.worldX = 0;
            self.worldY = 0;
            self.lastPointer = void 0;
          },
          exit: function() {
            var pointer = self.lastPointer;
            self.x = pointer.x;
            self.y = pointer.y;
            self.worldX = pointer.worldX;
            self.worldY = pointer.worldY;
          }
        },
        BEGIN: {
          enter: function() {
            self.start();
            self.tapsCount = 0;
            self.emit("tappingstart", self, self.gameObject, self.lastPointer);
          }
        },
        RECOGNIZED: {
          enter: function() {
            self.start();
            self.emit("tap", self, self.gameObject, self.lastPointer);
            self.emit(`${self.tapsCount}tap`, self, self.gameObject, self.lastPointer);
          }
        }
      },
      init: function() {
        this.state = IDLE3;
      },
      eventEmitter: false
    };
    this.setRecongizedStateObject(new fsm_default(stateConfig));
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setHoldTime(GetValue89(o, "time", 250));
    this.setTapInterval(GetValue89(o, "tapInterval", 200));
    this.setDragThreshold(GetValue89(o, "threshold", 9));
    this.setTapOffset(GetValue89(o, "tapOffset", 10));
    var taps = GetValue89(o, "taps", void 0);
    if (taps !== void 0) {
      this.setTaps(taps);
    } else {
      this.setMaxTaps(GetValue89(o, "maxTaps", void 0));
      this.setMinTaps(GetValue89(o, "minTaps", void 0));
    }
    return this;
  }
  onDragStart() {
    switch (this.state) {
      case IDLE3:
        this.state = BEGIN;
        break;
      case BEGIN:
        var pointer = this.lastPointer;
        var tapsOffset = DistanceBetween3(
          pointer.upX,
          pointer.upY,
          pointer.x,
          pointer.y
        );
        if (tapsOffset > this.tapOffset) {
          this.state = RECOGNIZED;
          this.state = BEGIN;
        }
        break;
      case RECOGNIZED:
        this.state = BEGIN;
        break;
    }
  }
  onDragEnd() {
    if (this.state === BEGIN) {
      this.tapsCount++;
      this.emit("tapping", this, this.gameObject, this.lastPointer);
      if (this.maxTaps !== void 0 && this.tapsCount === this.maxTaps) {
        this.state = RECOGNIZED;
      }
    }
  }
  onDrag() {
    if (this.state === IDLE3) {
      return;
    }
    if (this.pointer.getDistance() > this.dragThreshold) {
      this.state = IDLE3;
    }
  }
  preUpdate(time, delta) {
    if (!this.isRunning || !this.enable) {
      return;
    }
    if (this.state === BEGIN) {
      var pointer = this.lastPointer;
      if (pointer.isDown) {
        var holdTime = time - pointer.downTime;
        if (holdTime > this.holdTime) {
          this.state = IDLE3;
        }
      } else {
        var releasedTime = time - pointer.upTime;
        if (releasedTime > this.tapInterval) {
          if (this.minTaps === void 0 || this.tapsCount >= this.minTaps) {
            this.state = RECOGNIZED;
          } else {
            this.state = IDLE3;
          }
        }
      }
    }
  }
  postUpdate(time, delta) {
    if (!this.isRunning || !this.enable) {
      return;
    }
    if (this.state === RECOGNIZED) {
      this.state = IDLE3;
    }
  }
  get isTapping() {
    return this.state === RECOGNIZED;
  }
  // Backward compatible
  get isTapped() {
    return this.isTapping;
  }
  setHoldTime(time) {
    this.holdTime = time;
    return this;
  }
  setTapInterval(time) {
    this.tapInterval = time;
    return this;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
  setTapOffset(distance) {
    this.tapOffset = distance;
    return this;
  }
  setMaxTaps(taps) {
    this.maxTaps = taps;
    return this;
  }
  setMinTaps(taps) {
    this.minTaps = taps;
    return this;
  }
  setTaps(minTaps, maxTaps) {
    if (maxTaps === void 0) {
      maxTaps = minTaps;
    }
    this.setMinTaps(minTaps).setMaxTaps(maxTaps);
    return this;
  }
};
var IDLE3 = "IDLE";
var BEGIN = "BEGIN";
var RECOGNIZED = "RECOGNIZED";
var Tap_default = Tap;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/press/Press.js
var GetValue90 = Phaser.Utils.Objects.GetValue;
var Press = class extends OnePointerTracer_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    var self = this;
    var stateConfig = {
      states: {
        IDLE: {
          enter: function() {
            self.x = 0;
            self.y = 0;
            self.worldX = 0;
            self.worldY = 0;
            self.lastPointer = void 0;
          },
          exit: function() {
            var pointer = self.lastPointer;
            self.x = pointer.x;
            self.y = pointer.y;
            self.worldX = pointer.worldX;
            self.worldY = pointer.worldY;
          }
        },
        BEGIN: {
          enter: function() {
            self.start();
          },
          exit: function() {
            self.stop();
          }
        },
        RECOGNIZED: {
          enter: function() {
            self.emit("pressstart", self, self.gameObject, self.lastPointer);
          },
          exit: function() {
            self.emit("pressend", self, self.gameObject, self.lastPointer);
          }
        }
      },
      init: function() {
        this.state = IDLE4;
      },
      eventEmitter: false
    };
    this.setRecongizedStateObject(new fsm_default(stateConfig));
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setDragThreshold(GetValue90(o, "threshold", 9));
    this.setHoldTime(GetValue90(o, "time", 251));
    return this;
  }
  onDragStart() {
    this.state = BEGIN2;
    if (this.holdTime === 0) {
      this.state = RECOGNIZED2;
    }
  }
  onDragEnd() {
    this.state = IDLE4;
  }
  onDrag() {
    if (this.state === IDLE4) {
      return;
    }
    if (this.pointer.getDistance() > this.dragThreshold) {
      this.state = IDLE4;
    }
  }
  preUpdate(time, delta) {
    if (!this.isRunning || !this.enable) {
      return;
    }
    if (this.state === BEGIN2) {
      var holdTime = time - this.pointer.downTime;
      if (holdTime >= this.holdTime) {
        this.state = RECOGNIZED2;
      }
    }
  }
  get isPressing() {
    return this.state === RECOGNIZED2;
  }
  // Backward compatible
  get isPressed() {
    return this.isPressing;
  }
  setHoldTime(time) {
    this.holdTime = time;
    return this;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
};
var IDLE4 = "IDLE";
var BEGIN2 = "BEGIN";
var RECOGNIZED2 = "RECOGNIZED";
var Press_default = Press;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/pan/Pan.js
var GetValue91 = Phaser.Utils.Objects.GetValue;
var Pan = class extends OnePointerTracer_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    var self = this;
    var stateConfig = {
      states: {
        IDLE: {},
        BEGIN: {
          enter: function() {
            var pointer = self.pointer;
            self.startX = pointer.x;
            self.startY = pointer.y;
            self.startWorldX = pointer.worldX;
            self.startWorldY = pointer.worldY;
          }
        },
        RECOGNIZED: {
          enter: function() {
            self.emit("panstart", self, self.gameObject, self.lastPointer);
          },
          exit: function() {
            var pointer = self.lastPointer;
            self.endX = pointer.x;
            self.endY = pointer.y;
            var worldXY = GetPointerWorldXY_default(pointer, self.pointerCamera, true);
            self.endWorldX = worldXY.x;
            self.endWorldY = worldXY.y;
            self.emit("panend", self, self.gameObject, self.lastPointer);
          }
        }
      },
      init: function() {
        this.state = IDLE5;
      },
      eventEmitter: false
    };
    this.setRecongizedStateObject(new fsm_default(stateConfig));
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setDragThreshold(GetValue91(o, "threshold", 10));
    return this;
  }
  onDragStart() {
    this.state = BEGIN3;
    if (this.dragThreshold === 0) {
      this.state = RECOGNIZED3;
    }
  }
  onDragEnd() {
    this.state = IDLE5;
  }
  onDrag() {
    switch (this.state) {
      case BEGIN3:
        if (this.pointer.getDistance() >= this.dragThreshold) {
          this.state = RECOGNIZED3;
          this.dx = 0;
          this.dy = 0;
          this.dWorldX = 0;
          this.dWorldY = 0;
          var pointer = this.pointer;
          this.x = pointer.x;
          this.y = pointer.y;
          this.worldX = pointer.worldX;
          this.worldY = pointer.worldY;
        }
        break;
      case RECOGNIZED3:
        var pointerCamera = this.pointerCamera;
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        this.dx = p1.x - p0.x;
        this.dy = p1.y - p0.y;
        this.dWorldX = this.dx / pointerCamera.zoom;
        this.dWorldY = this.dy / pointerCamera.zoom;
        var pointer = this.pointer;
        this.x = pointer.x;
        this.y = pointer.y;
        var worldXY = GetPointerWorldXY_default(pointer, pointerCamera, true);
        this.worldX = worldXY.x;
        this.worldY = worldXY.y;
        this.emit("pan", this, this.gameObject, this.lastPointer);
        break;
    }
  }
  get isPanning() {
    return this.state === RECOGNIZED3;
  }
  // Backward compatible
  get isPanned() {
    return this.isPanning;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
};
var IDLE5 = "IDLE";
var BEGIN3 = "BEGIN";
var RECOGNIZED3 = "RECOGNIZED";
var Pan_default = Pan;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/swipe/VelocityMethods.js
var DistanceBetween4 = Phaser.Math.Distance.Between;
var AngleBetween = Phaser.Math.Angle.Between;
var VelocityMethods_default = {
  getDt: function() {
    var dt = GetTickDelta_default(this.scene);
    return dt;
  },
  getVelocity: function() {
    var p1 = this.pointer.position;
    var p0 = this.pointer.prevPosition;
    var d = DistanceBetween4(p0.x, p0.y, p1.x, p1.y);
    var velocity = d / (this.getDt() * 1e-3);
    return velocity;
  },
  getVelocityX: function() {
    var p1 = this.pointer.position;
    var p0 = this.pointer.prevPosition;
    var d = Math.abs(p1.x - p0.x);
    var velocity = d / (this.getDt() * 1e-3);
    return velocity;
  },
  getVelocityY: function() {
    var p1 = this.pointer.position;
    var p0 = this.pointer.prevPosition;
    var d = Math.abs(p1.y - p0.y);
    var velocity = d / (this.getDt() * 1e-3);
    return velocity;
  },
  getVelocityAngle: function() {
    var p1 = this.pointer.position;
    var p0 = this.pointer.prevPosition;
    var angle = AngleBetween(p0.x, p0.y, p1.x, p1.y);
    return angle;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/math/angle/angletodirections/Const.js
var Const_default = {
  "up&down": 0,
  "left&right": 1,
  "4dir": 2,
  "8dir": 3
};

// node_modules/phaser3-rex-plugins/plugins/utils/math/angle/angletodirections/AngleToDirections.js
var AngleToDirections = function(angle, dirMode, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = globOut3;
  }
  out2.left = false;
  out2.right = false;
  out2.up = false;
  out2.down = false;
  angle = (angle + 360) % 360;
  switch (dirMode) {
    case 0:
      if (angle < 180) {
        out2.down = true;
      } else {
        out2.up = true;
      }
      break;
    case 1:
      if (angle > 90 && angle <= 270) {
        out2.left = true;
      } else {
        out2.right = true;
      }
      break;
    case 2:
      if (angle > 45 && angle <= 135) {
        out2.down = true;
      } else if (angle > 135 && angle <= 225) {
        out2.left = true;
      } else if (angle > 225 && angle <= 315) {
        out2.up = true;
      } else {
        out2.right = true;
      }
      break;
    case 3:
      if (angle > 22.5 && angle <= 67.5) {
        out2.down = true;
        out2.right = true;
      } else if (angle > 67.5 && angle <= 112.5) {
        out2.down = true;
      } else if (angle > 112.5 && angle <= 157.5) {
        out2.down = true;
        out2.left = true;
      } else if (angle > 157.5 && angle <= 202.5) {
        out2.left = true;
      } else if (angle > 202.5 && angle <= 247.5) {
        out2.left = true;
        out2.up = true;
      } else if (angle > 247.5 && angle <= 292.5) {
        out2.up = true;
      } else if (angle > 292.5 && angle <= 337.5) {
        out2.up = true;
        out2.right = true;
      } else {
        out2.right = true;
      }
      break;
  }
  return out2;
};
var globOut3 = {};
var AngleToDirections_default = AngleToDirections;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/swipe/Swipe.js
var GetValue92 = Phaser.Utils.Objects.GetValue;
var RadToDeg10 = Phaser.Math.RadToDeg;
var Swipe = class extends OnePointerTracer_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    var self = this;
    var stateConfig = {
      states: {
        IDLE: {
          enter: function() {
            self.x = 0;
            self.y = 0;
            self.worldX = 0;
            self.worldY = 0;
          },
          exit: function() {
            var pointer = self.lastPointer;
            self.x = pointer.x;
            self.y = pointer.y;
            self.worldX = pointer.worldX;
            self.worldY = pointer.worldY;
          }
        },
        BEGIN: {
          enter: function() {
            self.validDrag = false;
          }
        },
        RECOGNIZED: {
          enter: function() {
            self.start();
            self.updateDirectionStates();
            self.emit("swipe", self, self.gameObject, self.lastPointer);
          },
          exit: function() {
            self.stop();
            self.clearDirectionStates();
          }
        }
      },
      init: function() {
        this.state = IDLE6;
      },
      eventEmitter: false
    };
    this.setRecongizedStateObject(new fsm_default(stateConfig));
    this.clearDirectionStates();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setDragThreshold(GetValue92(o, "threshold", 10));
    this.setVelocityThreshold(GetValue92(o, "velocityThreshold", 1e3));
    this.setDirectionMode(GetValue92(o, "dir", "8dir"));
    return this;
  }
  onDragStart() {
    this.state = BEGIN4;
  }
  onDragEnd() {
    this.state = IDLE6;
  }
  onDrag() {
    if (this.state === BEGIN4) {
      if (!this.validDrag) {
        this.validDrag = this.dragThreshold === 0 || this.pointer.getDistance() >= this.dragThreshold;
      }
      if (this.validDrag && this.dragVelocity > this.velocityThreshold) {
        this.state = RECOGNIZED4;
      }
    }
  }
  postUpdate(time, delta) {
    if (!this.isRunning || !this.enable) {
      return;
    }
    if (this.state === RECOGNIZED4) {
      this.state = IDLE6;
    }
  }
  get isSwiping() {
    return this.state === RECOGNIZED4;
  }
  // Backward compatible
  get isSwiped() {
    return this.isSwiping;
  }
  get dragVelocity() {
    var velocity;
    switch (this.dirMode) {
      case 0:
        velocity = this.getVelocityY();
        break;
      case 1:
        velocity = this.getVelocityX();
        break;
      default:
        velocity = this.getVelocity();
        break;
    }
    return velocity;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
  setVelocityThreshold(velocity) {
    this.velocityThreshold = velocity;
    return this;
  }
  setDirectionMode(m) {
    if (typeof m === "string") {
      m = Const_default[m];
    }
    this.dirMode = m;
    return this;
  }
  updateDirectionStates() {
    var angle = RadToDeg10(this.getVelocityAngle());
    AngleToDirections_default(angle, this.dirMode, this);
    return this;
  }
  clearDirectionStates() {
    this.left = false;
    this.right = false;
    this.up = false;
    this.down = false;
    return this;
  }
};
Object.assign(
  Swipe.prototype,
  VelocityMethods_default
);
var IDLE6 = "IDLE";
var BEGIN4 = "BEGIN";
var RECOGNIZED4 = "RECOGNIZED";
var Swipe_default = Swipe;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/twopointerstracer/TwoPointersTracer.js
var GetValue93 = Phaser.Utils.Objects.GetValue;
var SpliceOne = Phaser.Utils.Array.SpliceOne;
var DistanceBetween5 = Phaser.Math.Distance.Between;
var AngleBetween2 = Phaser.Math.Angle.Between;
var TwoPointersTracer = class {
  constructor(gameObject2, config) {
    var scene = GetSceneObject_default(gameObject2);
    if (scene === gameObject2) {
      gameObject2 = void 0;
    }
    var amount = scene.input.manager.pointersTotal - 1;
    if (amount < 2) {
      scene.input.addPointer(2 - amount);
    }
    this.scene = scene;
    this.gameObject = gameObject2;
    if (gameObject2) {
      gameObject2.setInteractive(GetValue93(config, "inputConfig", void 0));
    }
    this.setEventEmitter(GetValue93(config, "eventEmitter", void 0));
    this._enable = void 0;
    this.pointers = [];
    this.movedState = {};
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.setEnable(GetValue93(o, "enable", true));
    this.bounds = GetValue93(o, "bounds", void 0);
    this.tracerState = TOUCH02;
    this.pointers.length = 0;
    Clear_default(this.movedState);
    return this;
  }
  boot() {
    if (this.gameObject) {
      this.gameObject.on("pointerdown", this.onPointerDown, this);
    } else {
      this.scene.input.on("pointerdown", this.onPointerDown, this);
    }
    this.scene.input.on("pointerup", this.onPointerUp, this);
    this.scene.input.on("gameout", this.dragCancel, this);
    this.scene.input.on("pointermove", this.onPointerMove, this);
    this.scene.sys.events.once("shutdown", this.destroy, this);
  }
  shutdown() {
    if (!this.scene) {
      return;
    }
    this.destroyEventEmitter();
    this.pointers.length = 0;
    Clear_default(this.movedState);
    if (this.gameObject) {
    } else {
      this.scene.input.off("pointerdown", this.onPointerDown, this);
    }
    this.scene.input.off("pointerup", this.onPointerUp, this);
    this.scene.input.off("gameout", this.dragCancel, this);
    this.scene.input.off("pointermove", this.onPointerMove, this);
    this.scene.sys.events.off("shutdown", this.destroy, this);
    this.scene = void 0;
    this.gameObject = void 0;
  }
  destroy() {
    this.shutdown();
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.dragCancel();
    }
    this._enable = e;
    return this;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  onPointerDown(pointer) {
    if (!this.enable) {
      return;
    }
    if (this.pointers.length === 2) {
      return;
    }
    var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
    if (!isInsideBounds) {
      return;
    }
    var index = this.pointers.indexOf(pointer);
    if (index !== -1) {
      return;
    }
    this.movedState[pointer.id] = false;
    this.pointers.push(pointer);
    this.pointerCamera = pointer.camera;
    switch (this.tracerState) {
      case TOUCH02:
        this.tracerState = TOUCH12;
        this.onDrag1Start();
        break;
      case TOUCH12:
        this.tracerState = TOUCH2;
        this.onDrag2Start();
        break;
    }
  }
  onPointerUp(pointer) {
    if (!this.enable) {
      return;
    }
    var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
    if (!isInsideBounds) {
      return;
    }
    var index = this.pointers.indexOf(pointer);
    if (index === -1) {
      return;
    } else {
      delete this.movedState[pointer.id];
      SpliceOne(this.pointers, index);
    }
    switch (this.tracerState) {
      case TOUCH12:
        this.tracerState = TOUCH02;
        this.onDrag1End();
        break;
      case TOUCH2:
        this.tracerState = TOUCH12;
        this.onDrag2End();
        this.onDrag1Start();
        break;
    }
  }
  onPointerMove(pointer) {
    if (!this.enable) {
      return;
    }
    if (pointer.isDown) {
      var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
      var isCatchedPointer = this.pointers.indexOf(pointer) !== -1;
      if (!isCatchedPointer && isInsideBounds) {
      } else if (isCatchedPointer && !isInsideBounds) {
        this.onPointerUp(pointer);
      } else {
        if (!this.movedState[pointer.id]) {
          this.movedState[pointer.id] = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
        }
        if (this.movedState[pointer.id]) {
          switch (this.tracerState) {
            case TOUCH12:
              this.onDrag1();
              break;
            case TOUCH2:
              this.onDrag2();
              break;
          }
        }
      }
    }
  }
  dragCancel() {
    if (this.tracerState === TOUCH2) {
      this.onDrag2End();
    }
    this.pointers.length = 0;
    Clear_default(this.movedState);
    this.tracerState = TOUCH02;
    return this;
  }
  onDrag1Start() {
    this.emit("drag1start", this);
  }
  onDrag1End() {
    this.emit("drag1end", this);
  }
  onDrag1() {
    this.emit("drag1", this);
  }
  onDrag2Start() {
    this.emit("drag2start", this);
  }
  onDrag2End() {
    this.emit("drag2end", this);
  }
  onDrag2() {
    this.emit("drag2", this);
  }
  get distanceBetween() {
    if (this.tracerState !== TOUCH2) {
      return 0;
    }
    var p0 = this.pointers[0], p1 = this.pointers[1];
    return DistanceBetween5(p0.x, p0.y, p1.x, p1.y);
  }
  get angleBetween() {
    if (this.tracerState !== TOUCH2) {
      return 0;
    }
    var p0 = this.pointers[0], p1 = this.pointers[1];
    return AngleBetween2(p0.x, p0.y, p1.x, p1.y);
  }
  get drag1Vector() {
    var pointer = this.pointers[0];
    if (pointer && this.movedState[pointer.id]) {
      var p1 = pointer.position;
      var p0 = pointer.prevPosition;
      tmpDragVector.x = p1.x - p0.x;
      tmpDragVector.y = p1.y - p0.y;
    } else {
      tmpDragVector.x = 0;
      tmpDragVector.y = 0;
    }
    return tmpDragVector;
  }
  get centerX() {
    if (this.tracerState !== TOUCH2) {
      return 0;
    }
    var p0 = this.pointers[0].position;
    var p1 = this.pointers[1].position;
    return (p0.x + p1.x) / 2;
  }
  get centerY() {
    if (this.tracerState !== TOUCH2) {
      return 0;
    }
    var p0 = this.pointers[0].position;
    var p1 = this.pointers[1].position;
    return (p0.y + p1.y) / 2;
  }
  get prevCenterX() {
    if (this.tracerState !== TOUCH2) {
      return 0;
    }
    var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
    var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
    return (preP0.x + preP1.x) / 2;
  }
  get prevCenterY() {
    if (this.tracerState !== TOUCH2) {
      return 0;
    }
    var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
    var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
    return (preP0.y + preP1.y) / 2;
  }
  get movementCenterX() {
    return this.centerX - this.prevCenterX;
  }
  get movementCenterY() {
    return this.centerY - this.prevCenterY;
  }
  setRecongizedStateObject(stateObject) {
    this.recongizedState = stateObject;
    return this;
  }
  get state() {
    return this.recongizedState.state;
  }
  set state(newState) {
    this.recongizedState.state = newState;
  }
  cancel() {
    this.state = IDLE7;
    return this;
  }
  isPointer0InGameObject(gameObject2, preTest, postTest) {
    var pointer = this.pointers[0];
    if (!pointer) {
      return false;
    }
    return IsPointerInBounds_default(gameObject2, pointer, preTest, postTest);
  }
  isPointer1InGameObject(gameObject2, preTest, postTest) {
    var pointer = this.pointers[1];
    if (!pointer) {
      return false;
    }
    return IsPointerInBounds_default(gameObject2, pointer, preTest, postTest);
  }
};
Object.assign(
  TwoPointersTracer.prototype,
  EventEmitterMethods_default
);
var tmpDragVector = {};
var TOUCH02 = 0;
var TOUCH12 = 1;
var TOUCH2 = 2;
var IDLE7 = "IDLE";
var TwoPointersTracer_default = TwoPointersTracer;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/pinch/Pinch.js
var GetValue94 = Phaser.Utils.Objects.GetValue;
var Pinch = class extends TwoPointersTracer_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    var self = this;
    var stateConfig = {
      states: {
        IDLE: {
          enter: function() {
            self.prevDistance = void 0;
            self.scaleFactor = 1;
          }
        },
        BEGIN: {},
        RECOGNIZED: {
          enter: function() {
            self.emit("pinchstart", self);
          },
          exit: function() {
            self.emit("pinchend", self);
          }
        }
      },
      init: function() {
        this.state = IDLE8;
      },
      eventEmitter: false
    };
    this.setRecongizedStateObject(new fsm_default(stateConfig));
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setDragThreshold(GetValue94(o, "threshold", 0));
    return this;
  }
  onDrag2Start() {
    this.scaleFactor = 1;
    this.prevDistance = this.distanceBetween;
    this.state = BEGIN5;
    if (this.dragThreshold === 0) {
      this.state = RECOGNIZED5;
    }
  }
  onDrag2End() {
    this.state = IDLE8;
  }
  onDrag2() {
    switch (this.state) {
      case BEGIN5:
        if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) {
          var curDistance = this.distanceBetween;
          this.scaleFactor = curDistance / this.prevDistance;
          this.prevDistance = curDistance;
          this.state = RECOGNIZED5;
        }
        break;
      case RECOGNIZED5:
        var curDistance = this.distanceBetween;
        this.scaleFactor = curDistance / this.prevDistance;
        this.emit("pinch", this);
        this.prevDistance = curDistance;
        break;
    }
  }
  get isPinching() {
    return this.state === RECOGNIZED5;
  }
  // Backward compatible
  get isPinched() {
    return this.isPinching;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
};
var IDLE8 = "IDLE";
var BEGIN5 = "BEGIN";
var RECOGNIZED5 = "RECOGNIZED";
var Pinch_default = Pinch;

// node_modules/phaser3-rex-plugins/plugins/utils/actions/RotateObjectAround.js
var RotateAround6 = Phaser.Math.RotateAround;
var RotateObjectAround = function(gameObject2, x, y, angle) {
  RotateAround6(gameObject2, x, y, angle);
  gameObject2.rotation += angle;
  return gameObject2;
};
var RotateObjectAround_default = RotateObjectAround;

// node_modules/phaser3-rex-plugins/plugins/utils/position/ScreenXYToWorldXY.js
var ScreenXYToWorldXY = function(screenX, screenY, camera, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = globalOut2;
  }
  camera.getWorldPoint(screenX, screenY, out2);
  return out2;
};
var globalOut2 = {};
var ScreenXYToWorldXY_default = ScreenXYToWorldXY;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/rotate/SpinObject.js
var SpinObject = function(gameObject2, camera) {
  if (!this.isRotation) {
    return this;
  }
  if (camera === void 0) {
    camera = this.pointers[0].camera;
  }
  var movementX = this.movementCenterX, movementY = this.movementCenterY;
  var worldXY = ScreenXYToWorldXY_default(this.centerX, this.centerY, camera, true);
  var centerWorldX = worldXY.x;
  var centerWorldY = worldXY.y;
  var angle = this.rotation;
  if (Array.isArray(gameObject2)) {
    var gameObjects = gameObject2;
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      gameObject2 = gameObjects[i];
      gameObject2.x += movementX;
      gameObject2.y += movementY;
      RotateObjectAround_default(gameObject2, centerWorldX, centerWorldY, angle);
    }
  } else {
    gameObject2.x += movementX;
    gameObject2.y += movementY;
    RotateObjectAround_default(gameObject2, centerWorldX, centerWorldY, angle);
  }
  return this;
};
var SpinObject_default = SpinObject;

// node_modules/phaser3-rex-plugins/plugins/input/gestures/rotate/Rotate.js
var GetValue95 = Phaser.Utils.Objects.GetValue;
var WrapDegrees = Phaser.Math.Angle.WrapDegrees;
var ShortestBetween = Phaser.Math.Angle.ShortestBetween;
var RadToDeg11 = Phaser.Math.RadToDeg;
var DegToRad14 = Phaser.Math.DegToRad;
var Rotate2 = class extends TwoPointersTracer_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    var self = this;
    var stateConfig = {
      states: {
        IDLE: {
          enter: function() {
            self.prevAngle = void 0;
            self.angle = 0;
          }
        },
        BEGIN: {},
        RECOGNIZED: {
          enter: function() {
            self.emit("rotatestart", self);
          },
          exit: function() {
            self.emit("rotateend", self);
          }
        }
      },
      init: function() {
        this.state = IDLE9;
      },
      eventEmitter: false
    };
    this.setRecongizedStateObject(new fsm_default(stateConfig));
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setDragThreshold(GetValue95(o, "threshold", 0));
    return this;
  }
  onDrag2Start() {
    this.prevAngle = WrapDegrees(RadToDeg11(this.angleBetween));
    this.state = BEGIN6;
    if (this.dragThreshold === 0) {
      this.state = RECOGNIZED6;
    }
  }
  onDrag2End() {
    this.state = IDLE9;
  }
  onDrag2() {
    switch (this.state) {
      case BEGIN6:
        if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) {
          var curAngle = WrapDegrees(RadToDeg11(this.angleBetween));
          this.angle = ShortestBetween(this.prevAngle, curAngle);
          this.prevAngle = curAngle;
          this.state = RECOGNIZED6;
        }
        break;
      case RECOGNIZED6:
        var curAngle = WrapDegrees(RadToDeg11(this.angleBetween));
        this.angle = ShortestBetween(this.prevAngle, curAngle);
        this.prevAngle = curAngle;
        this.emit("rotate", this);
        break;
    }
  }
  get isRotating() {
    return this.state === RECOGNIZED6;
  }
  // Backward compatible
  get isRotated() {
    return this.isRotating;
  }
  get rotation() {
    return DegToRad14(this.angle);
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
};
var methods16 = {
  spinObject: SpinObject_default
};
Object.assign(
  Rotate2.prototype,
  methods16
);
var IDLE9 = "IDLE";
var BEGIN6 = "BEGIN";
var RECOGNIZED6 = "RECOGNIZED";
var Rotate_default = Rotate2;

// node_modules/phaser3-rex-plugins/templates/ui/tap/Tap.js
var Tap_default2 = Tap_default;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/TapChild.js
var GetValue96 = Phaser.Utils.Objects.GetValue;
var TapChild = function(config) {
  var tapConfig = GetValue96(config, "tap", void 0);
  if (tapConfig === false) {
    return;
  } else if (tapConfig === true) {
    tapConfig = void 0;
  }
  var childrenInteractive = this._childrenInteractive;
  this._tap = new Tap_default2(this, tapConfig);
  this._tap.on("tap", function(tap, gameObject2, lastPointer) {
    EmitChildEvent_default(
      childrenInteractive.eventEmitter,
      `${childrenInteractive.eventNamePrefix}${tap.tapsCount}tap`,
      childrenInteractive.targetSizers,
      childrenInteractive.targetMode,
      tap.worldX,
      tap.worldY,
      lastPointer,
      tap
    );
    EmitChildEvent_default(
      childrenInteractive.eventEmitter,
      `${childrenInteractive.eventNamePrefix}tap`,
      childrenInteractive.targetSizers,
      childrenInteractive.targetMode,
      tap.worldX,
      tap.worldY,
      lastPointer,
      tap
    );
  }, this);
};
var TapChild_default = TapChild;

// node_modules/phaser3-rex-plugins/templates/ui/press/Press.js
var Press_default2 = Press_default;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/PressChild.js
var GetValue97 = Phaser.Utils.Objects.GetValue;
var PressChild = function(config) {
  var pressConfig = GetValue97(config, "press", void 0);
  if (pressConfig === false) {
    return;
  } else if (pressConfig === true) {
    pressConfig = void 0;
  }
  var childrenInteractive = this._childrenInteractive;
  this._press = new Press_default2(this, pressConfig);
  this._press.on("pressstart", function(press, gameObject2, lastPointer) {
    EmitChildEvent_default(
      childrenInteractive.eventEmitter,
      `${childrenInteractive.eventNamePrefix}pressstart`,
      childrenInteractive.targetSizers,
      childrenInteractive.targetMode,
      press.worldX,
      press.worldY,
      lastPointer,
      press
    );
  }, this).on("pressend", function(press, gameObject2, lastPointer) {
    EmitChildEvent_default(
      childrenInteractive.eventEmitter,
      `${childrenInteractive.eventNamePrefix}pressend`,
      childrenInteractive.targetSizers,
      childrenInteractive.targetMode,
      press.worldX,
      press.worldY,
      lastPointer,
      press
    );
  }, this);
};
var PressChild_default = PressChild;

// node_modules/phaser3-rex-plugins/templates/ui/swipe/Swipe.js
var Swipe_default2 = Swipe_default;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/SwipeChild.js
var GetValue98 = Phaser.Utils.Objects.GetValue;
var SwipeChild = function(config) {
  var swipeConfig = GetValue98(config, "swipe", void 0);
  if (swipeConfig === false) {
    return;
  } else if (swipeConfig === true) {
    swipeConfig = void 0;
  }
  if (swipeConfig === void 0) {
    swipeConfig = {};
  }
  if (!swipeConfig.hasOwnProperty("dir")) {
    swipeConfig.dir = "4dir";
  }
  var childrenInteractive = this._childrenInteractive;
  this._swipe = new Swipe_default2(this, swipeConfig);
  this._swipe.on("swipe", function(swipe, gameObject2, lastPointer) {
    var dirName = swipe.left ? "left" : swipe.right ? "right" : swipe.up ? "up" : "down";
    EmitChildEvent_default(
      childrenInteractive.eventEmitter,
      `${childrenInteractive.eventNamePrefix}swipe${dirName}`,
      childrenInteractive.targetSizers,
      childrenInteractive.targetMode,
      swipe.worldX,
      swipe.worldY,
      lastPointer,
      swipe
    );
    EmitChildEvent_default(
      childrenInteractive.eventEmitter,
      `${childrenInteractive.eventNamePrefix}swipe`,
      childrenInteractive.targetSizers,
      childrenInteractive.targetMode,
      swipe.worldX,
      swipe.worldY,
      lastPointer,
      swipe
    );
  }, this);
};
var SwipeChild_default = SwipeChild;

// node_modules/phaser3-rex-plugins/templates/ui/utils/setchildreninteractive/SetChildrenInteractive.js
var GetValue99 = Phaser.Utils.Objects.GetValue;
var SetChildrenInteractive2 = function(gameObject2, config) {
  gameObject2.setInteractive();
  if (GetValue99(config, "dropZone", false)) {
    gameObject2.input.dropZone = true;
  }
  gameObject2._childrenInteractive = {
    targetSizers: GetValue99(config, "targets", [gameObject2]),
    targetMode: GetValue99(config, "targetMode", "parent"),
    eventEmitter: GetValue99(config, "eventEmitter", gameObject2),
    eventNamePrefix: GetValue99(config, "inputEventPrefix", "child.")
  };
  DownChild_default.call(gameObject2, config);
  UpChild_default.call(gameObject2, config);
  OverChild_default.call(gameObject2, config);
  ClickChild_default.call(gameObject2, config);
  TapChild_default.call(gameObject2, config);
  PressChild_default.call(gameObject2, config);
  SwipeChild_default.call(gameObject2, config);
  return gameObject2;
};
var SetChildrenInteractive_default2 = SetChildrenInteractive2;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/SetChildrenInteractive.js
var SetChildrenInteractiveWrap = function(config) {
  SetChildrenInteractive_default2(this, config);
  return this;
};
var SetChildrenInteractive_default3 = SetChildrenInteractiveWrap;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/BroadcastEvent.js
var BroadcastEvent = function() {
  var gameObjects = this.getAllChildren([this]);
  for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
    var gameObject2 = gameObjects[i];
    gameObject2.emit.apply(gameObject2, arguments);
  }
  return this;
};
var BroadcastEvent_default = BroadcastEvent;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/Methods.js
var methods17 = {
  getSizerConfig: GetSizerConfig_default2,
  getChildPrevState: GetChildPrevState_default,
  pushIntoBounds: PushIntoBounds_default,
  drawBounds: DrawBounds_default3,
  resolveWidth: ResolveWidth_default,
  hasWidthWrap: HasWidthWrap_default,
  resolveChildrenWidth: ResolveChildrenWidth_default,
  runWidthWrap: RunWidthWrap_default,
  resolveHeight: ResolveHeight_default,
  hasHeightWrap: HasHeightWrap_default,
  resolveChildrenHeight: ResolveChildrenHeight_default,
  runHeightWrap: RunHeightWrap_default,
  getChildWidth: GetChildWidth_default,
  getChildHeight: GetChildHeight_default,
  getExpandedChildWidth: GetExpandedChildWidth_default,
  getExpandedChildHeight: GetExpandedChildHeight_default,
  getChildrenWidth: GetChildrenWidth_default,
  getChildrenHeight: GetChildrenHeight_default,
  addChildrenMap: AddChildrenMap_default,
  addElement: AddChildrenMap_default,
  removeChildrenMap: RemoveChildrenMap_default,
  getElement: GetElement_default,
  getChildIndex: GetChildIndex_default,
  getAllChildrenSizers: GetAllChildrenSizers_default,
  getChildrenSizers: GetChildrenSizers_default,
  preLayout: PreLayout_default,
  layout: Layout_default,
  runLayout: RunLayout_default,
  layoutChildren: LayoutChildren_default,
  layoutBackgrounds: LayoutBackgrounds_default,
  postLayout: PostLayout_default,
  setAnchor: SetAnchor_default,
  isInTouching: IsInTouching_default,
  pointToChild: PointToChild_default,
  setDraggable: SetDraggable_default,
  setChildrenInteractive: SetChildrenInteractive_default3,
  broadcastEvent: BroadcastEvent_default
};
Object.assign(
  methods17,
  PaddingMethods_default,
  AddChildMethods_default,
  RemoveChildMethods_default,
  GetParentSizerMethods_default,
  ScaleMethods_default2,
  FadeMethods_default3,
  EaseMoveMethods_default2,
  ShakeMethods_default,
  EaseDataMethods_default,
  DelayCallMethods_default,
  ClickMethods_default,
  ClickOutsideMethods_default,
  TouchingMethods_default,
  HoverMethods_default,
  HideMethods_default,
  ModalMethods_default,
  GetShownChildrenMethods_default,
  BindEventMethods_default
);
var Methods_default18 = methods17;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/BaseSizer.js
var GetValue100 = Phaser.Utils.Objects.GetValue;
var Base4 = class extends Container_default {
  constructor(scene, x, y, minWidth, minHeight, config) {
    super(scene, x, y, 1, 1);
    this.isRexSizer = true;
    var origin = GetValue100(config, "origin", 0.5);
    var originX = GetValue100(config, "originX", origin);
    var originY = GetValue100(config, "originY", origin);
    this.setOrigin(originX, originY);
    this.setMinSize(minWidth, minHeight);
    this.setName(GetValue100(config, "name", ""));
    this.rexSizer = {};
    this.space = {};
    this.backgroundChildren = void 0;
    this.sizerChildren = void 0;
    this.childrenMap = {};
    this.layoutedChildren = void 0;
    this.runChildrenWrapFlag = false;
    this.enableLayoutWarn(false);
    var anchorConfig = GetValue100(config, "anchor", void 0);
    if (anchorConfig) {
      this.setAnchor(anchorConfig);
    }
    this.setInnerPadding(GetValue100(config, "space", 0));
    var draggable = GetValue100(config, "draggable", false);
    if (draggable) {
      this.setDraggable(draggable);
    }
    this.setSizerEventsEnable(GetValue100(config, "sizerEvents", false));
    this.setDirty(true);
    if (GetValue100(config, "enableLayer", false)) {
      this.enableLayer();
    }
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (fromScene) {
      var sizers = this.getAllChildrenSizers([this]);
      for (var i = 0, cnt = sizers.length; i < cnt; i++) {
        sizers[i].sizerEventsEnable = false;
      }
    }
    super.destroy(fromScene);
    Clear_default(this.backgroundChildren);
    Clear_default(this.sizerChildren);
    this.childrenMap = void 0;
    this.space = void 0;
    this.rexSizer = void 0;
    this.layoutedChildren = void 0;
  }
  setMinSize(minWidth, minHeight) {
    this.setMinWidth(minWidth).setMinHeight(minHeight);
    return this;
  }
  setMinWidth(minWidth) {
    if (minWidth == null) {
      minWidth = 0;
    }
    this.minWidth = minWidth;
    return this;
  }
  setMinHeight(minHeight) {
    if (minHeight == null) {
      minHeight = 0;
    }
    this.minHeight = minHeight;
    return this;
  }
  setDirty(dirty) {
    if (dirty === void 0) {
      dirty = true;
    }
    this.dirty = dirty;
    return this;
  }
  setSizerEventsEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.sizerEventsEnable = enable;
    return this;
  }
  enableLayoutWarn(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.layoutWarnEnable = enable;
    return this;
  }
  get ignoreLayout() {
    return this.rexSizer.hidden || !this.dirty;
  }
  get childrenWidth() {
    if (this._childrenWidth === void 0) {
      this._childrenWidth = this.getChildrenWidth();
    }
    return this._childrenWidth;
  }
  get childrenHeight() {
    if (this._childrenHeight === void 0) {
      this._childrenHeight = this.getChildrenHeight();
    }
    return this._childrenHeight;
  }
  get left() {
    return this.x - GetDisplayWidth(this) * this.originX;
  }
  set left(value) {
    this.x += value - this.left;
  }
  alignLeft(value) {
    this.left = value;
    return this;
  }
  get right() {
    return this.left + GetDisplayWidth(this);
  }
  set right(value) {
    this.x += value - this.right;
  }
  alignRight(value) {
    this.right = value;
    return this;
  }
  get centerX() {
    return this.left + GetDisplayWidth(this) / 2;
  }
  set centerX(value) {
    this.x += value - this.centerX;
  }
  alignCenterX(value) {
    this.centerX = value;
    return this;
  }
  get top() {
    return this.y - GetDisplayHeight(this) * this.originY;
  }
  set top(value) {
    this.y += value - this.top;
  }
  alignTop(value) {
    this.top = value;
    return this;
  }
  get bottom() {
    return this.top + GetDisplayHeight(this);
  }
  set bottom(value) {
    this.y += value - this.bottom;
  }
  alignBottom(value) {
    this.bottom = value;
    return this;
  }
  get centerY() {
    return this.top + GetDisplayHeight(this) / 2;
  }
  set centerY(value) {
    this.y += value - this.centerY;
  }
  alignCenterY(value) {
    this.centerY = value;
    return this;
  }
  get innerLeft() {
    return this.left + this.space.left * this.scaleX;
  }
  get innerRight() {
    return this.right - this.space.right * this.scaleX;
  }
  get innerTop() {
    return this.top + this.space.top * this.scaleY;
  }
  get innerBottom() {
    return this.bottom - this.space.bottom * this.scaleY;
  }
  get innerWidth() {
    return (this.width - this.space.left - this.space.right) * this.scaleX;
  }
  get innerHeight() {
    return (this.height - this.space.top - this.space.bottom) * this.scaleY;
  }
  get minInnerWidth() {
    var result = (this.minWidth - this.space.left - this.space.right) * this.scaleX;
    return Math.max(result, 0);
  }
  get minInnerHeight() {
    var result = (this.minHeight - this.space.top - this.space.bottom) * this.scaleY;
    return Math.max(result, 0);
  }
};
Object.assign(
  Base4.prototype,
  Methods_default18
);
var BaseSizer_default = Base4;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/GetChildrenWidth.js
var GetChildrenWidth2 = function() {
  if (this.rexSizer.hidden) {
    return 0;
  }
  var result = 0;
  var children = this.sizerChildren;
  var child, padding, childWidth;
  var hasUnknownChildWidth = false;
  for (var key2 in children) {
    child = children[key2];
    childWidth = this.getChildWidth(child);
    if (childWidth === void 0) {
      hasUnknownChildWidth = true;
    }
    if (hasUnknownChildWidth) {
      continue;
    }
    padding = child.rexSizer.padding;
    childWidth += (padding.left + padding.right) * this.scaleX;
    result = Math.max(childWidth, result);
  }
  if (hasUnknownChildWidth) {
    return void 0;
  }
  return result + (this.space.left + this.space.right) * this.scaleX;
};
var GetChildrenWidth_default2 = GetChildrenWidth2;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/GetChildrenHeight.js
var GetChildrenHeight2 = function() {
  if (this.rexSizer.hidden) {
    return 0;
  }
  var result = 0;
  var children = this.sizerChildren;
  var child, padding, childHeight;
  var hasUnknownChildHeight = false;
  for (var key2 in children) {
    child = children[key2];
    childHeight = this.getChildHeight(child);
    if (childHeight === void 0) {
      hasUnknownChildHeight = true;
    }
    if (hasUnknownChildHeight) {
      continue;
    }
    padding = child.rexSizer.padding;
    childHeight += (padding.top + padding.bottom) * this.scaleY;
    result = Math.max(childHeight, result);
  }
  if (hasUnknownChildHeight) {
    return void 0;
  }
  return result + (this.space.top + this.space.bottom) * this.scaleY;
};
var GetChildrenHeight_default2 = GetChildrenHeight2;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/GetExpandedChildWidth.js
var GetExpandedChildWidth2 = function(child, parentWidth) {
  if (parentWidth === void 0) {
    parentWidth = this.width * this.scaleX;
  }
  var childWidth;
  var childConfig = child.rexSizer;
  if (childConfig.expandWidth) {
    var innerWidth = parentWidth - (this.space.left + this.space.right) * this.scaleX;
    var padding = childConfig.padding;
    childWidth = innerWidth - (padding.left + padding.right) * this.scaleX;
  }
  return childWidth;
};
var GetExpandedChildWidth_default2 = GetExpandedChildWidth2;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/GetExpandedChildHeight.js
var GetExpandedChildHeight2 = function(child, parentHeight) {
  if (parentHeight === void 0) {
    parentHeight = this.height;
  }
  var childHeight;
  var childConfig = child.rexSizer;
  if (childConfig.expandHeight) {
    var innerHeight = parentHeight - (this.space.top + this.space.bottom) * this.scaleY;
    var padding = childConfig.padding;
    childHeight = innerHeight - (padding.top + padding.bottom) * this.scaleY;
  }
  return childHeight;
};
var GetExpandedChildHeight_default2 = GetExpandedChildHeight2;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/GetChildrenSizers.js
var GetChildrenSizers2 = function(out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  var children = this.sizerChildren, child;
  for (var key2 in children) {
    child = children[key2];
    if (child.isRexSizer) {
      out2.push(child);
    }
  }
  return out2;
};
var GetChildrenSizers_default2 = GetChildrenSizers2;

// node_modules/phaser3-rex-plugins/plugins/utils/size/FitTo.js
var FitTo = function(source, target, fitMode, out2) {
  if (fitMode === void 0) {
    fitMode = 0;
  } else {
    var fitModeType = typeof fitMode;
    if (fitModeType === "boolean") {
      out2 = fitMode;
      fitMode = 0;
    } else if (fitModeType === "string") {
      fitMode = FitModeMap[fitMode];
    }
  }
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    out2 = globalSize;
  }
  var scaleX = target.width / source.width;
  var scaleY = target.height / source.height;
  var scale = !fitMode ? Math.min(scaleX, scaleY) : Math.max(scaleX, scaleY);
  out2.width = source.width * scale;
  out2.height = source.height * scale;
  return out2;
};
var FitModeMap = {
  "fit": 0,
  "FIT": 0,
  "envelop": 1,
  "ENVELOP": 1
};
var globalSize = {};
var FitTo_default = FitTo;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/utils/CheckSize.js
var CheckSize = function(child, parent) {
  if (child.layoutWarnEnable) {
    if (child.width < child.childrenWidth) {
      console.warn(`Layout width error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
    }
    if (child.height < child.childrenHeight) {
      console.warn(`Layout height error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
    }
  }
};
var CheckSize_default = CheckSize;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/LayoutChildren.js
var LayoutChildren2 = function() {
  var child, childConfig, padding;
  var startX = this.innerLeft, startY = this.innerTop;
  var innerWidth = this.innerWidth, innerHeight = this.innerHeight;
  var x, y, width, height, alignOffsetX, alignOffsetY;
  var childWidth, childHeight, childSize;
  var children = this.sizerChildren;
  for (var key2 in children) {
    child = children[key2];
    if (child.rexSizer.hidden) {
      continue;
    }
    childConfig = child.rexSizer;
    padding = childConfig.padding;
    PreLayoutChild_default.call(this, child);
    childWidth = this.getExpandedChildWidth(child);
    childHeight = this.getExpandedChildHeight(child);
    if (childConfig.aspectRatio > 0) {
      sourceSize.width = childConfig.aspectRatio;
      sourceSize.height = 1;
      targetSize.width = childWidth;
      targetSize.height = childHeight;
      childSize = FitTo_default(sourceSize, targetSize, "FIT", true);
      childWidth = childSize.width;
      childHeight = childSize.height;
    }
    if (child.isRexSizer) {
      child.runLayout(this, childWidth, childHeight);
      CheckSize_default(child, this);
    } else {
      ResizeGameObject_default(child, childWidth, childHeight);
    }
    x = startX + padding.left * this.scaleX;
    width = innerWidth - (padding.left + padding.right) * this.scaleX;
    y = startY + padding.top * this.scaleY;
    height = innerHeight - (padding.top + padding.bottom) * this.scaleY;
    if (childWidth === void 0) {
      childWidth = GetDisplayWidth(child);
    }
    if (childHeight === void 0) {
      childHeight = GetDisplayHeight(child);
    }
    alignOffsetX = (childConfig.alignOffsetX + childConfig.alignOffsetOriginX * childWidth) * this.scaleX;
    alignOffsetY = (childConfig.alignOffsetY + childConfig.alignOffsetOriginY * childHeight) * this.scaleY;
    LayoutChild_default.call(
      this,
      child,
      x,
      y,
      width,
      height,
      childConfig.align,
      alignOffsetX,
      alignOffsetY
    );
  }
};
var sourceSize = {};
var targetSize = {};
var LayoutChildren_default2 = LayoutChildren2;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/AddChildMethods.js
var IsPlainObject28 = Phaser.Utils.Objects.IsPlainObject;
var GetValue101 = Phaser.Utils.Objects.GetValue;
var ALIGN_CENTER2 = Phaser.Display.Align.CENTER;
var UUID3 = Phaser.Utils.String.UUID;
var Add2 = function(gameObject2, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY, aspectRatio) {
  var offsetOriginX, offsetOriginY;
  AddChild_default4.call(this, gameObject2);
  if (IsPlainObject28(childKey)) {
    var config = childKey;
    childKey = GetValue101(config, "key", void 0);
    align = GetValue101(config, "align", ALIGN_CENTER2);
    padding = GetValue101(config, "padding", 0);
    expand = GetValue101(config, "expand", true);
    if (!gameObject2.isRexSizer) {
      minWidth = GetValue101(config, "minWidth", gameObject2._minWidth);
      minHeight = GetValue101(config, "minHeight", gameObject2._minHeighted);
    }
    offsetX = GetValue101(config, "offsetX", 0);
    offsetY = GetValue101(config, "offsetY", 0);
    offsetOriginX = GetValue101(config, "offsetOriginX", 0);
    offsetOriginY = GetValue101(config, "offsetOriginY", 0);
    aspectRatio = GetValue101(config, "aspectRatio", 0);
  }
  var hasValidKey = childKey !== void 0;
  if (!hasValidKey) {
    childKey = UUID3();
  }
  if (typeof align === "string") {
    align = AlignConst_default2[align];
  }
  if (align === void 0) {
    align = ALIGN_CENTER2;
  }
  if (padding === void 0) {
    padding = 0;
  }
  if (expand === void 0) {
    expand = true;
  }
  if (!gameObject2.isRexSizer) {
    if (minWidth === void 0) {
      minWidth = gameObject2._minWidth;
    }
    if (minHeight === void 0) {
      minHeight = gameObject2._minHeight;
    }
  }
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  if (offsetOriginX === void 0) {
    offsetOriginX = 0;
  }
  if (offsetOriginY === void 0) {
    offsetOriginY = 0;
  }
  if (aspectRatio === void 0) {
    aspectRatio = 0;
  } else if (aspectRatio === true) {
    aspectRatio = GetDisplayWidth(gameObject2) / GetDisplayHeight(gameObject2);
  }
  if (aspectRatio > 0) {
    expand = true;
    if (minWidth === void 0) {
      minWidth = 0;
    }
    if (minHeight === void 0) {
      minHeight = 0;
    }
  }
  var config = this.getSizerConfig(gameObject2);
  config.align = align;
  config.padding = GetBoundsConfig_default2(padding);
  if (IsPlainObject28(expand)) {
    config.expandWidth = GetValue101(expand, "width", false);
    config.expandHeight = GetValue101(expand, "height", false);
  } else {
    config.expandWidth = expand;
    config.expandHeight = expand;
  }
  if (!gameObject2.isRexSizer) {
    if (config.expandWidth) {
      gameObject2.minWidth = minWidth === void 0 ? GetDisplayWidth(gameObject2) : minWidth;
    }
    if (config.expandHeight) {
      gameObject2.minHeight = minHeight === void 0 ? GetDisplayHeight(gameObject2) : minHeight;
    }
  }
  config.alignOffsetX = offsetX;
  config.alignOffsetY = offsetY;
  config.alignOffsetOriginX = offsetOriginX;
  config.alignOffsetOriginY = offsetOriginY;
  config.aspectRatio = aspectRatio;
  if (this.sizerChildren.hasOwnProperty(childKey)) {
    this.sizerChildren[childKey].destroy();
  }
  this.sizerChildren[childKey] = gameObject2;
  if (hasValidKey) {
    this.addChildrenMap(childKey, gameObject2);
  }
  return this;
};
var AddChildMethods_default2 = {
  add: Add2
};

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/utils/ClearChildren.js
var ContainerClear = Container_default.prototype.clear;
var ClearChildren = function(destroyChild) {
  if (this.backgroundChildren) {
    this.backgroundChildren.length = 0;
  }
  var fireRemoveEvent = !destroyChild && this.sizerEventsEnable;
  var children;
  if (fireRemoveEvent) {
    children = this.getChildren([]);
  }
  ContainerClear.call(this, destroyChild);
  if (fireRemoveEvent) {
    var gameObject2;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      gameObject2 = children[i];
      gameObject2.emit("sizer.remove", gameObject2, this);
      this.emit("remove", gameObject2, this);
    }
  }
  return this;
};
var ClearChildren_default = ClearChildren;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/RemoveChildMethods.js
var RemoveChildMethods_default2 = {
  remove(gameObject2, destroyChild) {
    var key2;
    if (typeof gameObject2 === "string") {
      key2 = gameObject2;
      gameObject2 = this.sizerChildren[key2];
      if (!gameObject2) {
        return this;
      }
    } else if (this.getParentSizer(gameObject2) !== this) {
      return this;
    } else {
      key2 = this.childToKey(gameObject2);
    }
    if (key2) {
      delete this.sizerChildren[key2];
      if (this.childrenMap.hasOwnProperty(key2)) {
        delete this.childrenMap[key2];
      }
    }
    RemoveChild_default4.call(this, gameObject2, destroyChild);
    return this;
  },
  removeAll(destroyChild) {
    for (var key2 in this.sizerChildren) {
      this.remove(key2, destroyChild);
    }
    return this;
  },
  clear(destroyChild) {
    for (var key2 in this.sizerChildren) {
      delete this.sizerChildren[key2];
      if (this.childrenMap.hasOwnProperty(key2)) {
        delete this.childrenMap[key2];
      }
    }
    ClearChildren_default.call(this, destroyChild);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/Methods.js
var methods18 = {
  getChildrenWidth: GetChildrenWidth_default2,
  getChildrenHeight: GetChildrenHeight_default2,
  getExpandedChildWidth: GetExpandedChildWidth_default2,
  getExpandedChildHeight: GetExpandedChildHeight_default2,
  getChildrenSizers: GetChildrenSizers_default2,
  layoutChildren: LayoutChildren_default2
};
Object.assign(
  methods18,
  AddChildMethods_default2,
  RemoveChildMethods_default2
);
var Methods_default19 = methods18;

// node_modules/phaser3-rex-plugins/plugins/utils/object/IndexOf.js
var IndexOf = function(obj, child) {
  if (Array.isArray(obj)) {
    return obj.indexOf(child);
  } else {
    for (var key2 in obj) {
      if (obj[key2] === child) {
        return key2;
      }
    }
    return null;
  }
};
var IndexOf_default = IndexOf;

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/OverlapSizer.js
var IsPlainObject29 = Phaser.Utils.Objects.IsPlainObject;
var GetValue102 = Phaser.Utils.Objects.GetValue;
var OverlapSizer = class extends BaseSizer_default {
  constructor(scene, x, y, minWidth, minHeight, config) {
    if (IsPlainObject29(x)) {
      config = x;
      x = GetValue102(config, "x", 0);
      y = GetValue102(config, "y", 0);
      minWidth = GetValue102(config, "width", void 0);
      minHeight = GetValue102(config, "height", void 0);
    } else if (IsPlainObject29(minWidth)) {
      config = minWidth;
      minWidth = GetValue102(config, "width", void 0);
      minHeight = GetValue102(config, "height", void 0);
    }
    super(scene, x, y, minWidth, minHeight, config);
    this.type = "rexOverlapSizer";
    this.sizerChildren = {};
    this.addChildrenMap("items", this.sizerChildren);
  }
  childToKey(gameObject2) {
    if (typeof gameObject2 === "string") {
      var key2 = gameObject2;
      if (this.sizerChildren.hasOwnPropery(key2)) {
        return key2;
      }
    } else {
      return IndexOf_default(this.sizerChildren, gameObject2);
    }
    return null;
  }
};
Object.assign(
  OverlapSizer.prototype,
  Methods_default19
);
var OverlapSizer_default = OverlapSizer;

// node_modules/phaser3-rex-plugins/templates/ui/knob/input/IsLocalPointInKnob.js
var GetDistance2 = Phaser.Math.Distance.Between;
var IsLocalPointInKnob = function(knob, localX, localY) {
  var centerX = knob.width / 2;
  return GetDistance2(centerX, centerX, localX, localY) <= centerX;
};
var IsLocalPointInKnob_default = IsLocalPointInKnob;

// node_modules/phaser3-rex-plugins/templates/ui/knob/input/OnTouchPad.js
var GetAngle = Phaser.Math.Angle.Between;
var NormalizeAngle = Phaser.Math.Angle.Normalize;
var OnTouchPad = function(pointer, localX, localY) {
  if (!this.enable) {
    return;
  }
  if (!pointer.isDown) {
    return;
  }
  var knob = this.sizerChildren.knob;
  if (!IsLocalPointInKnob_default(knob, localX, localY)) {
    return;
  }
  var centerX = knob.width / 2;
  var startAngle = knob.startAngle;
  var endAngle = GetAngle(centerX, centerX, localX, localY);
  var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
  var value = NormalizeAngle(deltaAngle) / (2 * Math.PI);
  this.stopEaseValue();
  if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
    this.value = value;
  } else {
    this.easeValueTo(value);
  }
};
var InstallEvents = function() {
  var knob = this.sizerChildren.knob;
  knob.on("pointerdown", OnTouchPad, this).on("pointermove", OnTouchPad, this).setInteractive();
};
var OnTouchPad_default = InstallEvents;

// node_modules/phaser3-rex-plugins/templates/ui/knob/input/OnPanPad.js
var GetAngle2 = Phaser.Math.Angle.Between;
var WrapAngle = Phaser.Math.Angle.Wrap;
var OnPointerDown2 = function(pointer, localX, localY) {
  if (!this.enable || this.panPointer) {
    return;
  }
  var knob = this.sizerChildren.knob;
  if (!IsLocalPointInKnob_default(knob, localX, localY)) {
    return;
  }
  OnPanStart.call(this, pointer);
};
var OnPointerMove = function(pointer, localX, localY) {
  if (!this.enable) {
    return;
  }
  if (!pointer.isDown) {
    return;
  }
  var knob = this.sizerChildren.knob;
  switch (this.panState) {
    case TOUCH03:
      if (IsLocalPointInKnob_default(knob, localX, localY)) {
        OnPanStart.call(this, pointer);
      }
      break;
    case TOUCH13:
      if (IsLocalPointInKnob_default(knob, localX, localY)) {
        OnPan.call(this);
      } else {
        OnPanEnd.call(this);
      }
      break;
  }
};
var OnPointerUp2 = function(pointer, localX, localY) {
  if (!this.enable || this.panPointer !== pointer) {
    return;
  }
  OnPanEnd.call(this);
};
var OnPanStart = function(pointer) {
  this.panPointer = pointer;
  this.panState = TOUCH13;
};
var OnPanEnd = function() {
  this.panPointer = void 0;
  this.panState = TOUCH03;
};
var OnPan = function() {
  var p0 = this.panPointer.prevPosition, p1 = this.panPointer.position;
  var knob = this.sizerChildren.knob;
  var startAngle = GetAngle2(knob.x, knob.y, p0.x, p0.y), endAngle = GetAngle2(knob.x, knob.y, p1.x, p1.y);
  var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
  var deltaValue = WrapAngle(deltaAngle) / (Math.PI * 2);
  this.stopEaseValue();
  this.value += deltaValue;
};
var TOUCH03 = 0;
var TOUCH13 = 1;
var InstallEvents2 = function() {
  var knob = this.sizerChildren.knob;
  knob.on("pointerdown", OnPointerDown2, this).on("pointermove", OnPointerMove, this).on("pointerup", OnPointerUp2, this).setInteractive();
  this.panPointer = void 0;
  this.panState = TOUCH03;
};
var OnPanPad_default = InstallEvents2;

// node_modules/phaser3-rex-plugins/templates/ui/knob/TextObjectMethods.js
var SetTextFormatCallback = function(callback, scope) {
  this.textFormatCallback = callback;
  this.textFormatCallbackScope = scope;
  return this;
};
var GetFormatText = function(value) {
  if (value === void 0) {
    value = this.value;
  }
  var text;
  if (this.textFormatCallbackScope) {
    text = this.textFormatCallback(value);
  } else {
    text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
  }
  return text;
};
var UpdateText = function(value) {
  var textObject = this.sizerChildren.text;
  if (textObject && this.textFormatCallback) {
    textObject.setText(GetFormatText.call(this, value));
    if (textObject.layout) {
      textObject.layout();
    }
  }
  return this;
};
var TextObjectMethods_default = {
  setTextFormatCallback: SetTextFormatCallback,
  getFormatText: GetFormatText,
  updateText: UpdateText
};

// node_modules/phaser3-rex-plugins/templates/ui/knob/Knob.js
var GetValue103 = Phaser.Utils.Objects.GetValue;
var SnapTo = Phaser.Math.Snap.To;
var Knob = class extends ProgressBase_default(OverlapSizer_default) {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexKnob";
    this.bootProgressBase(config);
    var background = GetValue103(config, "background", void 0);
    var textObject = GetValue103(config, "text", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (textObject) {
      config.textColor = void 0;
      config.textStrokeColor = void 0;
      this.setTextFormatCallback(
        GetValue103(config, "textFormatCallback", void 0),
        GetValue103(config, "textFormatCallbackScope", void 0)
      );
      config.textFormatCallback = void 0;
      config.textFormatCallbackScope = void 0;
    }
    var knob = new CircularProgressCanvas_default(scene, config);
    knob.setDepth(GetValue103(config, "knobDepth", 0));
    knob._value = -1;
    scene.add.existing(knob);
    this.add(knob, "knob");
    if (textObject) {
      this.add(textObject, "text", "center", 0, false);
      scene.children.moveBelow(knob, textObject);
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("knob", knob);
    this.addChildrenMap("text", textObject);
    this.setEnable(GetValue103(config, "enable", void 0));
    this.setGap(GetValue103(config, "gap", void 0));
    this.setValue(GetValue103(config, "value", 0), GetValue103(config, "min", void 0), GetValue103(config, "max", void 0));
    var inputMode = GetValue103(config, "input", 0);
    if (typeof inputMode === "string") {
      inputMode = INPUTMODE[inputMode];
    }
    switch (inputMode) {
      case 0:
        OnPanPad_default.call(this);
        break;
      case 1:
        OnTouchPad_default.call(this);
        break;
    }
  }
  setEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.enable = enable;
    return this;
  }
  setGap(gap) {
    this.gap = gap;
    return this;
  }
  // Override
  get value() {
    return this.sizerChildren.knob.value;
  }
  // Override
  set value(value) {
    if (this.gap !== void 0) {
      value = SnapTo(value, this.gap);
    }
    var oldValue = this.value;
    this.sizerChildren.knob.value = value;
    var newValue = this.value;
    if (oldValue !== newValue) {
      this.updateText();
      this.eventEmitter.emit("valuechange", newValue, oldValue, this.eventEmitter);
    }
  }
};
var INPUTMODE = {
  pan: 0,
  drag: 0,
  click: 1,
  none: -1
};
Object.assign(
  Knob.prototype,
  TextObjectMethods_default
);
var Knob_default = Knob;

// node_modules/phaser3-rex-plugins/templates/ui/knob/Factory.js
ObjectFactory_default.register("knob", function(config) {
  var gameObject2 = new Knob_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Knob", Knob_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/customshapes/ShapesUpdateMethods.js
var ShapeClasses = {
  arc: Arc_default,
  circle: Circle_default,
  curve: Curve_default,
  ellipse: Ellipse_default,
  line: Line_default,
  lines: Lines_default,
  rectangle: Rectangle_default,
  roundRectangle: RoundRectangle_default5,
  triangle: Triangle_default
};
var GetValue104 = Phaser.Utils.Objects.GetValue;
var IsPlainObject30 = Phaser.Utils.Objects.IsPlainObject;
var ClearAll = function() {
  var shapes = this.getShapes();
  for (var i = 0, cnt = shapes.length; i < cnt; i++) {
    shapes[i].lineStyle().fillStyle();
  }
};
var ShapesUpdateMethods_default5 = {
  createShape(shapeType, name2) {
    var ShapeClass = ShapeClasses[shapeType];
    var shape = new ShapeClass();
    if (name2) {
      shape.setName(name2);
    }
    return shape;
  },
  buildShapes(config) {
    var createCallback = GetValue104(config, "create", void 0);
    if (IsPlainObject30(createCallback)) {
      var shapes = createCallback;
      for (var shapeType in shapes) {
        var name2 = shapes[shapeType];
        switch (typeof name2) {
          case "number":
            for (var i = 0; i < name2; i++) {
              this.addShape(this.createShape(shapeType));
            }
            break;
          case "string":
            this.addShape(this.createShape(shapeType, name2));
            break;
          default:
            var names = name2;
            for (var i = 0, cnt = names.length; i < cnt; i++) {
              this.addShape(this.createShape(shapeType, names[i]));
            }
            break;
        }
      }
    } else if (Array.isArray(createCallback)) {
      var shapes = createCallback;
      for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        var shape = shapes[i];
        this.addShape(this.createShape(shape.type, shape.name));
      }
    } else if (typeof createCallback === "function") {
      createCallback.call(this);
    }
    this.setUpdateShapesCallback(GetValue104(config, "update"));
  },
  setUpdateShapesCallback(callback) {
    if (callback === void 0) {
      callback = ClearAll;
    }
    this.dirty = this.dirty || this.updateCallback !== callback;
    this.updateCallback = callback;
    return this;
  },
  updateShapes() {
    this.updateCallback.call(this);
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/customshapes/CustomShapes.js
var GetValue105 = Phaser.Utils.Objects.GetValue;
var IsPlainObject31 = Phaser.Utils.Objects.IsPlainObject;
var CustomShapes = class extends BaseShapes_default {
  constructor(scene, x, y, width, height, config) {
    if (IsPlainObject31(x)) {
      config = x;
      x = GetValue105(config, "x", 0);
      y = GetValue105(config, "y", 0);
      width = GetValue105(config, "width", 2);
      height = GetValue105(config, "height", 2);
    }
    super(scene, x, y, width, height);
    this.type = GetValue105(config, "type", "rexCustomShapes");
    this.buildShapes(config);
  }
  get centerX() {
    return this.width / 2;
  }
  get centerY() {
    return this.height / 2;
  }
  worldToLocalXY(worldX, worldY, camera, out2) {
    if (typeof camera === "boolean") {
      out2 = camera;
      camera = void 0;
    }
    return WorldXYToGameObjectLocalXY_default(this, worldX, worldY, camera, out2);
  }
};
Object.assign(
  CustomShapes.prototype,
  ShapesUpdateMethods_default5
);
var CustomShapes_default = CustomShapes;

// node_modules/phaser3-rex-plugins/plugins/customshapes.js
var customshapes_default = CustomShapes_default;

// node_modules/phaser3-rex-plugins/templates/ui/customshapes/CustomShapes.js
var CustomShapes_default2 = customshapes_default;

// node_modules/phaser3-rex-plugins/templates/ui/customshapes/Factory.js
ObjectFactory_default.register("customShapes", function(x, y, width, height, config) {
  var gameObject2 = new CustomShapes_default2(this.scene, x, y, width, height, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.CustomShapes", CustomShapes_default2);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/shape/customprogress/CustomProgress.js
var GetValue106 = Phaser.Utils.Objects.GetValue;
var IsPlainObject32 = Phaser.Utils.Objects.IsPlainObject;
var CustomProgress = class extends ProgressBase_default(CustomShapes_default) {
  constructor(scene, x, y, width, height, config) {
    if (IsPlainObject32(x)) {
      config = x;
      x = GetValue106(config, "x", 0);
      y = GetValue106(config, "y", 0);
      width = GetValue106(config, "width", 2);
      height = GetValue106(config, "height", 2);
    }
    if (config === void 0) {
      config = {};
    }
    if (!config.type) {
      config.type = "rexCustomProgress";
    }
    super(scene, x, y, width, height, config);
    this.bootProgressBase(config);
    this.setValue(GetValue106(config, "value", 0));
  }
  get centerX() {
    return this.width / 2;
    ;
  }
  get centerY() {
    return this.height / 2;
  }
  get radius() {
    return Math.min(this.centerX, this.centerY);
  }
};
var CustomProgress_default = CustomProgress;

// node_modules/phaser3-rex-plugins/plugins/customprogress.js
var customprogress_default = CustomProgress_default;

// node_modules/phaser3-rex-plugins/templates/ui/customprogress/CustomProgress.js
var CustomProgress_default2 = customprogress_default;

// node_modules/phaser3-rex-plugins/templates/ui/customprogress/Factory.js
ObjectFactory_default.register("customProgress", function(x, y, width, height, config) {
  var gameObject2 = new CustomProgress_default2(this.scene, x, y, width, height, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.CustomProgress", CustomProgress_default2);

// node_modules/phaser3-rex-plugins/templates/spinner/base/EaseValueMethods.js
var Start2 = function(duration) {
  if (!this.easeValueTask) {
    this.easeValueTask = new EaseValueTask_default(this, { eventEmitter: null });
  }
  if (duration !== void 0) {
    this.duration = duration;
    this.easeValueTask.stop();
  }
  if (this.easeValueTask.isRunning) {
    return this;
  }
  this.easeValueTask.restart({
    key: "value",
    from: 0,
    to: 1,
    duration: this.duration,
    ease: this.ease,
    repeat: -1,
    // -1: infinity
    delay: this.delay,
    repeatDelay: this.repeatDelay
  });
  this.setDirty();
  return this;
};
var Stop = function() {
  if (!this.easeValueTask) {
    return this;
  }
  this.easeValueTask.stop();
  this.setDirty();
  return this;
};
var Pause2 = function() {
  if (!this.easeValueTask) {
    return this;
  }
  this.easeValueTask.pause();
  this.setDirty();
  return this;
};
var Resume2 = function() {
  if (!this.easeValueTask) {
    return this;
  }
  this.easeValueTask.pause();
  this.setDirty();
  return this;
};
var EaseValueMethods_default2 = {
  start: Start2,
  stop: Stop,
  pause: Pause2,
  resume: Resume2
};

// node_modules/phaser3-rex-plugins/templates/spinner/base/Base.js
var GetValue107 = Phaser.Utils.Objects.GetValue;
var Base5 = class extends BaseShapes_default {
  constructor(scene, config) {
    var x = GetValue107(config, "x", 0);
    var y = GetValue107(config, "y", 0);
    var width = GetValue107(config, "width", 64);
    var height = GetValue107(config, "height", 64);
    super(scene, x, y, width, height);
    this.resetFromConfig(config, true);
    this.buildShapes(config);
    if (GetValue107(config, "start", true)) {
      this.start();
    }
  }
  resetFromConfig(config, setDefaults) {
    if (setDefaults === void 0) {
      setDefaults = false;
    }
    var defaultValue;
    defaultValue = setDefaults ? 1e3 : this.duration;
    this.setDuration(GetValue107(config, "duration", defaultValue));
    defaultValue = setDefaults ? "Linear" : this.ease;
    this.setEase(GetValue107(config, "ease", defaultValue));
    defaultValue = setDefaults ? 0 : this.delay;
    this.setDelay(GetValue107(config, "delay", defaultValue));
    defaultValue = setDefaults ? 0 : this.repeatDelay;
    this.setRepeatDelay(GetValue107(config, "repeatDelay", defaultValue));
    defaultValue = setDefaults ? 16777215 : this.color;
    this.setColor(GetValue107(config, "color", defaultValue));
    defaultValue = setDefaults ? 0 : this.value;
    this.setValue(GetValue107(config, "value", defaultValue));
    return this;
  }
  buildShapes() {
  }
  get centerX() {
    return this.width / 2;
    ;
  }
  get centerY() {
    return this.height / 2;
  }
  get radius() {
    return Math.min(this.centerX, this.centerY);
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this.isColorChanged = this.isColorChanged || this._color !== value;
    this.dirty = this.dirty || this.isColorChanged;
    this._color = value;
    this.setShapesColor(value);
  }
  setColor(color) {
    this.color = color;
    return this;
  }
  setShapesColor(color) {
  }
  get value() {
    return this._value;
  }
  set value(value) {
    value = Phaser.Math.Clamp(value, 0, 1);
    this.dirty = this.dirty || this._value != value;
    this._value = value;
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  setDuration(duration) {
    this.duration = duration;
    return this;
  }
  setDelay(delay) {
    this.delay = delay;
    return this;
  }
  setRepeatDelay(repeatDelay) {
    this.repeatDelay = repeatDelay;
    return this;
  }
  setEase(ease) {
    this.ease = ease;
    return this;
  }
  get isRunning() {
    return this.tweenTask ? this.tweenTask.isRunning : false;
  }
};
Object.assign(
  Base5.prototype,
  EaseValueMethods_default2
);
var Base_default4 = Base5;

// node_modules/phaser3-rex-plugins/templates/spinner/utils/Yoyo.js
var Yoyo_default3 = Yoyo_default;

// node_modules/phaser3-rex-plugins/templates/spinner/arrow/UpdateShapeMethods.js
var DegToRad15 = Phaser.Math.DegToRad;
var Linear13 = Phaser.Math.Linear;
var ExpoIn = Phaser.Math.Easing.Expo.In;
var DIRMAP = {
  right: 0,
  down: 1,
  left: 2,
  up: 3
};
var ArrowPolygon = function(polygon, innerX, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d) {
  var p0 = Transform(innerX, 0, gridWidth, gridHeight, x0, y0, a, b, c, d);
  polygon.startAt(p0.x, p0.y);
  var p1 = Transform(outerX, 0, gridWidth, gridHeight, x0, y0, a, b, c, d);
  polygon.lineTo(p1.x, p1.y);
  var p2 = Transform(outerX, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
  polygon.lineTo(p2.x, p2.y);
  var p3 = Transform(0, outerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
  polygon.lineTo(p3.x, p3.y);
  var p4 = Transform(0, innerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
  polygon.lineTo(p4.x, p4.y);
  var p5 = Transform(innerX, innerX, gridWidth, gridHeight, x0, y0, a, b, c, d);
  polygon.lineTo(p5.x, p5.y);
  polygon.close();
};
var GlobPoint = {};
var Transform = function(gridX, gridY, gridWidth, gridHeight, x0, y0, a, b, c, d) {
  var x = gridX * gridWidth;
  var y = gridY * gridHeight;
  GlobPoint.x = a * x + b * y + x0;
  GlobPoint.y = c * x + d * y + y0;
  return GlobPoint;
};
var UpdateShapeMethods_default = {
  setDirection(direction) {
    if (typeof direction === "string") {
      direction = DIRMAP[direction];
    }
    this.direction = direction;
    return this;
  },
  buildShapes() {
    for (var i = 0; i < 3; i++) {
      this.addShape(new Lines_default());
    }
  },
  updateShapes() {
    var x0, y0, a, b, c, d;
    switch (this.direction) {
      case 1:
        x0 = this.centerX;
        y0 = this.centerY - this.radius;
        var radX = DegToRad15(315);
        a = Math.cos(radX);
        b = Math.sin(radX);
        var radY = DegToRad15(45);
        c = Math.cos(radY);
        d = Math.sin(radY);
        break;
      case 3:
        x0 = this.centerX;
        y0 = this.centerY + this.radius;
        var radX = DegToRad15(135);
        a = Math.cos(radX);
        b = Math.sin(radX);
        var radY = DegToRad15(225);
        c = Math.cos(radY);
        d = Math.sin(radY);
        break;
      case 2:
        x0 = this.centerX + this.radius;
        y0 = this.centerY;
        var radX = DegToRad15(225);
        a = Math.cos(radX);
        b = Math.sin(radX);
        var radY = DegToRad15(315);
        c = Math.cos(radY);
        d = Math.sin(radY);
        break;
      default:
        x0 = this.centerX - this.radius;
        y0 = this.centerY;
        var radX = DegToRad15(45);
        a = Math.cos(radX);
        b = Math.sin(radX);
        var radY = DegToRad15(135);
        c = Math.cos(radY);
        d = Math.sin(radY);
        break;
    }
    var gridSize = this.radius / 7;
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var shape = shapes[i];
      var t = (this.value + (cnt - i) * 0.1) % 1;
      t = ExpoIn(Yoyo_default3(t));
      var alpha = Linear13(0.25, 1, t);
      shape.fillStyle(this.color, alpha);
      var innerX = i * 3 + 1;
      var outerX = innerX + 2;
      ArrowPolygon(shape, innerX, outerX, gridSize, gridSize, x0, y0, a, b, c, d);
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/audio/UpdateShapeMethods.js
var Linear14 = Phaser.Math.Linear;
var UpdateShapeMethods_default2 = {
  buildShapes() {
    for (var i = 0; i < 4; i++) {
      this.addShape(new Line_default());
    }
    this.prevValue = void 0;
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var leftBound = centerX - radius;
    var bottomBound = centerY + radius;
    var maxLineHeight = radius * 2;
    var shapes = this.getShapes(), cnt = shapes.length;
    var cellWidth = radius * 2 / cnt;
    var lineWidth = cellWidth * 0.7;
    if (this.prevValue === void 0 || this.prevValue > this.value) {
      for (var i = 0; i < cnt; i++) {
        var line = shapes[i];
        var from = this.prevValue === void 0 ? Math.random() : line.getData("to");
        line.setData("from", from).setData("to", Math.random());
      }
    }
    this.prevValue = this.value;
    for (var i = 0; i < cnt; i++) {
      var line = shapes[i];
      var from = line.getData("from"), to = line.getData("to"), current = Linear14(from, to, this.value);
      var lineHeight = current * maxLineHeight;
      var x = leftBound + cellWidth * (i + 0.5);
      line.lineStyle(lineWidth, this.color, 1).setP0(x, bottomBound).setP1(x, bottomBound - lineHeight);
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/ball/UpdateShapeMethods.js
var Linear15 = Phaser.Math.Linear;
var UpdateShapeMethods_default3 = {
  buildShapes() {
    for (var i = 0; i < 3; i++) {
      this.addShape(new Circle_default());
    }
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var ballRadius = radius * 0.1;
    var lineWidth = Math.ceil(ballRadius * 0.25);
    var t = 1 - Yoyo_default3(this.value);
    var trackRadius = Linear15(0.3, 0.9, t) * radius;
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var ball = shapes[i];
      var t = (this.value + i / cnt) % 1;
      var angle = Math.PI * 2 * t;
      ball.lineStyle(lineWidth, this.color).setRadius(ballRadius).setCenterPosition(
        centerX + Math.cos(angle) * trackRadius,
        centerY + Math.sin(angle) * trackRadius
      );
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/bars/UpdateShapeMethods.js
var Linear16 = Phaser.Math.Linear;
var ExpoIn2 = Phaser.Math.Easing.Expo.In;
var UpdateShapeMethods_default4 = {
  buildShapes() {
    var cnt = 5;
    for (var i = 0; i < cnt; i++) {
      var line = new Line_default();
      this.addShape(line);
      var offset = Yoyo_default3(i / (cnt - 1)) / 2;
      line.setData("offset", offset);
    }
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var leftBound = centerX - radius;
    var maxLineHeight = radius * 2;
    var shapes = this.getShapes(), cnt = shapes.length;
    var cellWidth = radius * 2 / cnt;
    var lineWidth = cellWidth * 0.7;
    for (var i = 0; i < cnt; i++) {
      var line = shapes[i];
      var t = (this.value + line.getData("offset")) % 1;
      t = ExpoIn2(Yoyo_default3(t));
      var lineHeight = Linear16(0.4, 1, t) * maxLineHeight;
      var x = leftBound + cellWidth * (i + 0.5);
      line.lineStyle(lineWidth, this.color, 1).setP0(x, centerY - lineHeight / 2).setP1(x, centerY + lineHeight / 2);
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/box/UpdateShapeMethods.js
var UpdateShapeMethods_default5 = {
  buildShapes() {
    this.addShape(new Lines_default().setName("border"));
    this.addShape(new Lines_default().setName("fill"));
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var halfWidth = radius * 0.7;
    var left = centerX - halfWidth, top = centerY - halfWidth, width = halfWidth * 2;
    this.getShape("border").lineStyle(2, this.color, 1).startAt(left, top).lineTo(width, 0, true).lineTo(0, width, true).lineTo(-width, 0, true).lineTo(0, -width, true).close();
    if (this.value < 0.5) {
      var t = (0.5 - this.value) * 2;
      var height = width * t;
      this.getShape("fill").fillStyle(this.color, 1).startAt(left, top).lineTo(width, 0, true).lineTo(0, height, true).lineTo(-width, 0, true).lineTo(0, -height, true).close();
    } else {
      var t = (this.value - 0.5) * 2;
      var angle = 180 * t;
      this.getShape("border").rotateAround(centerX, centerY, angle);
      this.getShape("fill").fillStyle().lineStyle();
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/clock/UpdateShapeMethods.js
var RadToDeg12 = Phaser.Math.RadToDeg;
var WrapDegrees2 = Phaser.Math.Angle.WrapDegrees;
var WrapRad = Phaser.Math.Angle.Wrap;
var ShortestBetween2 = Phaser.Math.Angle.ShortestBetween;
var DegToRad16 = Phaser.Math.DegToRad;
var Rad270 = Phaser.Math.DegToRad(270);
var UpdateShapeMethods_default6 = {
  buildShapes() {
    this.addShape(new Circle_default().setName("border"));
    this.addShape(new Line_default().setName("minuteHand"));
    this.addShape(new Line_default().setName("hourHand"));
    this.minuteHandAngle = 0;
    this.hourHandAngle = 0;
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var lineWidth = Math.ceil(radius / 25);
    var borderRadius = radius - lineWidth / 2;
    var minuteHandLength = radius * 0.8;
    var hourHandLength = radius * 0.5;
    var prevMinuteHandAngle = this.minuteHandAngle;
    this.minuteHandAngle = Math.PI * 2 * this.value;
    var angle0 = WrapDegrees2(RadToDeg12(prevMinuteHandAngle));
    var angle1 = WrapDegrees2(RadToDeg12(this.minuteHandAngle));
    var deltaAngle = ShortestBetween2(angle0, angle1);
    this.hourHandAngle = WrapRad(this.hourHandAngle + DegToRad16(deltaAngle) / 12);
    this.getShape("border").lineStyle(lineWidth, this.color).setRadius(borderRadius).setCenterPosition(centerX, centerY);
    var angle = this.minuteHandAngle + Rad270;
    this.getShape("minuteHand").lineStyle(lineWidth, this.color).setP0(centerX, centerY).setP1(
      centerX + Math.cos(angle) * minuteHandLength,
      centerY + Math.sin(angle) * minuteHandLength
    );
    var angle = this.hourHandAngle + Rad270;
    this.getShape("hourHand").lineStyle(lineWidth, this.color).setP0(centerX, centerY).setP1(
      centerX + Math.cos(angle) * hourHandLength,
      centerY + Math.sin(angle) * hourHandLength
    );
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/cube/UpdateShapeMethods.js
var Linear17 = Phaser.Math.Linear;
var ExpoIn3 = Phaser.Math.Easing.Expo.In;
var RowNum = 2;
var ColNum = 2;
var UpdateShapeMethods_default7 = {
  buildShapes() {
    var cnt = RowNum * ColNum;
    for (var i = 0; i < cnt; i++) {
      var line = new Line_default();
      this.addShape(line);
    }
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var leftBound = centerX - radius;
    var topBound = centerY - radius;
    var cellWidth = radius * 2 / ColNum;
    var cellHeight = radius * 2 / RowNum;
    var shapes = this.getShapes(), cnt = shapes.length;
    for (var i = 0; i < cnt; i++) {
      var colIdx = i % ColNum;
      var rowIdx = Math.floor(i / RowNum);
      var x = leftBound + cellWidth * (colIdx + 0.5);
      var y = topBound + cellHeight * (rowIdx + 0.5);
      var line = shapes[i];
      var t = (this.value + (cnt - i) * 0.1) % 1;
      t = ExpoIn3(Yoyo_default3(t));
      var lineAlpha = (cnt - i) / cnt;
      var lineHeight = Linear17(0.7, 1, t) * cellHeight;
      var lineWidth = Linear17(0.7, 1, t) * cellWidth;
      line.lineStyle(lineWidth, this.color, lineAlpha).setP0(x - lineHeight / 2, y).setP1(x + lineHeight / 2, y);
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/dots/UpdateShapeMethods.js
var Linear18 = Phaser.Math.Linear;
var UpdateShapeMethods_default8 = {
  buildShapes() {
    var cnt = 3;
    for (var i = 0; i < cnt; i++) {
      var dot = new Circle_default();
      this.addShape(dot);
      var offset = Yoyo_default3(i / (cnt - 1)) / 2;
      dot.setData("offset", offset);
    }
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var leftBound = centerX - radius;
    var shapes = this.getShapes(), cnt = shapes.length;
    var cellWidth = radius * 2 / cnt;
    var maxDotRadius = cellWidth / 2;
    for (var i = 0; i < cnt; i++) {
      var dot = shapes[i];
      var t = (this.value + dot.getData("offset")) % 1;
      t = Yoyo_default3(t);
      var dotAlpha = Linear18(0.25, 1, t);
      var dotRadius = Linear18(0.5, 1, t) * maxDotRadius;
      dot.fillStyle(this.color, dotAlpha).setRadius(dotRadius).setCenterPosition(
        leftBound + cellWidth * (i + 0.5),
        centerY
      );
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/facebook/UpdateShapeMethods.js
var Linear19 = Phaser.Math.Linear;
var ExpoIn4 = Phaser.Math.Easing.Expo.In;
var UpdateShapeMethods_default9 = {
  buildShapes() {
    for (var i = 0; i < 3; i++) {
      var shape = new Line_default();
      this.addShape(shape);
    }
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var leftBound = centerX - radius;
    var shapes = this.getShapes(), cnt = shapes.length;
    var cellWidth = radius * 2 / cnt;
    var cellHeight = radius * 2;
    for (var i = 0; i < cnt; i++) {
      var line = shapes[i];
      var t = (this.value + (cnt - i) * 0.1) % 1;
      t = ExpoIn4(Yoyo_default3(t));
      var lineAlpha = (i + 1) / cnt;
      var lineHeight = Linear19(0.7, 1, t) * cellHeight;
      var lineWidth = Linear19(0.7, 1, t) * cellWidth;
      var x = leftBound + cellWidth * (i + 0.5);
      line.lineStyle(lineWidth, this.color, lineAlpha).setP0(x, centerY - lineHeight / 2).setP1(x, centerY + lineHeight / 2);
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/grid/UpdateShapeMethods.js
var Linear20 = Phaser.Math.Linear;
var RowNum2 = 3;
var ColNum2 = 3;
var UpdateShapeMethods_default10 = {
  buildShapes() {
    var cnt = RowNum2 * ColNum2;
    for (var i = 0; i < cnt; i++) {
      var dot = new Circle_default();
      this.addShape(dot);
      dot.setData("offset", Math.random());
    }
    this.isInitialize = true;
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var needLayout = this.isInitialize || this.isSizeChanged;
    var leftBound = centerX - radius;
    var topBound = centerY - radius;
    var cellWidth = radius * 2 / ColNum2;
    var cellHeight = radius * 2 / RowNum2;
    var maxDotRadius = Math.min(cellWidth, cellHeight) / 2 * 0.8;
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var colIdx = i % ColNum2;
      var rowIdx = Math.floor(i / RowNum2);
      var x = leftBound + cellWidth * (colIdx + 0.5);
      var y = topBound + cellHeight * (rowIdx + 0.5);
      var dot = shapes[i];
      var t = (this.value + dot.getData("offset")) % 1;
      t = Yoyo_default3(t);
      dot.fillStyle(this.color, Linear20(0.25, 1, t));
      if (needLayout) {
        dot.setRadius(maxDotRadius).setCenterPosition(x, y);
      }
    }
    this.isInitialize = false;
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/hearts/UpdateShapeMethods.js
var UpdateShapeMethods_default11 = {
  buildShapes() {
    for (var i = 0; i < 2; i++) {
      this.addShape(new Lines_default());
    }
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var lineWidth = Math.ceil(radius / 25);
    var maxW50 = radius - lineWidth, maxW30 = maxW50 * 0.6, maxW35 = maxW50 * 0.7, maxW60 = maxW50 * 1.2;
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var heart = shapes[i];
      var t = (this.value + i / cnt) % 1;
      var alpha = Yoyo_default3(t);
      var x = centerX, y = centerY - 15 * t;
      var w50 = maxW50 * t, w30 = maxW30 * t, w35 = maxW35 * t, w60 = maxW60 * t;
      heart.lineStyle(lineWidth, this.color, alpha).startAt(
        x,
        y
      ).cubicBezierTo(
        x,
        y - w30,
        x - w50,
        y - w30,
        x - w50,
        y
      ).cubicBezierTo(
        x - w50,
        y + w30,
        x,
        y + w35,
        x,
        y + w60
      ).cubicBezierTo(
        x,
        y + w35,
        x + w50,
        y + w30,
        x + w50,
        y
      ).cubicBezierTo(
        x + w50,
        y - w30,
        x,
        y - w30,
        x,
        y
      ).close();
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/ios/UpdateShapeMethods.js
var Linear21 = Phaser.Math.Linear;
var UpdateShapeMethods_default12 = {
  buildShapes() {
    for (var i = 0; i < 12; i++) {
      this.addShape(new Line_default());
    }
    this.isInitialize = true;
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var needLayout = this.isInitialize || this.isSizeChanged;
    var radius = this.radius;
    var startRadius = radius / 2;
    var lineWidth = Math.ceil(radius / 20);
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var line = shapes[i];
      var t = i / cnt;
      var angle = Math.PI * 2 * t;
      var alpha = Linear21(0.25, 1, (1 - this.value + t) % 1);
      line.lineStyle(lineWidth, this.color, alpha);
      if (needLayout) {
        line.setP0(
          centerX + Math.cos(angle) * startRadius,
          centerY + Math.sin(angle) * startRadius
        ).setP1(
          centerX + Math.cos(angle) * radius,
          centerY + Math.sin(angle) * radius
        );
      }
    }
    this.isInitialize = false;
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/orbit/UpdateShapeMethods.js
var UpdateShapeMethods_default13 = {
  buildShapes() {
    this.addShape(new Circle_default().setName("track"));
    this.addShape(new Circle_default().setName("thumb"));
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var trackRadius = radius * 0.9;
    var trackThickness = Math.ceil(trackRadius / 25);
    var thumbRadius = radius * 0.1;
    var thumbAngle = Math.PI * 2 * this.value;
    this.getShape("track").lineStyle(trackThickness, this.color, 0.7).setRadius(trackRadius).setCenterPosition(centerX, centerY);
    this.getShape("thumb").fillStyle(this.color).setRadius(thumbRadius).setCenterPosition(
      centerX + Math.cos(thumbAngle) * trackRadius,
      centerY + Math.sin(thumbAngle) * trackRadius
    );
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/oval/UpdateShapeMethods.js
var UpdateShapeMethods_default14 = {
  buildShapes() {
    this.addShape(new Circle_default().setName("track"));
    this.addShape(new Arc_default().setName("arc"));
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var lineWidth = Math.ceil(radius / 25);
    var maxRadius = radius - lineWidth / 2;
    this.getShape("track").lineStyle(lineWidth, this.color, 0.5).setRadius(maxRadius).setCenterPosition(centerX, centerY);
    var startAngle = this.value * 360;
    var endAngle = startAngle + 60;
    this.getShape("arc").lineStyle(lineWidth, this.color, 1).setRadius(maxRadius).setCenterPosition(centerX, centerY).setAngle(startAngle, endAngle);
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/pie/UpdateShapeMethods.js
var Linear22 = Phaser.Math.Linear;
var UpdateShapeMethods_default15 = {
  buildShapes() {
    for (var i = 0; i < 4; i++) {
      var pie = new Arc_default().setPie();
      this.addShape(pie);
      pie.setData("speed", Linear22(180, 360, Math.random()));
    }
    this.prevValue = void 0;
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var deltaValue;
    if (this.prevValue !== void 0) {
      deltaValue = this.value - this.prevValue;
      if (this.prevValue > this.value) {
        deltaValue += 1;
      }
    }
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var pie = shapes[i];
      var pieAlpha = (i + 1) / cnt;
      if (this.prevValue === void 0) {
        var startAngle = i / cnt * 360;
        var endAngle = startAngle + 90;
        pie.fillStyle(this.color, pieAlpha).setRadius(radius).setCenterPosition(centerX, centerY).setAngle(startAngle, endAngle).setData("angle", startAngle);
      } else {
        var startAngle = pie.getData("angle") + pie.getData("speed") * deltaValue;
        startAngle = startAngle % 360;
        var endAngle = startAngle + 90;
        pie.fillStyle(this.color, pieAlpha).setRadius(radius).setCenterPosition(centerX, centerY).setAngle(startAngle, endAngle).setData("angle", startAngle);
      }
    }
    this.prevValue = this.value;
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/puff/UpdateShapeMethods.js
var UpdateShapeMethods_default16 = {
  buildShapes() {
    this.addShape(new Circle_default());
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var puffRadius = radius * this.value;
    var lineWidth = Math.ceil(radius / 25);
    var alpha = Yoyo_default3(this.value);
    this.getShapes()[0].lineStyle(lineWidth, this.color, alpha).setRadius(puffRadius).setCenterPosition(centerX, centerY);
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/radio/UpdateShapeMethods.js
var Linear23 = Phaser.Math.Linear;
var ExpoIn5 = Phaser.Math.Easing.Expo.In;
var UpdateShapeMethods_default17 = {
  buildShapes() {
    this.addShape(new Circle_default().setName("center"));
    this.addShape(new Lines_default().setName("arc0"));
    this.addShape(new Lines_default().setName("arc1"));
    this.isInitialize = true;
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var needLayout = this.isInitialize || this.isSizeChanged;
    var centerRadius = radius * 2 / 6;
    var x = centerX - radius + centerRadius;
    var y = centerY + radius - centerRadius;
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var shape = shapes[i];
      var t = (this.value + (cnt - i) * 0.1) % 1;
      t = ExpoIn5(Yoyo_default3(t));
      var alpha = Linear23(0.25, 1, t);
      switch (shape.name) {
        case "center":
          shape.fillStyle(this.color, alpha);
          if (needLayout) {
            shape.setRadius(centerRadius).setCenterPosition(x, y);
          }
          break;
        case "arc0":
          shape.fillStyle(this.color, alpha);
          if (needLayout) {
            var radius0 = centerRadius * 2, radius1 = centerRadius * 3;
            shape.startAt(x, y - radius0).lineTo(x, y - radius1).setIterations(8).arc(x, y, radius1, 270, 360).lineTo(x + radius0, y).setIterations(6).arc(x, y, radius0, 360, 270, true).close();
          }
          break;
        case "arc1":
          shape.fillStyle(this.color, alpha);
          if (needLayout) {
            var radius0 = centerRadius * 4, radius1 = centerRadius * 5;
            shape.startAt(x, y - radius0).lineTo(x, y - radius1).setIterations(8).arc(x, y, radius1, 270, 360).lineTo(x + radius0, y).setIterations(6).arc(x, y, radius0, 360, 270, true).close();
          }
          break;
      }
    }
    this.isInitialize = false;
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/rings/UpdateShapeMethods.js
var UpdateShapeMethods_default18 = {
  buildShapes() {
    for (var i = 0; i < 2; i++) {
      this.addShape(new Circle_default());
    }
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var lineWidth = Math.ceil(radius / 25);
    var maxRingRadius = radius - lineWidth;
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      var ring = shapes[i];
      var t = (this.value + i / cnt) % 1;
      var alpha = Yoyo_default3(t);
      ring.lineStyle(lineWidth, this.color, alpha).setRadius(t * maxRingRadius).setCenterPosition(centerX, centerY);
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/spinner/UpdateShapeMethods.js
var UpdateShapeMethods_default19 = {
  buildShapes() {
    this.addShape(new Arc_default().setName("arc"));
  },
  updateShapes() {
    var centerX = this.centerX;
    var centerY = this.centerY;
    var radius = this.radius;
    var lineWidth = Math.ceil(radius / 10);
    var maxRadius = radius - lineWidth;
    var endAngle = this.value * 720;
    var arcAngle = Yoyo_default3(this.value) * 180;
    var startAngle = endAngle - arcAngle;
    this.getShape("arc").lineStyle(lineWidth, this.color, 1).setRadius(maxRadius).setCenterPosition(centerX, centerY).setAngle(startAngle + 315, endAngle + 315);
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/aio/UpdateShapeMethods.js
var GetValue108 = Phaser.Utils.Objects.GetValue;
var AnimationModeMap = {
  leftArrow: UpdateShapeMethods_default,
  rightArrow: UpdateShapeMethods_default,
  upArrow: UpdateShapeMethods_default,
  downArrow: UpdateShapeMethods_default,
  audio: UpdateShapeMethods_default2,
  ball: UpdateShapeMethods_default3,
  bars: UpdateShapeMethods_default4,
  box: UpdateShapeMethods_default5,
  clock: UpdateShapeMethods_default6,
  cube: UpdateShapeMethods_default7,
  dots: UpdateShapeMethods_default8,
  facebook: UpdateShapeMethods_default9,
  grid: UpdateShapeMethods_default10,
  hearts: UpdateShapeMethods_default11,
  ios: UpdateShapeMethods_default12,
  oribit: UpdateShapeMethods_default13,
  oval: UpdateShapeMethods_default14,
  pie: UpdateShapeMethods_default15,
  puff: UpdateShapeMethods_default16,
  radio: UpdateShapeMethods_default17,
  rings: UpdateShapeMethods_default18,
  spinner: UpdateShapeMethods_default19
};
var AnimationModeList = [];
for (name2 in AnimationModeMap) {
  AnimationModeList.push(name2);
}
var name2;
var GetRandomItem = Phaser.Utils.Array.GetRandom;
var UpdateShapeMethods_default20 = {
  setAnimationMode(mode, config) {
    if (!AnimationModeMap.hasOwnProperty(mode)) {
      mode = GetRandomItem(AnimationModeList);
    }
    this.animationMode = mode;
    var updateMethods = AnimationModeMap[mode];
    if (config) {
      this.resetFromConfig(config);
    }
    switch (mode) {
      case "leftArrow":
        updateMethods.setDirection.call(this, "left");
        break;
      case "rightArrow":
        updateMethods.setDirection.call(this, "right");
        break;
      case "upArrow":
        updateMethods.setDirection.call(this, "up");
        break;
      case "downArrow":
        updateMethods.setDirection.call(this, "down");
        break;
    }
    this.clear();
    updateMethods.buildShapes.call(this);
    this.updateShapes = updateMethods.updateShapes.bind(this);
    this.stop().start();
    return this;
  },
  setRandomAnimationMode(config) {
    var mode = GetRandomItem(AnimationModeList);
    this.setAnimationMode(mode, config);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/spinner/aio/AIO.js
var GetValue109 = Phaser.Utils.Objects.GetValue;
var AIO = class extends Base_default4 {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexSpinnerAIO";
    this.setAnimationMode(GetValue109(config, "animationMode"));
  }
};
Object.assign(
  AIO.prototype,
  UpdateShapeMethods_default20
);
var AIO_default = AIO;

// node_modules/phaser3-rex-plugins/templates/ui/aiospinner/AIOSpinner.js
var AIOSpinner_default = AIO_default;

// node_modules/phaser3-rex-plugins/templates/ui/aiospinner/Factory.js
ObjectFactory_default.register("aioSpinner", function(config) {
  var gameObject2 = new AIOSpinner_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.AIOSpinner", AIOSpinner_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/SetTransitionCallbackMethods.js
var SetTransitionCallbackMethods_default = {
  setTransitionStartCallback(callback, scope) {
    this.onStartCallback = callback;
    this.onStartCallbackScope = scope;
    return this;
  },
  setTransitionProgressCallback(callback, scope) {
    this.onProgressCallback = callback;
    this.onProgressCallbackScope = scope;
    return this;
  },
  setTransitionCompleteCallback(callback, scope) {
    this.onCompleteCallback = callback;
    this.onCompleteCallbackScope = scope;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/FitImages.js
var FitImages = function() {
  var scaleMode = this.scaleMode - 1;
  for (var i = 0, cnt = this.images.length; i < cnt; i++) {
    var image = this.images[i];
    var result = FitTo_default(image, this, scaleMode, true);
    var biasScale = result.width / image.width;
    this.setChildLocalScale(image, biasScale);
    image.biasScale = biasScale;
  }
};
var FitImages_default = FitImages;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/OnTextureChange.js
var OnTextureChange = function(newImage) {
  if (this.scaleMode === 0) {
    this.resize(newImage.width, newImage.height);
  } else {
    FitImages_default.call(this);
  }
};
var OnTextureChange_default = OnTextureChange;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/TransitionMethods.js
var IsPlainObject33 = Phaser.Utils.Objects.IsPlainObject;
var GetValue110 = Phaser.Utils.Objects.GetValue;
var GetRandomItem2 = Phaser.Utils.Array.GetRandom;
var DirMode = {
  out: 0,
  in: 1
};
var GetValueFromConfigs = function(key2, defaultValue, ...configs) {
  for (var i = 0, cnt = configs.length; i < cnt; i++) {
    var config = configs[i];
    if (config && config.hasOwnProperty(key2)) {
      return config[key2];
    }
  }
  return defaultValue;
};
var TransitionMethods_default = {
  setTransitionDirection(dir) {
    if (typeof dir === "string") {
      dir = DirMode[dir];
    }
    this.dir = dir;
    return this;
  },
  setDuration(duration) {
    this.duration = duration;
    return this;
  },
  setEaseFunction(ease) {
    this.easeFunction = ease;
    return this;
  },
  setNextTexture(texture, frame) {
    this.nextImage.setTexture(texture, frame);
    OnTextureChange_default.call(this, this.nextImage);
    return this;
  },
  transit(texture, frame, mode) {
    if (this.isRunning) {
      this.ignoreCompleteEvent = true;
      this.stop();
      this.ignoreCompleteEvent = false;
    }
    if (mode !== void 0) {
      texture = {
        key: texture,
        frame,
        mode
      };
    }
    this.currentTransitionMode = void 0;
    if (IsPlainObject33(texture)) {
      var config = texture;
      texture = GetValue110(config, "key", void 0);
      frame = GetValue110(config, "frame", void 0);
      mode = GetValue110(config, "mode");
      if (Array.isArray(mode)) {
        mode = GetRandomItem2(mode);
      }
      var modeConfig;
      if (this.transitionModes && this.transitionModes.hasOwnProperty(mode)) {
        modeConfig = this.transitionModes[mode];
        this.currentTransitionMode = mode;
      }
      this.setDuration(GetValueFromConfigs("duration", this.duration, config, modeConfig)).setEaseFunction(GetValueFromConfigs("ease", this.easeFunction, config, modeConfig)).setTransitionDirection(GetValueFromConfigs("dir", this.dir, config, modeConfig));
      var maskGameObject = GetValueFromConfigs("mask", void 0, config, modeConfig);
      if (maskGameObject) {
        this.setMaskGameObject(maskGameObject);
      }
      this.setMaskEnable(maskGameObject === true);
      var onStart = GetValueFromConfigs("onStart", void 0, config, modeConfig);
      var onProgress = GetValueFromConfigs("onProgress", void 0, config, modeConfig);
      var onComplete = GetValueFromConfigs("onComplete", void 0, config, modeConfig);
      if (onStart !== void 0 || onProgress !== void 0 || onComplete !== void 0) {
        this.setTransitionStartCallback(
          onStart,
          GetValueFromConfigs("onStartScope", void 0, config, modeConfig)
        ).setTransitionProgressCallback(
          onProgress,
          GetValueFromConfigs("onProgressScope", void 0, config, modeConfig)
        ).setTransitionCompleteCallback(
          onComplete,
          GetValueFromConfigs("onCompleteScope", void 0, config, modeConfig)
        );
      }
    }
    this.setNextTexture(texture, frame);
    this.start();
    return this;
  },
  addTransitionMode(name2, config) {
    if (this.transitionModes === void 0) {
      this.transitionModes = {};
    }
    if (IsPlainObject33(name2)) {
      config = name2;
      name2 = config.name;
      delete config.name;
    }
    this.transitionModes[name2] = config;
    return this;
  },
  start() {
    if (this.easeValueTask === void 0) {
      this.easeValueTask = new EaseValueTask_default(this, { eventEmitter: null });
    }
    this.easeValueTask.restart({
      key: "t",
      from: 0,
      to: 1,
      duration: this.duration,
      ease: this.easeFunction
    });
    return this;
  },
  pause() {
    if (this.easeValueTask) {
      this.easeValueTask.pause();
    }
    return this;
  },
  resume() {
    if (this.easeValueTask) {
      this.easeValueTask.resume();
    }
    return this;
  },
  stop() {
    if (this.easeValueTask) {
      this.easeValueTask.stop();
    }
    this.setT(1);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/SetPosition.js
var SetPositionBase = Phaser.GameObjects.Graphics.prototype.setPosition;
var SetPosition = function(x, y) {
  var parent = this.parent;
  if (x === void 0) {
    x = parent.x;
  }
  if (y === void 0) {
    y = parent.y;
  }
  SetPositionBase.call(this, x, y);
  return this;
};
var SetPosition_default = SetPosition;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/GetGeom.js
var RectangleGeom = Phaser.Geom.Rectangle;
var CircleGemo = Phaser.Geom.Circle;
var GetGeom = function(shapeType, width, height, padding, originX, originY, out2) {
  switch (shapeType) {
    case 1:
      padding = padding.left;
      var centerX = -width * (originX - 0.5);
      var centerY = -height * (originY - 0.5);
      var radius = Math.min(width, height) / 2 + padding;
      if (out2 === void 0 || !(out2 instanceof CircleGemo)) {
        out2 = new CircleGemo();
      }
      out2.setTo(centerX, centerY, radius);
      break;
    default:
      var topLeftX = -(width * originX) - padding.left;
      var topLeftY = -(height * originY) - padding.top;
      var rectWidth = width + padding.left + padding.right;
      var rectHeight = height + padding.top + padding.bottom;
      if (out2 === void 0 || !(out2 instanceof RectangleGeom)) {
        out2 = new RectangleGeom();
      }
      out2.setTo(topLeftX, topLeftY, rectWidth, rectHeight);
      break;
  }
  return out2;
};
var GetGeom_default = GetGeom;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/DrawShape.js
var DrawShape = function(width, height, padding, originX, originY) {
  this.geom = GetGeom_default(this.shapeType, width, height, padding, originX, originY, this.geom);
  this.clear().fillStyle(16777215);
  switch (this.shapeType) {
    case 1:
      this.fillCircleShape(this.geom);
      break;
    default:
      this.fillRectShape(this.geom);
      break;
  }
};
var DrawShape_default = DrawShape;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/Resize.js
var Resize2 = function(width, height, padding) {
  var parent = this.parent;
  if (width === void 0) {
    width = parent.width;
  }
  if (height === void 0) {
    height = parent.height;
  }
  if (padding === void 0) {
    padding = this.padding;
  } else if (typeof padding === "number") {
    padding = GetBoundsConfig(padding);
  }
  var isSizeChanged = this.width !== width || this.height !== height;
  var isPaddingChanged = this.padding !== padding && !IsKeyValueEqual_default(this.padding, padding);
  if (!isSizeChanged && !isPaddingChanged) {
    return this;
  }
  this.width = width;
  this.height = height;
  if (isPaddingChanged) {
    Clone_default(padding, this.padding);
  }
  this.originX = parent.originX;
  this.originY = parent.originY;
  DrawShape_default.call(
    this,
    width,
    height,
    padding,
    parent.originX,
    parent.originY
  );
  return this;
};
var Resize_default3 = Resize2;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/SetOrigin.js
var SetOrigin = function(originX, originY) {
  if (originY === void 0) {
    originY = originX;
  }
  var parent = this.parent;
  if (originX === void 0) {
    originX = parent.originX;
  }
  if (originY === void 0) {
    originY = parent.originY;
  }
  if (this.originX === originX && this.originY === originY) {
    return this;
  }
  this.originX = originX;
  this.originY = originY;
  DrawShape_default.call(
    this,
    this.width,
    this.height,
    this.padding,
    originX,
    originY
  );
  return this;
};
var SetOrigin_default = SetOrigin;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/Contains.js
var Contains2 = function(x, y) {
  x -= this.x;
  y -= this.y;
  return this.geom.contains(x, y);
};
var Contains_default2 = Contains2;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/methods/Methods.js
var Methods12 = {
  setPosition: SetPosition_default,
  resize: Resize_default3,
  setOrigin: SetOrigin_default,
  contains: Contains_default2
};
var Methods_default20 = Methods12;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/defaultmaskgraphics/DefaultMaskGraphics.js
var Graphics = Phaser.GameObjects.Graphics;
var DefaultMaskGraphics = class extends Graphics {
  constructor(parent, shapeType, padding) {
    if (shapeType === void 0) {
      shapeType = 0;
    }
    if (typeof shapeType === "string") {
      shapeType = SHAPEMODE[shapeType];
    }
    super(parent.scene);
    this.parent = parent;
    this.shapeType = shapeType;
    this.padding = GetBoundsConfig_default(padding);
    this.setPosition().resize().setVisible(false);
  }
  destroy() {
    this.parent = void 0;
    super.destroy();
    return this;
  }
};
var SHAPEMODE = {
  rectangle: 0,
  circle: 1
};
Object.assign(
  DefaultMaskGraphics.prototype,
  Methods_default20
);
var DefaultMaskGraphics_default = DefaultMaskGraphics;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/MaskMethods.js
var MaskMethods_default = {
  setMaskGameObject(gameObject2) {
    if (!gameObject2) {
      this.removeMaskGameObject();
      return this;
    }
    if (this.maskGameObject) {
      if (gameObject2 === true && this.maskGameObject instanceof DefaultMaskGraphics_default) {
        return this;
      }
      if (this.maskGameObject === gameObject2) {
        return this;
      }
      this.removeMaskGameObject();
    }
    if (gameObject2 === true) {
      gameObject2 = new DefaultMaskGraphics_default(this);
    }
    gameObject2.resize(this.width, this.height).setOrigin(this.originX, this.originY).setPosition(0, 0).setScale(1).setVisible(false);
    this.addLocal(gameObject2);
    this.maskGameObject = gameObject2;
    if (!gameObject2._maskObject) {
      gameObject2._maskObject = gameObject2.createGeometryMask();
      gameObject2.once("destroy", function() {
        gameObject2._maskObject.destroy();
        gameObject2._maskObject = void 0;
      });
    }
    this.childrenMask = gameObject2._maskObject;
    return this;
  },
  removeMaskGameObject(destroyMaskGameObject) {
    if (destroyMaskGameObject === void 0) {
      destroyMaskGameObject = true;
    }
    this.backImage.clearMask();
    this.frontImage.clearMask();
    this.childrenMask = void 0;
    this.remove(this.maskGameObject, destroyMaskGameObject);
    this.maskGameObject = void 0;
    return this;
  },
  setImageMaskEnable(gameObject2, enable, invertAlpha) {
    if (enable === void 0) {
      enable = true;
    }
    if (invertAlpha === void 0) {
      invertAlpha = false;
    }
    if (enable) {
      if (!this.childrenMask) {
        this.setMaskGameObject(true);
      }
      gameObject2.setMask(this.childrenMask);
      this.childrenMask.setInvertAlpha(invertAlpha);
    } else {
      gameObject2.clearMask();
    }
    return this;
  },
  setCurrentImageMaskEnable(enable, invertAlpha) {
    this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
    return this;
  },
  setNextImageMaskEnable(enable, invertAlpha) {
    this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
    return this;
  },
  setCellImagesMaskEnable(enable, invertAlpha) {
    var cellImages = this.getCellImages();
    for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
      this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
    }
    return this;
  },
  setMaskEnable(enable, invertAlpha) {
    this.setImageMaskEnable(this.backImage, enable, invertAlpha);
    this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
    this.setCellImagesMaskEnable(enable, invertAlpha);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/texture/gridcut/GetFrameNameCallback.js
var GetFrameNameCallback = function(baseFrameName, delimiter) {
  if (typeof baseFrameName === "object") {
    baseFrameName = baseFrameName.name;
  }
  if (delimiter === void 0) {
    delimiter = ",";
  }
  var callback;
  if (baseFrameName === "__BASE") {
    callback = function(colIndex, rowIndex) {
      return `${colIndex}${delimiter}${rowIndex}`;
    };
  } else {
    callback = function(colIndex, rowIndex) {
      return `${baseFrameName}_${colIndex}${delimiter}${rowIndex}`;
    };
  }
  return callback;
};
var GetFrameNameCallback_default = GetFrameNameCallback;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/gridcut/GenerateFrames.js
var GenerateFrames = function(scene, key2, frame, columns, rows, getFrameNameCallback) {
  if (frame == null) {
    frame = "__BASE";
  }
  if (!getFrameNameCallback) {
    getFrameNameCallback = GetFrameNameCallback_default(frame, getFrameNameCallback);
  }
  var texture = scene.sys.textures.get(key2);
  var baseFrame = typeof frame === "object" ? frame : texture.get(frame);
  var baseWidth = baseFrame.width, baseHeight = baseFrame.height;
  var cellX, cellY, cellName;
  var cellWidth = baseWidth / columns, cellHeight = baseHeight / rows;
  var frameCutX = baseFrame.cutX, frameCutY = baseFrame.cutY;
  var offsetX = 0, offsetY = 0;
  for (var y = 0; y < rows; y++) {
    offsetX = 0;
    for (var x = 0; x < columns; x++) {
      cellName = getFrameNameCallback(x, y);
      cellX = offsetX + frameCutX;
      cellY = offsetY + frameCutY;
      texture.add(
        cellName,
        0,
        cellX,
        cellY,
        cellWidth,
        cellHeight
      );
      offsetX += cellWidth;
    }
    offsetY += cellHeight;
  }
  return {
    getFrameNameCallback,
    cellWidth,
    cellHeight,
    columns,
    rows
  };
};
var GenerateFrames_default = GenerateFrames;

// node_modules/phaser3-rex-plugins/plugins/actions/GridCutImage.js
var GetValue111 = Phaser.Utils.Objects.GetValue;
var DefaultImageClass = Phaser.GameObjects.Image;
var IsPlainObject34 = Phaser.Utils.Objects.IsPlainObject;
var RotateAround7 = Phaser.Math.RotateAround;
var GridCutImage = function(gameObject2, columns, rows, config) {
  if (IsPlainObject34(columns)) {
    config = columns;
    columns = GetValue111(config, "columns", 1);
    rows = GetValue111(config, "rows", 1);
  }
  var createImageCallback = GetValue111(config, "createImageCallback");
  if (!createImageCallback) {
    var ImageClass = GetValue111(config, "ImageClass", DefaultImageClass);
    createImageCallback = function(scene2, key2, frame2) {
      return new ImageClass(scene2, 0, 0, key2, frame2);
    };
  }
  var originX = GetValue111(config, "originX", 0.5);
  var originY = GetValue111(config, "originY", 0.5);
  var addToScene = GetValue111(config, "add", true);
  var align = GetValue111(config, "align", addToScene);
  var imageObjectPool = GetValue111(config, "objectPool", void 0);
  var scene = gameObject2.scene;
  var texture = gameObject2.texture;
  var frame = gameObject2.frame;
  var result = GenerateFrames_default(scene, texture, frame, columns, rows);
  var getFrameNameCallback = result.getFrameNameCallback;
  var scaleX = gameObject2.scaleX, scaleY = gameObject2.scaleY;
  var rotation = gameObject2.rotation;
  var topLeft = gameObject2.getTopLeft(), startX = topLeft.x, startY = topLeft.y;
  var cellGameObjects = [];
  var scaleCellWidth = result.cellWidth * scaleX, scaleCellHeight = result.cellHeight * scaleY;
  for (var y = 0; y < rows; y++) {
    for (var x = 0; x < columns; x++) {
      var cellGameObject;
      var frameName = getFrameNameCallback(x, y);
      if (imageObjectPool && imageObjectPool.length > 0) {
        cellGameObject = imageObjectPool.pop().setTexture(texture, frameName);
      } else {
        cellGameObject = createImageCallback(scene, texture, frameName);
      }
      if (addToScene) {
        scene.add.existing(cellGameObject);
      }
      if (align) {
        var cellTLX = startX + scaleCellWidth * x;
        var cellTLY = startY + scaleCellHeight * y;
        var cellX = cellTLX + originX * scaleCellWidth;
        var cellY = cellTLY + originY * scaleCellHeight;
        cellGameObject.setOrigin(originX, originY).setPosition(cellX, cellY).setScale(scaleX, scaleY).setRotation(rotation);
        RotateAround7(cellGameObject, startX, startY, rotation);
      }
      cellGameObjects.push(cellGameObject);
    }
  }
  return cellGameObjects;
};
var GridCutImage_default = GridCutImage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/GridCutMethods.js
var GridCutMethods_default = {
  gridCutImage(gameObject2, columns, rows, config) {
    if (config === void 0) {
      config = {};
    }
    config.objectPool = this.imagesPool;
    var cellImages = GridCutImage_default(gameObject2, columns, rows, config), cellImage;
    for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
      cellImage = cellImages[i];
      cellImage.setVisible(true);
      this.add(cellImage);
    }
    this.cellImages = cellImages;
    this.setChildLocalVisible(gameObject2, false);
    return cellImages;
  },
  gridCutCurrentImage(columns, rows, config) {
    return this.gridCutImage(this.currentImage, columns, rows, config);
  },
  gridCutNextImage(columns, rows, config) {
    return this.gridCutImage(this.nextImage, columns, rows, config);
  },
  getCellImages() {
    return this.cellImages;
  },
  freeCellImages() {
    if (this.cellImages.length === 0) {
      return this;
    }
    var texture = this.cellImages[0].texture;
    var cellImages = this.cellImages, cellImage, frameName;
    for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
      cellImage = cellImages[i];
      this.setChildLocalAlpha(cellImage, 1).setChildLocalScale(cellImage, 1).setChildLocalVisible(cellImage, false);
      cellImage.clearMask();
      frameName = cellImage.frame.name;
      cellImage.setTexture();
      texture.remove(frameName);
    }
    this.imagesPool.push(...cellImages);
    cellImages.length = 0;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/utils/FlipMethods.js
var FlipMethods_default = {
  setFlipX(value) {
    this.flipX = value;
    return this;
  },
  setFlipY(value) {
    this.flipY = value;
    return this;
  },
  toggleFlipX() {
    this.flipX = !this.flipX;
    return this;
  },
  toggleFlipY() {
    this.flipY = !this.flipY;
    return this;
  },
  setFlip(x, y) {
    this.flipX = x;
    this.flipY = y;
    return this;
  },
  resetFlip() {
    this.flipX = false;
    this.flipY = false;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/Methods.js
var methods19 = {};
Object.assign(
  methods19,
  SetTransitionCallbackMethods_default,
  TransitionMethods_default,
  MaskMethods_default,
  GridCutMethods_default,
  FlipMethods_default
);
var Methods_default21 = methods19;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/methods/CrossFadeTransition.js
var OnStart = function(parent, currentImage, nextImage, t) {
};
var OnProgress = function(parent, currentImage, nextImage, t) {
  parent.setChildLocalAlpha(currentImage, 1 - t).setChildLocalAlpha(nextImage, t);
};
var OnComplete = function(parent, currentImage, nextImage, t) {
  parent.setChildLocalAlpha(currentImage, 1);
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/transitionimage/TransitionImage.js
var IsPlainObject35 = Phaser.Utils.Objects.IsPlainObject;
var GetValue112 = Phaser.Utils.Objects.GetValue;
var Clamp7 = Phaser.Math.Clamp;
var TransitionImage = class extends ContainerLite_default {
  constructor(scene, x, y, texture, frame, config) {
    if (IsPlainObject35(x)) {
      config = x;
      x = GetValue112(config, "x", 0);
      y = GetValue112(config, "y", 0);
      texture = GetValue112(config, "key", void 0);
      frame = GetValue112(config, "frame", void 0);
    } else if (IsPlainObject35(frame)) {
      config = frame;
      frame = void 0;
    }
    var backImage = GetValue112(config, "back", void 0);
    var frontImage = GetValue112(config, "front", void 0);
    if (!backImage) {
      backImage = scene.add.image(x, y, texture, frame);
    }
    if (!frontImage) {
      frontImage = scene.add.image(x, y, texture, frame);
    }
    var width = GetValue112(config, "width", void 0);
    var height = GetValue112(config, "height", void 0);
    var scaleMode = width !== void 0 && height !== void 0 ? 1 : 0;
    if (width === void 0) {
      width = frontImage.width;
    }
    if (height === void 0) {
      height = frontImage.height;
    }
    super(scene, x, y, width, height);
    this.type = "rexTransitionImage";
    this._flipX = false;
    this._flipY = false;
    scaleMode = GetValue112(config, "scaleMode", scaleMode);
    if (typeof scaleMode === "string") {
      scaleMode = ScaleModeMap[scaleMode];
    }
    this.scaleMode = scaleMode;
    backImage.setVisible(false);
    this.addMultiple([backImage, frontImage]);
    this.backImage = backImage;
    this.frontImage = frontImage;
    this.images = [this.backImage, this.frontImage];
    this.maskGameObject = void 0;
    this.cellImages = [];
    this.imagesPool = [];
    this.transitionModes = void 0;
    this.currentTransitionMode = void 0;
    var onStart = GetValue112(config, "onStart", void 0);
    var onProgress = GetValue112(config, "onProgress", void 0);
    var onComplete = GetValue112(config, "onComplete", void 0);
    var dir = GetValue112(config, "dir", 0);
    if (onStart === void 0 && onProgress === void 0 && onComplete === void 0) {
      onStart = OnStart;
      onProgress = OnProgress;
      onComplete = OnComplete;
      dir = 0;
    }
    this.setTransitionStartCallback(
      onStart,
      GetValue112(config, "onStartScope", void 0)
    ).setTransitionProgressCallback(
      onProgress,
      GetValue112(config, "onProgressScope", void 0)
    ).setTransitionCompleteCallback(
      onComplete,
      GetValue112(config, "onCompleteScope", void 0)
    ).setTransitionDirection(dir).setDuration(GetValue112(config, "duration", 1e3)).setEaseFunction(GetValue112(config, "ease", "Linear"));
    var maskGameObject = GetValue112(config, "mask", void 0);
    if (maskGameObject) {
      this.setMaskGameObject(maskGameObject);
    }
    this.setMaskEnable(false);
    this.ignoreCompleteEvent = false;
    OnTextureChange_default.call(this, this.frontImage);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (this.childrenMask) {
      this.childrenMask.destroy();
      this.childrenMask = void 0;
    }
    this.backImage = void 0;
    this.frontImage = void 0;
    this.images.length = 0;
    this.maskGameObject = void 0;
    this.cellImages.length = 0;
    this.imagesPool.length = 0;
    this.transitionModes = void 0;
    super.destroy(fromScene);
    this.onStartCallback = void 0;
    this.onStartCallbackScope = void 0;
    this.onProgressCallback = void 0;
    this.onProgressCallbackScope = void 0;
    this.onCompleteCallback = void 0;
    this.onCompleteCallbackScope = void 0;
    this.easeValueTask = void 0;
  }
  get currentImage() {
    return this.dir === 0 ? this.frontImage : this.backImage;
  }
  get nextImage() {
    return this.dir === 0 ? this.backImage : this.frontImage;
  }
  get texture() {
    return this.nextImage.texture;
  }
  get frame() {
    return this.nextImage.frame;
  }
  get tint() {
    return this._tint;
  }
  set tint(value) {
    if (this._tint === value) {
      return;
    }
    this._tint = value;
    this.backImage.setTint(value);
    this.frontImage.setTint(value);
  }
  setTint(value) {
    this.tint = value;
    return this;
  }
  get flipX() {
    return this._flipX;
  }
  set flipX(value) {
    if (this._flipX === value) {
      return;
    }
    this._flipX = value;
    this.backImage.setFlipX(value);
    this.frontImage.setFlipX(value);
  }
  setFlipX(value) {
    this.flipX = value;
    return this;
  }
  toggleFlipX() {
    this.flipX = !this.flipX;
    return this;
  }
  get flipY() {
    return this._flipY;
  }
  set flipY(value) {
    if (this._flipY === value) {
      return;
    }
    this._flipY = value;
    this.backImage.setFlipY(value);
    this.frontImage.setFlipY(value);
  }
  setFlipY(value) {
    this.flipY = value;
    return this;
  }
  toggleFlipY() {
    this.flipY = !this.flipY;
    return this;
  }
  setFlip(flipX, flipY) {
    this.flipX = flipX;
    this.flipY = flipY;
    return this;
  }
  get t() {
    return this._t;
  }
  set t(value) {
    value = Clamp7(value, 0, 1);
    if (this._t === value) {
      return;
    }
    this._t = value;
    var currentImage = this.currentImage;
    var nextImage = this.nextImage;
    if (value === 0) {
      this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, true);
      RunCallback.call(
        this,
        this.onStartCallback,
        this.onStartCallbackScope,
        this,
        currentImage,
        nextImage,
        value
      );
    }
    RunCallback.call(
      this,
      this.onProgressCallback,
      this.onProgressCallbackScope,
      this,
      currentImage,
      nextImage,
      value
    );
    if (value === 1) {
      RunCallback.call(
        this,
        this.onCompleteCallback,
        this.onCompleteCallbackScope,
        this,
        currentImage,
        nextImage,
        value
      );
      var key2 = nextImage.texture.key, frame = nextImage.frame.name;
      this.frontImage.setTexture(key2, frame);
      this.backImage.setTexture(key2, frame);
      OnTextureChange_default.call(this, nextImage);
      this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, false).setMaskEnable(false).freeCellImages();
    }
    if (value === 1 && !this.ignoreCompleteEvent) {
      this.emit("complete");
    }
  }
  setT(value) {
    this.t = value;
    return this;
  }
  get isRunning() {
    return this.easeValueTask ? this.easeValueTask.isRunning : false;
  }
  setOrigin(originX, originY) {
    super.setOrigin(originX, originY);
    this.backImage.setOrigin(originX, originY);
    this.frontImage.setOrigin(originX, originY);
    if (this.maskGameObject) {
      this.maskGameObject.setOrigin(originX, originY);
    }
    return this;
  }
  setTexture(texture, frame) {
    this.frontImage.setTexture(texture, frame);
    this.backImage.setTexture(texture, frame).setVisible(false);
    OnTextureChange_default.call(this, this.frontImage);
    return this;
  }
  setSize(width, height) {
    super.setSize(width, height);
    if (this.scaleMode) {
      FitImages_default.call(this);
    }
    return this;
  }
};
var RunCallback = function(callback, scope, parent, currentImage, nextImage, t) {
  if (!callback) {
    return;
  }
  if (this.scaleMode) {
    var localScale;
    if (currentImage.biasScale > 0) {
      localScale = this.getChildLocalScaleX(currentImage);
      localScale = localScale / currentImage.biasScale;
      this.setChildLocalScale(currentImage, localScale);
    }
    if (nextImage.biasScale) {
      localScale = this.getChildLocalScaleX(nextImage);
      localScale = localScale / nextImage.biasScale;
      this.setChildLocalScale(nextImage, localScale);
    }
  }
  if (scope) {
    callback.call(scope, parent, currentImage, nextImage, t);
  } else {
    callback(parent, currentImage, nextImage, t);
  }
  if (this.scaleMode) {
    var localScale;
    if (currentImage.biasScale > 0) {
      localScale = this.getChildLocalScaleX(currentImage);
      localScale = localScale * currentImage.biasScale;
      this.setChildLocalScale(currentImage, localScale);
    }
    if (nextImage.biasScale) {
      localScale = this.getChildLocalScaleX(nextImage);
      localScale = localScale * nextImage.biasScale;
      this.setChildLocalScale(nextImage, localScale);
    }
  }
};
Object.assign(
  TransitionImage.prototype,
  Methods_default21
);
var ScaleModeMap = {
  fit: 1,
  FIT: 1,
  envelop: 2,
  ENVELOP: 2
};
var TransitionImage_default = TransitionImage;

// node_modules/phaser3-rex-plugins/plugins/transitionimage.js
var transitionimage_default = TransitionImage_default;

// node_modules/phaser3-rex-plugins/templates/ui/transitionimage/TransitionImage.js
var TransitionImage_default2 = transitionimage_default;

// node_modules/phaser3-rex-plugins/templates/ui/transitionimage/Factory.js
ObjectFactory_default.register("transitionImage", function(x, y, texture, frame, config) {
  var gameObject2 = new TransitionImage_default2(this.scene, x, y, texture, frame, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TransitionImage", TransitionImage_default2);

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/Const.js
var SlideLeft = "slideLeft";
var SlideRight = "slideRight";
var SlideUp = "slideUp";
var SlideDown = "slideDown";
var SlideAwayLeft = "slideAwayLeft";
var SlideAwayRight = "slideAwayRight";
var SlideAwayUp = "slideAwayUp";
var SlideAwayDown = "slideAwayDown";
var PushLeft = "pushLeft";
var PushRight = "pushRight";
var PushUp = "pushUp";
var PushDown = "pushDown";
var ZoomOut = "zoomOut";
var ZoomIn = "zoomIn";
var ZoomInOut = "zoomInOut";
var Fade3 = "fade";
var CrossFade = "crossFade";
var WipeLeft = "wipeLeft";
var WipeRight = "wipeRight";
var WipeUp = "wipeUp";
var WipeDown = "wipeDown";
var IrisOut = "irisOut";
var IrisIn = "irisIn";
var IrisInOut = "irisInOut";
var PieOut = "pieOut";
var PieIn = "pieIn";
var PieInOut = "pieInOut";
var Blinds = "blinds";
var Squares = "squares";
var Diamonds = "diamonds";
var Circles = "circles";
var Curtain = "curtain";
var Pixellate = "pixellate";
var Dissolve = "dissolve";
var RevealLeft = "revealLeft";
var RevealRight = "revealRight";
var RevealUp = "revealUp";
var RevealDown = "revealDown";

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddSlideAwayModes.js
var AddSlideAwayModes = function(image) {
  image.addTransitionMode(SlideAwayRight, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * t;
      parent.setChildLocalPosition(currentImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  }).addTransitionMode(SlideAwayLeft, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * -t;
      parent.setChildLocalPosition(currentImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  }).addTransitionMode(SlideAwayDown, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * t;
      parent.setChildLocalPosition(currentImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  }).addTransitionMode(SlideAwayUp, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * -t;
      parent.setChildLocalPosition(currentImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
    }
  });
};
var AddSlideAwayModes_default = AddSlideAwayModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddSlideModes.js
var AddSlideModes = function(image) {
  image.addTransitionMode(SlideRight, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = nextImage.width * (t - 1);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(SlideLeft, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = nextImage.width * (1 - t);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(SlideDown, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = nextImage.height * (t - 1);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(SlideUp, {
    ease: "Linear",
    dir: "in",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = nextImage.height * (1 - t);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  });
};
var AddSlideModes_default = AddSlideModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddPushModes.js
var AddSliderModes = function(image) {
  image.addTransitionMode(PushRight, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * t;
      parent.setChildLocalPosition(currentImage, x, 0);
      var x = nextImage.width * (t - 1);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(PushLeft, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var x = currentImage.width * -t;
      parent.setChildLocalPosition(currentImage, x, 0);
      var x = nextImage.width * (1 - t);
      parent.setChildLocalPosition(nextImage, x, 0);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(PushDown, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * t;
      parent.setChildLocalPosition(currentImage, 0, y);
      var y = nextImage.height * (t - 1);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  }).addTransitionMode(PushUp, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var y = currentImage.height * -t;
      parent.setChildLocalPosition(currentImage, 0, y);
      var y = nextImage.height * (1 - t);
      parent.setChildLocalPosition(nextImage, 0, y);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalPosition(currentImage, 0, 0);
      parent.setChildLocalPosition(nextImage, 0, 0);
    }
  });
};
var AddPushModes_default = AddSliderModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/Yoyo.js
var Yoyo_default4 = Yoyo_default;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddZoomModes.js
var AddZoomModes = function(image) {
  image.addTransitionMode(ZoomOut, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var scale = 1 - t;
      parent.setChildLocalScale(currentImage, scale, scale);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalScale(currentImage, 1, 1);
    }
  }).addTransitionMode(ZoomIn, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var scale = t;
      parent.setChildLocalScale(nextImage, scale, scale);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalScale(nextImage, 1, 1);
    }
  }).addTransitionMode(ZoomInOut, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var scale;
      if (t < 0.5) {
        scale = 1 - Yoyo_default4(t);
        parent.setChildLocalScale(currentImage, scale, scale);
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        scale = 1 - Yoyo_default4(t);
        parent.setChildLocalScale(nextImage, scale, scale);
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalScale(currentImage, 1, 1);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildLocalScale(nextImage, 1, 1);
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddZoomModes_default = AddZoomModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddFadeModes.js
var AddFadeModes = function(image) {
  image.addTransitionMode(Fade3, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  }).addTransitionMode(CrossFade, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalAlpha(currentImage, 1 - t);
      parent.setChildLocalAlpha(nextImage, t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.setChildLocalAlpha(currentImage, 1);
    }
  });
};
var AddFadeModes_default = AddFadeModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddWipeModes.js
var CreateMask = function(scene) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: [
      { name: "rect", type: "rectangle" }
    ],
    update: function() {
      var rect = this.getShape("rect").fillStyle(16777215);
      var t = 1 - this.value;
      switch (this.wipeMode) {
        case "right":
          rect.setSize(this.width * t, this.height).setTopLeftPosition(this.width - rect.width, 0);
          break;
        case "left":
          rect.setSize(this.width * t, this.height).setTopLeftPosition(0, 0);
          break;
        case "down":
          rect.setSize(this.width, this.height * t).setTopLeftPosition(0, this.height - rect.height);
          break;
        case "up":
          rect.setSize(this.width, this.height * t).setTopLeftPosition(0, 0);
          break;
      }
    }
  });
  return maskGameObject;
};
var AddWipeModes = function(image) {
  var maskGameObject = CreateMask(image.scene);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(WipeRight, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "right";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(WipeLeft, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "left";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(WipeDown, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "down";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(WipeUp, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true);
      parent.maskGameObject.wipeMode = "up";
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddWipeModes_default = AddWipeModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddIrisModes.js
var CreateMask2 = function(scene) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: [
      { name: "rect", type: "rectangle" }
    ],
    update: function() {
      this.getShape("rect").fillStyle(16777215).setSize(this.width * this.value, this.height * this.value).setCenterPosition(this.centerX, this.centerY);
    }
  });
  return maskGameObject;
};
var AddIrisModes = function(image) {
  var maskGameObject = CreateMask2(image.scene);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(IrisOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(IrisIn, {
    ease: "Linear",
    dir: "in",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setNextImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(1 - t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(IrisInOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
      parent.setCurrentImageMaskEnable(true);
      parent.setNextImageMaskEnable(true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddIrisModes_default = AddIrisModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddPieModes.js
var CreateMask3 = function(scene) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: [
      { name: "pie", type: "arc" }
    ],
    update: function() {
      var radius = Math.max(this.width, this.height) * 2;
      var deltaAngle = 90 * this.value;
      this.getShape("pie").fillStyle(16777215).setCenterPosition(this.centerX, 0).setRadius(radius).setAngle(90 - deltaAngle, 90 + deltaAngle).setPie();
    }
  });
  return maskGameObject;
};
var AddPieModes = function(image) {
  var maskGameObject = CreateMask3(image.scene);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(PieOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(PieIn, {
    ease: "Linear",
    dir: "in",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setNextImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(1 - t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  }).addTransitionMode(PieInOut, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
      parent.setCurrentImageMaskEnable(true);
      parent.setNextImageMaskEnable(true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(1 - t);
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddPieModes_default = AddPieModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddBlindsModes.js
var CreateMask4 = function(scene, columns) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      rectangle: columns
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeWidth = this.width / columns;
      for (var i = 0; i < columns; i++) {
        shapes[i].fillStyle(16777215).setSize(shapeWidth * this.value, this.height).setTopLeftPosition(shapeWidth * i, 0);
      }
    }
  });
  return maskGameObject;
};
var AddBlindsModes = function(image) {
  var maskGameObject = CreateMask4(image.scene, 10);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Blinds, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddBlindsModes_default = AddBlindsModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddSquaresModes.js
var CreateMask5 = function(scene, columns, rows) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      rectangle: columns * rows
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeWidth = this.width / columns, shapeHeight = this.height / rows;
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < columns; c++) {
          shapes[c * rows + r].fillStyle(16777215).setSize(shapeWidth * this.value, shapeHeight * this.value).setCenterPosition(shapeWidth * (c + 0.5), shapeHeight * (r + 0.5));
        }
      }
    }
  });
  return maskGameObject;
};
var AddSquaresModes = function(image) {
  var maskGameObject = CreateMask5(image.scene, Math.ceil(image.width / 40), Math.ceil(image.height / 40));
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Squares, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddSquaresModes_default = AddSquaresModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddDiamondsMode.js
var CreateMask6 = function(scene, columns, rows) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      lines: columns * rows
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeHalfWidth = this.width / (columns - 1), shapeHelfHeight = this.height / rows;
      var shapeHeight = shapeHelfHeight * 2;
      var halfWidth = shapeHalfWidth * this.value, halfHeight = shapeHelfHeight * this.value;
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < columns; c++) {
          var centerX = c * shapeHalfWidth;
          var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
          shapes[c * rows + r].fillStyle(16777215).start(centerX + halfWidth, centerY).lineTo(centerX, centerY + halfHeight).lineTo(centerX - halfWidth, centerY).lineTo(centerX, centerY - halfHeight).lineTo(centerX + halfWidth, centerY).close();
        }
      }
    }
  });
  return maskGameObject;
};
var AddDiamondsMode = function(image) {
  var maskGameObject = CreateMask6(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Diamonds, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddDiamondsMode_default = AddDiamondsMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddCirclesMode.js
var CreateMask7 = function(scene, columns, rows) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      circle: columns * rows
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeHalfWidth = this.width / (columns - 1), shapeHelfHeight = this.height / rows;
      var shapeHeight = shapeHelfHeight * 2;
      var radius = Math.max(shapeHalfWidth, shapeHelfHeight) * this.value;
      for (var r = 0; r < rows; r++) {
        for (var c = 0; c < columns; c++) {
          var centerX = c * shapeHalfWidth;
          var centerY = r * shapeHeight + c % 2 * shapeHelfHeight;
          shapes[c * rows + r].fillStyle(16777215).setCenterPosition(centerX, centerY).setRadius(radius);
        }
      }
    }
  });
  return maskGameObject;
};
var AddCirclesMode = function(image) {
  var maskGameObject = CreateMask7(image.scene, Math.ceil(image.width / 60), Math.ceil(image.height / 60));
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Circles, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setCurrentImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      parent.maskGameObject.setValue(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
    }
  });
};
var AddCirclesMode_default = AddCirclesMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddCurtainMode.js
var CreateMask8 = function(scene, columns) {
  var maskGameObject = new customprogress_default(scene, {
    type: "Graphics",
    create: {
      lines: columns
    },
    update: function() {
      var shapes = this.getShapes();
      var shapeWidth = this.width / columns;
      var radius = shapeWidth / 2;
      for (var i = 0; i < columns; i++) {
        var leftX = shapeWidth * i;
        var bottomY = this.height * this.value;
        var centerX = leftX + radius;
        shapes[i].fillStyle(16777215).start(leftX, 0).horizontalLineTo(bottomY).arc(centerX, bottomY, radius, 180, 0, true).horizontalLineTo(-bottomY).lineTo(leftX, 0).close();
      }
    }
  });
  return maskGameObject;
};
var AddCurtainMode = function(image) {
  var maskGameObject = CreateMask8(image.scene, 10);
  image.once("destroy", function() {
    maskGameObject.destroy();
  }).addTransitionMode(Curtain, {
    ease: "Linear",
    dir: "out",
    mask: maskGameObject,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.tint = 0;
      parent.setCurrentImageMaskEnable(true, true);
      parent.setNextImageMaskEnable(true, true);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      var tintGray;
      if (t < 0.5) {
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(t);
        currentImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        t = Yoyo_default4(t);
        tintGray = Math.floor(255 * (1 - t));
        parent.maskGameObject.setValue(t);
        nextImage.tint = (tintGray << 16) + (tintGray << 8) + tintGray;
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      parent.removeMaskGameObject(false);
      parent.setChildVisible(currentImage, true);
      currentImage.tint = 16777215;
      parent.setChildVisible(nextImage, true);
      nextImage.tint = 16777215;
    }
  });
};
var AddCurtainMode_default = AddCurtainMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddPixellateMode.js
var AddPixellateMode = function(image) {
  image.addTransitionMode(Pixellate, {
    ease: "Linear",
    dir: "out",
    mask: true,
    onStart: function(parent, currentImage, nextImage, t) {
      parent.setChildVisible(nextImage, false);
      currentImage.effect = currentImage.preFX.addPixelate(0);
      nextImage.effect = nextImage.preFX.addPixelate(0);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      if (t < 0.5) {
        t = Yoyo_default4(t);
        var maxAmount = Math.min(currentImage.width, currentImage.height) / 5;
        currentImage.effect.amount = Math.ceil(maxAmount * t);
      } else {
        if (currentImage.visible) {
          parent.setChildVisible(currentImage, false);
        }
        if (!nextImage.visible) {
          parent.setChildVisible(nextImage, true);
        }
        t = Yoyo_default4(t);
        var maxAmount = Math.min(nextImage.width, nextImage.height) / 5;
        nextImage.effect.amount = Math.ceil(maxAmount * t);
      }
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      currentImage.preFX.remove(currentImage.effect);
      delete currentImage.effect;
      parent.setChildVisible(currentImage, true);
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  });
};
var AddPixellateMode_default = AddPixellateMode;

// node_modules/phaser3-rex-plugins/plugins/shaders/utils/noise/Perlin.js
var frag = `vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
float Perlin(vec3 P) {
    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0); gx1 = fract(gx1);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
}
float Perlin(vec2 P) { return Perlin(vec3(P, 0.0)); }
`;
var Perlin_default = frag;

// node_modules/phaser3-rex-plugins/plugins/shaders/dissolve/dissolve-frag.js
var frag2 = `#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
// Scene buffer
uniform sampler2D uMainSampler;
uniform sampler2D uMainSampler2;

uniform int resizeMode;
uniform float progress;
uniform float fromRatio;
uniform float toRatio;
varying vec2 outFragCoord;
// Effect parameters
uniform float noiseX;
uniform float noiseY;
uniform float noiseZ;
uniform float fromEdgeStart;
uniform float fromEdgeWidth;
uniform float toEdgeStart;
uniform float toEdgeWidth;

${Perlin_default}

vec4 getFromColor (vec2 uv) {
  return texture2D(uMainSampler, uv);
}

vec4 getToColor (vec2 uv) {
  if (resizeMode == 2) {
    //  cover
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(min(fromRatio / toRatio, 1.0), min((toRatio / fromRatio), 1.0)));
  } else if (resizeMode == 1) {
    //  contain
    return texture2D(uMainSampler2, 0.5 + (vec2(uv.x, 1.0 - uv.y) - 0.5) * vec2(max(fromRatio / toRatio, 1.0), max((toRatio / fromRatio), 1.0)));
  } else {
    //  stretch
    return texture2D(uMainSampler2, vec2(uv.x, 1.0 - uv.y));
  }
}

vec4 transition (vec2 uv) {    
  vec4 colorFront = getFromColor(uv);
  vec4 colorTo = getToColor(uv);

  float noise = (Perlin(vec3(uv.x * noiseX, uv.y * noiseY, noiseZ)) + 1.0) / 2.0
    * (1.0 - (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth))
    + (fromEdgeStart + fromEdgeWidth + toEdgeStart + toEdgeWidth) * 0.5;
  vec4 colorResult = colorFront * smoothstep(progress - (fromEdgeStart + fromEdgeWidth), progress - fromEdgeStart, noise)
    + colorTo * smoothstep((1.0 - progress) - (toEdgeStart + toEdgeWidth), (1.0 - progress) - toEdgeStart, (1.0 - noise));
  return colorResult;
}

void main () {
  vec2 uv = outFragCoord;
  gl_FragColor = transition(uv);
}
`;
var dissolve_frag_default = frag2;

// node_modules/phaser3-rex-plugins/plugins/shaders/dissolve/DissolvePostFxPipeline.js
var PostFXPipeline = Phaser.Renderer.WebGL.Pipelines.PostFXPipeline;
var GetValue113 = Phaser.Utils.Objects.GetValue;
var Clamp8 = Phaser.Math.Clamp;
var DissolvePostFxPipeline = class extends PostFXPipeline {
  constructor(game) {
    super({
      name: "rexDissolvePostFx",
      game,
      renderTarget: true,
      fragShader: dissolve_frag_default
    });
    this._progress = 0;
    this.toFrame = null;
    this.targetTexture = null;
    this.resizeMode = 1;
    this.toRatio = 1;
    this.noiseX = 0;
    this.noiseY = 0;
    this.noiseZ = 0;
    this.fromEdgeStart = 0.01;
    this.fromEdgeWidth = 0.05;
    this.toEdgeStart = 0.01;
    this.toEdgeWidth = 0.05;
  }
  resetFromJSON(o) {
    this.setProgress(GetValue113(o, "progress", 0));
    this.setTransitionTargetTexture(GetValue113(o, "toTexture", "__DEFAULT"), GetValue113(o, "toFrame", void 0), GetValue113(o, "resizeMode", 1));
    this.setNoise(GetValue113(o, "noiseX", void 0), GetValue113(o, "noiseY", void 0), GetValue113(o, "noiseZ", void 0));
    this.setFromEdge(GetValue113(o, "fromEdgeStart", 0.01), GetValue113(o, "fromEdgeWidth", 0.05));
    this.setToEdge(GetValue113(o, "toEdgeStart", 0.01), GetValue113(o, "toEdgeWidth", 0.05));
    return this;
  }
  onBoot() {
  }
  onPreRender() {
    this.set1f("progress", this.progress);
    this.set1i("resizeMode", this.resizeMode);
    this.set1f("noiseX", this.noiseX);
    this.set1f("noiseY", this.noiseY);
    this.set1f("noiseZ", this.noiseZ);
    this.set1f("fromEdgeStart", this.fromEdgeStart);
    this.set1f("fromEdgeWidth", this.fromEdgeWidth);
    this.set1f("toEdgeStart", this.toEdgeStart);
    this.set1f("toEdgeWidth", this.toEdgeWidth);
  }
  onDraw(renderTarget) {
    this.set1f("fromRatio", renderTarget.width / renderTarget.height);
    this.set1f("toRatio", this.toRatio);
    this.set1i("uMainSampler2", 1);
    this.bindTexture(this.targetTexture, 1);
    this.bindAndDraw(renderTarget);
  }
  get progress() {
    return this._progress;
  }
  set progress(value) {
    this._progress = Clamp8(value, 0, 1);
  }
  setProgress(value) {
    this.progress = value;
    return this;
  }
  setTransitionTargetTexture(key2, frame, resizeMode) {
    if (key2 === void 0) {
      key2 = "__DEFAULT";
    }
    var phaserTexture = this.game.textures.getFrame(key2, frame);
    if (!phaserTexture) {
      phaserTexture = this.game.textures.getFrame("__DEFAULT");
    }
    this.toRatio = phaserTexture.width / phaserTexture.height;
    this.toFrame = phaserTexture;
    this.targetTexture = phaserTexture.glTexture;
    if (resizeMode !== void 0) {
      this.resizeMode = resizeMode;
    }
    return this;
  }
  setResizeMode(mode) {
    if (typeof mode === "string") {
      mode = ResizeMode[mode];
    }
    this.resizeMode = mode;
    return this;
  }
  setNoise(x, y, z) {
    if (x === void 0) {
      x = 4 + Math.random() * 6;
    }
    if (y === void 0) {
      y = 4 + Math.random() * 6;
    }
    if (z === void 0) {
      z = Math.random() * 10;
    }
    this.noiseX = x;
    this.noiseY = y;
    this.noiseZ = z;
    return this;
  }
  setFromEdge(edgeStart, edgeWidth) {
    this.fromEdgeStart = edgeStart;
    this.fromEdgeWidth = edgeWidth;
    return this;
  }
  setToEdge(edgeStart, edgeWidth) {
    this.toEdgeStart = edgeStart;
    this.toEdgeWidth = edgeWidth;
    return this;
  }
};
var ResizeMode = {
  stretch: 0,
  contain: 1,
  cover: 2
};
var DissolvePostFxPipeline_default = DissolvePostFxPipeline;

// node_modules/phaser3-rex-plugins/plugins/dissolvepipeline.js
var dissolvepipeline_default = DissolvePostFxPipeline_default;

// node_modules/phaser3-rex-plugins/plugins/utils/renderer/postfxpipeline/RegisterPostPipeline.js
var RegisterPostPipeline = function(game, postFxPipelineName, PostFxPipelineClass) {
  GetGame_default(game).renderer.pipelines.addPostPipeline(postFxPipelineName, PostFxPipelineClass);
};
var RegisterPostPipeline_default = RegisterPostPipeline;

// node_modules/phaser3-rex-plugins/plugins/utils/renderer/postfxpipeline/AddPostFxPipelineInstance.js
var AddPostFxPipelineInstance = function(gameObject2, PostFxPipelineClass, config) {
  if (config === void 0) {
    config = {};
  }
  gameObject2.setPostPipeline(PostFxPipelineClass);
  var pipeline = gameObject2.postPipelines[gameObject2.postPipelines.length - 1];
  pipeline.resetFromJSON(config);
  if (config.name) {
    pipeline.name = config.name;
  }
  return pipeline;
};
var AddPostFxPipelineInstance_default = AddPostFxPipelineInstance;

// node_modules/phaser3-rex-plugins/plugins/utils/renderer/postfxpipeline/RemovePostFxPipelineInstance.js
var SpliceOne2 = Phaser.Utils.Array.SpliceOne;
var RemovePostFxPipelineInstance = function(gameObject2, PostFxPipelineClass, name2) {
  if (name2 === void 0) {
    var pipelines = gameObject2.postPipelines;
    for (var i = pipelines.length - 1; i >= 0; i--) {
      var instance = pipelines[i];
      if (instance instanceof PostFxPipelineClass) {
        instance.destroy();
        SpliceOne2(pipelines, i);
      }
    }
  } else {
    var pipelines = gameObject2.postPipelines;
    for (var i = 0, cnt = pipelines.length; i < cnt; i++) {
      var instance = pipelines[i];
      if (instance instanceof PostFxPipelineClass && instance.name === name2) {
        instance.destroy();
        SpliceOne2(pipelines, i);
      }
    }
  }
  gameObject2.hasPostPipeline = gameObject2.postPipelines.length > 0;
};
var RemovePostFxPipelineInstance_default = RemovePostFxPipelineInstance;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddDissolveMode.js
var AddDissolveMode = function(image) {
  RegisterPostPipeline_default(image.scene.game, "rexDissolvePostFx", dissolvepipeline_default);
  image.addTransitionMode(Dissolve, {
    ease: "Linear",
    dir: "out",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      currentImage.effect = AddPostFxPipelineInstance_default(currentImage, dissolvepipeline_default);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      currentImage.effect.setProgress(t);
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      RemovePostFxPipelineInstance_default(currentImage, dissolvepipeline_default);
      delete currentImage.effect;
    }
  });
};
var AddDissolveMode_default = AddDissolveMode;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/AddRevealModes.js
var WipeWidth = 0.1;
var DirLeftToRight = 0;
var DirTopToBottom = 0;
var DirRightToLeft = 1;
var DirBottomToTop = 1;
var AxisX = 0;
var AxisY = 1;
var AddRevealModes = function(image) {
  image.addTransitionMode(RevealRight, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirLeftToRight, AxisX);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  }).addTransitionMode(RevealLeft, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirRightToLeft, AxisX);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  }).addTransitionMode(RevealDown, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirTopToBottom, AxisY);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  }).addTransitionMode(RevealUp, {
    ease: "Linear",
    dir: "in",
    mask: false,
    onStart: function(parent, currentImage, nextImage, t) {
      nextImage.effect = nextImage.preFX.addReveal(WipeWidth, DirBottomToTop, AxisY);
    },
    onProgress: function(parent, currentImage, nextImage, t) {
      nextImage.effect.progress = t;
    },
    onComplete: function(parent, currentImage, nextImage, t) {
      nextImage.preFX.remove(nextImage.effect);
      delete nextImage.effect;
    }
  });
};
var AddRevealModes_default = AddRevealModes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/transitionmodes/Modes.js
var Modes = [
  AddSlideAwayModes_default,
  AddSlideModes_default,
  AddPushModes_default,
  AddZoomModes_default,
  AddFadeModes_default,
  AddIrisModes_default,
  AddPieModes_default,
  AddWipeModes_default,
  AddBlindsModes_default,
  AddSquaresModes_default,
  AddDiamondsMode_default,
  AddCirclesMode_default,
  AddCurtainMode_default,
  AddPixellateMode_default,
  AddDissolveMode_default,
  AddRevealModes_default
];
var Modes_default = Modes;

// node_modules/phaser3-rex-plugins/templates/transitionimagepack/TransitionImagePack.js
var TransitionImagePack = class extends transitionimage_default {
  constructor(scene, x, y, texture, frame, config) {
    super(scene, x, y, texture, frame, config);
    for (var i = 0, cnt = Modes_default.length; i < cnt; i++) {
      Modes_default[i](this);
    }
  }
};
var TransitionImagePack_default = TransitionImagePack;

// node_modules/phaser3-rex-plugins/templates/ui/transitionimagepack/TransitionImagePack.js
var TransitionImagePack_default2 = TransitionImagePack_default;

// node_modules/phaser3-rex-plugins/templates/ui/transitionimagepack/Factory.js
ObjectFactory_default.register("transitionImagePack", function(x, y, texture, frame, config) {
  var gameObject2 = new TransitionImagePack_default2(this.scene, x, y, texture, frame, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TransitionImagePack", TransitionImagePack_default2);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/imagebox/methods/ScaleImage.js
var ScaleImage = function() {
  var image = this.image;
  if (!this.scaleUp && image.width <= this.width && image.height <= this.height) {
    return this;
  }
  var result = FitTo_default(image, this, "FIT", true);
  image.setDisplaySize(result.width, result.height);
  this.resetChildScaleState(image);
  return this;
};
var ScaleImage_default = ScaleImage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/imagebox/methods/Methods.js
var methods20 = {
  scaleImage: ScaleImage_default
};
Object.assign(
  methods20,
  FlipMethods_default
);
var Methods_default22 = methods20;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/imagebox/methods/ResizeBackground.js
var ResizeBackground = function() {
  var background = this.background;
  if (!background) {
    return this;
  }
  background.setOrigin(this.originX, this.originY);
  background.setPosition(this.x, this.y);
  ResizeGameObject_default(background, this.displayWidth, this.displayHeight);
  this.resetChildScaleState(background);
  return this;
};
var ResizeBackground_default = ResizeBackground;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/imagebox/ImageBox.js
var IsPlainObject36 = Phaser.Utils.Objects.IsPlainObject;
var GetValue114 = Phaser.Utils.Objects.GetValue;
var ImageBox = class extends ContainerLite_default {
  constructor(scene, x, y, texture, frame, config) {
    if (IsPlainObject36(x)) {
      config = x;
      x = GetValue114(config, "x", 0);
      y = GetValue114(config, "y", 0);
      texture = GetValue114(config, "key", void 0);
      frame = GetValue114(config, "frame", void 0);
    } else if (IsPlainObject36(frame)) {
      config = frame;
      frame = void 0;
    }
    var image = GetValue114(config, "image");
    if (!image) {
      image = scene.add.image(x, y, texture, frame);
      if (texture === void 0) {
        image.setVisible(false);
      }
    } else {
      image.setPosition(x, y).setOrigin(0.5);
    }
    super(scene, x, y, 1, 1);
    this.type = "rexImageBox";
    var background = GetValue114(config, "background");
    if (background) {
      this.add(background);
    }
    this.background = background;
    this.add(image);
    this.image = image;
    this.scaleUp = GetValue114(config, "scaleUp", false);
    var width = GetValue114(config, "width", image.width);
    var height = GetValue114(config, "height", image.height);
    this.resize(width, height);
  }
  get texture() {
    return this.image.texture;
  }
  get frame() {
    return this.image.frame;
  }
  get flipX() {
    return this._flipX;
  }
  set flipX(value) {
    if (this._flipX === value) {
      return;
    }
    this._flipX = value;
    this.image.setFlipX(value);
  }
  get flipY() {
    return this._flipY;
  }
  set flipY(value) {
    if (this._flipY === value) {
      return;
    }
    this._flipY = value;
    this.image.setFlipY(value);
  }
  resize(width, height) {
    super.resize(width, height);
    ResizeBackground_default.call(this);
    this.scaleImage();
    return this;
  }
  setTexture(texture, frame) {
    var image = this.image;
    image.setTexture(texture, frame);
    if (texture !== null) {
      this.setChildVisible(image, true);
      this.scaleImage();
    } else {
      this.setChildVisible(image, false);
    }
    return this;
  }
};
Object.assign(
  ImageBox.prototype,
  Methods_default22
);
var ImageBox_default = ImageBox;

// node_modules/phaser3-rex-plugins/plugins/imagebox.js
var imagebox_default = ImageBox_default;

// node_modules/phaser3-rex-plugins/templates/ui/imagebox/ImageBox.js
var ImageBox_default2 = imagebox_default;

// node_modules/phaser3-rex-plugins/templates/ui/imagebox/Factory.js
ObjectFactory_default.register("imageBox", function(x, y, texture, frame, config) {
  var gameObject2 = new ImageBox_default2(this.scene, x, y, texture, frame, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ImageBox", ImageBox_default2);

// node_modules/phaser3-rex-plugins/templates/ui/fullwindowrectangle/FullWindowRectangle.js
var FullWindowRectangle_default2 = fullwindowrectangle_default;

// node_modules/phaser3-rex-plugins/templates/ui/fullwindowrectangle/Factory.js
ObjectFactory_default.register("fullWindowRectangle", function(fillColor, fillAlpha) {
  var gameObject2 = new FullWindowRectangle_default2(this.scene, fillColor, fillAlpha);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.FullWindowRectangle", FullWindowRectangle_default2);

// node_modules/phaser3-rex-plugins/plugins/fullwindowzone.js
var fullwindowzone_default = FullWindowZone_default;

// node_modules/phaser3-rex-plugins/templates/ui/fullwindowzone/FullWindowZone.js
var FullWindowZone_default2 = fullwindowzone_default;

// node_modules/phaser3-rex-plugins/templates/ui/fullwindowzone/Factory.js
ObjectFactory_default.register("fullWindowZone", function() {
  var gameObject2 = new FullWindowZone_default2(this.scene);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.FullWindowZone", FullWindowZone_default2);

// node_modules/phaser3-rex-plugins/templates/ui/cover/Cover.js
var Cover_default2 = Cover_default;

// node_modules/phaser3-rex-plugins/templates/ui/cover/Factory.js
ObjectFactory_default.register("cover", function(config) {
  var gameObject2 = new Cover_default2(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Cover", Cover_default2);

// node_modules/phaser3-rex-plugins/plugins/inputtext.js
var inputtext_default = InputText_default;

// node_modules/phaser3-rex-plugins/templates/ui/inputtext/InputText.js
var InputText_default2 = inputtext_default;

// node_modules/phaser3-rex-plugins/templates/ui/inputtext/Factory.js
ObjectFactory_default.register("inputText", function(config) {
  var gameObject2 = new InputText_default2(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.InputText", InputText_default2);

// node_modules/phaser3-rex-plugins/plugins/behaviors/filechooser/CreateFileInput.js
var GetValue115 = Phaser.Utils.Objects.GetValue;
var CreateFileInput = function(game, config) {
  var fileInput = document.createElement("input");
  fileInput.type = "file";
  var accept = GetValue115(config, "accept", "");
  var multiple = GetValue115(config, "multiple", false);
  fileInput.setAttribute("accept", accept);
  if (multiple) {
    fileInput.setAttribute("multiple", "");
  } else {
    fileInput.removeAttribute("multiple");
  }
  return fileInput;
};
var CreateFileInput_default = CreateFileInput;

// node_modules/phaser3-rex-plugins/plugins/utils/promise/Delay.js
var Delay = function(time, result) {
  if (time === void 0) {
    time = 0;
  }
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      resolve(result);
    }, time);
  });
};
var Delay_default = Delay;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/filechooser/ClickPromise.js
var ClickPromise = function({ game, fileInput, closeDelay }) {
  return WaitEvent2(GetGame_default(game).events, "focus").then(function() {
    return Delay_default(closeDelay);
  }).then(function() {
    var result = {
      files: fileInput.files
    };
    return Promise.resolve(result);
  });
};
var ClickPromise_default = ClickPromise;

// node_modules/phaser3-rex-plugins/plugins/behaviors/filechooser/Open.js
var GetValue116 = Phaser.Utils.Objects.GetValue;
var RemoveFromDOM2 = Phaser.DOM.RemoveFromDOM;
var Open2 = function(game, config) {
  var closeDelay = GetValue116(config, "closeDelay", 200);
  var fileInput = CreateFileInput_default(game, config);
  fileInput.click();
  return ClickPromise_default({ game, fileInput, closeDelay }).then(function(result) {
    RemoveFromDOM2(fileInput);
    fileInput.remove();
    return Promise.resolve(result);
  });
};
var Open_default2 = Open2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/utils/SyncTo.js
var SyncTo = function(gameObject2) {
  this.setOrigin(gameObject2.originX, gameObject2.originY);
  this.setPosition(gameObject2.x, gameObject2.y);
  this.resize(gameObject2.displayWidth, gameObject2.displayHeight);
  return this;
};
var SyncTo_default = SyncTo;

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetCache.js
var GetCache = function(game, loaderType, cacheType) {
  if (cacheType === void 0) {
    switch (loaderType) {
      case "image":
      case "svg":
        cacheType = "textures";
        break;
      case "animation":
        cacheType = "json";
        break;
      case "tilemapTiledJSON":
      case "tilemapCSV":
        cacheType = "tilemap";
        break;
      case "glsl":
        cacheType = "shader";
        break;
      default:
        cacheType = loaderType;
        break;
    }
  }
  game = GetGame_default(game);
  var cache;
  if (cacheType === "textures") {
    cache = game.textures;
  } else {
    cache = game.cache[cacheType];
  }
  return cache;
};
var GetCache_default = GetCache;

// node_modules/phaser3-rex-plugins/plugins/utils/loader/FileObjectToCache.js
var FileObjectToCache = function(scene, file, loaderType, key2, cacheType, onComplete) {
  if (cacheType === null || cacheType === false) {
  } else if (IsFunction_default(cacheType)) {
    cacheType();
  } else {
    var cache = GetCache_default(scene, loaderType, cacheType);
    if (cache.exists(key2)) {
      cache.remove(key2);
    }
  }
  var loader = scene.load;
  if (onComplete) {
    loader.once(`filecomplete-${loaderType}-${key2}`, function(key3, type, data) {
      onComplete(data);
    });
  }
  if (IsFunction_default(file)) {
    file();
  } else {
    var url = window.URL.createObjectURL(file);
    loader[loaderType](key2, url);
  }
  loader.start();
};
var FileObjectToCache_default = FileObjectToCache;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/utils/LoadFileMethods.js
var LoadFile = function(file, loaderType, key2, cacheType, onComplete) {
  var scene = this.scene;
  FileObjectToCache_default(scene, file, loaderType, key2, cacheType, onComplete);
  return this;
};
var LoadFilePromise = function(file, loaderType, key2, cacheType) {
  var scene = this.scene;
  return new Promise(function(resolve, reject) {
    var onComplete = function(data) {
      resolve(data);
    };
    FileObjectToCache_default(scene, file, loaderType, key2, cacheType, onComplete);
  });
};
var LoadFileMethods_default = {
  loadFile: LoadFile,
  loadFilePromise: LoadFilePromise
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/filechooser/FileChooser.js
var DOMElement = Phaser.GameObjects.DOMElement;
var IsPlainObject37 = Phaser.Utils.Objects.IsPlainObject;
var GetValue117 = Phaser.Utils.Objects.GetValue;
var FileChooser = class extends DOMElement {
  constructor(scene, x, y, width, height, config) {
    if (IsPlainObject37(x)) {
      config = x;
      x = GetValue117(config, "x", 0);
      y = GetValue117(config, "y", 0);
      width = GetValue117(config, "width", 0);
      height = GetValue117(config, "height", 0);
    } else if (IsPlainObject37(width)) {
      config = width;
      width = GetValue117(config, "width", 0);
      height = GetValue117(config, "height", 0);
    }
    var inputElement = document.createElement("input");
    inputElement.type = "file";
    var inputStyle = inputElement.style;
    inputStyle.display = "none";
    var labelElement = document.createElement("label");
    labelElement.appendChild(inputElement);
    var style = GetValue117(config, "style", void 0);
    super(scene, x, y, labelElement, style);
    this.type = "rexFileChooser";
    this.resetFromJSON(config);
    this.resize(width, height);
    var self = this;
    inputElement.onchange = function() {
      self.emit("change", self);
    };
    this.setCloseDelay(GetValue117(config, "closeDelay", 200));
    inputElement.onclick = function() {
      ClickPromise_default({
        game: scene,
        fileInput: inputElement,
        closeDelay: self.closeDelay
      }).then(function() {
        self.emit("select", self);
      });
    };
  }
  resetFromJSON(config) {
    this.setAccept(GetValue117(config, "accept", ""));
    this.setMultiple(GetValue117(config, "multiple", false));
    return this;
  }
  setAccept(accept) {
    if (accept === void 0) {
      accept = "";
    }
    this.fileInput.setAttribute("accept", accept);
    return this;
  }
  setMultiple(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    if (enabled) {
      this.fileInput.setAttribute("multiple", "");
    } else {
      this.fileInput.removeAttribute("multiple");
    }
    return this;
  }
  setCloseDelay(delay) {
    if (delay === void 0) {
      delay = 200;
    }
    this.closeDelay = delay;
    return this;
  }
  get fileInput() {
    return this.node.children[0];
  }
  open() {
    this.fileInput.click();
    return this;
  }
  get files() {
    return this.fileInput.files;
  }
  setOpenEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.fileInput.disabled = !enable;
    return this;
  }
};
var methods21 = {
  resize: Resize_default,
  syncTo: SyncTo_default
};
Object.assign(
  FileChooser.prototype,
  methods21,
  LoadFileMethods_default
);
var FileChooser_default = FileChooser;

// node_modules/phaser3-rex-plugins/templates/ui/filechooser/Factory.js
ObjectFactory_default.register("fileChooser", function(config) {
  var gameObject2 = new FileChooser_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.FileChooser", FileChooser_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/filedropzone/methods/DropEnableMethods.js
var DropEnableMethods_default = {
  setDropEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.dropEnable = enable;
    return this;
  },
  toggleDropEnable() {
    this.dropEnable = !this.dropEnable;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/filedropzone/methods/FilterMethods.js
var FilterMethods_default = {
  addFilter(name2, callback) {
    if (!this.filters) {
      this.filters = {};
    }
    this.filters[name2] = callback;
    return this;
  },
  addFilters(filters) {
    if (!this.filters) {
      this.filters = {};
    }
    for (var name2 in filters) {
      this.filters[name2] = filters[name2];
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/filedropzone/methods/Methods.js
var Methods13 = {
  resize: Resize_default,
  syncTo: SyncTo_default
};
Object.assign(
  Methods13,
  DropEnableMethods_default,
  FilterMethods_default,
  LoadFileMethods_default
);
var Methods_default23 = Methods13;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/filedropzone/FileDropZoneProperties.js
var DragDropEvents = {
  dragenter: "dragenter",
  dragleave: "dragleave",
  dragover: "dragover",
  drop: "drop"
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/dom/filedropzone/FileDropZone.js
var DOMElement2 = Phaser.GameObjects.DOMElement;
var IsPlainObject38 = Phaser.Utils.Objects.IsPlainObject;
var GetValue118 = Phaser.Utils.Objects.GetValue;
var FileDropZone = class extends DOMElement2 {
  constructor(scene, x, y, width, height, config) {
    if (IsPlainObject38(x)) {
      config = x;
      x = GetValue118(config, "x", 0);
      y = GetValue118(config, "y", 0);
      width = GetValue118(config, "width", 0);
      height = GetValue118(config, "height", 0);
    } else if (IsPlainObject38(width)) {
      config = width;
      width = GetValue118(config, "width", 0);
      height = GetValue118(config, "height", 0);
    }
    if (config === void 0) {
      config = {};
    }
    var element = document.createElement("div");
    var style = GetValue118(config, "style", void 0);
    super(scene, x, y, element, style);
    this.type = "rexFileDropZone";
    this.resize(width, height);
    this._files = [];
    this.setDropEnable(GetValue118(config, "dropEnable", true));
    var filters = GetValue118(config, "filters");
    if (filters) {
      this.addFilters(filters);
    }
    RouteEvents_default(this, element, DragDropEvents, {
      preventDefault: true,
      preTest(gameObject2) {
        return gameObject2.dropEnable;
      }
    });
    this.on("drop", function(gameObject2, e) {
      this._files = e.dataTransfer.files;
      var files = this._files;
      if (files && this.filters) {
        for (var filterType in this.filters) {
          var filterCallback = this.filters[filterType];
          var filteredFiles = [];
          for (var i = 0, cnt = files.length; i < cnt; i++) {
            var file = files[i];
            if (filterCallback(file, files)) {
              filteredFiles.push(file);
            }
          }
          if (filteredFiles.length > 0) {
            this.emit(`drop.${filterType}`, filteredFiles);
          }
        }
      }
    }, this);
  }
  get files() {
    return this._files;
  }
};
Object.assign(
  FileDropZone.prototype,
  Methods_default23
);
var FileDropZone_default = FileDropZone;

// node_modules/phaser3-rex-plugins/plugins/filedropzone.js
var filedropzone_default = FileDropZone_default;

// node_modules/phaser3-rex-plugins/templates/ui/filedropzone/FileDropZone.js
var FileDropZone_default2 = filedropzone_default;

// node_modules/phaser3-rex-plugins/templates/ui/filedropzone/Factory.js
ObjectFactory_default.register("fileDropZone", function(config) {
  var gameObject2 = new FileDropZone_default2(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.FileDropZone", FileDropZone_default2);

// node_modules/phaser3-rex-plugins/templates/ui/sizer/GetChildrenWidth.js
var GetChildrenWidth3 = function(minimumMode) {
  if (this.rexSizer.hidden) {
    return 0;
  }
  if (minimumMode === void 0) {
    minimumMode = true;
  }
  var result = 0;
  var children = this.sizerChildren;
  var child, sizerConfig, proportion, padding, childWidth;
  var hasUnknownChildWidth = false;
  var totalProportion = this.childrenProportion;
  if (this.orientation === 0) {
    var isFirstChild = true;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (!child.hasOwnProperty("rexSizer")) {
        continue;
      }
      sizerConfig = child.rexSizer;
      if (sizerConfig.hidden) {
        continue;
      }
      proportion = sizerConfig.proportion;
      if (proportion === 0 || minimumMode) {
        childWidth = this.getChildWidth(child);
        if (sizerConfig.fitRatio > 0 && !sizerConfig.resolved) {
          childWidth = void 0;
        }
        if (childWidth === void 0) {
          if (proportion !== 0 && !this.hasProportion0Child) {
            childWidth = 0;
          } else {
            hasUnknownChildWidth = true;
          }
        }
      } else {
        childWidth = 0;
      }
      if (hasUnknownChildWidth) {
        continue;
      }
      padding = child.rexSizer.padding;
      childWidth += (padding.left + padding.right) * this.scaleX;
      if (isFirstChild) {
        isFirstChild = false;
      } else {
        childWidth += this.space.item * this.scaleX;
      }
      result += childWidth;
    }
  } else {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (!child.hasOwnProperty("rexSizer")) {
        continue;
      }
      sizerConfig = child.rexSizer;
      if (sizerConfig.hidden) {
        continue;
      }
      childWidth = this.getChildWidth(child);
      if (childWidth === void 0) {
        hasUnknownChildWidth = true;
      }
      if (hasUnknownChildWidth) {
        continue;
      }
      padding = sizerConfig.padding;
      childWidth += (padding.left + padding.right) * this.scaleX;
      result = Math.max(childWidth, result);
    }
  }
  if (hasUnknownChildWidth) {
    return void 0;
  }
  return result + (this.space.left + this.space.right) * this.scaleX;
};
var GetChildrenWidth_default3 = GetChildrenWidth3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/GetChildrenHeight.js
var GetChildrenHeight3 = function(minimumMode) {
  if (this.rexSizer.hidden) {
    return 0;
  }
  if (minimumMode === void 0) {
    minimumMode = true;
  }
  var result = 0;
  var children = this.sizerChildren;
  var child, sizerConfig, proportion, padding, childHeight;
  var hasUnknownChildHeight = false;
  var totalProportion = this.childrenProportion;
  if (this.orientation === 0) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (!child.hasOwnProperty("rexSizer")) {
        continue;
      }
      sizerConfig = child.rexSizer;
      if (sizerConfig.hidden) {
        continue;
      }
      childHeight = this.getChildHeight(child);
      if (childHeight === void 0) {
        hasUnknownChildHeight = true;
      }
      if (hasUnknownChildHeight) {
        continue;
      }
      padding = sizerConfig.padding;
      childHeight += (padding.top + padding.bottom) * this.scaleY;
      result = Math.max(childHeight, result);
    }
  } else {
    var isFirstChild = true;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (!child.hasOwnProperty("rexSizer")) {
        continue;
      }
      sizerConfig = child.rexSizer;
      if (sizerConfig.hidden) {
        continue;
      }
      proportion = sizerConfig.proportion;
      if (proportion === 0 || minimumMode) {
        childHeight = this.getChildHeight(child);
        if (sizerConfig.fitRatio > 0 && !sizerConfig.resolved) {
          childHeight = void 0;
        }
        if (childHeight === void 0) {
          if (proportion !== 0 && !this.hasProportion0Child) {
            childHeight = 0;
          } else {
            hasUnknownChildHeight = true;
          }
        }
      } else {
        childHeight = 0;
      }
      if (hasUnknownChildHeight) {
        continue;
      }
      padding = sizerConfig.padding;
      childHeight += (padding.top + padding.bottom) * this.scaleY;
      if (isFirstChild) {
        isFirstChild = false;
      } else {
        childHeight += this.space.item * this.scaleY;
      }
      result += childHeight;
    }
  }
  if (hasUnknownChildHeight) {
    return void 0;
  }
  return result + (this.space.top + this.space.bottom) * this.scaleY;
};
var GetChildrenHeight_default3 = GetChildrenHeight3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/GetExpandedChildWidth.js
var GetExpandedChildWidth3 = function(child, parentWidth) {
  if (parentWidth === void 0) {
    parentWidth = this.width * this.scaleX;
  }
  var childWidth;
  var sizerConfig = child.rexSizer;
  if (this.orientation === 0) {
    if (sizerConfig.proportion > 0 && this.proportionLength > 0) {
      childWidth = sizerConfig.proportion * this.proportionLength;
    }
  } else {
    if (sizerConfig.expand) {
      var space = this.space;
      var innerWidth = parentWidth - (space.left + space.right) * this.scaleX;
      var padding = sizerConfig.padding;
      childWidth = innerWidth - (padding.left + padding.right) * this.scaleX;
    }
  }
  return childWidth;
};
var GetExpandedChildWidth_default3 = GetExpandedChildWidth3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/GetExpandedChildHeight.js
var GetExpandedChildHeight3 = function(child, parentHeight) {
  if (parentHeight === void 0) {
    parentHeight = this.height;
  }
  var childHeight;
  var sizerConfig = child.rexSizer;
  if (this.orientation === 0) {
    if (sizerConfig.expand) {
      var space = this.space;
      var innerHeight = parentHeight - (space.top + space.bottom) * this.scaleY;
      var padding = sizerConfig.padding;
      childHeight = innerHeight - (padding.top + padding.bottom) * this.scaleY;
    }
  } else {
    if (sizerConfig.proportion > 0 && this.proportionLength > 0) {
      childHeight = sizerConfig.proportion * this.proportionLength;
    }
  }
  return childHeight;
};
var GetExpandedChildHeight_default3 = GetExpandedChildHeight3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/GetChildrenSizers.js
var GetChildrenSizers3 = function(out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  var children = this.sizerChildren, child;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child.isRexSizer) {
      out2.push(child);
    }
  }
  return out2;
};
var GetChildrenSizers_default3 = GetChildrenSizers3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/PreLayout.js
var PreLayout2 = function() {
  this.hasRatioFitChild = false;
  var child, sizerConfig;
  var children = this.sizerChildren;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    sizerConfig = child.rexSizer;
    if (sizerConfig.hidden) {
      continue;
    }
    if (sizerConfig.fitRatio > 0) {
      ResizeGameObject_default(child, 0, 0);
      sizerConfig.resolved = false;
      this.hasRatioFitChild = true;
    }
  }
  this._childrenProportion = void 0;
  this.hasProportion0Child = false;
  this.proportionLength = void 0;
  PreLayout_default.call(this);
  return this;
};
var PreLayout_default2 = PreLayout2;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/LayoutChildren.js
var Wrap4 = Phaser.Math.Wrap;
var LayoutChildren3 = function() {
  var children = this.sizerChildren;
  var child, childConfig, padding;
  var startX = this.innerLeft, startY = this.innerTop;
  var innerWidth = this.innerWidth;
  var innerHeight = this.innerHeight;
  var itemX = startX, itemY = startY;
  var x, y, width, height, alignOffsetX, alignOffsetY;
  var childWidth, childHeight;
  var childIndex, startChildIndex = this.startChildIndex;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    if (startChildIndex === 0) {
      childIndex = i;
    } else {
      childIndex = Wrap4(i + startChildIndex, 0, cnt);
    }
    if (this.rtl) {
      childIndex = cnt - childIndex - 1;
    }
    child = children[childIndex];
    if (child.rexSizer.hidden) {
      continue;
    }
    childConfig = child.rexSizer;
    padding = childConfig.padding;
    PreLayoutChild_default.call(this, child);
    if (child.isRexSpace) {
      childWidth = 0;
      childHeight = 0;
    } else {
      childWidth = this.getExpandedChildWidth(child);
      childHeight = this.getExpandedChildHeight(child);
    }
    if (child.isRexSizer) {
      child.runLayout(this, childWidth, childHeight);
      CheckSize_default(child, this);
    } else {
      ResizeGameObject_default(child, childWidth, childHeight);
    }
    if (childWidth === void 0) {
      childWidth = GetDisplayWidth(child);
    }
    if (childHeight === void 0) {
      childHeight = GetDisplayHeight(child);
    }
    if (this.orientation === 0) {
      x = itemX + padding.left * this.scaleX;
      if (childConfig.proportion === 0 || this.proportionLength === 0) {
        width = childWidth;
      } else {
        width = childConfig.proportion * this.proportionLength;
      }
      y = itemY + padding.top * this.scaleY;
      height = innerHeight - (padding.top + padding.bottom) * this.scaleY;
    } else {
      x = itemX + padding.left * this.scaleX;
      width = innerWidth - (padding.left + padding.right) * this.scaleX;
      y = itemY + padding.top * this.scaleY;
      if (childConfig.proportion === 0 || this.proportionLength === 0) {
        height = childHeight;
      } else {
        height = childConfig.proportion * this.proportionLength;
      }
    }
    if (childWidth === void 0) {
      childWidth = GetDisplayWidth(child);
    }
    if (childHeight === void 0) {
      childHeight = GetDisplayHeight(child);
    }
    alignOffsetX = (childConfig.alignOffsetX + childConfig.alignOffsetOriginX * childWidth) * this.scaleX;
    alignOffsetY = (childConfig.alignOffsetY + childConfig.alignOffsetOriginY * childHeight) * this.scaleY;
    LayoutChild_default.call(
      this,
      child,
      x,
      y,
      width,
      height,
      childConfig.align,
      alignOffsetX,
      alignOffsetY
    );
    if (this.orientation === 0) {
      itemX += width + (padding.left + padding.right) * this.scaleX + this.space.item * this.scaleX;
    } else {
      itemY += height + (padding.top + padding.bottom) * this.scaleY + this.space.item * this.scaleY;
    }
  }
};
var LayoutChildren_default3 = LayoutChildren3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/ResolveWidth.js
var ResolveWidth3 = function(width) {
  var width = ResolveWidth_default.call(this, width);
  if (width !== void 0 && this.orientation === 0 && this.proportionLength === void 0) {
    var remainder = width - this.childrenWidth;
    if (remainder > 0) {
      remainder = width - this.getChildrenWidth(false);
      this.proportionLength = remainder / this.childrenProportion;
    } else {
      this.proportionLength = 0;
      if (remainder < 0) {
      }
    }
  }
  return width;
};
var ResolveWidth_default2 = ResolveWidth3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/ResolveHeight.js
var ResolveHeight3 = function(height) {
  var height = ResolveHeight_default.call(this, height);
  if (height !== void 0 && this.orientation === 1 && this.proportionLength === void 0) {
    var remainder = height - this.childrenHeight;
    if (remainder > 0) {
      remainder = height - this.getChildrenHeight(false);
      this.proportionLength = remainder / this.childrenProportion;
    } else {
      this.proportionLength = 0;
      if (remainder < 0) {
      }
    }
  }
  return height;
};
var ResolveHeight_default2 = ResolveHeight3;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/HasWidthWrap.js
var HasWidthWrap2 = function() {
  if (this.hasRatioFitChild && this.orientation === 1) {
    return true;
  }
  return HasWidthWrap_default.call(this);
};
var HasWidthWrap_default2 = HasWidthWrap2;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/ExpandFitRatioChildren.js
var ExpandFitRatioChildren = function(width, height) {
  if (!this.hasRatioFitChild) {
    return;
  }
  var innerHeight, innerWidth;
  if (this.orientation === 0) {
    innerHeight = height - (this.getInnerPadding("top") + this.getInnerPadding("bottom")) * this.scaleY;
  } else {
    innerWidth = width - (this.getInnerPadding("left") + this.getInnerPadding("right")) * this.scaleX;
  }
  var child, sizerConfig;
  var childWidth, childHeight;
  var children = this.sizerChildren;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    var sizerConfig = child.rexSizer;
    if (sizerConfig.hidden) {
      continue;
    }
    var fitRatio = sizerConfig.fitRatio;
    if (!fitRatio) {
      continue;
    }
    if (this.orientation === 0) {
      childHeight = innerHeight - (this.getChildOuterPadding(child, "top") + this.getChildOuterPadding(child, "bottom")) * this.scaleY;
      childWidth = childHeight * fitRatio;
    } else {
      childWidth = innerHeight - (this.getChildOuterPadding(child, "top") + this.getChildOuterPadding(child, "bottom")) * this.scaleX;
      childHeight = childWidth / fitRatio;
    }
    ResizeGameObject_default(child, childWidth, childHeight);
    if (child.isRexSizer) {
      child.setMinSize(childWidth, childHeight);
    }
    sizerConfig.resolved = true;
  }
};
var ExpandFitRatioChildren_default = ExpandFitRatioChildren;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/RunWidthWrap.js
var RunWidthWrap2 = function(width) {
  if (this.wrapResult) {
    return;
  }
  if (this.orientation === 1) {
    ExpandFitRatioChildren_default.call(this, width, void 0);
  }
  RunWidthWrap_default.call(this, width);
};
var RunWidthWrap_default2 = RunWidthWrap2;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/HasHeightWrap.js
var HasHeightWrap2 = function() {
  if (this.hasRatioFitChild && this.orientation === 0) {
    return true;
  }
  return HasHeightWrap_default.call(this);
};
var HasHeightWrap_default2 = HasHeightWrap2;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/RunHeightWrap.js
var RunHeightWrap2 = function(height) {
  if (this.wrapResult) {
    return;
  }
  if (this.orientation === 0) {
    ExpandFitRatioChildren_default.call(this, void 0, height);
  }
  RunHeightWrap_default.call(this, height);
};
var RunHeightWrap_default2 = RunHeightWrap2;

// node_modules/phaser3-rex-plugins/templates/ui/space/Space.js
var Zone3 = Phaser.GameObjects.Zone;
var Space2 = class extends Zone3 {
  constructor(scene) {
    super(scene, 0, 0, 1, 1);
    this.isRexSpace = true;
  }
};
var Space_default2 = Space2;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/GetNearestChildIndex.js
var GetNearestChildIndex = function(x, y) {
  var children = this.sizerChildren;
  if (children.length === 0) {
    return -1;
  }
  var nearestIndex = -1, minDistance = Infinity;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    var distance;
    if (this.orientation === 0) {
      distance = Math.abs(child.left - x);
    } else {
      distance = Math.abs(child.top - y);
    }
    if (minDistance > distance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  var child = children[children.length - 1];
  var distance;
  if (this.orientation === 0) {
    distance = Math.abs(child.right - x);
  } else {
    distance = Math.abs(child.bottom - y);
  }
  if (minDistance > distance) {
    minDistance = distance;
    nearestIndex = i + 1;
  }
  return nearestIndex;
};
var GetNearestChildIndex_default = GetNearestChildIndex;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/AddChildMethods.js
var IsPlainObject39 = Phaser.Utils.Objects.IsPlainObject;
var GetValue119 = Phaser.Utils.Objects.GetValue;
var ALIGN_CENTER3 = Phaser.Display.Align.CENTER;
var PROPORTIONMODE = {
  min: 0,
  full: -1
};
var Add3 = function(gameObject2, proportion, align, paddingConfig, expand, childKey, index, minWidth, minHeight, fitRatio) {
  var offsetX, offsetY;
  var offsetOriginX, offsetOriginY;
  AddChild_default4.call(this, gameObject2);
  var isRexSpace = gameObject2.isRexSpace;
  var proportionType = typeof proportion;
  if (proportion === null) {
    return this;
  } else if (proportionType === "number") {
  } else if (proportionType === "string") {
    proportion = PROPORTIONMODE[proportion];
  } else if (IsPlainObject39(proportion)) {
    var config = proportion;
    proportion = GetValue119(config, "proportion", void 0);
    align = GetValue119(config, "align", ALIGN_CENTER3);
    paddingConfig = GetValue119(config, "padding", 0);
    expand = GetValue119(config, "expand", false);
    childKey = GetValue119(config, "key", void 0);
    index = GetValue119(config, "index", void 0);
    if (!gameObject2.isRexSizer) {
      minWidth = GetValue119(config, "minWidth", void 0);
      minHeight = GetValue119(config, "minHeight", void 0);
    }
    fitRatio = GetValue119(config, "fitRatio", 0);
    offsetX = GetValue119(config, "offsetX", 0);
    offsetY = GetValue119(config, "offsetY", 0);
    offsetOriginX = GetValue119(config, "offsetOriginX", 0);
    offsetOriginY = GetValue119(config, "offsetOriginY", 0);
  }
  if (typeof align === "string") {
    align = AlignConst_default2[align];
  }
  if (proportion === void 0) {
    proportion = isRexSpace ? 1 : 0;
  }
  if (align === void 0) {
    align = ALIGN_CENTER3;
  }
  if (paddingConfig === void 0) {
    paddingConfig = 0;
  }
  if (expand === void 0) {
    expand = false;
  }
  if (minWidth === void 0) {
    if (isRexSpace) {
      minWidth = 0;
    } else if (!gameObject2.isRexSizer) {
      minWidth = gameObject2._minWidth;
    }
  }
  if (minHeight === void 0) {
    if (isRexSpace) {
      minHeight = 0;
    } else if (!gameObject2.isRexSizer) {
      minHeight = gameObject2._minHeight;
    }
  }
  if (fitRatio === void 0 || fitRatio === false) {
    fitRatio = 0;
  } else if (fitRatio === true) {
    fitRatio = GetDisplayWidth(gameObject2) / GetDisplayHeight(gameObject2);
  }
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  if (offsetOriginX === void 0) {
    offsetOriginX = 0;
  }
  if (offsetOriginY === void 0) {
    offsetOriginY = 0;
  }
  var config = this.getSizerConfig(gameObject2);
  config.proportion = proportion;
  config.align = align;
  config.padding = GetBoundsConfig_default2(paddingConfig);
  config.expand = expand;
  config.fitRatio = proportion === 0 ? fitRatio : 0;
  config.alignOffsetX = offsetX;
  config.alignOffsetY = offsetY;
  config.alignOffsetOriginX = offsetOriginX;
  config.alignOffsetOriginY = offsetOriginY;
  if (index === void 0 || index >= this.sizerChildren.length) {
    this.sizerChildren.push(gameObject2);
  } else {
    this.sizerChildren.splice(index, 0, gameObject2);
  }
  if (!gameObject2.isRexSizer) {
    if (proportion > 0) {
      if (this.orientation === 0) {
        gameObject2.minWidth = minWidth === void 0 ? GetDisplayWidth(gameObject2) : minWidth;
      } else {
        gameObject2.minHeight = minHeight === void 0 ? GetDisplayHeight(gameObject2) : minHeight;
      }
    }
    if (expand) {
      if (this.orientation === 0) {
        gameObject2.minHeight = minHeight;
      } else {
        gameObject2.minWidth = minWidth;
      }
    }
  }
  if (childKey !== void 0) {
    this.addChildrenMap(childKey, gameObject2);
  }
  return this;
};
var AddChildMethods_default3 = {
  add: Add3,
  // sizer.add could be override
  addSpace(proportion) {
    this.insertSpace(void 0, proportion);
    return this;
  },
  insertSpace(index, proportion) {
    if (proportion === void 0) {
      proportion = 1;
    }
    Add3.call(
      this,
      new Space_default2(this.scene),
      {
        proportion,
        minWidth: 0,
        minHeight: 0,
        index
      }
    );
    return this;
  },
  insert(index, gameObject2, proportion, align, paddingConfig, expand, childKey, minSize) {
    if (IsPlainObject39(proportion)) {
      proportion.index = index;
    }
    Add3.call(this, gameObject2, proportion, align, paddingConfig, expand, childKey, index, minSize);
    return this;
  },
  insertAtPosition(x, y, gameObject2, proportion, align, paddingConfig, expand, childKey, minSize) {
    var index = GetNearestChildIndex_default.call(this, x, y);
    if (index === -1) {
      index = void 0;
    }
    this.insert(index, gameObject2, proportion, align, paddingConfig, expand, childKey, minSize);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sizer/RemoveChildMethods.js
var RemoveItem13 = Phaser.Utils.Array.Remove;
var RemoveChildMethods_default3 = {
  remove(gameObject2, destroyChild) {
    if (this.getParentSizer(gameObject2) !== this) {
      return this;
    }
    RemoveItem13(this.sizerChildren, gameObject2);
    RemoveChild_default4.call(this, gameObject2, destroyChild);
    return this;
  },
  removeAll(destroyChild) {
    for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
      this.remove(this.sizerChildren[i], destroyChild);
    }
    return this;
  },
  clear(destroyChild) {
    this.sizerChildren.length = 0;
    ClearChildren_default.call(this, destroyChild);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sizer/AlignMethods.js
var AlignMethods_default = {
  getChildAlign(gameObject2) {
    return this.getSizerConfig(gameObject2).align;
  },
  setChildAlign(gameObject2, align) {
    if (typeof align === "string") {
      align = AlignConst_default2[align];
    }
    this.getSizerConfig(gameObject2).align = align;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sizer/ProportionMethods.js
var ProportionMethods_default = {
  getChildProportion(gameObject2) {
    return this.getSizerConfig(gameObject2).proportion;
  },
  setChildProportion(gameObject2, proportion) {
    this.getSizerConfig(gameObject2).proportion = proportion;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sizer/ExpandMethods.js
var ExpandMethods_default = {
  getChildExpand(gameObject2) {
    return this.getSizerConfig(gameObject2).expand;
  },
  setChildExpand(gameObject2, expand) {
    this.getSizerConfig(gameObject2).expand = expand;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sizer/SetChildrenAlignMode.js
var SetChildrenAlignMode = function(mode) {
  if (mode === void 0) {
    mode = "left";
  }
  var children = this.sizerChildren;
  var firstChild = children[0];
  var isFirstChildASpace = firstChild && firstChild.isRexSpace;
  if (
    // Has left space
    mode === "right" || mode === "bottom" || mode === "center"
  ) {
    if (!isFirstChildASpace) {
      this.insertSpace(0);
    }
  } else {
    if (isFirstChildASpace) {
      this.remove(firstChild, true);
    }
  }
  var lastChildIndex = children.length - 1;
  var lastChild = children[lastChildIndex];
  var isLastChildASpace = lastChild && lastChild.isRexSpace;
  if (mode === "center") {
    if (!isLastChildASpace) {
      this.insertSpace(lastChildIndex + 1);
    }
  } else {
    if (isLastChildASpace) {
      this.remove(lastChild, true);
    }
  }
  return this;
};
var SetChildrenAlignMode_default = SetChildrenAlignMode;

// node_modules/phaser3-rex-plugins/templates/ui/basesizer/utils/SortChildrenMethods.js
var SortChildrenMethods_default = {
  sortChildren(callback) {
    this.sizerChildren.sort(callback);
    return this;
  },
  sortChildrenByData(key2, descending) {
    this.sizerChildren.sort(function(childA, childB) {
      var valueA = childA.getData(key2);
      var valueB = childB.getData(key2);
      if (descending) {
        return valueB - valueA;
      } else {
        return valueA - valueB;
      }
    });
    return this;
  },
  sortChildrenByProperty(key2, descending) {
    this.sizerChildren.sort(function(childA, childB) {
      var valueA = childA[key2];
      var valueB = childB[key2];
      if (descending) {
        return valueB - valueA;
      } else {
        return valueA - valueB;
      }
    });
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sizer/Methods.js
var methods22 = {
  getChildrenWidth: GetChildrenWidth_default3,
  getChildrenHeight: GetChildrenHeight_default3,
  getExpandedChildWidth: GetExpandedChildWidth_default3,
  getExpandedChildHeight: GetExpandedChildHeight_default3,
  getChildrenSizers: GetChildrenSizers_default3,
  preLayout: PreLayout_default2,
  layoutChildren: LayoutChildren_default3,
  resolveWidth: ResolveWidth_default2,
  resolveHeight: ResolveHeight_default2,
  hasWidthWrap: HasWidthWrap_default2,
  runWidthWrap: RunWidthWrap_default2,
  hasHeightWrap: HasHeightWrap_default2,
  runHeightWrap: RunHeightWrap_default2,
  setChildrenAlignMode: SetChildrenAlignMode_default
};
Object.assign(
  methods22,
  AddChildMethods_default3,
  RemoveChildMethods_default3,
  AlignMethods_default,
  ProportionMethods_default,
  ExpandMethods_default,
  SortChildrenMethods_default
);
var Methods_default24 = methods22;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/GetChildrenProportion.js
var GetChildrenProportion = function() {
  var result = 0;
  var children = this.sizerChildren;
  var child, proportion;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child.rexSizer.hidden) {
      continue;
    }
    proportion = child.rexSizer.proportion;
    if (proportion > 0) {
      result += proportion;
    } else if (proportion === 0) {
      this.hasProportion0Child = true;
    }
  }
  return result;
};
var GetChildrenProportion_default = GetChildrenProportion;

// node_modules/phaser3-rex-plugins/templates/ui/utils/GetOrientationMode.js
var GetOrientationMode_default2 = GetOrientationMode_default;

// node_modules/phaser3-rex-plugins/templates/ui/sizer/Sizer.js
var IsPlainObject40 = Phaser.Utils.Objects.IsPlainObject;
var GetValue120 = Phaser.Utils.Objects.GetValue;
var Sizer = class extends BaseSizer_default {
  constructor(scene, x, y, minWidth, minHeight, orientation, config) {
    if (IsPlainObject40(x)) {
      config = x;
      x = GetValue120(config, "x", 0);
      y = GetValue120(config, "y", 0);
      minWidth = GetValue120(config, "width", void 0);
      minHeight = GetValue120(config, "height", void 0);
      orientation = GetValue120(config, "orientation", 0);
    } else if (IsPlainObject40(minWidth)) {
      config = minWidth;
      minWidth = GetValue120(config, "width", void 0);
      minHeight = GetValue120(config, "height", void 0);
      orientation = GetValue120(config, "orientation", 0);
    } else if (IsPlainObject40(orientation)) {
      config = orientation;
      orientation = GetValue120(config, "orientation", 0);
    }
    if (orientation === void 0) {
      orientation = 0;
    }
    super(scene, x, y, minWidth, minHeight, config);
    this.type = "rexSizer";
    this.sizerChildren = [];
    this.setOrientation(orientation);
    this.setItemSpacing(GetValue120(config, "space.item", 0));
    this.setStartChildIndex(GetValue120(config, "startChildIndex", 0));
    this.setRTL(GetValue120(config, "rtl", false));
    this.addChildrenMap("items", this.sizerChildren);
  }
  setOrientation(orientation) {
    this.orientation = GetOrientationMode_default2(orientation);
    return this;
  }
  setItemSpacing(space) {
    this.space.item = space;
    return this;
  }
  setStartChildIndex(index) {
    this.startChildIndex = index;
    return this;
  }
  setRTL(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.rtl = enable;
    return this;
  }
  get childrenProportion() {
    if (this._childrenProportion === void 0) {
      this._childrenProportion = GetChildrenProportion_default.call(this);
    }
    return this._childrenProportion;
  }
};
Object.assign(
  Sizer.prototype,
  Methods_default24
);
var Sizer_default = Sizer;

// node_modules/phaser3-rex-plugins/plugins/utils/size/SetDisplaySize.js
var SetDisplaySize = function(gameObject2, width, height) {
  if (!gameObject2) {
    return;
  }
  var unknownWidth = width == null;
  var unknownHeight = height == null;
  if (unknownWidth && unknownHeight) {
    return gameObject2;
  }
  if (!unknownWidth) {
    gameObject2.displayWidth = width;
  }
  if (!unknownHeight) {
    gameObject2.displayHeight = height;
  }
  if (unknownWidth) {
    gameObject2.scaleX = gameObject2.scaleY;
  }
  if (unknownHeight) {
    gameObject2.scaleY = gameObject2.scaleX;
  }
  return gameObject2;
};
var SetDisplaySize_default = SetDisplaySize;

// node_modules/phaser3-rex-plugins/templates/ui/label/methods/ResetDisplayContent.js
var ResetDisplayContent = function(config) {
  if (config === void 0) {
    config = {};
  } else if (typeof config === "string") {
    config = {
      text: config
    };
  }
  var text = config.text || "";
  this.setText(text);
  var iconGameObjct = this.childrenMap.icon;
  if (iconGameObjct) {
    if (!config.icon) {
      this.hide(iconGameObjct);
    } else {
      this.show(iconGameObjct);
    }
    var iconSize = config.iconSize;
    if (iconSize) {
      this.setChildDisplaySize(iconGameObjct, iconSize, iconSize);
      if (this.iconWidth !== void 0) {
        this.setIconSize(iconSize);
      }
    }
    if (config.icon !== true) {
      this.setIconTexture(config.icon, config.iconFrame);
    }
  }
  var actionGameObjct = this.childrenMap.action;
  if (actionGameObjct) {
    if (!config.action) {
      this.hide(actionGameObjct);
    } else {
      this.show(actionGameObjct);
    }
    var actionSize = config.actionSize;
    if (actionSize) {
      this.setChildDisplaySize(actionGameObjct, actionSize, actionSize);
      if (this.actionWidth !== void 0) {
        this.setActionSize(actionSize);
      }
    }
    if (config.action !== true) {
      this.setActionTexture(config.action, config.actionFrame);
    }
  }
  return this;
};
var ResetDisplayContent_default = ResetDisplayContent;

// node_modules/phaser3-rex-plugins/templates/ui/label/methods/Methods.js
var methods23 = {
  appendText: AppendText_default,
  resetDisplayContent: ResetDisplayContent_default
};
var Methods_default25 = methods23;

// node_modules/phaser3-rex-plugins/templates/ui/label/Base.js
var LabelBase = class extends Sizer_default {
  /*
  Elements in childrenMap: 
  
  - background
  - icon, iconMask
  - text, 
  - action, actionMask
  */
  // Access text game object
  get text() {
    var textObject = this.childrenMap.text;
    if (!textObject) {
      return "";
    }
    return textObject.text;
  }
  set text(value) {
    var textObject = this.childrenMap.text;
    if (!textObject) {
      return;
    }
    textObject.setText(value);
  }
  setText(value) {
    this.text = value;
    return this;
  }
  // Access icon game object
  setIconTexture(key2, frame) {
    var imageObject = this.childrenMap.icon;
    if (!imageObject || !imageObject.setTexture) {
      return this;
    }
    imageObject.setTexture(key2, frame);
    if (this.iconWidth !== void 0 && this.iconHeight !== void 0) {
      SetDisplaySize_default(imageObject, this.iconWidth, this.iconHeight);
      this.resetChildScaleState(imageObject);
    }
    return this;
  }
  setTexture(key2, frame) {
    this.setIconTexture(key2, frame);
    return this;
  }
  setIconSize(width, height) {
    if (height === void 0) {
      height = width;
    }
    this.iconWidth = width;
    this.iconHeight = height;
    return this;
  }
  get texture() {
    var imageObject = this.childrenMap.icon;
    if (!imageObject) {
      return void 0;
    }
    return imageObject.texture;
  }
  get frame() {
    var imageObject = this.childrenMap.icon;
    if (!imageObject) {
      return void 0;
    }
    return imageObject.frame;
  }
  setActionTexture(key2, frame) {
    var imageObject = this.childrenMap.action;
    if (!imageObject || !imageObject.setTexture) {
      return this;
    }
    imageObject.setTexture(key2, frame);
    if (this.actionWidth !== void 0 && this.actionHeight !== void 0) {
      SetDisplaySize_default(imageObject, this.actionWidth, this.actionHeight);
      this.resetChildScaleState(imageObject);
    }
    return this;
  }
  get actionTexture() {
    var imageObject = this.childrenMap.action;
    if (!imageObject) {
      return void 0;
    }
    return imageObject.texture;
  }
  get actionFrame() {
    var imageObject = this.childrenMap.action;
    if (!imageObject) {
      return void 0;
    }
    return imageObject.frame;
  }
  setActionSize(width, height) {
    if (height === void 0) {
      height = width;
    }
    this.actionWidth = width;
    this.actionHeight = height;
    return this;
  }
  preLayout() {
    var icon = this.childrenMap.icon;
    if (icon && this.iconWidth !== void 0 && this.iconHeight !== void 0) {
      SetDisplaySize_default(icon, this.iconWidth, this.iconHeight);
    }
    var action = this.childrenMap.action;
    if (action && this.actionWidth !== void 0 && this.actionHeight !== void 0) {
      SetDisplaySize_default(action, this.actionWidth, this.actionHeight);
    }
    super.preLayout();
  }
  postLayout(parent, newWidth, newHeight) {
    var iconMask = this.childrenMap.iconMask;
    if (iconMask) {
      iconMask.setPosition();
      this.resetChildPositionState(iconMask);
    }
    var actionMask = this.childrenMap.actionMask;
    if (actionMask) {
      actionMask.setPosition();
      this.resetChildPositionState(actionMask);
    }
    super.postLayout(parent, newWidth, newHeight);
    return this;
  }
  resize(width, height) {
    super.resize(width, height);
    var iconMask = this.childrenMap.iconMask;
    if (iconMask) {
      iconMask.resize();
    }
    var actionMask = this.childrenMap.actionMask;
    if (actionMask) {
      actionMask.resize();
    }
    return this;
  }
};
Object.assign(
  LabelBase.prototype,
  Methods_default25
);
var Base_default5 = LabelBase;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/mask/AddChildMask.js
var AddChildMask = function(maskTarget, sizeTarget, shape, padding) {
  var maskGameObject = new DefaultMaskGraphics_default(sizeTarget, shape, padding);
  if (maskTarget && !maskTarget.isRexSizer) {
    var mask = maskGameObject.createGeometryMask();
    maskTarget.setMask(mask);
    this.once("destroy", function() {
      maskTarget.setMask();
      mask.destroy();
    });
  }
  this.pin(maskGameObject);
  return maskGameObject;
};
var AddChildMask_default = AddChildMask;

// node_modules/phaser3-rex-plugins/plugins/utils/text/IsTextGameObject.js
var TextClass = Phaser.GameObjects.Text;
var IsTextGameObject = function(gameObject2) {
  return gameObject2 instanceof TextClass;
};
var IsTextGameObject_default = IsTextGameObject;

// node_modules/phaser3-rex-plugins/plugins/utils/bitmaptext/IsBitmapTextGameObject.js
var BitmapTextClass = Phaser.GameObjects.BitmapText;
var IsBitmapTextGameObject = function(gameObject2) {
  return gameObject2 instanceof BitmapTextClass;
};
var IsBitmapTextGameObject_default = IsBitmapTextGameObject;

// node_modules/phaser3-rex-plugins/plugins/utils/text/GetTextObjectType.js
var TextType = 0;
var TagTextType = 1;
var BitmapTextType = 2;
var GetTextObjectType = function(textObject) {
  var textObjectType;
  if (IsBitmapTextGameObject_default(textObject)) {
    textObjectType = BitmapTextType;
  } else if (IsTextGameObject_default(textObject)) {
    textObjectType = TextType;
  } else {
    textObjectType = TagTextType;
  }
  return textObjectType;
};
var GetTextObjectType_default = GetTextObjectType;

// node_modules/phaser3-rex-plugins/plugins/utils/text/TextWrapByCharCallback.js
var TextWrapByCharCallback = function(text, textObject) {
  var output = [];
  var textLines = text.split("\n");
  var style = textObject.style;
  var wrapWidth = style.wordWrapWidth;
  var wrapMode = style.hasOwnProperty("wrapMode") ? style.wrapMode : 3;
  var context = textObject.context;
  for (var i = 0, cnt = textLines.length; i < cnt; i++) {
    WrapLine(context, textLines[i], wrapWidth, wrapMode, output);
  }
  return output;
};
var GetTokenArray = function(text, wrapMode) {
  var tokenArray;
  if (wrapMode === 2) {
    tokenArray = text.split("");
  } else {
    tokenArray = [];
    var words = text.split(" "), word;
    for (var i = 0, wordCount = words.length; i < wordCount; i++) {
      word = words[i];
      if (i < wordCount - 1) {
        if (IsASCIIString_default(word)) {
          tokenArray.push(word + " ");
        } else {
          tokenArray.push(...word.split(""));
          tokenArray.push(" ");
        }
      } else {
        if (word !== "") {
          if (IsASCIIString_default(word)) {
            tokenArray.push(word);
          } else {
            tokenArray.push(...word.split(""));
          }
        }
      }
    }
  }
  return tokenArray;
};
var WrapLine = function(context, text, wrapWidth, wrapMode, output) {
  if (text.length <= 100) {
    var textWidth = context.measureText(text).width;
    if (textWidth <= wrapWidth) {
      output.push(text);
      return output;
    }
  }
  var tokenArray = GetTokenArray(text, wrapMode);
  var token, tokenWidth;
  var line = [], remainderLineWidth = wrapWidth;
  for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
    token = tokenArray[j];
    tokenWidth = context.measureText(token).width;
    remainderLineWidth -= tokenWidth;
    if (remainderLineWidth < 0) {
      output.push(line.join(""));
      line.length = 0;
      remainderLineWidth = wrapWidth - tokenWidth;
    }
    line.push(token);
  }
  if (line.length > 0) {
    output.push(line.join(""));
  }
  return output;
};
var TextWrapByCharCallback_default = TextWrapByCharCallback;

// node_modules/phaser3-rex-plugins/plugins/utils/text/SetWrapMode.js
var SetWrapMode = function(textObject, mode) {
  var textObjectType = GetTextObjectType_default(textObject);
  switch (textObjectType) {
    case TextType:
      if (typeof mode === "string") {
        mode = WrapModes_default[mode] || 0;
      }
      textObject.style.wrapMode = mode;
      switch (mode) {
        case 2:
        case 3:
          textObject.style.wordWrapCallback = TextWrapByCharCallback_default;
          break;
        case 1:
        default:
          textObject.style.wordWrapCallback = null;
          break;
      }
      break;
    case TagTextType:
      if (typeof mode === "string") {
        mode = WrapModes_default[mode] || 0;
      }
      textObject.style.wrapMode = mode;
      break;
    case BitmapTextType:
      break;
  }
};
var SetWrapMode_default = SetWrapMode;

// node_modules/phaser3-rex-plugins/templates/ui/utils/wrapexpandtext/TextRunWidthWrap.js
var TextRunWidthWrap = function(textObject) {
  var RunWidthWrap5 = function(width) {
    var padding = textObject.padding;
    var wrapWidth = width - (padding.left + padding.right) * textObject.scaleX;
    var style = textObject.style;
    if (IsTextGameObject_default(textObject)) {
      style.wordWrapWidth = wrapWidth;
      style.maxLines = 0;
    } else {
      if (style.wrapMode === 0) {
        style.wrapMode = 1;
      }
      style.wrapWidth = wrapWidth;
      style.maxLines = 0;
    }
    style.fixedWidth = width;
    style.fixedHeight = 0;
    textObject.updateText();
    textObject.minHeight = textObject.height;
    return textObject;
  };
  return RunWidthWrap5;
};
var TextRunWidthWrap_default = TextRunWidthWrap;

// node_modules/phaser3-rex-plugins/templates/ui/utils/wrapexpandtext/DynamicTextRunWidthWrap.js
var DynamicTextRunWidthWrap = function(textObject) {
  var RunWidthWrap5 = function(width) {
    textObject.setFixedSize(width, 0).runWordWrap();
    textObject.minHeight = textObject.height;
    return textObject;
  };
  return RunWidthWrap5;
};
var DynamicTextRunWidthWrap_default = DynamicTextRunWidthWrap;

// node_modules/phaser3-rex-plugins/templates/ui/utils/wrapexpandtext/BitmapTextRunWidthWrap.js
var BitmapTextRunWidthWrap = function(textObject) {
  var RunWidthWrap5 = function(width) {
    textObject.setMaxWidth(width);
    textObject.minHeight = textObject.height;
    return textObject;
  };
  return RunWidthWrap5;
};
var BitmapTextRunWidthWrap_default = BitmapTextRunWidthWrap;

// node_modules/phaser3-rex-plugins/templates/ui/utils/wrapexpandtext/WrapExpandText.js
var IsDynamicTextGameObject = function(gameObject2) {
  return gameObject2 instanceof DynamicText_default2;
};
var WrapExpandText = function(textObject, minWidth) {
  if (minWidth === void 0) {
    minWidth = 0;
  }
  textObject._minWidth = minWidth;
  textObject.runWidthWrap = IsDynamicTextGameObject(textObject) ? DynamicTextRunWidthWrap_default(textObject) : IsBitmapTextGameObject_default(textObject) ? BitmapTextRunWidthWrap_default(textObject) : TextRunWidthWrap_default(textObject);
  return textObject;
};
var WrapExpandText_default = WrapExpandText;

// node_modules/phaser3-rex-plugins/plugins/utils/text/fontsizefit/FontSizeFit.js
var MaxTestCount = 65535;
var FontSizeFit = function(textObject, width, height) {
  if (width == null) {
    return textObject;
  }
  if (width === 0) {
    SetTextWidth(textObject, 0, height);
    return textObject;
  }
  var textLength = textObject.text.length;
  if (textLength === 0) {
    SetTextWidth(textObject, width, height);
    return textObject;
  }
  var fontSize = Math.floor(width * 1.5 / textLength);
  if (height !== void 0) {
    if (fontSize > height) {
      fontSize = Math.floor(height);
    }
  }
  var sizeData = {};
  var testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
  for (var i = 0; i <= MaxTestCount; i++) {
    if (testResult === 0) {
      break;
    } else {
      fontSize += testResult;
      if (fontSize < 0) {
        fontSize = 0;
        break;
      }
    }
    testResult = TestFontSize(textObject, fontSize, width, height, sizeData);
  }
  if (i === MaxTestCount) {
    console.warn(`FontSizeFit: Test count exceeds ${MaxTestCount}`);
  }
  textObject.setFontSize(fontSize);
  SetTextWidth(textObject, width, height);
  return textObject;
};
var GetTextSize = function(textObject, fontSize, sizeData) {
  if (sizeData[fontSize] === void 0) {
    textObject.setFontSize(fontSize);
    sizeData[fontSize] = {
      width: textObject.width,
      height: textObject.height
    };
  }
  return sizeData[fontSize];
};
var TestFontSize = function(textObject, fontSize, width, height, sizeData) {
  var textSize = GetTextSize(textObject, fontSize, sizeData);
  var textSize1 = GetTextSize(textObject, fontSize + 1, sizeData);
  var deltaHeight;
  if (height !== void 0) {
    if (textSize.height <= height && textSize1.height > height) {
      deltaHeight = 0;
    } else if (textSize.height > height) {
      return -1;
    } else {
      deltaHeight = Math.floor(height - textSize.height);
    }
  }
  var deltaWidth;
  if (textSize.width <= width && textSize1.width > width) {
    return 0;
  } else if (textSize.width > width) {
    return -1;
  } else {
    var deltaWidth = Math.floor(width - textSize.width);
    if (deltaHeight === void 0) {
      return deltaWidth;
    } else {
      return Math.min(deltaWidth, deltaHeight);
    }
  }
};
var SetTextWidth = function(textObject, width, height) {
  var style = textObject.style;
  if (!style) {
    return;
  }
  style.fixedWidth = width;
  style.parent.width = width;
  if (height !== void 0) {
    style.fixedHeight = height;
    style.parent.height = height;
  }
  style.update(false);
};
var FontSizeFit_default = FontSizeFit;

// node_modules/phaser3-rex-plugins/templates/ui/utils/fontsizeexpandtext/FontSizeExpandText.js
var GetValue121 = Phaser.Utils.Objects.GetValue;
var FontSizeExpandText = function(textObject, config) {
  if (typeof config === "number") {
    config = {
      minWidth: config
    };
  }
  var minWidth = GetValue121(config, "minWidth", 0);
  var minHeight = GetValue121(config, "minHeight", 0);
  var fitHeight = GetValue121(config, "fitHeight", false);
  textObject._minWidth = minWidth;
  textObject._minHeight = minHeight;
  if (!fitHeight) {
    textObject.runWidthWrap = function(width) {
      if (textObject.setFixedSize) {
        textObject.setFixedSize(0, 0);
      }
      FontSizeFit_default(textObject, width, void 0);
      return textObject;
    };
    textObject.resize = function(width, height) {
      if (textObject.width === width && textObject.height === height) {
        return textObject;
      }
      textObject.setFixedSize(width, height);
      return textObject;
    };
  } else {
    textObject.runWidthWrap = function(width) {
      if (textObject.setFixedSize) {
        textObject.setFixedSize(0, 0);
      }
      textObject.setFontSize(1);
      return textObject;
    };
    textObject.resize = function(width, height) {
      FontSizeFit_default(textObject, width, height);
      return textObject;
    };
  }
  return textObject;
};
var FontSizeExpandText_default = FontSizeExpandText;

// node_modules/phaser3-rex-plugins/templates/ui/label/Label.js
var GetValue122 = Phaser.Utils.Objects.GetValue;
var Label = class extends Base_default5 {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexLabel";
    var background = GetValue122(config, "background", void 0);
    var icon = GetValue122(config, "icon", void 0);
    var iconMask = GetValue122(config, "iconMask", void 0);
    var text = GetValue122(config, "text", void 0);
    var action = GetValue122(config, "action", void 0);
    var actionMask = GetValue122(config, "actionMask", void 0);
    var align = GetValue122(config, "align", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (icon) {
      var padding;
      if (this.orientation === 0) {
        if (text || action) {
          padding = {
            right: GetValue122(config, "space.icon", 0),
            top: GetValue122(config, "space.iconTop", 0),
            bottom: GetValue122(config, "space.iconBottom", 0),
            left: GetValue122(config, "space.iconLeft", 0)
          };
        }
      } else {
        if (text || action) {
          padding = {
            bottom: GetValue122(config, "space.icon", 0),
            left: GetValue122(config, "space.iconLeft", 0),
            right: GetValue122(config, "space.iconRight", 0),
            top: GetValue122(config, "space.iconTop", 0)
          };
        }
      }
      var fitRatio = GetValue122(config, "squareFitIcon", false) ? 1 : 0;
      this.add(
        icon,
        { proportion: 0, padding, fitRatio }
      );
      if (iconMask) {
        iconMask = AddChildMask_default.call(this, icon, icon, 1);
      }
      if (!fitRatio) {
        var iconSize = GetValue122(config, "iconSize", void 0);
        this.setIconSize(
          GetValue122(config, "iconWidth", iconSize),
          GetValue122(config, "iconHeight", iconSize)
        );
      }
    }
    if (text) {
      var wrapText = GetValue122(config, "wrapText", false);
      var adjustTextFontSize = GetValue122(config, "adjustTextFontSize", false);
      if (wrapText) {
        if (wrapText === true) {
          wrapText = "word";
        }
        SetWrapMode_default(text, wrapText);
        config.expandTextWidth = true;
        WrapExpandText_default(text);
      } else if (adjustTextFontSize) {
        config.expandTextWidth = true;
        config.expandTextHeight = true;
        FontSizeExpandText_default(text, { fitHeight: true });
      }
      var textSpace = GetValue122(config, "space.text", 0);
      var expandTextWidth = GetValue122(config, "expandTextWidth", false);
      var expandTextHeight = GetValue122(config, "expandTextHeight", false);
      var proportion, padding, expand;
      if (this.orientation === 0) {
        proportion = expandTextWidth ? 1 : 0;
        if (action) {
          padding = { right: textSpace };
        }
        expand = expandTextHeight;
      } else {
        proportion = expandTextHeight ? 1 : 0;
        if (action) {
          padding = { bottom: textSpace };
        }
        expand = expandTextWidth;
      }
      this.add(
        text,
        { proportion, expand, padding }
      );
    }
    if (action) {
      var padding;
      if (this.orientation === 0) {
        padding = {
          top: GetValue122(config, "space.actionTop", 0),
          bottom: GetValue122(config, "space.actionBottom", 0),
          right: GetValue122(config, "space.actionRight", 0)
        };
      } else {
        padding = {
          left: GetValue122(config, "space.actionLeft", 0),
          right: GetValue122(config, "space.actionRight", 0),
          bottom: GetValue122(config, "space.actionBottom", 0)
        };
      }
      var fitRatio = GetValue122(config, "squareFitAction", false) ? 1 : 0;
      this.add(
        action,
        { proportion: 0, padding, fitRatio }
      );
      if (actionMask) {
        actionMask = AddChildMask_default.call(this, action, action, 1);
      }
      if (!fitRatio) {
        var actionSize = GetValue122(config, "actionSize");
        this.setActionSize(
          GetValue122(config, "actionWidth", actionSize),
          GetValue122(config, "actionHeight", actionSize)
        );
      }
    }
    this.setChildrenAlignMode(align);
    this.addChildrenMap("background", background);
    this.addChildrenMap("icon", icon);
    this.addChildrenMap("iconMask", iconMask);
    this.addChildrenMap("text", text);
    this.addChildrenMap("action", action);
    this.addChildrenMap("actionMask", actionMask);
  }
};
var Label_default = Label;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/CreateImageBox.js
var GetValue123 = Phaser.Utils.Objects.GetValue;
var CreateCanvas = function(scene, config) {
  var canvasConfig = GetValue123(config, "canvas");
  var width = GetValue123(canvasConfig, "width", 128);
  var height = GetValue123(canvasConfig, "height", 128);
  var canvas = new Canvas_default3(scene, 0, 0, width, height);
  scene.add.existing(canvas);
  var key2 = GetValue123(canvasConfig, "key");
  var frame = GetValue123(canvasConfig, "frame");
  var fillColor = GetValue123(canvasConfig, "fill");
  if (fillColor !== void 0) {
    canvas.fill(fillColor);
  } else if (key2 !== void 0) {
    canvas.loadTexture(key2, frame);
  }
  canvas.setTexture = canvas.loadTexture.bind(canvas);
  return canvas;
};
var CreateImageBox = function(scene, config) {
  var icon = new ImageBox_default2(scene, {
    scaleUp: GetValue123(config, "scaleUpIcon", false),
    background: GetValue123(config, "iconBackground"),
    image: CreateCanvas(scene, config)
  });
  scene.add.existing(icon);
  return icon;
};
var CreateImageBox_default = CreateImageBox;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/GetClickTarget.js
var GetValue124 = Phaser.Utils.Objects.GetValue;
var GetClickTarget = function(parent, config) {
  var clickTarget = GetValue124(config, "clickTarget", this);
  if (typeof clickTarget === "string") {
    clickTarget = parent.getElement(clickTarget);
  }
  return clickTarget;
};
var GetClickTarget_default = GetClickTarget;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/CreateClickBehavior.js
var GetValue125 = Phaser.Utils.Objects.GetValue;
var CreateClickBehavior = function(parent, config) {
  var clickTarget = GetClickTarget_default(parent, config);
  if (!clickTarget) {
    return void 0;
  }
  var clickConfig = GetValue125(config, "click");
  var clickBehavior = new Click_default(clickTarget, clickConfig);
  clickBehavior.on("click", parent.open, parent);
  return clickBehavior;
};
var CreateClickBehavior_default = CreateClickBehavior;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/FileChooserConfig.js
var Config = {
  accept: "image/*",
  multiple: false
};
var FileChooserConfig_default = Config;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/OnSelectFile.js
var OnSelectFile = function(parent, files) {
  if (files.length === 0) {
    return;
  }
  var imageBox = parent.childrenMap.icon;
  var canvas = imageBox.image;
  var selectedFile = files[0];
  return canvas.loadFromFilePromise(selectedFile).then(function() {
    imageBox.scaleImage();
    parent.emit("select", selectedFile, parent);
    return Promise.resolve(selectedFile);
  });
};
var OnSelectFile_default = OnSelectFile;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/CreateFileChooser.js
var CreateFileChooser = function(parent, config) {
  var scene = parent.scene;
  var fileChooser = new FileChooser_default(scene, FileChooserConfig_default);
  scene.add.existing(fileChooser);
  parent.pin(fileChooser);
  fileChooser.on("change", function() {
    OnSelectFile_default(parent, fileChooser.files);
  });
  return fileChooser;
};
var CreateFileChooser_default = CreateFileChooser;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/OpenMethods.js
var OpenMethods_default2 = {
  async openPromise() {
    var self = this;
    return Open_default2(this.scene.game, FileChooserConfig_default).then(function(result) {
      return OnSelectFile_default(self, result.files);
    });
  },
  open() {
    this.openPromise();
    return this;
  },
  setClickOpenEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    if (this.clickBehavior) {
      this.clickBehavior.setEnable(enable);
    }
    if (this.fileChooser) {
      this.fileChooser.setOpenEnable(enable);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/GetFileName.js
var GetFileName = function(file) {
  if (!file) {
    return null;
  }
  var name2 = file.name;
  return name2.substr(0, name2.lastIndexOf("."));
};
var GetFileName_default = GetFileName;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/SaveTexture.js
var SaveTexture = function(key2) {
  var canvas = this.childrenMap.canvas;
  canvas.generateTexture(key2);
  return this;
};
var SaveTexture_default = SaveTexture;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/methods/Methods.js
var methods24 = {
  getFileName: GetFileName_default,
  saveTexture: SaveTexture_default
};
Object.assign(
  methods24,
  OpenMethods_default2
);
var Methods_default26 = methods24;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/ImageInputLabel.js
var GetValue126 = Phaser.Utils.Objects.GetValue;
var ImageInputLabel = class extends Label_default {
  constructor(scene, config) {
    var icon = CreateImageBox_default(scene, config);
    config.icon = icon;
    super(scene, config);
    this.type = "rexImageFileInputLabel";
    var iconWidth = this.iconWidth, iconHeight = this.iconWidth;
    if (iconWidth !== void 0 && iconHeight !== void 0) {
      icon.resize(iconWidth, iconHeight);
    }
    this.clickTarget = GetClickTarget_default(this, config);
    if (this.clickTarget) {
      if (!GetValue126(config, "domButton", true)) {
        this.clickBehavior = CreateClickBehavior_default(this, config);
      } else {
        this.fileChooser = CreateFileChooser_default(this, config);
      }
    }
    this.addChildrenMap("canvas", icon.image);
    this.addChildrenMap("iconBackground", icon.background);
    this.addChildrenMap("fileChooser", this.fileChooser);
  }
  postLayout(parent, newWidth, newHeight) {
    if (this.fileChooser) {
      this.fileChooser.syncTo(this.clickTarget);
      this.resetChildState(this.fileChooser);
    }
    super.postLayout(parent, newWidth, newHeight);
  }
};
Object.assign(
  ImageInputLabel.prototype,
  Methods_default26
);
var ImageInputLabel_default = ImageInputLabel;

// node_modules/phaser3-rex-plugins/templates/ui/imageinputlabel/Factory.js
ObjectFactory_default.register("imageInputLabel", function(config) {
  var gameObject2 = new ImageInputLabel_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ImageInputLabel", ImageInputLabel_default);

// node_modules/phaser3-rex-plugins/plugins/effectproperties.js
var effectproperties_default = AddEffectProperties_default;

// node_modules/phaser3-rex-plugins/templates/ui/statesimage/Style.js
var Style = class extends ComponentBase_default {
  constructor(gameObject2, style) {
    super(gameObject2);
    return new Proxy(this, this);
  }
  get(target, prop) {
    if (HasProperty_default(target, prop)) {
      return target[prop];
    }
    var gameObject2 = target.parent;
    if (HasProperty_default(gameObject2, prop)) {
      return gameObject2[prop];
    }
  }
  set(target, prop, value) {
    if (HasProperty_default(target, prop)) {
      target[prop] = value;
    } else if (HasProperty_default(target.parent, prop)) {
      target.parent[prop] = value;
    }
    return true;
  }
  get key() {
    return this.parent.texture.key;
  }
  set key(value) {
    this.parent.setTexture(value, this.frame);
  }
  get frame() {
    return this.parent.frame.name;
  }
  set frame(value) {
    this.parent.setFrame(value);
  }
  get scale() {
    return this.parent.scaleX;
  }
  set scale(value) {
    this.parent.setScale(value);
  }
};
var Style_default = Style;

// node_modules/phaser3-rex-plugins/templates/ui/utils/stylemanager/StyleManager.js
var GetValue127 = Phaser.Utils.Objects.GetValue;
var StyleManager = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.style = GetValue127(config, "style", this);
    var propertiesMap = GetValue127(config, "propertiesMap");
    this.activeStyle = ExtractStyle(config, "active", propertiesMap);
    this.hoverStyle = ExtractStyle(config, "hover", propertiesMap);
    this.disableStyle = ExtractStyle(config, "disable", propertiesMap);
    this.onModifyStyle = GetValue127(config, "onModifyStyle");
  }
  getStyle(keys) {
    return GetPartialData_default(this.style, keys);
  }
  modifyStyle(style) {
    for (var key2 in style) {
      this.style[key2] = style[key2];
    }
    if (this.onModifyStyle) {
      this.onModifyStyle(this.parent, style);
    }
    return this;
  }
  applyStyle(newStyle) {
    if (!newStyle) {
      return void 0;
    }
    var currentStyle = this.getStyle(newStyle);
    if (!IsKeyValueEqual_default(currentStyle, newStyle)) {
      this.modifyStyle(newStyle);
      return currentStyle;
    } else {
      return void 0;
    }
  }
  setActiveState(enable) {
    SetStateEnableMethod.call(this, "active", enable);
    return this;
  }
  setHoverState(enable) {
    SetStateEnableMethod.call(this, "hover", enable);
    return this;
  }
  setDisableState(enable) {
    SetStateEnableMethod.call(this, "disable", enable);
    return this;
  }
};
var ExtractStyle = function(config, prefix, propertiesMap) {
  var result = ExtractByPrefix_default(config, prefix);
  if (propertiesMap) {
    for (var name2 in result) {
      if (propertiesMap.hasOwnProperty(name2)) {
        result[propertiesMap[name2]] = result[name2];
        delete result[name2];
      }
    }
  }
  return result;
};
var SetStateEnableMethod = function(stateName, enable) {
  if (enable === void 0) {
    enable = true;
  }
  var stateVarName = `${stateName}State`;
  var styleVarName = `${stateName}Style`;
  var styleSaveVarName = `${stateName}StyleSave`;
  if (this[stateVarName] === enable) {
    return;
  }
  this[stateVarName] = enable;
  if (enable) {
    this[styleSaveVarName] = this.applyStyle(this[styleVarName]);
  } else {
    this.applyStyle(this[styleSaveVarName]);
    this[styleSaveVarName] = void 0;
  }
};
var StyleManager_default = StyleManager;

// node_modules/phaser3-rex-plugins/templates/ui/utils/stylemanager/HelperMethods.js
var HelperMethods_default = {
  addStyleManager(config) {
    this.styleManager = new StyleManager_default(this, config);
    return this;
  },
  setActiveState(enable) {
    this.styleManager.setActiveState(enable);
    return this;
  },
  setHoverState(enable) {
    this.styleManager.setHoverState(enable);
    return this;
  },
  setDisableState(enable) {
    this.styleManager.setDisableState(enable);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/statesimage/StatesImage.js
var PhaserImage = Phaser.GameObjects.Image;
var GetValue128 = Phaser.Utils.Objects.GetValue;
var StatesImage = class extends PhaserImage {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var x = GetValue128(config, "x", 0);
    var y = GetValue128(config, "y", 0);
    var key2 = GetValue128(config, "key", "");
    var frame = GetValue128(config, "frame", void 0);
    super(scene, x, y, key2, frame);
    this.type = "rexStatesImage";
    var effectConfig = GetValue128(config, "effects", true);
    if (effectConfig) {
      effectproperties_default(this, effectConfig);
    }
    this.style = new Style_default(this, config);
    config.style = this.style;
    this.addStyleManager(config);
    delete config.style;
  }
};
Object.assign(
  StatesImage.prototype,
  HelperMethods_default
);
var StatesImage_default = StatesImage;

// node_modules/phaser3-rex-plugins/templates/ui/statesimage/Factory.js
ObjectFactory_default.register("statesImage", function(config) {
  var gameObject2 = new StatesImage_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.StatesImage", StatesImage_default);

// node_modules/phaser3-rex-plugins/templates/ui/statesroundrectangle/StatesRoundRectangle.js
var StatesRoundRectangle = class extends RoundRectangle_default3 {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexStatesRoundRectangleShape";
    config.style = this;
    config.propertiesMap = PropertiesMap;
    this.addStyleManager(config);
    delete config.style;
    delete config.propertiesMap;
  }
};
var PropertiesMap = {
  color: "fillColor",
  alpha: "fillAlpha",
  // strokeColor: 'strokeColor',
  // strokeAlpha: 'strokeAlpha',
  strokeWidth: "lineWidth"
};
Object.assign(
  StatesRoundRectangle.prototype,
  HelperMethods_default
);
var StatesRoundRectangle_default = StatesRoundRectangle;

// node_modules/phaser3-rex-plugins/templates/ui/statesroundrectangle/Factory.js
ObjectFactory_default.register("statesRoundRectangle", function(config) {
  var gameObject2 = new StatesRoundRectangle_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.StatesRoundRectangle", StatesRoundRectangle_default);

// node_modules/phaser3-rex-plugins/templates/ui/statesnineslice/Style.js
var Style2 = class extends ComponentBase_default {
  constructor(gameObject2, style) {
    super(gameObject2);
    return new Proxy(this, this);
  }
  get(target, prop) {
    if (HasProperty_default(target, prop)) {
      return target[prop];
    }
    var gameObject2 = target.parent;
    if (HasProperty_default(gameObject2, prop)) {
      return gameObject2[prop];
    }
  }
  set(target, prop, value) {
    if (HasProperty_default(target, prop)) {
      target[prop] = value;
    } else if (HasProperty_default(target.parent, prop)) {
      target.parent[prop] = value;
    }
    return true;
  }
  get key() {
    return this.parent.texture.key;
  }
  set key(value) {
    if (this.key === value) {
      return;
    }
    this.parent.setTexture(value, this.frame);
  }
  get frame() {
    return this.parent.frame.name;
  }
  set frame(value) {
    if (this.frame === value) {
      return;
    }
    this.parent.setFrame(value);
  }
};
var Style_default2 = Style2;

// node_modules/phaser3-rex-plugins/templates/ui/statesnineslice/StatesNineSlice.js
var PhaserNineSlice = Phaser.GameObjects.NineSlice;
var GetValue129 = Phaser.Utils.Objects.GetValue;
var StatesNineSlice = class extends PhaserNineSlice {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var x = GetValue129(config, "x", 0);
    var y = GetValue129(config, "y", 0);
    var key2 = GetValue129(config, "key", null);
    var frame = GetValue129(config, "frame", null);
    var width = GetValue129(config, "width", 0);
    var height = GetValue129(config, "height", 0);
    var leftWidth = GetValue129(config, "leftWidth", 0);
    var rightWidth = GetValue129(config, "rightWidth", 0);
    var topHeight = GetValue129(config, "topHeight", 0);
    var bottomHeight = GetValue129(config, "bottomHeight", 0);
    super(scene, x, y, key2, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight);
    this.type = "rexStatesNineSlice";
    var effectConfig = GetValue129(config, "effects", true);
    if (effectConfig) {
      effectproperties_default(this, effectConfig);
    }
    this.style = new Style_default2(this, config);
    config.style = this.style;
    this.addStyleManager(config);
    delete config.style;
  }
};
Object.assign(
  StatesNineSlice.prototype,
  HelperMethods_default
);
var StatesNineSlice_default = StatesNineSlice;

// node_modules/phaser3-rex-plugins/templates/ui/statesnineslice/Factory.js
ObjectFactory_default.register("statesNineSlice", function(config) {
  var gameObject2 = new StatesNineSlice_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.StatesNineSlice", StatesNineSlice_default);

// node_modules/phaser3-rex-plugins/templates/ui/statesninepatch/Style.js
var Style3 = class extends ComponentBase_default {
  constructor(gameObject2, style) {
    super(gameObject2);
    return new Proxy(this, this);
  }
  get(target, prop) {
    if (HasProperty_default(target, prop)) {
      return target[prop];
    }
    var gameObject2 = target.parent;
    if (HasProperty_default(gameObject2, prop)) {
      return gameObject2[prop];
    }
  }
  set(target, prop, value) {
    if (HasProperty_default(target, prop)) {
      target[prop] = value;
    } else if (HasProperty_default(target.parent, prop)) {
      target.parent[prop] = value;
    }
    return true;
  }
  get key() {
    return this.parent.textureKey;
  }
  set key(value) {
    if (this.key === value) {
      return;
    }
    this.parent.setBaseTexture(value, this.baseFrameName);
  }
  get frame() {
    return this.parent.baseFrameName;
  }
  set frame(value) {
    if (this.frame === value) {
      return;
    }
    this.parent.setBaseTexture(this.parent.textureKey, value);
  }
};
var Style_default3 = Style3;

// node_modules/phaser3-rex-plugins/templates/ui/statesninepatch/StatesNinePatch.js
var GetValue130 = Phaser.Utils.Objects.GetValue;
var StatesNinePatch = class extends NinePatch_default3 {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexStatesNinePatch";
    var effectConfig = GetValue130(config, "effects", true);
    if (effectConfig) {
      effectproperties_default(this, effectConfig);
    }
    this.style = new Style_default3(this, config);
    config.style = this.style;
    this.addStyleManager(config);
    delete config.style;
  }
};
Object.assign(
  StatesNinePatch.prototype,
  HelperMethods_default
);
var StatesNinePatch_default = StatesNinePatch;

// node_modules/phaser3-rex-plugins/templates/ui/statesninepatch/Factory.js
ObjectFactory_default.register("statesNinePatch", function(config) {
  var gameObject2 = new StatesNinePatch_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.StatesNinePatch", StatesNinePatch_default);

// node_modules/phaser3-rex-plugins/templates/ui/statestext/StatesText.js
var PhaserText = Phaser.GameObjects.Text;
var GetValue131 = Phaser.Utils.Objects.GetValue;
var StatesText = class extends PhaserText {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var x = GetValue131(config, "x", 0);
    var y = GetValue131(config, "y", 0);
    var text = GetValue131(config, "text", "");
    super(scene, x, y, text, config);
    this.type = "rexStatesText";
    config.style = this.style;
    config.onModifyStyle = function(gameObject2, style) {
      var recalculateMetrics = style.hasOwnProperty("fontStyle") || style.hasOwnProperty("fontSize") || style.hasOwnProperty("fontFamily");
      gameObject2.style.update(recalculateMetrics);
    };
    this.addStyleManager(config);
    delete config.style;
  }
};
Object.assign(
  StatesText.prototype,
  HelperMethods_default
);
var StatesText_default = StatesText;

// node_modules/phaser3-rex-plugins/templates/ui/statestext/Factory.js
ObjectFactory_default.register("statesText", function(config) {
  var gameObject2 = new StatesText_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.StatesText", StatesText_default);

// node_modules/phaser3-rex-plugins/templates/ui/statesbitmaptext/Style.js
var Style4 = class extends ComponentBase_default {
  constructor(gameObject2, style) {
    super(gameObject2);
    return new Proxy(this, this);
  }
  get(target, prop) {
    if (HasProperty_default(target, prop)) {
      return target[prop];
    }
    var gameObject2 = target.parent;
    if (HasProperty_default(gameObject2, prop)) {
      return gameObject2[prop];
    }
  }
  set(target, prop, value) {
    if (HasProperty_default(target, prop)) {
      target[prop] = value;
    } else if (HasProperty_default(target.parent, prop)) {
      target.parent[prop] = value;
    }
    return true;
  }
  get key() {
    return this.parent.texture.key;
  }
  set key(value) {
    this.parent.setTexture(value, this.frame);
  }
  get fontSize() {
    return this.parent.fontSize;
  }
  set fontSize(value) {
    this.parent.setFontSize(value);
  }
  get tint() {
    return this.parent.tintTopLeft;
  }
  set tint(value) {
    this.parent.setTint(value);
  }
  get letterSpacing() {
    return this.parent.letterSpacing;
  }
  set letterSpacing(value) {
    this.parent.setLetterSpacing(value);
  }
  get lineSpacing() {
    return this.parent.lineSpacing;
  }
  set lineSpacing(value) {
    this.parent.setLineSpacing(value);
  }
};
var Style_default4 = Style4;

// node_modules/phaser3-rex-plugins/templates/ui/statesbitmaptext/StatesBitmapText.js
var PhaserBitmapText = Phaser.GameObjects.BitmapText;
var GetValue132 = Phaser.Utils.Objects.GetValue;
var StatesBitmapText = class extends PhaserBitmapText {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var x = GetValue132(config, "x", 0);
    var y = GetValue132(config, "y", 0);
    var font = GetValue132(config, "font", "");
    var size = GetValue132(config, "fontSize", false);
    var align = GetValue132(config, "align", 0);
    var tint = GetValue132(config, "tint");
    super(scene, x, y, font, "", size, align);
    this.type = "rexStatesBitmapText";
    if (tint !== void 0) {
      this.setTint(tint);
    }
    var effectConfig = GetValue132(config, "effects", true);
    if (effectConfig) {
      effectproperties_default(this, effectConfig);
    }
    this.style = new Style_default4(this, config);
    config.style = this.style;
    this.addStyleManager(config);
    delete config.style;
  }
};
Object.assign(
  StatesBitmapText.prototype,
  HelperMethods_default
);
var StatesBitmapText_default = StatesBitmapText;

// node_modules/phaser3-rex-plugins/templates/ui/statesbitmaptext/Factory.js
ObjectFactory_default.register("statesBitmapText", function(config) {
  var gameObject2 = new StatesBitmapText_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.StatesBitmapText", StatesBitmapText_default);

// node_modules/phaser3-rex-plugins/templates/ui/statesbarrectangle/StatesBarRectangle.js
var StatesBarRectangle = class extends LineProgress_default2 {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("value")) {
      config.value = 0;
    }
    if (!config.hasOwnProperty("hover.bar")) {
      config["hover.bar"] = true;
    }
    if (!config.hasOwnProperty("easeDuration")) {
      config.easeDuration = 200;
    }
    if (!config.hasOwnProperty("ease")) {
      config.ease = "Quad";
    }
    SetValue_default(config, "easeValue.duration", config.easeDuration);
    SetValue_default(config, "easeValue.ease", config.ease);
    super(scene, config);
    this.type = "rexStatesBarRectangleShape";
    this.barState = false;
    config.style = this;
    config.propertiesMap = PropertiesMap2;
    this.addStyleManager(config);
    delete config.style;
    delete config.propertiesMap;
  }
  get bar() {
    return this.barState;
  }
  set bar(value) {
    value = !!value;
    if (this.barState === value) {
      return;
    }
    this.barState = value;
    this.easeValueTo(this.barState ? 1 : 0);
  }
};
var PropertiesMap2 = {
  color: "trackColor",
  strokeColor: "trackStrokeColor",
  strokeWidth: "trackStrokeThickness"
  // barColor: 'barColor'
};
Object.assign(
  StatesBarRectangle.prototype,
  HelperMethods_default
);
var StatesBarRectangle_default = StatesBarRectangle;

// node_modules/phaser3-rex-plugins/templates/ui/statesbarrectangle/Factory.js
ObjectFactory_default.register("statesBarRectangle", function(config) {
  var gameObject2 = new StatesBarRectangle_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.StatesBarRectangle", StatesBarRectangle_default);

// node_modules/phaser3-rex-plugins/templates/ui/chart/SetChart.js
var SetChart = function(config) {
  if (!window.Chart) {
    var msg = `Can not find chartjs! Load chartjs in preload stage.
scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');`;
    console.error(msg);
    return this;
  }
  if (this.chart) {
    this.chart.destroy();
  }
  this.chart = new Chart(this.context, FillConfig(this, config));
  return this;
};
var FillConfig = function(canvas, config) {
  if (config === void 0) {
    config = {};
  }
  if (config.options === void 0) {
    config.options = {};
  }
  var options = config.options;
  options.responsive = false;
  options.maintainAspectRatio = false;
  if (!options.hasOwnProperty("devicePixelRatio")) {
    options.devicePixelRatio = 1;
  }
  var noAnimation = false;
  if (options.animation === void 0) {
    options.animation = {};
  } else if (options.animation === false) {
    noAnimation = true;
    options.animation = {};
  }
  var animationConfig = options.animation;
  if (noAnimation) {
    animationConfig.duration = 0;
  }
  var onProgress = animationConfig.onProgress;
  animationConfig.onProgress = function(animation) {
    if (onProgress) {
      onProgress(animation);
    }
    canvas.needRedraw();
  };
  var onComplete = animationConfig.onComplete;
  animationConfig.onComplete = function(animation) {
    if (onComplete) {
      onComplete(animation);
    }
    canvas.needRedraw();
  };
  return config;
};
var SetChart_default = SetChart;

// node_modules/phaser3-rex-plugins/templates/ui/chart/GetChartDataset.js
var GetChartDataset = function(datasetIndex) {
  if (this.chart === void 0) {
    return void 0;
  }
  if (typeof datasetIndex === "string") {
    var datasets = this.chart.data.datasets, dataset;
    for (var i = 0, cnt = datasets.length; i < cnt; i++) {
      dataset = datasets[i];
      if (dataset.label === datasetIndex) {
        return dataset;
      }
    }
  } else {
    return this.chart.data.datasets[datasetIndex];
  }
  return void 0;
};
var GetChartDataset_default = GetChartDataset;

// node_modules/phaser3-rex-plugins/templates/ui/chart/GetChartData.js
var GetChartData = function(datasetIndex, dataIndex) {
  var dataset = this.getChartDataset(datasetIndex);
  if (dataset === void 0) {
    return void 0;
  }
  if (typeof dataIndex === "string") {
    var labels = this.chart.data.labels;
    dataIndex = labels.indexOf(dataIndex);
    if (dataIndex === -1) {
      return void 0;
    }
  }
  return dataset.data[dataIndex];
};
var GetChartData_default = GetChartData;

// node_modules/phaser3-rex-plugins/templates/ui/chart/SetChartData.js
var SetChartData = function(datasetIndex, dataIndex, value) {
  if (this.chart === void 0) {
    return this;
  }
  var dataset = this.getChartDataset(datasetIndex);
  if (typeof dataIndex === "string") {
    var labels = this.chart.data.labels;
    dataIndex = labels.indexOf(dataIndex);
    if (dataIndex === -1) {
      return this;
    }
  }
  dataset.data[dataIndex] = value;
  return this;
};
var SetChartData_default = SetChartData;

// node_modules/phaser3-rex-plugins/templates/ui/chart/UpdateChart.js
var UpdateChart = function() {
  if (this.chart === void 0) {
    return this;
  }
  this.chart.update();
  return this;
};
var UpdateChart_default = UpdateChart;

// node_modules/phaser3-rex-plugins/templates/ui/chart/Chart.js
var Chart2 = class extends Canvas_default3 {
  constructor(scene, x, y, width, height, config) {
    super(scene, x, y, width, height);
    this.type = "rexChart";
    this.chart = void 0;
    if (config !== void 0) {
      this.setChart(config);
    }
  }
  destroy(fromScene) {
    if (!this.scene) {
      return;
    }
    if (this.chart) {
      this.chart.destroy();
      this.chart = void 0;
    }
    super.destroy(fromScene);
  }
  resize(width, height) {
    if (width === this.width && height === this.height) {
      return this;
    }
    super.resize(width, height);
    if (this.chart) {
      var chart = this.chart;
      chart.height = this.canvas.height;
      chart.width = this.canvas.width;
      chart.aspectRatio = chart.height ? chart.width / chart.height : null;
      chart.update();
    }
    return this;
  }
};
var methods25 = {
  setChart: SetChart_default,
  getChartDataset: GetChartDataset_default,
  getChartData: GetChartData_default,
  setChartData: SetChartData_default,
  updateChart: UpdateChart_default
};
Object.assign(
  Chart2.prototype,
  methods25
);
var Chart_default = Chart2;

// node_modules/phaser3-rex-plugins/templates/ui/chart/Factory.js
ObjectFactory_default.register("chart", function(x, y, width, height, config) {
  var gameObject2 = new Chart_default(this.scene, x, y, width, height, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Chart", Chart_default);

// node_modules/phaser3-rex-plugins/templates/ui/container/Factory.js
ObjectFactory_default.register("container", function(x, y, width, height, children) {
  var gameObject2 = new Container_default(this.scene, x, y, width, height, children);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Container", Container_default);

// node_modules/phaser3-rex-plugins/templates/ui/sizer/Factory.js
ObjectFactory_default.register("sizer", function(x, y, minWidth, minHeight, orientation, config) {
  var gameObject2 = new Sizer_default(this.scene, x, y, minWidth, minHeight, orientation, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Sizer", Sizer_default);

// node_modules/phaser3-rex-plugins/plugins/utils/math/Sum.js
var Sum = function() {
  return Array.prototype.reduce.call(arguments, Add4, 0);
};
var Add4 = function(a, b) {
  return a + b;
};
var Sum_default = Sum;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GetChildrenWidth.js
var GetChildrenWidth4 = function(minimumMode) {
  if (this.rexSizer.hidden) {
    return 0;
  }
  if (minimumMode === void 0) {
    minimumMode = true;
  }
  var result = 0, columnWidth;
  var children = this.sizerChildren;
  var child, padding, childWidth, proportion;
  var hasUnknownChildWidth = false;
  var totalColumnProportions = this.totalColumnProportions;
  for (var i = 0; i < this.columnCount; i++) {
    proportion = this.columnProportions[i];
    columnWidth = 0;
    if (proportion === 0 || minimumMode) {
      for (var j = 0; j < this.rowCount; j++) {
        child = children[j * this.columnCount + i];
        if (!child) {
          continue;
        }
        if (child.rexSizer.hidden) {
          continue;
        }
        childWidth = this.getChildWidth(child);
        if (childWidth === void 0) {
          if (proportion !== 0 && !this.hasColumnProportion0Child) {
            childWidth = 0;
          } else {
            hasUnknownChildWidth = true;
          }
        }
        if (hasUnknownChildWidth) {
          continue;
        }
        padding = child.rexSizer.padding;
        childWidth += (padding.left + padding.right) * this.scaleX;
        columnWidth = Math.max(columnWidth, childWidth);
      }
      if (!hasUnknownChildWidth) {
        result += columnWidth;
      }
    }
    if (!hasUnknownChildWidth) {
      if (minimumMode) {
        this.columnWidth[i] = columnWidth;
      }
    }
  }
  if (hasUnknownChildWidth) {
    return void 0;
  }
  var indentLeft = Math.max(this.space.indentLeftOdd, this.space.indentLeftEven);
  var totalSpace = Sum_default(this.space.left, indentLeft, ...this.space.column, this.space.right);
  return result + totalSpace * this.scaleX;
};
var GetChildrenWidth_default4 = GetChildrenWidth4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GetChildrenHeight.js
var GetChildrenHeight4 = function(minimumMode) {
  if (this.rexSizer.hidden) {
    return 0;
  }
  if (minimumMode === void 0) {
    minimumMode = true;
  }
  var result = 0, rowHeight;
  var children = this.sizerChildren;
  var child, padding, childHeight, proportion;
  var hasUnknownChildHeight = false;
  var totalRowProportions = this.totalRowProportions;
  for (var i = 0; i < this.rowCount; i++) {
    proportion = this.rowProportions[i];
    rowHeight = 0;
    if (proportion === 0 || minimumMode) {
      for (var j = 0; j < this.columnCount; j++) {
        child = children[i * this.columnCount + j];
        if (!child) {
          continue;
        }
        if (child.rexSizer.hidden) {
          continue;
        }
        childHeight = this.getChildHeight(child);
        if (childHeight === void 0) {
          if (proportion !== 0 && !this.hasRowProportion0Child) {
            childHeight = 0;
          } else {
            hasUnknownChildHeight = true;
          }
        }
        if (hasUnknownChildHeight) {
          continue;
        }
        padding = child.rexSizer.padding;
        childHeight += (padding.top + padding.bottom) * this.scaleY;
        rowHeight = Math.max(rowHeight, childHeight);
      }
      if (!hasUnknownChildHeight) {
        result += rowHeight;
      }
    }
    if (!hasUnknownChildHeight) {
      if (minimumMode) {
        this.rowHeight[i] = rowHeight;
      }
    }
  }
  if (hasUnknownChildHeight) {
    return void 0;
  }
  var indentTop = Math.max(this.space.indentTopOdd, this.space.indentTopEven);
  var totalSpace = Sum_default(this.space.top, indentTop, ...this.space.row, this.space.bottom);
  return result + totalSpace * this.scaleY;
};
var GetChildrenHeight_default4 = GetChildrenHeight4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GetExpandedChildWidth.js
var GetExpandedChildWidth4 = function(child, colWidth) {
  var childWidth;
  var childConfig = child.rexSizer;
  if (childConfig.expandWidth) {
    var padding = childConfig.padding;
    childWidth = colWidth - (padding.left + padding.right) * this.scaleX;
  }
  return childWidth;
};
var GetExpandedChildWidth_default4 = GetExpandedChildWidth4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GetExpandedChildHeight.js
var GetExpandedChildHeight4 = function(child, rowHeight) {
  var childHeight;
  var childConfig = child.rexSizer;
  if (childConfig.expandHeight) {
    var padding = childConfig.padding;
    childHeight = rowHeight - (padding.top + padding.bottom) * this.scaleY;
  }
  return childHeight;
};
var GetExpandedChildHeight_default4 = GetExpandedChildHeight4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GetChildrenSizers.js
var GetChildrenSizers4 = function(out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  var children = this.sizerChildren, child;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child && child.isRexSizer) {
      out2.push(child);
    }
  }
  return out2;
};
var GetChildrenSizers_default4 = GetChildrenSizers4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/PreLayout.js
var PreLayout3 = function() {
  this._totalColumnProportions = void 0;
  this._totalRowProportions = void 0;
  this.hasColumnProportion0Child = false;
  this.hasRowProportion0Child = false;
  this.proportionWidthLength = void 0;
  this.proportionHeightLength = void 0;
  PreLayout_default.call(this);
  return this;
};
var PreLayout_default3 = PreLayout3;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/LayoutChildren.js
var LayoutChildren4 = function() {
  var child, childConfig, padding;
  var startX = this.innerLeft, startY = this.innerTop;
  var itemX, itemY = startY;
  var x, y, width, height, alignOffsetX, alignOffsetY;
  var childWidth, childHeight;
  var colWidth, rowHeight;
  var indentLeft, indentTop;
  for (var rowIndex = 0; rowIndex < this.rowCount; rowIndex++) {
    rowHeight = this.getRowHeight(rowIndex);
    indentLeft = rowIndex % 2 ? this.space.indentLeftEven : this.space.indentLeftOdd;
    itemX = startX + indentLeft * this.scaleX;
    for (var columnIndex = 0; columnIndex < this.columnCount; columnIndex++) {
      colWidth = this.getColumnWidth(columnIndex);
      child = this.getChildAt(columnIndex, rowIndex);
      if (!child || child.rexSizer.hidden) {
        itemX += colWidth + this.space.column[columnIndex] * this.scaleX;
        continue;
      }
      PreLayoutChild_default.call(this, child);
      childWidth = this.getExpandedChildWidth(child, colWidth);
      childHeight = this.getExpandedChildHeight(child, rowHeight);
      if (child.isRexSizer) {
        child.runLayout(this, childWidth, childHeight);
        CheckSize_default(child, this);
      } else {
        ResizeGameObject_default(child, childWidth, childHeight);
      }
      childConfig = child.rexSizer;
      padding = childConfig.padding;
      x = itemX + padding.left * this.scaleX;
      width = colWidth - (padding.left + padding.right) * this.scaleX;
      indentTop = columnIndex % 2 ? this.space.indentTopEven : this.space.indentTopOdd;
      y = itemY + indentTop * this.scaleY + padding.top * this.scaleY;
      height = rowHeight - (padding.top + padding.bottom) * this.scaleY;
      if (childWidth === void 0) {
        childWidth = GetDisplayWidth(child);
      }
      if (childHeight === void 0) {
        childHeight = GetDisplayHeight(child);
      }
      alignOffsetX = (childConfig.alignOffsetX + childConfig.alignOffsetOriginX * childWidth) * this.scaleX;
      alignOffsetY = (childConfig.alignOffsetY + childConfig.alignOffsetOriginY * childHeight) * this.scaleY;
      LayoutChild_default.call(
        this,
        child,
        x,
        y,
        width,
        height,
        childConfig.align,
        alignOffsetX,
        alignOffsetY
      );
      itemX += colWidth + this.space.column[columnIndex] * this.scaleX;
    }
    itemY += rowHeight + this.space.row[rowIndex] * this.scaleY;
  }
};
var LayoutChildren_default4 = LayoutChildren4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/ResolveWidth.js
var ResolveWidth4 = function(width) {
  var width = ResolveWidth_default.call(this, width);
  if (width !== void 0 && this.proportionWidthLength === void 0) {
    var totalColumnProportions = this.totalColumnProportions;
    if (totalColumnProportions > 0) {
      var remainder = width - this.getChildrenWidth(false);
      if (remainder >= 0) {
        this.proportionWidthLength = remainder / totalColumnProportions;
      } else {
      }
    } else {
      this.proportionWidthLength = 0;
    }
  }
  return width;
};
var ResolveWidth_default3 = ResolveWidth4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/ResolveHeight.js
var ResolveHeight4 = function(height) {
  var height = ResolveHeight_default.call(this, height);
  if (height !== void 0 && this.proportionHeightLength === void 0) {
    var totalRowProportions = this.totalRowProportions;
    if (totalRowProportions > 0) {
      var remainder = height - this.getChildrenHeight(false);
      if (remainder >= 0) {
        this.proportionHeightLength = remainder / totalRowProportions;
      } else {
      }
    } else {
      this.proportionHeightLength = 0;
    }
  }
  return height;
};
var ResolveHeight_default3 = ResolveHeight4;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/ResolveChildrenWidth.js
var ResolveChildrenWidth2 = function(parentWidth) {
  var child, expandedChildWidth, childWidth;
  var colWidth;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (child && child.isRexSizer && !child.ignoreLayout) {
      colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
      expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
      childWidth = child.resolveWidth(expandedChildWidth);
      if (childWidth === void 0) {
        childWidth = expandedChildWidth;
      }
      child.resolveChildrenWidth(childWidth);
    }
  }
};
var ResolveChildrenWidth_default2 = ResolveChildrenWidth2;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/ResolveChildrenHeight.js
var ResolveChildrenHeight2 = function(parentHeight) {
  var child, expandedChildHeight, childHeight;
  var rowHeight;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (child && child.isRexSizer && !child.ignoreLayout) {
      rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
      expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
      childHeight = child.resolveHeight(expandedChildHeight);
      if (childHeight === void 0) {
        childHeight = expandedChildHeight;
      }
      child.resolveChildrenHeight(childHeight);
    }
  }
};
var ResolveChildrenHeight_default2 = ResolveChildrenHeight2;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/RunWidthWrap.js
var RunWidthWrap3 = function(width) {
  var child, expandedChildWidth, childWidth;
  var colWidth;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
      continue;
    }
    colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
    expandedChildWidth = this.getExpandedChildWidth(child, colWidth);
    if (child.isRexSizer) {
      childWidth = child.resolveWidth(expandedChildWidth);
      if (childWidth === void 0) {
        childWidth = expandedChildWidth;
      }
    }
    child.runWidthWrap(childWidth);
  }
  return this;
};
var RunWidthWrap_default3 = RunWidthWrap3;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/RunHeightWrap.js
var RunHeightWrap3 = function(height) {
  var child, expandedChildHeight, childHeight;
  var rowHeight;
  for (var i in this.sizerChildren) {
    child = this.sizerChildren[i];
    if (!child || child.isRexSizer && child.ignoreLayout || !child.runHeightWrap) {
      continue;
    }
    rowHeight = this.getRowHeight(Math.floor(parseInt(i) / this.rowCount));
    expandedChildHeight = this.getExpandedChildHeight(child, rowHeight);
    if (child.isRexSizer) {
      childHeight = child.resolveHeight(expandedChildHeight);
      if (childHeight === void 0) {
        childHeight = expandedChildHeight;
      }
    }
    child.runHeightWrap(childHeight);
  }
  return this;
};
var RunHeightWrap_default3 = RunHeightWrap3;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/AddChildMethods.js
var IsPlainObject41 = Phaser.Utils.Objects.IsPlainObject;
var GetValue133 = Phaser.Utils.Objects.GetValue;
var ALIGN_CENTER4 = Phaser.Display.Align.CENTER;
var GetEmptyCellIndex = function(columnIndex, rowIndex, cells, columnCount, rowCount) {
  if (typeof columnIndex === "number" || typeof rowIndex === "number") {
    if (columnIndex === void 0) {
      var idx;
      for (var i = 0; i < columnCount; i++) {
        idx = rowIndex * columnCount + i;
        if (!cells[idx]) {
          return idx;
        }
      }
    } else if (rowIndex === void 0) {
      var idx;
      for (var i = 0; i < rowCount; i++) {
        idx = i * columnCount + columnIndex;
        if (!cells[idx]) {
          return idx;
        }
      }
    } else {
      var idx = rowIndex * columnCount + columnIndex;
      if (!cells[idx]) {
        return idx;
      }
    }
  } else if (rowIndex === true) {
    var idx;
    for (var i = 0; i < columnCount; i++) {
      for (var j = 0; j < rowCount; j++) {
        idx = j * columnCount + i;
        if (!cells[idx]) {
          return idx;
        }
      }
    }
  } else {
    for (var i = 0, cnt = cells.length; i < cnt; i++) {
      if (!cells[i]) {
        return i;
      }
    }
  }
  return null;
};
var Add5 = function(gameObject2, columnIndex, rowIndex, align, paddingConfig, expand, childKey) {
  var offsetX, offsetY;
  var offsetOriginX, offsetOriginY;
  AddChild_default4.call(this, gameObject2);
  if (IsPlainObject41(columnIndex)) {
    var config = columnIndex;
    columnIndex = GetValue133(config, "column", void 0);
    rowIndex = GetValue133(config, "row", void 0);
    align = GetValue133(config, "align", ALIGN_CENTER4);
    paddingConfig = GetValue133(config, "padding", 0);
    expand = GetValue133(config, "expand", false);
    childKey = GetValue133(config, "key", void 0);
    offsetX = GetValue133(config, "offsetX", 0);
    offsetY = GetValue133(config, "offsetY", 0);
    offsetOriginX = GetValue133(config, "offsetOriginX", 0);
    offsetOriginY = GetValue133(config, "offsetOriginY", 0);
  }
  var itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
  if (itemIndex === null) {
    if (typeof columnIndex === "number" && typeof rowIndex === "number") {
      return this;
    }
    if (rowIndex === true || typeof rowIndex === "number") {
      this.addEmptyColumn();
    } else {
      this.addEmptyRow();
    }
    itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
  }
  if (typeof align === "string") {
    align = AlignConst_default2[align];
  }
  if (align === void 0) {
    align = ALIGN_CENTER4;
  }
  if (paddingConfig === void 0) {
    paddingConfig = 0;
  }
  if (expand === void 0) {
    expand = true;
  }
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  if (offsetOriginX === void 0) {
    offsetOriginX = 0;
  }
  if (offsetOriginY === void 0) {
    offsetOriginY = 0;
  }
  var config = this.getSizerConfig(gameObject2);
  config.align = align;
  config.padding = GetBoundsConfig_default2(paddingConfig);
  if (IsPlainObject41(expand)) {
    config.expandWidth = GetValue133(expand, "width", false);
    config.expandHeight = GetValue133(expand, "height", false);
  } else {
    config.expandWidth = expand;
    config.expandHeight = expand;
  }
  config.alignOffsetX = offsetX;
  config.alignOffsetY = offsetY;
  config.alignOffsetOriginX = offsetOriginX;
  config.alignOffsetOriginY = offsetOriginY;
  this.sizerChildren[itemIndex] = gameObject2;
  if (childKey !== void 0) {
    this.addChildrenMap(childKey, gameObject2);
  }
  return this;
};
var AddChildMethods_default4 = {
  add: Add5
};

// node_modules/phaser3-rex-plugins/plugins/utils/array/Fill.js
var Fill = function(arr, value, startIdx, endIdx) {
  if (startIdx === void 0) {
    startIdx = 0;
  }
  if (endIdx === void 0) {
    endIdx = arr.length - 1;
  }
  for (var i = startIdx; i <= endIdx; i++) {
    arr[i] = value;
  }
  return arr;
};
var Fill_default = Fill;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/RemoveChildMethods.js
var RemoveChildMethods_default4 = {
  remove(gameObject2, destroyChild) {
    if (this.getParentSizer(gameObject2) !== this) {
      return this;
    }
    var idx = this.sizerChildren.indexOf(gameObject2);
    if (idx !== -1) {
      this.sizerChildren[idx] = null;
    }
    RemoveChild_default4.call(this, gameObject2, destroyChild);
    return this;
  },
  removeAt(columnIndex, rowIndex, destroyChild) {
    var child = this.getChildAt(columnIndex, rowIndex);
    if (child) {
      this.remove(child, destroyChild);
    }
    return this;
  },
  removeAll(destroyChild) {
    for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
      var child = this.sizerChildren[i];
      if (!child) {
        continue;
      }
      this.remove(child, destroyChild);
    }
    return this;
  },
  clear(destroyChild) {
    Fill_default(this.sizerChildren, null);
    ClearChildren_default.call(this, destroyChild);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/SetSpaceMethods.js
var SetSpaceMethods_default = {
  setColumnSpace(columnSpace) {
    if (!this.space.column) {
      this.space.column = [];
    }
    this.space.column.length = this.columnCount - 1;
    if (typeof columnSpace === "number") {
      this.space.column0 = columnSpace;
      Fill_default(this.space.column, columnSpace);
    } else {
      this.space.column0 = columnSpace[0];
      for (var i = 0, cnt = this.columnCount - 1; i < cnt; i++) {
        this.space.column[i] = columnSpace[i] || 0;
      }
    }
    return this;
  },
  setRowSpace(rowSpace) {
    if (!this.space.row) {
      this.space.row = [];
    }
    this.space.row.length = this.rowCount - 1;
    if (typeof rowSpace === "number") {
      this.space.row0 = rowSpace;
      Fill_default(this.space.row, rowSpace);
    } else {
      this.space.row0 = rowSpace[i];
      for (var i = 0, cnt = this.rowCount - 1; i < cnt; i++) {
        this.space.row[i] = rowSpace[i] || 0;
      }
    }
    return this;
  },
  setIndentLeft(odd, even) {
    this.space.indentLeftOdd = odd;
    this.space.indentLeftEven = even;
    return this;
  },
  setIndentTop(odd, even) {
    this.space.indentTopOdd = odd;
    this.space.indentTopEven = even;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/ResetGrid.js
var GetValue134 = Phaser.Utils.Objects.GetValue;
var ResetGrid = function(columnCount, rowCount, columnProportions, rowProportions, space) {
  if (columnCount === void 0) {
    columnCount = 0;
  }
  if (rowCount === void 0) {
    rowCount = 0;
  }
  if (columnProportions === void 0) {
    columnProportions = 0;
  }
  if (rowProportions === void 0) {
    rowProportions = 0;
  }
  this.columnCount = columnCount;
  this.rowCount = rowCount;
  this.gridCount = columnCount * rowCount;
  this.removeAll();
  this.sizerChildren.length = columnCount * rowCount;
  Fill_default(this.sizerChildren, null);
  this.columnProportions = [];
  this.columnProportions.length = columnCount;
  if (typeof columnProportions === "number") {
    Fill_default(this.columnProportions, columnProportions);
  } else {
    for (var i = 0; i < columnCount; i++) {
      this.columnProportions[i] = columnProportions[i] || 0;
    }
  }
  this.rowProportions = [];
  this.rowProportions.length = rowCount;
  if (typeof rowProportions === "number") {
    Fill_default(this.rowProportions, rowProportions);
  } else {
    for (var i = 0; i < rowCount; i++) {
      this.rowProportions[i] = rowProportions[i] || 0;
    }
  }
  this.columnWidth = [];
  this.columnWidth.length = columnCount;
  this.rowHeight = [];
  this.rowHeight.length = rowCount;
  this.setColumnSpace(GetValue134(space, "column", 0));
  this.setRowSpace(GetValue134(space, "row", 0));
  var scene = this.scene;
  var createCellContainerCallback = this.createCellContainerCallback;
  if (createCellContainerCallback) {
    for (var y = 0, ycnt = this.rowCount; y < ycnt; y++) {
      for (var x = 0, xcnt = this.columnCount; x < xcnt; x++) {
        var addConfig = { column: x, row: y };
        var child = createCellContainerCallback(scene, x, y, addConfig);
        if (child) {
          this.add(child, addConfig);
        }
      }
    }
  }
  return this;
};
var ResetGrid_default = ResetGrid;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/InsertEmptyRow.js
var InsertEmptyRow = function(rowIndex, proportion, space) {
  if (proportion === void 0) {
    proportion = this.rowProportions[0] || 0;
  }
  if (space === void 0) {
    space = this.space.row0 || 0;
  }
  this.rowCount += 1;
  this.gridCount += this.columnCount;
  var args = [rowIndex * this.columnCount, 0];
  for (var i = 0; i < this.columnCount; i++) {
    args.push(null);
  }
  this.sizerChildren.splice.apply(this.sizerChildren, args);
  this.rowProportions.push(proportion);
  this.rowHeight.length += 1;
  this.space.row.splice(rowIndex, 0, space);
  return this;
};
var AddEmptyRow = function(proportion, space) {
  InsertEmptyRow.call(this, this.rowCount, proportion, space);
  return this;
};

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/InsertEmptyColumn.js
var InsertEmptyColumn = function(colIndex, proportion, space) {
  if (proportion === void 0) {
    proportion = this.columnProportions[0] || 0;
  }
  if (space === void 0) {
    space = this.space.column0 || 0;
  }
  this.columnCount += 1;
  this.gridCount += this.rowCount;
  for (var i = this.rowCount - 1; i >= 0; i--) {
    var insertIndex = i * this.columnCount + colIndex;
    this.sizerChildren.splice(insertIndex, 0, null);
  }
  this.columnProportions.push(proportion);
  this.columnWidth.length += 1;
  this.space.column.splice(colIndex, 0, space);
  return this;
};
var AddEmptyColumn = function(proportion, space) {
  InsertEmptyColumn.call(this, this.columnCount, proportion, space);
  return this;
};

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/Methods.js
var methods26 = {
  getChildrenWidth: GetChildrenWidth_default4,
  getChildrenHeight: GetChildrenHeight_default4,
  getExpandedChildWidth: GetExpandedChildWidth_default4,
  getExpandedChildHeight: GetExpandedChildHeight_default4,
  getChildrenSizers: GetChildrenSizers_default4,
  preLayout: PreLayout_default3,
  layoutChildren: LayoutChildren_default4,
  resolveWidth: ResolveWidth_default3,
  resolveHeight: ResolveHeight_default3,
  resolveChildrenWidth: ResolveChildrenWidth_default2,
  resolveChildrenHeight: ResolveChildrenHeight_default2,
  runWidthWrap: RunWidthWrap_default3,
  runHeightWrap: RunHeightWrap_default3,
  resetGrid: ResetGrid_default,
  insertEmptyRow: InsertEmptyRow,
  addEmptyRow: AddEmptyRow,
  insertEmptyColumn: InsertEmptyColumn,
  addEmptyColumn: AddEmptyColumn
};
Object.assign(
  methods26,
  AddChildMethods_default4,
  RemoveChildMethods_default4,
  SetSpaceMethods_default,
  SortChildrenMethods_default
);
var Methods_default27 = methods26;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GetTotalColumnProportions.js
var GetTotalColumnProportions = function() {
  var result = 0, proportion;
  for (var i = 0; i < this.columnCount; i++) {
    proportion = this.columnProportions[i];
    if (proportion > 0) {
      result += proportion;
    } else if (proportion === 0) {
      this.hasColumnProportion0Child = true;
    }
  }
  return result;
};
var GetTotalColumnProportions_default = GetTotalColumnProportions;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GetTotalRowProportions.js
var GetTotalRowProportions = function() {
  var result = 0, proportion;
  for (var i = 0; i < this.rowCount; i++) {
    proportion = this.rowProportions[i];
    if (proportion > 0) {
      result += proportion;
    } else if (proportion === 0) {
      this.hasRowProportion0Child = true;
    }
  }
  return result;
};
var GetTotalRowProportions_default = GetTotalRowProportions;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/GridSizer.js
var IsPlainObject42 = Phaser.Utils.Objects.IsPlainObject;
var GetValue135 = Phaser.Utils.Objects.GetValue;
var GridSizer = class extends BaseSizer_default {
  constructor(scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportions, config) {
    if (IsPlainObject42(x)) {
      config = x;
      x = GetValue135(config, "x", 0);
      y = GetValue135(config, "y", 0);
      minWidth = GetValue135(config, "width", void 0);
      minHeight = GetValue135(config, "height", void 0);
      columnCount = GetValue135(config, "column", config.col || 0);
      rowCount = GetValue135(config, "row", 0);
      columnProportions = GetValue135(config, "columnProportions", 0);
      rowProportions = GetValue135(config, "rowProportions", 0);
    } else if (IsPlainObject42(minWidth)) {
      config = minWidth;
      minWidth = GetValue135(config, "width", void 0);
      minHeight = GetValue135(config, "height", void 0);
      columnCount = GetValue135(config, "column", config.col || 0);
      rowCount = GetValue135(config, "row", 0);
      columnProportions = GetValue135(config, "columnProportions", 0);
      rowProportions = GetValue135(config, "rowProportions", 0);
    } else if (IsPlainObject42(columnCount)) {
      config = columnCount;
      columnCount = GetValue135(config, "column", config.col || 0);
      rowCount = GetValue135(config, "row", 0);
      columnProportions = GetValue135(config, "columnProportions", 0);
      rowProportions = GetValue135(config, "rowProportions", 0);
    } else if (IsPlainObject42(columnProportions)) {
      config = columnProportions;
      columnProportions = GetValue135(config, "columnProportions", 0);
      rowProportions = GetValue135(config, "rowProportions", 0);
    }
    super(scene, x, y, minWidth, minHeight, config);
    this.type = "rexGridSizer";
    this.sizerChildren = [];
    this.addChildrenMap("items", this.sizerChildren);
    this.setCreateCellContainerCallback(GetValue135(config, "createCellContainerCallback"));
    this.setIndentLeft(
      GetValue135(config, "space.indentLeftOdd", 0),
      GetValue135(config, "space.indentLeftEven", 0)
    );
    this.setIndentTop(
      GetValue135(config, "space.indentTopOdd", 0),
      GetValue135(config, "space.indentTopEven", 0)
    );
    this.resetGrid(
      columnCount,
      rowCount,
      columnProportions,
      rowProportions,
      GetValue135(config, "space", void 0)
    );
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    this.columnProportions = void 0;
    this.rowProportions = void 0;
    this.columnWidth = void 0;
    this.rowHeight = void 0;
    this.createCellContainerCallback = void 0;
  }
  setColumnProportion(columnIndex, proportion) {
    if (columnIndex >= this.columnProportions.length) {
      return this;
    }
    this.columnProportions[columnIndex] = proportion;
    return this;
  }
  setRowProportion(rowIndex, proportion) {
    if (rowIndex >= this.rowProportions.length) {
      return this;
    }
    this.rowProportions[rowIndex] = proportion;
    return this;
  }
  get totalColumnProportions() {
    if (this._totalColumnProportions === void 0) {
      this._totalColumnProportions = GetTotalColumnProportions_default.call(this);
    }
    return this._totalColumnProportions;
  }
  get totalRowProportions() {
    if (this._totalRowProportions === void 0) {
      this._totalRowProportions = GetTotalRowProportions_default.call(this);
    }
    return this._totalRowProportions;
  }
  getChildAt(columnIndex, rowIndex) {
    return this.sizerChildren[rowIndex * this.columnCount + columnIndex];
  }
  childToGridIndex(child, out2) {
    if (!child) {
      return null;
    }
    var index = this.sizerChildren.indexOf(child);
    if (index === -1) {
      return null;
    }
    if (out2 === void 0) {
      out2 = {};
    }
    out2.x = index % this.columnCount;
    out2.y = Math.floor(index / this.columnCount);
    return out2;
  }
  getColumnWidth(columnIndex) {
    var colProportion = this.columnProportions[columnIndex];
    var colWidth = colProportion === 0 ? this.columnWidth[columnIndex] : colProportion * this.proportionWidthLength;
    return colWidth;
  }
  getRowHeight(rowIndex) {
    var rowProportion = this.rowProportions[rowIndex];
    var rowHeight = rowProportion === 0 ? this.rowHeight[rowIndex] : rowProportion * this.proportionHeightLength;
    return rowHeight;
  }
  setCreateCellContainerCallback(callback) {
    this.createCellContainerCallback = callback;
    return this;
  }
};
Object.assign(
  GridSizer.prototype,
  Methods_default27
);
var GridSizer_default = GridSizer;

// node_modules/phaser3-rex-plugins/templates/ui/gridsizer/Factory.js
ObjectFactory_default.register("gridSizer", function(x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config) {
  var gameObject2 = new GridSizer_default(this.scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.GridSizer", GridSizer_default);

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetChildrenWidth.js
var GetChildrenWidth5 = function(minimumMode) {
  if (this.rexSizer.hidden) {
    return 0;
  }
  if (minimumMode === void 0) {
    minimumMode = true;
  }
  var childrenWidth;
  if (this.orientation === 0) {
    if (minimumMode) {
      childrenWidth = this.maxChildWidth;
    } else {
      childrenWidth = this.rexSizer.resolved ? this.wrapResult.width : void 0;
    }
  } else {
    childrenWidth = this.rexSizer.resolved ? this.wrapResult.width : void 0;
  }
  if (childrenWidth === void 0) {
    return void 0;
  }
  return childrenWidth + (this.space.left + this.space.right) * this.scaleX;
};
var GetChildrenWidth_default5 = GetChildrenWidth5;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetChildrenHeight.js
var GetChildrenHeight5 = function(minimumMode) {
  if (this.rexSizer.hidden) {
    return 0;
  }
  if (minimumMode === void 0) {
    minimumMode = true;
  }
  var childrenHeight;
  if (this.orientation === 1) {
    if (minimumMode) {
      childrenHeight = this.maxChildHeight;
    } else {
      childrenHeight = this.rexSizer.resolved ? this.wrapResult.height : void 0;
    }
  } else {
    childrenHeight = this.rexSizer.resolved ? this.wrapResult.height : void 0;
  }
  if (childrenHeight === void 0) {
    return void 0;
  }
  return childrenHeight + (this.space.top + this.space.bottom) * this.scaleY;
};
var GetChildrenHeight_default5 = GetChildrenHeight5;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetChildrenSizers.js
var GetChildrenSizers5 = function(out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  var children = this.sizerChildren, child;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child === "\n") {
      continue;
    }
    if (child.isRexSizer) {
      out2.push(child);
    }
  }
  return out2;
};
var GetChildrenSizers_default5 = GetChildrenSizers5;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/PreLayout.js
var PreLayout4 = function() {
  this._maxChildWidth = void 0;
  this._maxChildHeight = void 0;
  this.wrapResult = void 0;
  this.rexSizer.resolved = false;
  PreLayout_default.call(this);
  return this;
};
var PreLayout_default4 = PreLayout4;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/LayoutChildren.js
var LayoutChildren5 = function() {
  var horizontalWrap = this.orientation === 0;
  var innerLineWidth = horizontalWrap ? this.innerWidth : this.innerHeight;
  var child, childConfig, padding, justifySpace = 0, indentLeft, indentTop;
  var startX = this.innerLeft, startY = this.innerTop;
  var x, y, width, height, alignOffsetX, alignOffsetY;
  var lines = this.wrapResult.lines;
  var line, lineChlidren, remainderLineWidth;
  var itemX = startX, itemY = startY;
  for (var i = 0, icnt = lines.length; i < icnt; i++) {
    line = lines[i];
    lineChlidren = line.children;
    if (this.rtl) {
      lineChlidren.reverse();
    }
    if (horizontalWrap) {
      indentLeft = i % 2 ? this.space.indentLeftEven : this.space.indentLeftOdd;
      itemX = startX + indentLeft * this.scaleX;
    } else {
      indentTop = i % 2 ? this.space.indentTopEven : this.space.indentTopOdd;
      itemY = startY + indentTop * this.scaleY;
    }
    remainderLineWidth = innerLineWidth - (horizontalWrap ? line.width : line.height);
    switch (this.align) {
      case 0:
        break;
      case 1:
        if (horizontalWrap) {
          itemX += remainderLineWidth;
        } else {
          itemY += remainderLineWidth;
        }
        break;
      case 2:
        if (horizontalWrap) {
          itemX += remainderLineWidth / 2;
        } else {
          itemY += remainderLineWidth / 2;
        }
        break;
      case 3:
        justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
        break;
      case 4:
        justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
        if (justifySpace === 0) {
          if (horizontalWrap) {
            itemX += remainderLineWidth;
          } else {
            itemY += remainderLineWidth;
          }
        }
        break;
      case 5:
        justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, this.justifyPercentage, lineChlidren.length);
        if (justifySpace === 0) {
          if (horizontalWrap) {
            itemX += remainderLineWidth / 2;
          } else {
            itemY += remainderLineWidth / 2;
          }
        }
        break;
    }
    var isFirstChild = true;
    for (var j = 0, jcnt = lineChlidren.length; j < jcnt; j++) {
      child = lineChlidren[j];
      if (child.rexSizer.hidden) {
        continue;
      }
      childConfig = child.rexSizer;
      padding = childConfig.padding;
      PreLayoutChild_default.call(this, child);
      if (horizontalWrap) {
        x = itemX + padding.left * this.scaleX;
      } else {
        y = itemY + padding.top * this.scaleY;
      }
      if (isFirstChild) {
        isFirstChild = false;
      } else {
        if (horizontalWrap) {
          x += this.space.item * this.scaleX;
        } else {
          y += this.space.item * this.scaleY;
        }
      }
      width = GetDisplayWidth(child);
      height = GetDisplayHeight(child);
      if (horizontalWrap) {
        indentTop = j % 2 ? this.space.indentTopEven : this.space.indentTopOdd;
        y = itemY + indentTop * this.scaleY + padding.top * this.scaleY;
        itemX = x + width + padding.right * this.scaleX + justifySpace;
      } else {
        indentLeft = j % 2 ? this.space.indentLeftEven : this.space.indentLeftOdd;
        x = itemX + indentLeft * this.scaleX + padding.left * this.scaleX;
        itemY = y + height + padding.top * this.scaleY + justifySpace;
      }
      alignOffsetX = (childConfig.alignOffsetX + childConfig.alignOffsetOriginX * width) * this.scaleX;
      alignOffsetY = (childConfig.alignOffsetY + childConfig.alignOffsetOriginY * height) * this.scaleY;
      LayoutChild_default.call(
        this,
        child,
        x,
        y,
        width,
        height,
        childConfig.align,
        alignOffsetX,
        alignOffsetY
      );
    }
    if (horizontalWrap) {
      itemY += line.height + this.space.line * this.scaleY;
    } else {
      itemX += line.width + this.space.line * this.scaleX;
    }
  }
};
var GetJustifySpace = function(total, remainder, justifyPercentage, childCount) {
  return remainder / total <= justifyPercentage ? remainder / (childCount - 1) : 0;
};
var LayoutChildren_default5 = LayoutChildren5;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/HasWidthWrap.js
var HasWidthWrap3 = function() {
  if (this.orientation === 0) {
    return true;
  }
  return HasWidthWrap_default.call(this);
};
var HasWidthWrap_default3 = HasWidthWrap3;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/RunChildrenWrap.js
var RunChildrenWrap = function(lineWidth) {
  var out2 = {
    lines: [],
    width: 0,
    height: 0
  };
  var children = this.sizerChildren;
  var child, padding, childWidth, childHeight, remainder = 0, indentLeft, indentTop;
  var lines = out2.lines, lastLine = void 0, newLine;
  if (this.orientation === 0) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child === "\n") {
        child = void 0;
        childWidth = 0;
        newLine = true;
      } else {
        if (child.rexSizer.hidden) {
          continue;
        }
        if (child.isRexSizer) {
          child.runLayout(this);
        }
        childWidth = this.getChildWidth(child);
        padding = child.rexSizer.padding;
        childWidth += (padding.left + padding.right) * this.scaleX;
        newLine = remainder < childWidth || lastLine === void 0;
      }
      if (newLine) {
        if (lastLine) {
          lastLine.width = lineWidth - (remainder + this.space.item * this.scaleX);
          out2.width = Math.max(out2.width, lastLine.width);
          out2.height += lastLine.height + this.space.line * this.scaleY;
        }
        lastLine = {
          children: [],
          width: 0,
          height: 0
        };
        lines.push(lastLine);
        indentLeft = lines.length % 2 ? this.space.indentLeftOdd : this.space.indentLeftEven;
        remainder = lineWidth - indentLeft * this.scaleX;
      }
      remainder -= childWidth + this.space.item * this.scaleX;
      if (child) {
        lastLine.children.push(child);
        childHeight = this.getChildHeight(child);
        padding = child.rexSizer.padding;
        childHeight += (padding.top + padding.bottom) * this.scaleY;
        lastLine.height = Math.max(lastLine.height, childHeight);
      }
    }
    if (lastLine) {
      lastLine.width = lineWidth - (remainder + this.space.item * this.scaleX);
      out2.width = Math.max(out2.width, lastLine.width);
      out2.height += lastLine.height;
    }
    out2.height += Math.max(this.space.indentTopOdd, this.space.indentTopEven) * this.scaleY;
  } else {
    var lineHeight = lineWidth;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];
      if (child === "\n") {
        child = void 0;
        childWidth = 0;
        newLine = true;
      } else {
        if (child.rexSizer.hidden) {
          continue;
        }
        if (child.isRexSizer) {
          child.layout();
        }
        childHeight = this.getChildHeight(child);
        padding = child.rexSizer.padding;
        childHeight += (padding.top + padding.bottom) * this.scaleY;
        newLine = remainder < childHeight || lastLine === void 0;
      }
      if (newLine) {
        if (lastLine) {
          lastLine.height = lineHeight - (remainder + this.space.item * this.scaleY);
          out2.height = Math.max(out2.height, lastLine.height);
          out2.width += lastLine.width + this.space.line * this.scaleX;
        }
        lastLine = {
          children: [],
          width: 0,
          height: 0
        };
        lines.push(lastLine);
        indentTop = lines.length % 2 ? this.space.indentTopOdd : this.space.indentTopEven;
        remainder = lineHeight - indentTop * this.scaleY;
      }
      remainder -= childHeight + this.space.item * this.scaleY;
      if (child) {
        lastLine.children.push(child);
        childWidth = this.getChildWidth(child);
        padding = child.rexSizer.padding;
        childWidth += (padding.left + padding.right) * this.scaleX;
        lastLine.width = Math.max(lastLine.width, childWidth);
      }
    }
    if (lastLine) {
      lastLine.height = lineHeight - (remainder + this.space.item * this.scaleY);
      out2.height = Math.max(out2.height, lastLine.height);
      out2.width += lastLine.width;
    }
    out2.width += Math.max(this.space.indentLeftOdd, this.space.indentLeftEven) * this.scaleX;
  }
  return out2;
};
var RunChildrenWrap_default = RunChildrenWrap;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/RunWidthWrap.js
var RunWidthWrap4 = function(width) {
  if (this.wrapResult) {
    return;
  }
  if (this.orientation === 0) {
    var innerWidth = width - (this.space.left + this.space.right) * this.scaleX;
    this.wrapResult = RunChildrenWrap_default.call(this, innerWidth);
    this.rexSizer.resolved = true;
    RunWidthWrap_default.call(this, width);
  }
};
var RunWidthWrap_default4 = RunWidthWrap4;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/HasHeightWrap.js
var HasHeightWrap3 = function() {
  if (this.orientation === 1) {
    return true;
  }
  return HasHeightWrap_default.call(this);
};
var HasHeightWrap_default3 = HasHeightWrap3;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/RunHeightWrap.js
var RunHeightWrap4 = function(height) {
  if (this.wrapResult) {
    return;
  }
  if (this.orientation === 1) {
    var innerHeight = height - (this.space.top + this.space.bottom) * this.scaleY;
    this.wrapResult = RunChildrenWrap_default.call(this, innerHeight);
    this.rexSizer.resolved = true;
    RunHeightWrap_default.call(this, height);
  }
};
var RunHeightWrap_default4 = RunHeightWrap4;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetExpandedChildWidth.js
var GetExpandedChildWidth5 = function(child, parentWidth) {
  return void 0;
};
var GetExpandedChildWidth_default5 = GetExpandedChildWidth5;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetExpandedChildHeight.js
var GetExpandedChildHeight5 = function(child, parentHeight) {
  return void 0;
};
var GetExpandedChildHeight_default5 = GetExpandedChildHeight5;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetNearestChildIndex.js
var DistanceBetween6 = Phaser.Math.Distance.Between;
var GetNearestChildIndex2 = function(x, y) {
  var children = this.sizerChildren;
  if (children.length === 0) {
    return -1;
  }
  var nearestIndex = -1, minDistance = Infinity;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (Math.abs(child.centerY - y) > child.height / 2) {
      continue;
    }
    var distance = DistanceBetween6(child.left, child.centerY, x, y);
    if (minDistance > distance) {
      minDistance = distance;
      nearestIndex = i;
    }
    var nextChild = children[i + 1];
    if (nextChild && nextChild.y === child.y) {
      continue;
    }
    var distance = DistanceBetween6(child.right, child.centerY, x, y);
    if (minDistance > distance) {
      minDistance = distance;
      nearestIndex = i + 1;
    }
  }
  return nearestIndex;
};
var GetNearestChildIndex_default2 = GetNearestChildIndex2;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/AddChildMethods.js
var IsPlainObject43 = Phaser.Utils.Objects.IsPlainObject;
var GetValue136 = Phaser.Utils.Objects.GetValue;
var ALIGN_CENTER5 = Phaser.Display.Align.CENTER;
var Add6 = function(gameObject2, paddingConfig, childKey, index) {
  if (gameObject2 === "\n") {
    this.addNewLine();
    return this;
  }
  var offsetX, offsetY;
  var offsetOriginX, offsetOriginY;
  AddChild_default4.call(this, gameObject2);
  if (IsPlainObject43(paddingConfig)) {
    var config = paddingConfig;
    paddingConfig = GetValue136(config, "padding", 0);
    childKey = GetValue136(config, "key", void 0);
    index = GetValue136(config, "index", void 0);
    offsetX = GetValue136(config, "offsetX", 0);
    offsetY = GetValue136(config, "offsetY", 0);
    offsetOriginX = GetValue136(config, "offsetOriginX", 0);
    offsetOriginY = GetValue136(config, "offsetOriginY", 0);
  }
  if (paddingConfig === void 0) {
    paddingConfig = 0;
  }
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (offsetY === void 0) {
    offsetY = 0;
  }
  if (offsetOriginX === void 0) {
    offsetOriginX = 0;
  }
  if (offsetOriginY === void 0) {
    offsetOriginY = 0;
  }
  var config = this.getSizerConfig(gameObject2);
  config.align = ALIGN_CENTER5;
  config.padding = GetBoundsConfig_default2(paddingConfig);
  config.alignOffsetX = offsetX;
  config.alignOffsetY = offsetY;
  config.alignOffsetOriginX = offsetOriginX;
  config.alignOffsetOriginY = offsetOriginY;
  if (index === void 0 || index >= this.sizerChildren.length) {
    this.sizerChildren.push(gameObject2);
  } else {
    this.sizerChildren.splice(index, 0, gameObject2);
  }
  if (childKey !== void 0) {
    this.addChildrenMap(childKey, gameObject2);
  }
  return this;
};
var AddChildMethods_default5 = {
  add(gameObject2, paddingConfig, childKey) {
    if (IsArray_default(gameObject2)) {
      var gameObjects = gameObject2;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add6.call(this, gameObjects[i], paddingConfig);
      }
    } else {
      Add6.call(this, gameObject2, paddingConfig, childKey);
    }
    return this;
  },
  addNewLine() {
    this.sizerChildren.push("\n");
    return this;
  },
  insert(index, gameObject2, paddingConfig, childKey) {
    Add6.call(this, gameObject2, paddingConfig, childKey, index);
    return this;
  },
  insertAtPosition(x, y, gameObject2, paddingConfig, childKey) {
    var index = GetNearestChildIndex_default2.call(this, x, y);
    if (index === -1) {
      index = void 0;
    }
    this.insert(index, gameObject2, paddingConfig, childKey);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/RemoveChildMethods.js
var RemoveItem14 = Phaser.Utils.Array.Remove;
var RemoveChildMethods_default5 = {
  remove(gameObject2, destroyChild) {
    if (this.getParentSizer(gameObject2) !== this) {
      return this;
    }
    RemoveItem14(this.sizerChildren, gameObject2);
    RemoveChild_default4.call(this, gameObject2, destroyChild);
    return this;
  },
  removeAll(destroyChild) {
    for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
      this.remove(this.sizerChildren[i], destroyChild);
    }
    return this;
  },
  clear(destroyChild) {
    this.sizerChildren.length = 0;
    ClearChildren_default.call(this, destroyChild);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/Methods.js
var methods27 = {
  getChildrenWidth: GetChildrenWidth_default5,
  getChildrenHeight: GetChildrenHeight_default5,
  getChildrenSizers: GetChildrenSizers_default5,
  preLayout: PreLayout_default4,
  layoutChildren: LayoutChildren_default5,
  hasWidthWrap: HasWidthWrap_default3,
  runWidthWrap: RunWidthWrap_default4,
  hasHeightWrap: HasHeightWrap_default3,
  runHeightWrap: RunHeightWrap_default4,
  getExpandedChildWidth: GetExpandedChildWidth_default5,
  getExpandedChildHeight: GetExpandedChildHeight_default5
};
Object.assign(
  methods27,
  AddChildMethods_default5,
  RemoveChildMethods_default5,
  SortChildrenMethods_default
);
var Methods_default28 = methods27;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetMaxChildWidth.js
var GetMaxChildWidth = function(children) {
  if (children === void 0) {
    children = this.sizerChildren;
  }
  var result = 0;
  var child, childWidth;
  var hasUnknownChildWidth = false;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child === "\n") {
      continue;
    }
    childWidth = this.getChildWidth(child);
    if (childWidth === void 0) {
      hasUnknownChildWidth = true;
    }
    if (hasUnknownChildWidth) {
      continue;
    }
    result = Math.max(childWidth, result);
  }
  if (hasUnknownChildWidth) {
    return void 0;
  }
  return result;
};
var GetMaxChildWidth_default = GetMaxChildWidth;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/GetMaxChildHeight.js
var GetMaxChildHeight = function(children) {
  if (children === void 0) {
    children = this.sizerChildren;
  }
  var result = 0;
  var child, childHeight;
  var hasUnknownChildHeight = false;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child === "\n") {
      continue;
    }
    childHeight = this.getChildHeight(child);
    if (childHeight === void 0) {
      hasUnknownChildHeight = true;
    }
    if (hasUnknownChildHeight) {
      continue;
    }
    result = Math.max(childHeight, result);
  }
  if (hasUnknownChildHeight) {
    return void 0;
  }
  return result;
};
var GetMaxChildHeight_default = GetMaxChildHeight;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/FixWidthSizer.js
var IsPlainObject44 = Phaser.Utils.Objects.IsPlainObject;
var GetValue137 = Phaser.Utils.Objects.GetValue;
var FixWidthSizer = class extends BaseSizer_default {
  constructor(scene, x, y, minWidth, minHeight, config) {
    if (IsPlainObject44(x)) {
      config = x;
      x = GetValue137(config, "x", 0);
      y = GetValue137(config, "y", 0);
      minWidth = GetValue137(config, "width", void 0);
      minHeight = GetValue137(config, "height", void 0);
    } else if (IsPlainObject44(minWidth)) {
      config = minWidth;
      minWidth = GetValue137(config, "width", void 0);
      minHeight = GetValue137(config, "height", void 0);
    }
    super(scene, x, y, minWidth, minHeight, config);
    this.type = "rexFixWidthSizer";
    this.sizerChildren = [];
    this.runChildrenWrapFlag = true;
    this.setOrientation(GetValue137(config, "orientation", 0));
    this.setItemSpacing(GetValue137(config, "space.item", 0));
    this.setLineSpacing(GetValue137(config, "space.line", 0));
    this.setIntentLeft(
      GetValue137(config, "space.indentLeftOdd", 0),
      GetValue137(config, "space.indentLeftEven", 0)
    );
    this.setIntentTop(
      GetValue137(config, "space.indentTopOdd", 0),
      GetValue137(config, "space.indentTopEven", 0)
    );
    this.setAlign(GetValue137(config, "align", 0));
    this.setJustifyPercentage(GetValue137(config, "justifyPercentage", 0.25));
    this.setRTL(GetValue137(config, "rtl", false));
    this.wrapResult = void 0;
    this.addChildrenMap("items", this.sizerChildren);
  }
  setOrientation(orientation) {
    this.orientation = GetOrientationMode_default2(orientation);
    return this;
  }
  setItemSpacing(space) {
    this.space.item = space;
    return this;
  }
  setLineSpacing(space) {
    this.space.line = space;
    return this;
  }
  setIntentLeft(odd, even) {
    this.space.indentLeftOdd = odd;
    this.space.indentLeftEven = even;
    return this;
  }
  setIntentTop(odd, even) {
    this.space.indentTopOdd = odd;
    this.space.indentTopEven = even;
    return this;
  }
  setAlign(align) {
    if (typeof align === "string") {
      align = ALIGN2[align];
    }
    this.align = align;
    return this;
  }
  setJustifyPercentage(value) {
    this.justifyPercentage = value;
    return this;
  }
  setRTL(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.rtl = enabled;
    return this;
  }
  get maxChildWidth() {
    if (this._maxChildWidth === void 0) {
      this._maxChildWidth = GetMaxChildWidth_default.call(this);
    }
    return this._maxChildWidth;
  }
  get maxChildHeight() {
    if (this._maxChildHeight === void 0) {
      this._maxChildHeight = GetMaxChildHeight_default.call(this);
    }
    return this._maxChildHeight;
  }
};
var ALIGN2 = {
  left: 0,
  top: 0,
  right: 1,
  bottom: 1,
  center: 2,
  justify: 3,
  "justify-left": 3,
  "justify-top": 3,
  "justify-right": 4,
  "justify-bottom": 4,
  "justify-center": 5
};
Object.assign(
  FixWidthSizer.prototype,
  Methods_default28
);
var FixWidthSizer_default = FixWidthSizer;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthsizer/Factory.js
ObjectFactory_default.register("fixWidthSizer", function(x, y, minWidth, minHeight, config) {
  var gameObject2 = new FixWidthSizer_default(this.scene, x, y, minWidth, minHeight, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.FixWidthSizer", FixWidthSizer_default);

// node_modules/phaser3-rex-plugins/templates/ui/overlapsizer/Factory.js
ObjectFactory_default.register("overlapSizer", function(x, y, minWidth, minHeight, config) {
  var gameObject2 = new OverlapSizer_default(this.scene, x, y, minWidth, minHeight, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.OverlapSizer", OverlapSizer_default);

// node_modules/phaser3-rex-plugins/templates/ui/space/Factory.js
ObjectFactory_default.register("space", function() {
  var gameObject2 = new Space_default2(this.scene);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Space", Space_default2);

// node_modules/phaser3-rex-plugins/templates/ui/label/Factory.js
ObjectFactory_default.register("label", function(config) {
  var gameObject2 = new Label_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Label", Label_default);

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/DecorateGameObject.js
var Properties = [
  "alpha",
  "tint",
  "flipX",
  "flipY"
];
var DecorateGameObject = function(gameObject2, config) {
  if (!config) {
    return gameObject2;
  }
  for (var i = 0, cnt = Properties.length; i < cnt; i++) {
    var propertyName = Properties[i];
    if (propertyName in config && propertyName in gameObject2) {
      gameObject2[propertyName] = config[propertyName];
    }
  }
  if ("origin" in config && "originX" in gameObject2) {
    gameObject2.setOrigin(config.origin);
  } else {
    var originX, originY;
    if ("originX" in config && "originX" in gameObject2) {
      originX = config.originX;
    }
    if ("originY" in config && "originY" in gameObject2) {
      originY = config.originY;
    }
    if (originX !== void 0 && originY !== void 0) {
      gameObject2.setOrigin(originX, originY);
    }
  }
  return gameObject2;
};
var DecorateGameObject_default = DecorateGameObject;

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateBackground.js
var CreateBackground = function(scene, config) {
  var gameObjectType;
  if (config) {
    if (config.hasOwnProperty("$type")) {
      gameObjectType = config.$type;
    } else {
      if (config.hasOwnProperty("barColor")) {
        gameObjectType = "bar";
      } else if (config.hasOwnProperty("leftWidth")) {
        gameObjectType = "nineSlice";
      } else if (config.hasOwnProperty("key")) {
        gameObjectType = "image";
      }
    }
  }
  var gameObject2;
  switch (gameObjectType) {
    case "bar":
      gameObject2 = new StatesBarRectangle_default(scene, config);
      break;
    case "image":
      gameObject2 = new StatesImage_default(scene, config);
      break;
    case "nineSlice":
      if (!config.hasOwnProperty("stretchMode")) {
        gameObject2 = new StatesNineSlice_default(scene, config);
      } else {
        gameObject2 = new StatesNinePatch_default(scene, config);
      }
      break;
    default:
      gameObject2 = new StatesRoundRectangle_default(scene, config);
      break;
  }
  DecorateGameObject_default(gameObject2, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateBackground_default = CreateBackground;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/ResizeController.js
var ResizeController = function() {
  switch (this.scrollMode) {
    case 0:
    case 1:
      SetControllerBounds.call(this);
      this.updateController();
      HideUnscrollableSlider.call(this);
      AdaptThumbSize.call(this);
      break;
    default:
      SetControllerBounds.call(this, "y");
      SetControllerBounds.call(this, "x");
      this.updateController();
      HideUnscrollableSlider.call(this, "y");
      HideUnscrollableSlider.call(this, "x");
      AdaptThumbSize.call(this, "y");
      AdaptThumbSize.call(this, "x");
      break;
  }
  return this;
};
var SetControllerBounds = function(axis) {
  var bound0, bound1;
  var scroller, slider;
  switch (this.scrollMode) {
    case 0:
    case 1:
      bound0 = this.topChildOY;
      bound1 = this.bottomChildOY;
      scroller = this.childrenMap.scroller;
      slider = this.childrenMap.slider;
      axis = this.scrollMode === 0 ? "Y" : "X";
      break;
    default:
      axis = axis.toUpperCase();
      if (axis === "Y") {
        bound0 = this.topChildOY;
        bound1 = this.bottomChildOY;
      } else {
        bound0 = this.leftChildOX;
        bound1 = this.rightChildOX;
      }
      scroller = this.childrenMap[`scroller${axis}`];
      slider = this.childrenMap[`slider${axis}`];
  }
  var scale = axis === "Y" ? this.scaleY : this.scaleX;
  bound1 *= scale;
  if (scroller) {
    scroller.setBounds(bound0, bound1);
  }
  if (slider) {
    slider.setEnable(bound0 !== bound1);
    if (slider.tickLength) {
      slider.setTick(slider.tickLength, bound0, bound1);
    }
  }
};
var HideUnscrollableSlider = function(axis) {
  switch (this.scrollMode) {
    case 0:
    case 1:
      var slider = this.childrenMap.slider;
      if (slider && this.hideUnscrollableSlider) {
        this.setChildVisible(slider, this.isOverflow);
      }
      var scroller = this.childrenMap.scroller;
      if (scroller && this.disableUnscrollableDrag) {
        scroller.setEnable(this.isOverflow);
      }
      break;
    default:
      axis = axis.toUpperCase();
      var isOverflow = this[`isOverflow${axis}`];
      var slider = this.childrenMap[`slider${axis}`];
      var hideUnscrollableSlider = this[`hideUnscrollableSlider${axis}`];
      if (slider && hideUnscrollableSlider) {
        this.setChildVisible(slider, isOverflow);
      }
      var scroller = this.childrenMap.scroller;
      var disableUnscrollableDrag = this[`disableUnscrollableDrag${axis}`];
      if (scroller && disableUnscrollableDrag) {
        scroller.setEnable(isOverflow);
      }
      break;
  }
};
var AdaptThumbSize = function(axis) {
  switch (this.scrollMode) {
    case 0:
    case 1:
      if (!this.adaptThumbSizeMode) {
        return;
      }
      var slider = this.childrenMap.slider;
      if (!slider) {
        return;
      }
      var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
      var track = slider.childrenMap.track;
      var thumb = slider.childrenMap.thumb;
      var minThumbSize = this.minThumbSize;
      if (this.scrollMode === 0) {
        var newHeight = track.displayHeight * ratio;
        if (minThumbSize !== void 0 && newHeight < minThumbSize) {
          newHeight = minThumbSize;
        }
        ResizeGameObject_default(thumb, void 0, newHeight);
      } else {
        var newWidth = track.displayWidth * ratio;
        if (minThumbSize !== void 0 && newWidth < minThumbSize) {
          newWidth = minThumbSize;
        }
        ResizeGameObject_default(thumb, newWidth, void 0);
      }
      LayoutSlider(slider);
      break;
    default:
      axis = axis.toUpperCase();
      var adaptThumbSizeMode = this[`adaptThumb${axis}SizeMode`];
      if (!adaptThumbSizeMode) {
        return;
      }
      var slider = this.childrenMap[`slider${axis}`];
      if (!slider) {
        return;
      }
      var track = slider.childrenMap.track;
      var thumb = slider.childrenMap.thumb;
      var minThumbSize = this[`minThumb${axis}Size`];
      if (axis === "Y") {
        var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
        var newHeight = track.displayHeight * ratio;
        if (minThumbSize !== void 0 && newHeight < minThumbSize) {
          newHeight = minThumbSize;
        }
        ResizeGameObject_default(thumb, void 0, newHeight);
      } else {
        var ratio = Math.min(this.childVisibleWidth / this.childWidth, 1);
        var newWidth = track.displayWidth * ratio;
        if (minThumbSize !== void 0 && newWidth < minThumbSize) {
          newWidth = minThumbSize;
        }
        ResizeGameObject_default(thumb, newWidth, void 0);
      }
      LayoutSlider(slider);
      break;
  }
};
var LayoutSlider = function(slider) {
  var minWidthSave = slider.minWidth;
  var minHeightSave = slider.minHeight;
  slider.minWidth = slider.width;
  slider.minHeight = slider.height;
  slider.layout();
  slider.minWidth = minWidthSave;
  slider.minHeight = minHeightSave;
};
var ResizeController_default = ResizeController;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/UpdateController.js
var UpdateController = function() {
  switch (this.scrollMode) {
    case 0:
    case 1:
      var scroller = this.childrenMap.scroller;
      var slider = this.childrenMap.slider;
      if (scroller) {
        scroller.setValue(this.childOY);
      }
      if (slider) {
        slider.setValue(this.t);
      }
      break;
    default:
      var scrollerY = this.childrenMap.scrollerY;
      var sliderY = this.childrenMap.sliderY;
      var scrollerX = this.childrenMap.scrollerX;
      var sliderX = this.childrenMap.sliderX;
      if (scrollerY) {
        scrollerY.setValue(this.childOY);
      }
      if (sliderY) {
        sliderY.setValue(this.t);
      }
      if (scrollerX) {
        scrollerX.setValue(this.childOX);
      }
      if (sliderX) {
        sliderX.setValue(this.s);
      }
      break;
  }
};
var UpdateController_default = UpdateController;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/ChildPositionMethods.js
var Clamp9 = Phaser.Math.Clamp;
var ChildPositionMethods_default = {
  setChildOY(value, clamp) {
    if (clamp === void 0) {
      clamp = false;
    }
    if (clamp) {
      value = Clamp9(value, this.bottomChildOY, this.topChildOY);
    }
    this.childOY = value;
    return this;
  },
  addChildOY(inc, clamp) {
    this.setChildOY(this.childOY + inc, clamp);
    return this;
  },
  setT(value, clamp) {
    if (clamp === void 0) {
      clamp = false;
    }
    if (clamp) {
      value = Clamp9(value, 0, 1);
    }
    this.t = value;
    return this;
  },
  addT(inc, clamp) {
    this.setT(this.t + inc, clamp);
    return this;
  },
  scrollToTop() {
    this.t = 0;
    return this;
  },
  scrollToBottom() {
    this.t = 1;
    if (this.t === 0) {
      return this;
    }
    do {
      this.t = 1;
    } while (this.t !== 1);
    return this;
  },
  setChildOX(value, clamp) {
    if (clamp === void 0) {
      clamp = false;
    }
    if (clamp) {
      value = Clamp9(value, this.leftChildOX, this.rightChildOX);
    }
    this.childOX = value;
    return this;
  },
  addChildOX(inc, clamp) {
    this.setChildOX(this.childOX + inc, clamp);
    return this;
  },
  setS(value, clamp) {
    if (clamp === void 0) {
      clamp = false;
    }
    if (clamp) {
      value = Clamp9(value, 0, 1);
    }
    this.s = value;
    return this;
  },
  addS(inc, clamp) {
    this.setS(this.s + inc, clamp);
    return this;
  },
  scrollToLeft() {
    this.s = 0;
    return this;
  },
  scrollToRight() {
    this.s = 1;
    if (this.s === 0) {
      return this;
    }
    do {
      this.s = 1;
    } while (this.s !== 1);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/Methods.js
var Methods14 = {
  resizeController: ResizeController_default,
  updateController: UpdateController_default
};
Object.assign(
  Methods14,
  ChildPositionMethods_default
);
var Methods_default29 = Methods14;

// node_modules/phaser3-rex-plugins/templates/ui/utils/ScrollModeConst.js
var ScrollModeConst_default = {
  v: 0,
  vertical: 0,
  y: 0,
  h: 1,
  horizontal: 1,
  x: 1,
  xy: 2,
  vh: 2
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/GetScrollMode.js
var GetScrollMode = function(config, key2) {
  if (key2 === void 0) {
    key2 = "scrollMode";
  }
  if (!config.hasOwnProperty(key2)) {
    config[key2] = GetDefaultScrollMode(config);
  }
  var scrollMode = config[key2];
  if (typeof scrollMode === "string") {
    scrollMode = ScrollModeConst_default[scrollMode];
  }
  return scrollMode;
};
var GetDefaultScrollMode = function(config) {
  var hasSliderY = !!config.sliderY || !!config.scrollerY;
  var hasSliderX = !!config.sliderX || !!config.scrollerX;
  var scrollMode;
  if (hasSliderY && hasSliderX) {
    scrollMode = 2;
  } else if (hasSliderY) {
    scrollMode = 0;
  } else if (hasSliderX) {
    scrollMode = 1;
  } else {
    scrollMode = 0;
  }
  return scrollMode;
};
var GetScrollMode_default = GetScrollMode;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/AddChild.js
var GetValue138 = Phaser.Utils.Objects.GetValue;
var AddChild4 = function(topPatent, childParent, config) {
  var childConfig = GetValue138(config, "child");
  var child = GetValue138(childConfig, "gameObject", void 0);
  if (child) {
    var childSpace = GetValue138(config, "space.child", 0);
    topPatent.childMargin = {};
    var childMargin = topPatent.childMargin;
    var childPadding = {};
    if (typeof childSpace === "number") {
      switch (topPatent.scrollMode) {
        case 0:
        case 1:
          childMargin.top = 0;
          childMargin.bottom = 0;
          childMargin.left = 0;
          childMargin.right = 0;
          break;
        default:
          childMargin.top = childSpace;
          childMargin.bottom = childSpace;
          childMargin.left = childSpace;
          childMargin.right = childSpace;
          break;
      }
    } else {
      switch (topPatent.scrollMode) {
        case 0:
          childMargin.top = GetValue138(childSpace, "top", 0);
          childMargin.bottom = GetValue138(childSpace, "bottom", 0);
          childPadding.left = GetValue138(childSpace, "left", 0);
          childPadding.right = GetValue138(childSpace, "right", 0);
          break;
        case 1:
          childMargin.top = GetValue138(childSpace, "left", 0);
          childMargin.bottom = GetValue138(childSpace, "right", 0);
          childPadding.top = GetValue138(childSpace, "top", 0);
          childPadding.bottom = GetValue138(childSpace, "bottom", 0);
          break;
        default:
          childMargin.top = GetValue138(childSpace, "top", 0);
          childMargin.bottom = GetValue138(childSpace, "bottom", 0);
          childMargin.left = GetValue138(childSpace, "left", 0);
          childMargin.right = GetValue138(childSpace, "right", 0);
          break;
      }
    }
    childParent.add(
      child,
      {
        column: 1,
        row: 1,
        align: GetValue138(childConfig, "align", "center"),
        padding: childPadding,
        expand: {
          width: GetValue138(childConfig, "expandWidth", true),
          // Private
          height: GetValue138(childConfig, "expandHeight", true)
          // Private
        }
      }
    );
  }
  topPatent.addChildrenMap("child", child);
};
var AddChild_default5 = AddChild4;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/PositionToPercent.js
var Percent3 = Phaser.Math.Percent;
var PositionToPercent = function(startPoint, endPoint, currentPoint) {
  var value;
  if (startPoint.y === endPoint.y) {
    value = Percent3(currentPoint.x, startPoint.x, endPoint.x);
  } else if (startPoint.x === endPoint.x) {
    value = Percent3(currentPoint.y, startPoint.y, endPoint.y);
  }
  return value;
};
var PositionToPercent_default = PositionToPercent;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/input/GetValueByPosition.js
var GetValueByPosition = function(x, y) {
  tmpPoint.x = x;
  tmpPoint.y = y;
  var startPoint, endPoint;
  if (!this.reverseAxis) {
    startPoint = this.getStartPoint();
    endPoint = this.getEndPoint();
  } else {
    startPoint = this.getEndPoint();
    endPoint = this.getStartPoint();
  }
  var value = PositionToPercent_default(startPoint, endPoint, tmpPoint);
  return value;
};
var tmpPoint = {};
var GetValueByPosition_default = GetValueByPosition;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/input/OnDragThumb.js
var OnDragThumb = function(pointer, dragX, dragY) {
  if (!this.enable || !this.inputActive) {
    return;
  }
  this.value = GetValueByPosition_default.call(this, dragX, dragY);
};
var OnDragThumb_default = OnDragThumb;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/input/OnTouchTrack.js
var OnTouchTrack = function(pointer) {
  if (!this.enable || !this.inputActive) {
    return;
  }
  if (!pointer.isDown) {
    return;
  }
  var value = GetValueByPosition_default.call(this, pointer.worldX, pointer.worldY);
  this.stopEaseValue();
  if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
    this.value = value;
  } else {
    this.easeValueTo(value);
  }
};
var OnTouchTrack_default = OnTouchTrack;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/input/RegisterInputEvents.js
var GetValue139 = Phaser.Utils.Objects.GetValue;
var RegisterInputEvents = function(config) {
  this.inputActive = false;
  var inputMode = GetValue139(config, "input", 0);
  if (typeof inputMode === "string") {
    inputMode = INPUTMODE2[inputMode];
  }
  var thumb = this.childrenMap.thumb;
  switch (inputMode) {
    case 0:
      if (thumb) {
        thumb.setInteractive();
        this.scene.input.setDraggable(thumb);
        thumb.on("dragstart", function(pointer) {
          this.inputActive = true;
          this.eventEmitter.emit("inputstart", pointer);
        }, this).on("dragend", function(pointer) {
          this.inputActive = false;
          this.eventEmitter.emit("inputend", pointer);
        }, this).on("drag", OnDragThumb_default, this);
      }
      break;
    case 1:
      this.setInteractive().on("pointerdown", function(pointer) {
        this.inputActive = true;
        this.eventEmitter.emit("inputstart", pointer);
      }, this).on("pointerdown", OnTouchTrack_default, this);
      var OnReleaseTrack = function(pointer) {
        if (!this.inputActive) {
          return;
        }
        this.inputActive = false;
        this.eventEmitter.emit("inputend", pointer);
      };
      this.scene.input.on("pointerup", OnReleaseTrack, this).on("pointermove", OnTouchTrack_default, this);
      this.once("destroy", function() {
        this.scene.input.on("pointerup", OnReleaseTrack, this).off("pointermove", OnTouchTrack_default, this);
      }, this);
      break;
  }
};
var INPUTMODE2 = {
  pan: 0,
  drag: 0,
  click: 1,
  none: -1
};
var RegisterInputEvents_default = RegisterInputEvents;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/GetThumbAlignPoint.js
var GetThumbAlignPoint = function(align, out2) {
  if (out2 === void 0) {
    out2 = tmpPoint2;
  }
  var thumb = this.childrenMap.thumb;
  var currentX = thumb.x;
  var currentY = thumb.y;
  AlignIn_default(thumb, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, align);
  out2.x = thumb.x;
  out2.y = thumb.y;
  thumb.x = currentX;
  thumb.y = currentY;
  return out2;
};
var tmpPoint2 = {};
var GetThumbAlignPoint_default = GetThumbAlignPoint;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/GetStartPoint.js
var AlignLeft = Phaser.Display.Align.LEFT_CENTER;
var AlignTop = Phaser.Display.Align.TOP_CENTER;
var GetStartPoint = function(out2) {
  if (out2 === void 0) {
    out2 = tmpPoint3;
  }
  if (this.childrenMap.thumb) {
    var align = this.orientation === 0 ? AlignLeft : AlignTop;
    GetThumbAlignPoint_default.call(this, align, out2);
  } else {
    if (this.orientation === 0) {
      out2.x = this.innerLeft + 1;
      out2.y = this.centerY;
    } else {
      out2.x = this.centerX;
      out2.y = this.innerTop + 1;
    }
  }
  return out2;
};
var tmpPoint3 = {};
var GetStartPoint_default = GetStartPoint;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/GetEndPoint.js
var AlignRight = Phaser.Display.Align.RIGHT_CENTER;
var AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;
var GetEndoint = function(out2) {
  if (out2 === void 0) {
    out2 = tmpPoint4;
  }
  if (this.childrenMap.thumb) {
    var align = this.orientation === 0 ? AlignRight : AlignBottom;
    GetThumbAlignPoint_default.call(this, align, out2);
  } else {
    if (this.orientation === 0) {
      out2.x = this.innerRight - 1;
      out2.y = this.centerY;
    } else {
      out2.x = this.centerX;
      out2.y = this.innerBottom - 1;
    }
  }
  return out2;
};
var tmpPoint4 = {};
var GetEndPoint_default = GetEndoint;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/PercentToPosition.js
var Linear24 = Phaser.Math.Linear;
var PercentToPosition = function(t, startPoint, endPoint, out2) {
  if (out2 === void 0) {
    out2 = tmpOut;
  }
  out2.x = Linear24(startPoint.x, endPoint.x, t);
  out2.y = Linear24(startPoint.y, endPoint.y, t);
  return out2;
};
var tmpOut = {};
var PercentToPosition_default = PercentToPosition;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/UpdateThumb.js
var UpdateThumb = function(t) {
  var thumb = this.childrenMap.thumb;
  if (thumb === void 0) {
    return this;
  }
  if (t === void 0) {
    t = this.value;
  }
  var startPoint, endPoint;
  if (!this.reverseAxis) {
    startPoint = this.getStartPoint();
    endPoint = this.getEndPoint();
  } else {
    startPoint = this.getEndPoint();
    endPoint = this.getStartPoint();
  }
  PercentToPosition_default(t, startPoint, endPoint, thumb);
  thumb.x += this.thumbOffsetX;
  thumb.y += this.thumbOffsetY;
  this.resetChildPositionState(thumb);
  return this;
};
var UpdateThumb_default = UpdateThumb;

// node_modules/phaser3-rex-plugins/templates/ui/slider/methods/UpdateIndicator.js
var AlignLeft2 = Phaser.Display.Align.LEFT_CENTER;
var AlignTop2 = Phaser.Display.Align.TOP_CENTER;
var AlignRight2 = Phaser.Display.Align.RIGHT_CENTER;
var AlignBottom2 = Phaser.Display.Align.BOTTOM_CENTER;
var UpdateIndicator = function(t) {
  var indicator = this.childrenMap.indicator;
  if (indicator === void 0) {
    return this;
  }
  if (t === void 0) {
    t = this.value;
  }
  var reverseAxis = this.reverseAxis;
  var newWidth, newHeight;
  var thumb = this.childrenMap.thumb;
  if (thumb) {
    if (this.orientation === 0) {
      var thumbWidth = GetDisplayWidth(thumb);
      if (!reverseAxis) {
        var thumbLeft = thumb.x - thumbWidth * thumb.originX;
        var thumbRight = thumbLeft + thumbWidth;
        newWidth = thumbRight - this.left;
      } else {
        var thumbLeft = thumb.x - thumbWidth * thumb.originX;
        newWidth = this.right - thumbLeft;
      }
    } else {
      var thumbHeight = GetDisplayHeight(thumb);
      if (!reverseAxis) {
        var thumbTop = thumb.y - thumbHeight * thumb.originY;
        var thumbBottom = thumbTop + thumbHeight;
        newHeight = thumbBottom - this.top;
      } else {
        var thumbTop = thumb.y - thumbHeight * thumb.originY;
        newHeight = this.bottom - thumbTop;
      }
    }
  } else {
    if (this.orientation === 0) {
      newWidth = this.width * t;
    } else {
      newHeight = this.height * t;
    }
  }
  ResizeGameObject_default(indicator, newWidth, newHeight);
  var align;
  if (!reverseAxis) {
    align = this.orientation === 0 ? AlignLeft2 : AlignTop2;
  } else {
    align = this.orientation === 0 ? AlignRight2 : AlignBottom2;
  }
  QuickSet_default(indicator, this, align);
  this.resetChildPositionState(indicator);
};
var UpdateIndicator_default = UpdateIndicator;

// node_modules/phaser3-rex-plugins/templates/ui/slider/Slider.js
var GetValue140 = Phaser.Utils.Objects.GetValue;
var IsPlainObject45 = Phaser.Utils.Objects.IsPlainObject;
var Clamp10 = Phaser.Math.Clamp;
var SnapTo2 = Phaser.Math.Snap.To;
var Slider = class extends ProgressBase_default(Sizer_default) {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexSlider";
    this.bootProgressBase(config);
    this.reverseAxis = GetValue140(config, "reverseAxis", false);
    var background = GetValue140(config, "background", void 0);
    var track = GetValue140(config, "track", void 0);
    var indicator = GetValue140(config, "indicator", void 0);
    var thumb = GetValue140(config, "thumb", void 0);
    if (background) {
      if (IsPlainObject45(background)) {
        background = CreateBackground_default(scene, background);
      }
      this.addBackground(background);
    }
    if (track) {
      if (IsPlainObject45(track)) {
        track = CreateBackground_default(scene, track);
      }
      this.add(
        track,
        {
          proportion: 1,
          expand: true,
          minWidth: this.orientation === 0 ? 0 : void 0,
          minHeight: this.orientation === 1 ? 0 : void 0
        }
      );
    }
    if (indicator) {
      if (IsPlainObject45(indicator)) {
        indicator = CreateBackground_default(scene, indicator);
      }
      this.pin(indicator);
    }
    if (thumb) {
      if (IsPlainObject45(thumb)) {
        thumb = CreateBackground_default(scene, thumb);
      }
      this.pin(thumb);
      var thumbOffsetX = GetValue140(config, "thumbOffsetX", 0);
      var thumbOffsetY = GetValue140(config, "thumbOffsetY", 0);
      this.setThumbOffset(thumbOffsetX, thumbOffsetY);
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("track", track);
    this.addChildrenMap("indicator", indicator);
    this.addChildrenMap("thumb", thumb);
    this.setEnable(GetValue140(config, "enable", void 0));
    var gap = GetValue140(config, "tick", void 0);
    if (gap === void 0) {
      gap = GetValue140(config, "gap", void 0);
    }
    this.setGap(gap);
    RegisterInputEvents_default.call(this, config);
    this.setValue(GetValue140(config, "value", 0), GetValue140(config, "min", void 0), GetValue140(config, "max", void 0));
  }
  setEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.enable = enable;
    return this;
  }
  setGap(gap, min, max) {
    if (gap && min !== void 0) {
      gap = gap / (max - min);
    }
    this.gap = gap;
    return this;
  }
  setTick(tick, min, max) {
    this.setGap(tick, min, max);
    return this;
  }
  get tick() {
    return this.gap;
  }
  set tick(value) {
    this.gap = value;
  }
  setThumbOffset(x, y) {
    this.thumbOffsetX = x;
    this.thumbOffsetY = y;
    return this;
  }
  // Override
  get value() {
    return this._value;
  }
  // Override
  set value(value) {
    if (this.gap !== void 0) {
      value = SnapTo2(value, this.gap);
    }
    var oldValue = this._value;
    this._value = Clamp10(value, 0, 1);
    if (oldValue !== this._value) {
      this.updateThumb(this._value);
      this.updateIndicator(this._value);
      this.eventEmitter.emit("valuechange", this._value, oldValue, this.eventEmitter);
    }
  }
  postLayout(parent, newWidth, newHeight) {
    this.updateThumb();
    this.updateIndicator();
    super.postLayout(parent, newWidth, newHeight);
    return this;
  }
};
var methods28 = {
  getStartPoint: GetStartPoint_default,
  getEndPoint: GetEndPoint_default,
  updateThumb: UpdateThumb_default,
  updateIndicator: UpdateIndicator_default
};
Object.assign(
  Slider.prototype,
  methods28
);
var Slider_default = Slider;

// node_modules/phaser3-rex-plugins/templates/ui/scrollbar/ScrollBar.js
var GetValue141 = Phaser.Utils.Objects.GetValue;
var ScrollBar = class extends Sizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexScrollBar";
    var background = GetValue141(config, "background", void 0);
    var buttonsConfig = GetValue141(config, "buttons", void 0);
    var button0 = GetValue141(buttonsConfig, "top", GetValue141(buttonsConfig, "left", void 0));
    var button1 = GetValue141(buttonsConfig, "bottom", GetValue141(buttonsConfig, "right", void 0));
    var slider, sliderConfig = GetValue141(config, "slider", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (button0) {
      this.add(button0);
      var inTouching = new InTouching_default2(button0);
      inTouching.on("intouch", function() {
        if (!this.enable) {
          return;
        }
        var step = !slider.reverseAxis ? -this.scrollStep : this.scrollStep;
        this.value += step;
      }, this);
    }
    if (sliderConfig) {
      sliderConfig.orientation = this.orientation;
      sliderConfig.eventEmitter = this;
      sliderConfig.value = null;
      var proportion;
      if (this.orientation === 0) {
        var sliderWidth = GetValue141(sliderConfig, "width", void 0);
        proportion = sliderWidth === void 0 ? 1 : 0;
      } else {
        var sliderHeight = GetValue141(sliderConfig, "height", void 0);
        proportion = sliderHeight === void 0 ? 1 : 0;
      }
      slider = new Slider_default(scene, sliderConfig);
      scene.add.existing(slider);
      this.add(
        slider,
        {
          proportion
        }
      );
    }
    if (button1) {
      this.add(button1);
      var inTouching = new InTouching_default2(button1);
      inTouching.on("intouch", function() {
        if (!this.enable) {
          return;
        }
        var step = !slider.reverseAxis ? this.scrollStep : -this.scrollStep;
        this.value += step;
      }, this);
    }
    var buttons = [button0, button1];
    this.addChildrenMap("background", background);
    this.addChildrenMap("slider", slider);
    this.addChildrenMap("buttons", buttons);
    var callback = GetValue141(config, "valuechangeCallback", null);
    if (callback !== null) {
      var scope = GetValue141(config, "valuechangeCallbackScope", void 0);
      this.on("valuechange", callback, scope);
    }
    this.setEnable(GetValue141(config, "enable", void 0));
    this.setValue(GetValue141(config, "value", 0));
    this.setScrollStep(GetValue141(buttonsConfig, "step", 0.01));
  }
  setScrollStep(value) {
    this.scrollStep = value;
    return this;
  }
  get enable() {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.enable;
    } else {
      return false;
    }
  }
  set enable(value) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setEnable(value);
    }
  }
  setEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.enable = enable;
    return this;
  }
  get value() {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.value;
    } else {
      return 0;
    }
  }
  set value(value) {
    if (!this.childrenMap.slider) {
      return;
    }
    this.childrenMap.slider.value = value;
  }
  setValue(value, min, max) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setValue(value, min, max);
    }
    return this;
  }
  addValue(inc, min, max) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.addValue(inc, min, max);
    }
    return this;
  }
  getValue(min, max) {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.getValue(min, max);
    } else {
      return 0;
    }
  }
  easeValueTo(value, min, max) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.easeValueTo(value, min, max);
    }
    return this;
  }
  stopEaseValue() {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.stopEaseValue();
    }
    return this;
  }
  setEaseValueDuration(duration) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setEaseValueDuration(duration);
    }
    return this;
  }
  setEaseValueFunction(ease) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setEaseValueFunction(ease);
    }
    return this;
  }
  setGap(gap, min, max) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setGap(gap, min, max);
    }
    return this;
  }
  get gap() {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.gap;
    }
    return void 0;
  }
  set gap(value) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.gap = value;
    }
  }
  setTick(tick, min, max) {
    this.setGap(tick, min, max);
    return this;
  }
  get tick() {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.tick;
    }
    return void 0;
  }
  set tick(value) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.tick = value;
    }
  }
};
var ScrollBar_default = ScrollBar;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/CreateScrollbar.js
var CreateScrollbar = function(scene, config) {
  if (config === void 0) {
    config = {};
  }
  var sliderConfig = Clone_default(config);
  config = {
    slider: sliderConfig
  };
  config.orientation = sliderConfig.orientation;
  delete sliderConfig.orientation;
  config.background = sliderConfig.background;
  delete sliderConfig.background;
  config.buttons = sliderConfig.buttons;
  delete sliderConfig.buttons;
  config.value = null;
  var scrollBar = new ScrollBar_default(scene, config);
  scene.add.existing(scrollBar);
  var slider = scrollBar.childrenMap.slider;
  scrollBar.addChildrenMap("track", slider.childrenMap.track);
  scrollBar.addChildrenMap("indicator", slider.childrenMap.indicator);
  scrollBar.addChildrenMap("thumb", slider.childrenMap.thumb);
  return scrollBar;
};
var CreateScrollbar_default = CreateScrollbar;

// node_modules/phaser3-rex-plugins/plugins/input/scroller/methods/StateActions.js
var SnapTo3 = Phaser.Math.Snap.To;
var Clamp11 = Phaser.Math.Clamp;
var OnDragStart = function() {
  this.emit("dragstart");
};
var OnDragEnd = function() {
  this.emit("dragend");
};
var Dragging = function() {
  this.value += this.dragDelta;
};
var OnSliding = function() {
  var start = this.value;
  var speed = this.dragSpeed;
  var snapStep = this.snapStep;
  var snapMode = !!snapStep;
  if (!snapMode) {
    if (speed === 0) {
      this._slowDown.stop();
      this._state.next();
    } else {
      var dec = this.slidingDeceleration;
      this._slowDown.init(start, speed > 0, speed, dec);
    }
  } else {
    var end = start;
    var dist = speed === 0 ? 0 : speed * speed / (2 * this.slidingDeceleration);
    end += speed > 0 ? dist : -dist;
    end = SnapTo3(end, snapStep, this.minValue);
    dist = Math.abs(end - start);
    if (dist > 0) {
      var dec;
      if (speed === 0) {
        dec = this.backDeceleration;
        speed = Math.sqrt(2 * dec * dist);
      } else {
        dec = speed * speed / (2 * dist);
        dec *= 0.99;
      }
      this._slowDown.init(start, void 0, speed, dec, end);
    } else {
      this._slowDown.stop();
      this._state.next();
    }
  }
};
var Sliding = function(time, delta) {
  delta *= 1e-3;
  var newValue = this._slowDown.update(delta).value;
  if (this.overMax(newValue)) {
    this.value = this.maxValue;
    this._slowDown.stop();
  } else if (this.overMin(newValue)) {
    this.value = this.minValue;
    this._slowDown.stop();
  } else {
    this.value = newValue;
  }
};
var OnBack = function() {
  var start = this.value;
  var end = this.outOfMinBound ? this.minValue : this.maxValue;
  var dist = Math.abs(end - start);
  var dec = this.backDeceleration;
  var speed = Math.sqrt(2 * dec * dist);
  this._slowDown.init(start, void 0, speed, dec, end);
};
var Back = function(time, delta) {
  delta *= 1e-3;
  this.value = this._slowDown.update(delta).value;
  if (!this._slowDown.isMoving) {
    this._state.next();
  }
};
var Stop2 = function() {
  this._slowDown.stop();
};

// node_modules/phaser3-rex-plugins/plugins/input/scroller/methods/State.js
var State2 = class extends fsm_default {
  constructor(parent, config) {
    super(config);
    this.parent = parent;
    this.init();
  }
  init() {
    this.start("IDLE");
  }
  // IDLE -> DRAGBEGIN|DRAG
  next_IDLE() {
    var nextState, parent = this.parent, dragState = parent.dragState;
    if (dragState.isDown) {
      nextState = parent.dragThreshold === 0 ? "DRAG" : "DRAGBEGIN";
    }
    return nextState;
  }
  update_IDLE(time, delta) {
    this.next();
  }
  // IDLE
  // DRAGBEGIN -> DRAG|IDLE
  next_DRAGBEGIN() {
    var nextState, parent = this.parent, dragState = parent.dragState;
    if (dragState.isDown) {
      nextState = dragState.pointer.getDistance() >= parent.dragThreshold ? "DRAG" : "DRAGBEGIN";
    } else {
      nextState = "IDLE";
    }
    return nextState;
  }
  update_DRAGBEGIN(time, delta) {
    this.next();
  }
  // DRAGBEGIN
  // DRAG -> BACK|SLIDE|IDLE
  next_DRAG() {
    var nextState, parent = this.parent, dragState = parent.dragState;
    if (dragState.isUp) {
      if (parent.outOfBounds) {
        nextState = "BACK";
      } else if (parent.slidingEnable) {
        nextState = "SLIDE";
      } else {
        nextState = "IDLE";
      }
    }
    return nextState;
  }
  update_DRAG(time, delta) {
    var parent = this.parent, dragState = parent.dragState;
    if (dragState.justMoved) {
      Dragging.call(parent);
    }
    this.next();
  }
  enter_DRAG() {
    OnDragStart.call(this.parent);
  }
  exit_DRAG() {
    OnDragEnd.call(this.parent);
  }
  // DRAG    
  // SLIDE -> DRAG|IDLE
  next_SLIDE() {
    var nextState, parent = this.parent, dragState = parent.dragState;
    if (dragState.isDown) {
      nextState = "DRAG";
    } else if (!parent.isSliding) {
      nextState = "IDLE";
    }
    return nextState;
  }
  enter_SLIDE() {
    OnSliding.call(this.parent);
  }
  exit_SLIDE() {
    Stop2.call(this.parent);
  }
  update_SLIDE(time, delta) {
    Sliding.call(this.parent, time, delta);
    this.next();
  }
  // SLIDE    
  // BACK -> DRAG|IDLE
  next_BACK() {
    var nextState, parent = this.parent, dragState = parent.dragState;
    if (dragState.isDown) {
      nextState = "DRAG";
    } else if (!parent.isPullBack) {
      nextState = "IDLE";
    }
    return nextState;
  }
  enter_BACK() {
    OnBack.call(this.parent);
  }
  exit_BACK() {
    Stop2.call(this.parent);
  }
  update_BACK(time, delta) {
    Back.call(this.parent, time, delta);
    this.next();
  }
  // BACK
};
var State_default2 = State2;

// node_modules/phaser3-rex-plugins/plugins/input/dragspeed/DragSpeed.js
var GetValue142 = Phaser.Utils.Objects.GetValue;
var DistanceBetween7 = Phaser.Math.Distance.Between;
var DragSpeed = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this._enable = void 0;
    this.rectBoundsInteractive = GetValue142(config, "rectBoundsInteractive", false);
    if (!this.rectBoundsInteractive) {
      gameObject2.setInteractive(GetValue142(config, "inputConfig", void 0));
    }
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.pointer = void 0;
    this.isInTouched = false;
    this.holdStartTime = void 0;
    this.x = void 0;
    this.y = void 0;
    this.preX = void 0;
    this.preY = void 0;
    this.localX = void 0;
    this.localY = void 0;
    this.justMoved = false;
    this.setEnable(GetValue142(o, "enable", true));
    this.holdThreshold = GetValue142(o, "holdThreshold", 50);
    this.pointerOutReleaseEnable = GetValue142(o, "pointerOutRelease", true);
    return this;
  }
  boot() {
    var scene = this.scene;
    var gameObject2 = this.parent;
    if (!this.rectBoundsInteractive) {
      gameObject2.on("pointerdown", this.onPointIn, this);
      gameObject2.on("pointerup", this.onPointOut, this);
      if (this.pointerOutReleaseEnable) {
        gameObject2.on("pointerout", this.onPointOut, this);
      }
      gameObject2.on("pointermove", this.onPointerMove, this);
    } else {
      scene.input.on("pointerdown", this.onPointIn, this);
      scene.input.on("pointerup", this.onPointOut, this);
      scene.input.on("pointermove", this.onPointerMove, this);
    }
    scene.sys.events.on("preupdate", this.preupdate, this);
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    var scene = this.scene;
    var gameObject2 = this.parent;
    if (!this.rectBoundsInteractive) {
    } else {
      scene.input.off("pointerdown", this.onPointIn, this);
      scene.input.off("pointerup", this.onPointOut, this);
      scene.input.off("pointermove", this.onPointerMove, this);
    }
    scene.sys.events.off("preupdate", this.preupdate, this);
    this.pointer = void 0;
    super.shutdown(fromScene);
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.isInTouched = false;
      this.pointer = void 0;
    }
    this._enable = e;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  setPointerOutReleaseEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.pointerOutReleaseEnable = enable;
    return this;
  }
  get isDown() {
    return this.pointer && this.pointer.isDown;
  }
  get isUp() {
    return !this.isDown;
  }
  get dx() {
    return this.x - this.preX;
  }
  get dy() {
    return this.y - this.preY;
  }
  get dt() {
    var delta = GetTickDelta_default(this.scene);
    return delta;
  }
  get speed() {
    if (this.x === this.preX && this.y === this.preY) {
      return 0;
    }
    var d = DistanceBetween7(this.preX, this.preY, this.x, this.y);
    var speed = d / (this.dt * 1e-3);
    return speed;
  }
  get speedX() {
    return this.dx / (this.dt * 1e-3);
  }
  get speedY() {
    return this.dy / (this.dt * 1e-3);
  }
  // internal
  onPointIn(pointer, localX, localY) {
    if (!this.enable || !pointer.isDown || this.pointer !== void 0) {
      return;
    }
    if (this.rectBoundsInteractive && !IsPointerInBounds_default(this.parent, pointer)) {
      return;
    }
    this.pointer = pointer;
    this.localX = localX;
    this.localY = localY;
  }
  onPointOut(pointer) {
    if (!this.enable || this.pointer !== pointer) {
      return;
    }
    this.pointer = void 0;
  }
  onPointerMove(pointer, localX, localY) {
    if (!this.enable || !pointer.isDown || this.pointer !== pointer) {
      return;
    }
    if (this.rectBoundsInteractive && this.pointerOutReleaseEnable && !IsPointerInBounds_default(this.parent, pointer)) {
      this.onPointOut(pointer);
      return;
    }
    this.localX = localX;
    this.localY = localY;
  }
  preupdate(time, delta) {
    if (!this.enable) {
      return;
    }
    var pointer = this.pointer;
    this.justMoved = false;
    if (pointer && !this.isInTouched) {
      this.x = pointer.worldX;
      this.y = pointer.worldY;
      this.preX = pointer.worldX;
      this.preY = pointer.worldY;
      this.isInTouched = true;
      this.holdStartTime = void 0;
      this.emit("touchstart", pointer, this.localX, this.localY);
    } else if (pointer && this.isInTouched) {
      if (this.x === pointer.x && this.y === pointer.y) {
        if (this.holdStartTime === void 0) {
          this.holdStartTime = time;
        } else if (time - this.holdStartTime > this.holdThreshold) {
          this.preX = this.x;
          this.preY = this.y;
        }
      } else {
        this.preX = this.x;
        this.preY = this.y;
        this.x = pointer.worldX;
        this.y = pointer.worldY;
        this.holdStartTime = void 0;
        this.justMoved = true;
        this.emit("touchmove", pointer, this.localX, this.localY);
      }
    } else if (!pointer && this.isInTouched) {
      this.isInTouched = false;
      this.holdStartTime = void 0;
      this.emit("touchend", pointer);
    }
  }
};
var DragSpeed_default = DragSpeed;

// node_modules/phaser3-rex-plugins/plugins/dragspeed.js
var dragspeed_default = DragSpeed_default;

// node_modules/phaser3-rex-plugins/plugins/utils/movement/Movement.js
var GetValue143 = Phaser.Utils.Objects.GetValue;
var Movement = class {
  constructor(config) {
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.setValue(GetValue143(o, "value", 0));
    this.setSpeed(GetValue143(o, "speed", 0));
    this.setAcceleration(GetValue143(o, "acceleration", 0));
    return this;
  }
  reset() {
    this.setValue(0);
    this.setSpeed(0);
    this.setAcceleration(0);
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  setSpeed(speed) {
    this.speed = speed;
    return this;
  }
  setAcceleration(acc) {
    this.acceleration = acc;
    return this;
  }
  updateSpeed(delta) {
    if (this.acceleration !== 0) {
      this.speed += this.acceleration * delta;
      if (this.speed < 0) {
        this.speed = 0;
      }
    }
    return this;
  }
  getDeltaValue(delta) {
    this.updateSpeed(delta);
    if (this.speed <= 0) {
      return 0;
    }
    return this.speed * delta;
  }
  update(delta) {
    this.updateSpeed(delta);
    if (this.speed > 0) {
      this.value += this.getDeltaValue(delta);
    }
    return this;
  }
  get isMoving() {
    return this.speed > 0;
  }
};
var Movement_default = Movement;

// node_modules/phaser3-rex-plugins/plugins/utils/movement/SlowDown.js
var SlowDown = class {
  constructor() {
    this.value;
    this.dir;
    this.movement = new Movement_default();
  }
  init(start, dir, speed, dec, end) {
    this.value = start;
    this.end = end;
    if (end !== void 0) {
      this.dir = start < end;
    } else {
      this.dir = dir;
    }
    speed = Math.abs(speed);
    this.movement.setSpeed(speed).setAcceleration(-dec);
    return this;
  }
  stop() {
    this.movement.reset();
  }
  update(delta) {
    var d = this.movement.getDeltaValue(delta);
    if (!this.dir) {
      d = -d;
    }
    if (this.end === void 0) {
      this.value += d;
    } else {
      if (d === 0) {
        this.value = this.end;
      } else {
        this.value += d;
        if (this.dir) {
          if (this.value > this.end) {
            this.value = this.end;
          }
        } else {
          if (this.value < this.end) {
            this.value = this.end;
          }
        }
      }
    }
    return this;
  }
  get isMoving() {
    return this.movement.isMoving;
  }
};
var SlowDown_default = SlowDown;

// node_modules/phaser3-rex-plugins/plugins/input/scroller/Scroller.js
var GetValue144 = Phaser.Utils.Objects.GetValue;
var Clamp12 = Phaser.Math.Clamp;
var Scroller = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    var enable = GetValue144(config, "enable", true);
    this._state = new State_default2(this, {
      enable,
      eventEmitter: false
    });
    var drapSpeedConfig = {
      rectBoundsInteractive: GetValue144(config, "rectBoundsInteractive", false),
      inputConfig: GetValue144(config, "inputConfig", void 0),
      enable,
      pointerOutRelease: GetValue144(config, "pointerOutRelease", true),
      eventEmitter: false
    };
    this.dragState = new dragspeed_default(gameObject2, drapSpeedConfig);
    this._enable = void 0;
    this._value = void 0;
    this._slowDown = new SlowDown_default();
    this.setSnapStep(GetValue144(config, "snapStep", void 0));
    var callback = GetValue144(config, "valuechangeCallback", null);
    if (callback !== null) {
      var scope = GetValue144(config, "valuechangeCallbackScope", void 0);
      this.on("valuechange", callback, scope);
    }
    callback = GetValue144(config, "overmaxCallback", null);
    if (callback !== null) {
      var scope = GetValue144(config, "overmaxCallbackScope", void 0);
      this.on("overmax", callback, scope);
    }
    callback = GetValue144(config, "overminCallback", null);
    if (callback !== null) {
      var scope = GetValue144(config, "overminCallbackScope", void 0);
      this.on("overmin", callback, scope);
    }
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.setOrientationMode(GetValue144(o, "orientation", 0));
    this.setDragThreshold(GetValue144(o, "threshold", 10));
    this.setSlidingDeceleration(GetValue144(o, "slidingDeceleration", 5e3));
    this.setBackDeceleration(GetValue144(o, "backDeceleration", 2e3));
    var dragRate = GetValue144(o, "dragRate", 1);
    dragRate = dragRate * (GetValue144(o, "dragReverse", false) ? -1 : 1);
    this.setDragRate(dragRate);
    var bounds = GetValue144(o, "bounds", void 0);
    if (bounds) {
      this.setBounds(bounds);
    } else {
      this.setBounds(GetValue144(o, "max", 0), GetValue144(o, "min", 0));
    }
    this.setValue(GetValue144(o, "value", this.maxValue || 0));
    this.setEnable(GetValue144(o, "enable", true));
    return this;
  }
  boot() {
    this.scene.sys.events.on("preupdate", this._state.update, this._state);
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.scene.sys.events.off("preupdate", this._state.update, this._state);
    this._state.destroy(fromScene);
    this.dragState.destroy(fromScene);
    this._state = void 0;
    this.dragState = void 0;
    super.shutdown(fromScene);
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    this._enable = e;
    this._state.setEnable(e);
    this.dragState.setEnable(e);
    return this;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  setOrientationMode(m) {
    if (typeof m === "string") {
      m = ORIENTATIONMODE[m];
    }
    this.orientationMode = m;
    return this;
  }
  setDragThreshold(distance) {
    this.dragThreshold = distance;
    return this;
  }
  setSlidingDeceleration(dec) {
    this.slidingDeceleration = dec;
    return this;
  }
  setBackDeceleration(dec) {
    this.backDeceleration = dec;
    return this;
  }
  setDragRate(ratio) {
    this.dragRate = ratio;
    return this;
  }
  setBounds(value0, value1) {
    if (Array.isArray(value0)) {
      var bounds = value0;
      value0 = bounds[0];
      value1 = bounds[1];
    }
    if (value0 < value1) {
      this.minValue = value0;
      this.maxValue = value1;
    } else {
      this.minValue = value1;
      this.maxValue = value0;
    }
    return this;
  }
  setSnapStep(snapStep) {
    this.snapStep = snapStep;
    return this;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (value === this._value) {
      return;
    }
    var oldValue = this._value;
    var isOverMax = this.overMax(value);
    var isOverMin = this.overMin(value);
    if (isOverMax) {
      this.emit("overmax", value, oldValue);
    }
    if (isOverMin) {
      this.emit("overmin", value, oldValue);
    }
    if (!this.backEnable) {
      if (isOverMax) {
        value = this.maxValue;
      }
      if (isOverMin) {
        value = this.minValue;
      }
    }
    this._value = value;
    this.emit("valuechange", value, oldValue);
  }
  setValue(value, clamp) {
    if (clamp === void 0) {
      clamp = false;
    }
    if (clamp) {
      value = Clamp12(value, this.minValue, this.maxValue);
    }
    this.value = value;
    return this;
  }
  addValue(inc, clamp) {
    this.setValue(this.value + inc, clamp);
    return this;
  }
  get state() {
    return this._state.state;
  }
  get isDragging() {
    return this.dragState.isInTouched;
  }
  get outOfMaxBound() {
    return this.overMax(this.value);
  }
  get outOfMinBound() {
    return this.overMin(this.value);
  }
  get outOfBounds() {
    return this.outOfMinBound || this.outOfMaxBound;
  }
  // internal
  overMax(value) {
    return this.maxValue != null && value > this.maxValue;
  }
  overMin(value) {
    return this.minValue != null && value < this.minValue;
  }
  get backEnable() {
    return typeof this.backDeceleration === "number";
  }
  get isPullBack() {
    return this._slowDown.isMoving;
  }
  get slidingEnable() {
    return typeof this.slidingDeceleration === "number";
  }
  get isSliding() {
    return this._slowDown.isMoving;
  }
  get dragDelta() {
    var delta;
    if (this.orientationMode === 0) {
      delta = this.dragState.dy;
    } else if (this.orientationMode === 1) {
      delta = this.dragState.dx;
    } else {
      delta = 0;
    }
    delta *= this.dragRate;
    return delta;
  }
  get dragSpeed() {
    var speed;
    if (this.orientationMode === 0) {
      speed = this.dragState.speedY;
    } else if (this.orientationMode === 1) {
      speed = this.dragState.speedX;
    } else {
      speed = 0;
    }
    speed *= this.dragRate;
    return speed;
  }
};
var ORIENTATIONMODE = {
  y: 0,
  v: 0,
  vertical: 0,
  x: 1,
  h: 1,
  horizontal: 1
};
var Scroller_default = Scroller;

// node_modules/phaser3-rex-plugins/plugins/scroller.js
var scroller_default = Scroller_default;

// node_modules/phaser3-rex-plugins/plugins/input/mousewheelscroller/MouseWheelScroller.js
var GetValue145 = Phaser.Utils.Objects.GetValue;
var MouseWheelScroller = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    if (this.parent !== this.scene) {
      this.focusMode = GetValue145(config, "focus", true);
    } else {
      this.focusMode = false;
    }
    if (typeof this.focusMode === "boolean") {
      this.focusMode = this.focusMode ? 1 : 0;
    }
    this.setSpeed(GetValue145(config, "speed", 0.1));
    this.setEnable(GetValue145(config, "enable", true));
    switch (this.focusMode) {
      case 0:
      case 2:
        this.scene.input.on("wheel", this.onSceneScroll, this);
        break;
      default:
        gameObject2.setInteractive(GetValue145(config, "inputConfig", void 0)).on("wheel", function(pointer, dx, dy, dz, event) {
          this.tryScroll(dy);
        }, this);
        break;
    }
  }
  destroy() {
    switch (this.focusMode) {
      case 0:
      case 2:
        this.scene.input.off("wheel", this.onSceneScroll, this);
        break;
      default:
        break;
    }
  }
  onSceneScroll(pointer, currentlyOver, dx, dy, dz, event) {
    if (this.focusMode === 2) {
      if (!IsPointerInBounds_default(this.parent, pointer)) {
        return;
      }
    }
    this.tryScroll(dy);
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  setSpeed(speed) {
    this.speed = speed;
    return this;
  }
  tryScroll(dy) {
    if (!this.enable) {
      return;
    }
    this.scroll(dy);
    return this;
  }
  scroll(dy) {
    dy *= this.speed;
    this.emit("scroll", dy, this.parent, this);
    return this;
  }
};
var MouseWheelScroller_default = MouseWheelScroller;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/AddSlider.js
var GetValue146 = Phaser.Utils.Objects.GetValue;
var SnapTo4 = Phaser.Math.Snap.To;
var AddSlider = function(topPatent, sliderParent, axis, config) {
  axis = axis.toUpperCase();
  var isAxisY = axis === "Y";
  var isScrollXYMode = topPatent.scrollMode === 2;
  var child = topPatent.childrenMap.child;
  var snapStep;
  var snapStepKey = `snapStep${axis}`;
  if (isScrollXYMode) {
    snapStep = GetValue146(config, snapStepKey, void 0);
  } else {
    var snapStep = GetValue146(config, "snapStep", void 0);
    if (snapStep === void 0) {
      snapStep = GetValue146(config, snapStepKey, void 0);
    }
  }
  topPatent[snapStepKey] = snapStep;
  var sliderConfig, slider;
  var sliderConfigKey = `slider${axis}`;
  if (isScrollXYMode) {
    sliderConfig = GetValue146(config, sliderConfigKey, void 0);
  } else {
    if (config.hasOwnProperty(sliderConfigKey)) {
      sliderConfig = GetValue146(config, sliderConfigKey, void 0);
    } else {
      sliderConfig = GetValue146(config, "slider", void 0);
    }
  }
  if (sliderConfig) {
    if (sliderConfig === true) {
      sliderConfig = {};
    }
    sliderConfig.orientation = isAxisY ? 1 : 0;
    slider = CreateScrollbar_default(topPatent.scene, sliderConfig);
    var column, row, padding;
    var sliderPosition = GetValue146(sliderConfig, "position", 0);
    if (typeof sliderPosition === "string") {
      sliderPosition = SLIDER_POSITION_MAP[sliderPosition];
    }
    var sliderPadding = GetValue146(config, `space.slider${axis}`, void 0);
    var childPadding;
    if (sliderPadding === void 0) {
      sliderPadding = GetValue146(config, "space.slider", void 0);
      if (sliderPadding === void 0) {
        if (isScrollXYMode) {
          sliderPadding = 0;
        } else {
          childPadding = GetValue146(config, "space.child", 0);
        }
      }
    }
    var isNumberSliderPadding;
    if (childPadding === void 0) {
      isNumberSliderPadding = typeof sliderPadding === "number";
    } else {
      isNumberSliderPadding = typeof childPadding === "number";
    }
    if (isAxisY) {
      if (sliderPosition === 0) {
        column = 2;
        row = 1;
        if (childPadding === void 0) {
          padding = isNumberSliderPadding ? { left: sliderPadding } : sliderPadding;
        } else {
          padding = { left: GetValue146(childPadding, "right", childPadding) };
        }
      } else {
        column = 0;
        row = 1;
        if (childPadding === void 0) {
          padding = isNumberSliderPadding ? { right: sliderPadding } : sliderPadding;
        } else {
          padding = { right: GetValue146(childPadding, "left", childPadding) };
        }
      }
    } else {
      if (sliderPosition === 0) {
        column = 1;
        row = 2;
        if (childPadding === void 0) {
          padding = isNumberSliderPadding ? { top: sliderPadding } : sliderPadding;
        } else {
          padding = { top: GetValue146(childPadding, "bottom", childPadding) };
        }
      } else {
        column = 1;
        row = 0;
        if (childPadding === void 0) {
          padding = isNumberSliderPadding ? { bottom: sliderPadding } : sliderPadding;
        } else {
          padding = { bottom: GetValue146(childPadding, "top", childPadding) };
        }
      }
    }
    sliderParent.add(
      slider,
      {
        column,
        row,
        align: "center",
        padding,
        expand: true
      }
    );
    topPatent[`hideUnscrollableSlider${axis}`] = GetValue146(sliderConfig, "hideUnscrollableSlider", false);
    topPatent[`disableUnscrollableDrag${axis}`] = GetValue146(sliderConfig, "disableUnscrollableDrag", false);
    topPatent[`adaptThumb${axis}SizeMode`] = GetValue146(sliderConfig, "adaptThumbSize", false);
    topPatent[`minThumb${axis}Size`] = GetValue146(sliderConfig, "minThumbSize", void 0);
  } else {
    topPatent[`hideUnscrollableSlider${axis}`] = false;
    topPatent[`disableUnscrollableDrag${axis}`] = false;
    topPatent[`adaptThumb${axis}SizeMode`] = false;
    topPatent[`minThumb${axis}Size`] = void 0;
  }
  var scrollDetectionMode = GetValue146(config, "scrollDetectionMode");
  if (typeof scrollDetectionMode === "string") {
    scrollDetectionMode = SCROLLDECTIONMODE_MAP[scrollDetectionMode];
  }
  var scrollerConfig, scroller;
  var scrollerConfigKey = `scroller${axis}`;
  if (isScrollXYMode) {
    scrollerConfig = GetValue146(config, scrollerConfigKey, true);
  } else {
    if (config.hasOwnProperty(scrollerConfigKey)) {
      scrollerConfig = GetValue146(config, scrollerConfigKey, true);
    } else {
      scrollerConfig = GetValue146(config, "scroller", true);
    }
  }
  if (scrollerConfig && child) {
    if (scrollerConfig === true) {
      scrollerConfig = {};
    }
    scrollerConfig.orientation = isAxisY ? 0 : 1;
    if (scrollDetectionMode !== void 0) {
      scrollerConfig.rectBoundsInteractive = scrollDetectionMode === 1;
    }
    scrollerConfig.snapStep = snapStep;
    scroller = new scroller_default(child, scrollerConfig);
    if (child.isRexContainerLite) {
      child.sendChildToBack(child);
    }
  }
  var mouseWheelScrollerConfig = GetValue146(config, isScrollXYMode ? `mouseWheelScroller${axis}` : "mouseWheelScroller", false), mouseWheelScroller;
  if (mouseWheelScrollerConfig && child) {
    if (scrollDetectionMode !== void 0) {
      mouseWheelScrollerConfig.focus = scrollDetectionMode === 1 ? 2 : 0;
    }
    mouseWheelScroller = new MouseWheelScroller_default(child, mouseWheelScrollerConfig);
  }
  topPatent.addChildrenMap(`slider${axis}`, slider);
  topPatent.addChildrenMap(`scroller${axis}`, scroller);
  topPatent.addChildrenMap(`mouseWheelScroller${axis}`, mouseWheelScroller);
  if (!isScrollXYMode || isAxisY) {
    topPatent["hideUnscrollableSlider"] = topPatent[`hideUnscrollableSlider${axis}`];
    topPatent["disableUnscrollableDrag"] = topPatent[`disableUnscrollableDrag${axis}`];
    topPatent["adaptThumbSizeMode"] = topPatent[`adaptThumb${axis}SizeMode`];
    topPatent["minThumbSize"] = topPatent[`minThumb${axis}Size`];
    topPatent.addChildrenMap("slider", slider);
    topPatent.addChildrenMap("scroller", scroller);
    topPatent.addChildrenMap("mouseWheelScroller", mouseWheelScroller);
  }
  if (slider) {
    var keyST, eventName;
    if (isScrollXYMode) {
      keyST = isAxisY ? "t" : "s";
      eventName = `scroll${axis}`;
    } else {
      keyST = "t";
      eventName = "scroll";
    }
    slider.on("valuechange", function(newValue) {
      topPatent[keyST] = newValue;
      topPatent.emit(eventName, topPatent);
    }).on("inputend", function() {
      var snapStep2 = topPatent[`snapStep${axis}`];
      if (snapStep2) {
        var min = topPatent[isAxisY ? `topChildOY` : `leftChildOX`];
        var max = topPatent[isAxisY ? `bottomChildOY` : `rightChildOX`];
        var valueEnd = topPatent[`childO${axis}`];
        var valueTo = SnapTo4(valueEnd, snapStep2, min);
        var easeDuration = 500 * (Math.abs(valueTo - valueEnd) / snapStep2);
        slider.setEaseValueDuration(easeDuration).easeValueTo(valueTo, min, max);
      }
    });
  }
  if (scroller) {
    var keyChildOXY, eventName;
    if (isScrollXYMode) {
      keyChildOXY = `childO${axis}`;
      eventName = `scroll${axis}`;
    } else {
      keyChildOXY = "childOY";
      eventName = "scroll";
    }
    scroller.on("valuechange", function(newValue) {
      topPatent[keyChildOXY] = newValue;
      topPatent.emit(eventName, topPatent);
    });
  }
  if (mouseWheelScroller) {
    var methodAddChildOXY;
    if (isScrollXYMode) {
      methodAddChildOXY = `addChildO${axis}`;
    } else {
      methodAddChildOXY = "addChildOY";
    }
    mouseWheelScroller.on("scroll", function(incValue) {
      var snapStep2 = topPatent[snapStepKey];
      if (snapStep2) {
        incValue = snapStep2;
      }
      topPatent[methodAddChildOXY](-incValue, true);
    });
  }
};
var SLIDER_POSITION_MAP = {
  right: 0,
  left: 1,
  bottom: 0,
  top: 1
};
var SCROLLDECTIONMODE_MAP = {
  gameObject: 0,
  rectBounds: 1
};
var AddSlider_default = AddSlider;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/methods/CreateScrollableSizer.js
var GetValue147 = Phaser.Utils.Objects.GetValue;
var CreateScrollableSizer = function(parent, config) {
  var scene = parent.scene;
  var columnProportions = [0, 1, 0], rowProportions = [0, 1, 0];
  var parentMinWidth = GetValue147(config, "width");
  var parentMinHeight = GetValue147(config, "height");
  if (!parentMinWidth) {
    var expandChildWidth = GetValue147(config, "child.expandWidth", true);
    if (!expandChildWidth) {
      columnProportions[1] = 0;
    }
  }
  if (!parentMinHeight) {
    var expandChildHeight = GetValue147(config, "child.expandHeight", true);
    if (!expandChildHeight) {
      rowProportions[1] = 0;
    }
  }
  var scrollableSizer = new GridSizer_default(scene, {
    column: 3,
    row: 3,
    columnProportions,
    rowProportions
  });
  AddChild_default5(parent, scrollableSizer, config);
  switch (parent.scrollMode) {
    case 0:
      AddSlider_default(parent, scrollableSizer, "y", config);
      break;
    case 1:
      AddSlider_default(parent, scrollableSizer, "x", config);
      break;
    default:
      AddSlider_default(parent, scrollableSizer, "y", config);
      AddSlider_default(parent, scrollableSizer, "x", config);
      break;
  }
  return scrollableSizer;
};
var CreateScrollableSizer_default = CreateScrollableSizer;

// node_modules/phaser3-rex-plugins/templates/ui/utils/scrollable/Scrollable.js
var GetValue148 = Phaser.Utils.Objects.GetValue;
var Scrollable = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var scrollMode = GetScrollMode_default(config);
    var isRevererXY = scrollMode === 1;
    config.orientation = !isRevererXY ? 1 : 0;
    super(scene, config);
    this.type = GetValue148(config, "type", "rexScrollable");
    this.scrollMode = scrollMode;
    var background = GetValue148(config, "background", void 0);
    if (background) {
      this.addBackground(background);
    }
    var header = GetValue148(config, "header", void 0);
    if (header) {
      var align = GetValue148(config, "align.header", "center");
      var headerSpace = GetValue148(config, "space.header", 0);
      var padding;
      if (!isRevererXY) {
        padding = { bottom: headerSpace };
      } else {
        padding = { right: headerSpace };
      }
      this.add(
        header,
        {
          proportion: 0,
          align,
          padding,
          expand: GetValue148(config, "expand.header", true)
        }
      );
    }
    var scrollableSizer = CreateScrollableSizer_default(this, config);
    if (scrollableSizer) {
      this.add(
        scrollableSizer,
        {
          proportion: 1,
          align: "center",
          padding: 0,
          expand: true
        }
      );
    }
    var footer = GetValue148(config, "footer", void 0);
    if (footer) {
      var align = GetValue148(config, "align.footer", "center");
      var footerSpace = GetValue148(config, "space.footer", 0);
      var padding;
      if (!isRevererXY) {
        padding = { top: footerSpace };
      } else {
        padding = { left: footerSpace };
      }
      this.add(
        footer,
        {
          proportion: 0,
          align,
          padding,
          expand: GetValue148(config, "expand.footer", true)
        }
      );
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("header", header);
    this.addChildrenMap("footer", footer);
    this.runLayoutFlag = false;
  }
  postLayout(parent, newWidth, newHeight) {
    var s = 0, t = 0;
    if (!this.runLayoutFlag) {
      this.runLayoutFlag = true;
    } else {
      t = this.t;
      if (this.scrollMode === 2) {
        s = this.s;
      }
    }
    this.resizeController();
    this.setT(t);
    if (this.scrollMode === 2) {
      this.setS(s);
    }
    super.postLayout(parent, newWidth, newHeight);
    return this;
  }
  set t(value) {
    var childMargin = this.childMargin;
    if (childMargin.top !== 0 || childMargin.bottom !== 0) {
      var child = this.childrenMap.child;
      var innerHeight = child.topChildOY - child.bottomChildOY;
      var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
      var innerChildOY = outerHeight * value - childMargin.top;
      value = innerHeight !== 0 ? innerChildOY / innerHeight : 0;
    }
    this.childrenMap.child.t = value;
    this.updateController();
  }
  get t() {
    var t = this.childrenMap.child.t;
    var childMargin = this.childMargin;
    if (childMargin.top !== 0 || childMargin.bottom !== 0) {
      var child = this.childrenMap.child;
      var innerHeight = child.topChildOY - child.bottomChildOY;
      var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
      var outerChildOY = innerHeight * t + childMargin.top;
      t = outerHeight !== 0 ? outerChildOY / outerHeight : 0;
    }
    return t;
  }
  set s(value) {
    var childMargin = this.childMargin;
    if (childMargin.left !== 0 || childMargin.right !== 0) {
      var child = this.childrenMap.child;
      var innerWidth = child.leftChildOX - child.rightChildOX;
      var outerWidth = innerWidth + childMargin.left + childMargin.right;
      var innerChildOX = outerWidth * value - childMargin.left;
      value = innerWidth !== 0 ? innerChildOX / innerWidth : 0;
    }
    this.childrenMap.child.s = value;
    this.updateController();
  }
  get s() {
    var s = this.childrenMap.child.s;
    var childMargin = this.childMargin;
    if (childMargin.left !== 0 || childMargin.right !== 0) {
      var child = this.childrenMap.child;
      var innerWidth = child.leftChildOX - child.rightChildOX;
      var outerWidth = innerWidth + childMargin.left + childMargin.right;
      var outerChildOX = innerWidth * s + childMargin.left;
      s = outerWidth !== 0 ? outerChildOX / outerWidth : 0;
    }
    return s;
  }
  set childOY(value) {
    this.childrenMap.child.childOY = value;
    this.updateController();
  }
  get childOY() {
    return this.childrenMap.child.childOY;
  }
  set childOX(value) {
    this.childrenMap.child.childOX = value;
    this.updateController();
  }
  get childOX() {
    return this.childrenMap.child.childOX;
  }
  get topChildOY() {
    return this.childrenMap.child.topChildOY + this.childMargin.top;
  }
  get bottomChildOY() {
    return this.childrenMap.child.bottomChildOY - this.childMargin.bottom;
  }
  get leftChildOX() {
    return this.childrenMap.child.leftChildOX + this.childMargin.left;
  }
  get rightChildOX() {
    return this.childrenMap.child.rightChildOX - this.childMargin.right;
  }
  get childVisibleHeight() {
    return this.childrenMap.child.childVisibleHeight;
  }
  get childHeight() {
    return this.childrenMap.child.childHeight;
  }
  get childVisibleWidth() {
    return this.childrenMap.child.childVisibleWidth;
  }
  get childWidth() {
    return this.childrenMap.child.childWidth;
  }
  get isOverflow() {
    var child = this.childrenMap.child;
    return child.topChildOY !== child.bottomChildOY;
  }
  get isOverflowY() {
    return this.isOverflow;
  }
  get isOverflowX() {
    var child = this.childrenMap.child;
    return child.leftChildOX !== child.rightChildOX;
  }
  get sliderEnable() {
    var slider = this.childrenMap.slider;
    if (!slider) {
      return false;
    }
    return slider.enable;
  }
  set sliderEnable(value) {
    var slider = this.childrenMap.slider;
    if (!slider) {
      return;
    }
    slider.setEnable(value);
  }
  setSliderEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.sliderEnable = enabled;
    return this;
  }
  get sliderYEnable() {
    return this.sliderEnable;
  }
  set sliderYEnable(value) {
    this.sliderEnable = value;
  }
  setSliderYEnable(enabled) {
    this.setSliderEnable(enabled);
    return this;
  }
  get sliderXEnable() {
    var slider = this.childrenMap.sliderX;
    if (!slider) {
      return false;
    }
    return slider.enable;
  }
  set sliderXEnable(value) {
    var slider = this.childrenMap.sliderX;
    if (!slider) {
      return;
    }
    slider.setEnable(value);
  }
  setSliderXEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.sliderXEnable = enabled;
    return this;
  }
  get scrollerEnable() {
    var scroller = this.childrenMap.scroller;
    if (!scroller) {
      return false;
    }
    return scroller.enable;
  }
  set scrollerEnable(value) {
    var scroller = this.childrenMap.scroller;
    if (!scroller) {
      return;
    }
    scroller.setEnable(value);
  }
  setScrollerEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.scrollerEnable = enabled;
    return this;
  }
  get scrollerYEnable() {
    return this.scrollerEnable;
  }
  set scrollerYEnable(value) {
    this.scrollerEnable = value;
  }
  setScrollerYEnable(enabled) {
    this.setScrollerEnable(enabled);
    return this;
  }
  get scrollerXEnable() {
    var scroller = this.childrenMap.scrollerX;
    if (!scroller) {
      return false;
    }
    return scroller.enable;
  }
  set scrollerXEnable(value) {
    var scroller = this.childrenMap.scrollerX;
    if (!scroller) {
      return;
    }
    scroller.setEnable(value);
  }
  setScrollerXEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.scrollerXEnable = enabled;
    return this;
  }
  get scrollerXEnable() {
    var scroller = this.childrenMap.scrollerX;
    if (!scroller) {
      return false;
    }
    return scroller.enable;
  }
  set scrollerXEnable(value) {
    var scroller = this.childrenMap.scrollerX;
    if (!scroller) {
      return;
    }
    scroller.setEnable(value);
  }
  setScrollerXEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.scrollerXEnable = enabled;
    return this;
  }
  get mouseWheelScrollerEnable() {
    var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
    if (!mouseWheelScroller) {
      return false;
    }
    return mouseWheelScroller.enable;
  }
  set mouseWheelScrollerEnable(value) {
    var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
    if (!mouseWheelScroller) {
      return;
    }
    mouseWheelScroller.setEnable(value);
  }
  setMouseWheelScrollerEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.mouseWheelScrollerEnable = enabled;
    return this;
  }
  get mouseWheelScrollerYEnable() {
    return this.mouseWheelScrollerEnable;
  }
  set mouseWheelScrollerYEnable(value) {
    this.mouseWheelScrollerEnable = value;
  }
  setMouseWheelScrollerYEnable(enabled) {
    this.setMouseWheelScrollerEnable(enabled);
    return this;
  }
  get mouseWheelScrollerXEnable() {
    var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
    if (!mouseWheelScroller) {
      return false;
    }
    return mouseWheelScroller.enable;
  }
  set mouseWheelScrollerXEnable(value) {
    var mouseWheelScroller = this.childrenMap.mouseWheelScrollerX;
    if (!mouseWheelScroller) {
      return;
    }
    mouseWheelScroller.setEnable(value);
  }
  setMouseWheelScrollerXEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    this.mouseWheelScrollerXEnable = enabled;
    return this;
  }
  setDropZoneEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    var child = this.childrenMap.child;
    child.setInteractive();
    child.input.dropZone = enable;
    return this;
  }
};
Object.assign(
  Scrollable.prototype,
  Methods_default29
);
var Scrollable_default = Scrollable;

// node_modules/phaser3-rex-plugins/plugins/utils/text/TextToLines.js
var TextToLines = function(textObject, text, lines) {
  var textObjectType = GetTextObjectType_default(textObject);
  switch (textObjectType) {
    case TextType:
      lines = textObject.getWrappedText(text);
      break;
    case TagTextType:
      lines = textObject.getPenManager(text, lines);
      break;
    case BitmapTextType:
      if (textObject.maxWidth > 0) {
        lines = textObject.setText(text).getTextBounds().wrappedText.split("\n");
      } else {
        lines = text.split("\n");
      }
      break;
  }
  return lines;
};
var TextToLines_default = TextToLines;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/SetText.js
var SetText3 = function(text) {
  if (text !== void 0) {
    this.text = text;
  }
  this.lines = TextToLines_default(this.textObject, this.text, this.lines);
  this.linesCount = this.lines.length;
  this._textHeight = void 0;
  this._textVisibleHeight = void 0;
  this.updateTextObject();
  return this;
};
var SetText_default3 = SetText3;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/TextHeightToLinesCount.js
var TextHeightToLinesCount = function(height) {
  return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
};
var TextHeightToLinesCount_default = TextHeightToLinesCount;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/LinesCountToTextHeight.js
var LinesCountToTextHeight = function(linesCount) {
  return linesCount * (this.textLineHeight + this.textLineSpacing) - this.textLineSpacing;
};
var LinesCountToTextHeight_default = LinesCountToTextHeight;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/GetLines.js
var GetLines = function(startLineIdx) {
  var endLineIdx = startLineIdx + this.visibleLinesCount + 1;
  var text;
  switch (this.textObjectType) {
    case TextType:
      text = this.lines.slice(startLineIdx, endLineIdx).join("\n");
      break;
    case TagTextType:
      var startIdx = this.lines.getLineStartIndex(startLineIdx);
      var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
      text = this.lines.getSliceTagText(startIdx, endIdx, true);
      break;
    case BitmapTextType:
      text = this.lines.slice(startLineIdx, endLineIdx).join("\n");
      break;
  }
  return text;
};
var GetLines_default = GetLines;

// node_modules/phaser3-rex-plugins/plugins/utils/text/SetNoWrapText.js
var SetNoWrapText = function(textObject, text) {
  var textObjectType = GetTextObjectType_default(textObject);
  switch (textObjectType) {
    case TextType:
      var style = textObject.style;
      var wordWrapWidth = style.wordWrapWidth;
      var wordWrapCallback = style.wordWrapCallback;
      style.wordWrapWidth = 0;
      style.wordWrapCallback = void 0;
      textObject.setText(text);
      style.wordWrapWidth = wordWrapWidth;
      style.wordWrapCallback = wordWrapCallback;
      break;
    case TagTextType:
      var style = textObject.style;
      var wrapMode = style.wrapMode;
      style.wrapMode = 0;
      textObject.setText(text);
      style.wrapMode = wrapMode;
      break;
    case BitmapTextType:
      var maxWidth = textObject._maxWidth;
      textObject._maxWidth = 0;
      textObject.setText(text);
      textObject._maxWidth = maxWidth;
      break;
  }
};
var SetNoWrapText_default = SetNoWrapText;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/ResetTextObjectPosition.js
var ResetTextObjectPosition = function() {
  var config = this.textObject.rexSizer;
  this.textObject.y += config.offsetY - config.preOffsetY;
  config.preOffsetY = config.offsetY;
  this.resetChildPositionState(this.textObject);
  if (this.textCropEnable) {
    CropTextObject.call(this);
  }
};
var CropTextObject = function() {
  if (!this.textObject.setCrop) {
    return;
  }
  var offsetY = this.textObject.rexSizer.offsetY;
  var cropY, cropHeight;
  if (offsetY <= 0) {
    cropY = -offsetY;
    cropHeight = this.height;
  } else {
    cropY = 0;
    cropHeight = this.height - offsetY;
  }
  this.textObject.setCrop(
    0,
    cropY,
    this.width,
    cropHeight
  );
};
var ResetTextObjectPosition_default = ResetTextObjectPosition;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/UpdateTextObject.js
var UpdateTextObject = function() {
  var startLineIndex = Math.max(Math.floor(TextHeightToLinesCount_default.call(this, -this.textOY)), 0);
  var textOffset = LinesCountToTextHeight_default.call(this, startLineIndex) + this.textOY;
  var text = GetLines_default.call(this, startLineIndex);
  SetNoWrapText_default(this.textObject, text);
  this.textObject.rexSizer.offsetY = textOffset;
  ResetTextObjectPosition_default.call(this);
  return this;
};
var UpdateTextObject_default = UpdateTextObject;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/PreLayout.js
var PreLayout5 = function() {
  this._textLineHeight = void 0;
  this._textLineSpacing = void 0;
  this._visibleLinesCount = void 0;
  this._textHeight = void 0;
  this._textVisibleHeight = void 0;
  PreLayout_default.call(this);
  return this;
};
var PreLayout_default5 = PreLayout5;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/ResizeText.js
var ResizeText = function(textObject, width, height) {
  height += this.textLineHeight + this.textLineSpacing;
  if (this.textObjectWidth === width && this._textObjectRealHeight === height) {
    return;
  }
  this.textObjectWidth = width;
  this._textObjectRealHeight = height;
  switch (this.textObjectType) {
    case TextType:
    case TagTextType:
      textObject.setFixedSize(width, height);
      var style = textObject.style;
      var wrapWidth = Math.max(width, 0);
      if (this.textObjectType === TextType) {
        style.wordWrapWidth = wrapWidth;
      } else {
        if (style.wrapMode === 0) {
          style.wrapMode = 1;
        }
        style.wrapWidth = wrapWidth;
      }
      break;
    case BitmapTextType:
      textObject.setMaxWidth(width);
      break;
  }
  this.setText();
};
var ResizeText_default = ResizeText;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/LayoutChildren.js
var LayoutChildren6 = function() {
  var child, childConfig, padding;
  var startX = this.left, startY = this.top;
  var x, y, width, height;
  child = this.textObject;
  if (!child.rexSizer.hidden) {
    childConfig = child.rexSizer;
    padding = childConfig.padding;
    x = startX + padding.left * this.scaleX;
    y = startY + padding.top * this.scaleY;
    width = this.width * this.scaleX - (padding.left + padding.right) * this.scaleX;
    height = this.height * this.scaleY - (padding.top + padding.bottom) * this.scaleY;
    ResizeText_default.call(this, child, width, height);
    AlignIn_default(child, x, y, width, height, childConfig.align);
    childConfig.preOffsetY = 0;
    ResetTextObjectPosition_default.call(this);
    if (this.textMask) {
      this.textMask.setPosition().resize();
      this.resetChildPositionState(this.textMask);
    }
  }
};
var LayoutChildren_default6 = LayoutChildren6;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/Methods.js
var Methods_default30 = {
  setText: SetText_default3,
  updateTextObject: UpdateTextObject_default,
  preLayout: PreLayout_default5,
  layoutChildren: LayoutChildren_default6
};

// node_modules/phaser3-rex-plugins/templates/ui/textarea/textblock/TextBlock.js
var IsPlainObject46 = Phaser.Utils.Objects.IsPlainObject;
var GetValue149 = Phaser.Utils.Objects.GetValue;
var ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;
var TextBlock = class extends BaseSizer_default {
  constructor(scene, x, y, minWidth, minHeight, config) {
    if (IsPlainObject46(x)) {
      config = x;
      x = GetValue149(config, "x", 0);
      y = GetValue149(config, "y", 0);
      minWidth = GetValue149(config, "width", void 0);
      minHeight = GetValue149(config, "height", void 0);
    } else if (IsPlainObject46(minWidth)) {
      config = minWidth;
      minWidth = GetValue149(config, "width", void 0);
      minHeight = GetValue149(config, "height", void 0);
    }
    super(scene, x, y, minWidth, minHeight, config);
    this.type = "rexTextBlock";
    this.textObject = void 0;
    this.linesCount = 0;
    this.textMask = void 0;
    this.textObjectType = void 0;
    this._textLineHeight = void 0;
    this._textLineSpacing = void 0;
    this._visibleLinesCount = void 0;
    this._textHeight = void 0;
    this._textVisibleHeight = void 0;
    this._textObjectRealHeight = 0;
    this.lines = void 0;
    this.text = GetValue149(config, "content", "");
    this._textOY = 0;
    this.execeedTopState = false;
    this.execeedBottomState = false;
    this.setClampMode(GetValue149(config, "clampTextOY", true));
    this.alwaysScrollable = GetValue149(config, "alwaysScrollable", false);
    var background = GetValue149(config, "background", void 0);
    var textObject = GetValue149(config, "text", void 0);
    if (textObject === void 0) {
      textObject = CreateDefaultTextObject(scene);
    }
    this.textCropEnable = GetValue149(config, "textCrop", !!textObject.setCrop);
    var textMaskEnable = GetValue149(config, "textMask", !this.textCropEnable);
    if (background) {
      this.addBackground(background);
    }
    this.add(textObject);
    this.sizerChildren = [textObject];
    var sizerConfig = this.getSizerConfig(textObject);
    sizerConfig.align = ALIGN_LEFTTOP;
    sizerConfig.padding = GetBoundsConfig_default2(0);
    sizerConfig.expand = true;
    this.textObject = textObject;
    this.textObjectType = GetTextObjectType_default(textObject);
    sizerConfig.preOffsetY = 0;
    sizerConfig.offsetY = 0;
    if (textMaskEnable) {
      this.textMask = AddChildMask_default.call(this, this.textObject, this);
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("text", textObject);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.textObject = void 0;
    this.textMask = void 0;
    if (this.lines) {
      switch (this.textObjectType) {
        case TextType:
          this.lines.length = 0;
          break;
        case TagTextType:
          this.lines.destroy();
          break;
        case BitmapTextType:
          this.lines.length = 0;
          break;
      }
      this.lines = void 0;
    }
    super.destroy(fromScene);
  }
  setClampMode(mode) {
    if (mode === void 0) {
      mode = true;
    }
    this.clampTextOY = mode;
    return this;
  }
  get textLineHeight() {
    if (this._textLineHeight === void 0) {
      var lineHeight;
      switch (this.textObjectType) {
        case TextType:
        case TagTextType:
          var style = this.textObject.style;
          lineHeight = style.metrics.fontSize + style.strokeThickness;
          break;
        case BitmapTextType:
          var scale = this.textObject.fontSize / this.textObject.fontData.size;
          lineHeight = this.textObject.fontData.lineHeight * scale;
          break;
      }
      this._textLineHeight = lineHeight;
    }
    return this._textLineHeight;
  }
  get textLineSpacing() {
    if (this._textLineSpacing === void 0) {
      var lineSpacing;
      switch (this.textObjectType) {
        case TextType:
        case TagTextType:
          lineSpacing = this.textObject.lineSpacing;
          break;
        case BitmapTextType:
          lineSpacing = 0;
          break;
      }
      this._textLineSpacing = lineSpacing;
    }
    return this._textLineSpacing;
  }
  get visibleLinesCount() {
    if (this._visibleLinesCount === void 0) {
      this._visibleLinesCount = Math.floor(TextHeightToLinesCount_default.call(this, this._textObjectRealHeight));
    }
    return this._visibleLinesCount;
  }
  get topTextOY() {
    return 0;
  }
  get bottomTextOY() {
    return -this.textVisibleHeight;
  }
  get textHeight() {
    if (this._textHeight === void 0) {
      this._textHeight = LinesCountToTextHeight_default.call(this, this.linesCount);
    }
    return this._textHeight;
  }
  get textObjectHeight() {
    return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing);
  }
  get textVisibleHeight() {
    if (this._textVisibleHeight === void 0) {
      var h = this.textHeight - this.textObjectHeight;
      if (!this.alwaysScrollable && h < 0) {
        h = 0;
      }
      this._textVisibleHeight = h;
    }
    return this._textVisibleHeight;
  }
  textOYExceedTop(oy) {
    if (oy === void 0) {
      oy = this.textOY;
    }
    return oy > this.topTextOY;
  }
  textOYExeceedBottom(oy) {
    if (oy === void 0) {
      oy = this.textOY;
    }
    return oy < this.bottomTextOY;
  }
  get textOY() {
    return this._textOY;
  }
  set textOY(oy) {
    var topTextOY = this.topTextOY;
    var bottomTextOY = this.bottomTextOY;
    var textOYExceedTop = this.textOYExceedTop(oy);
    var textOYExeceedBottom = this.textOYExeceedBottom(oy);
    if (this.clampTextOY) {
      if (this.visibleLinesCount > this.linesCount) {
        oy = 0;
      } else if (textOYExceedTop) {
        oy = topTextOY;
      } else if (textOYExeceedBottom) {
        oy = bottomTextOY;
      }
    }
    if (this._textOY !== oy) {
      this._textOY = oy;
      this.updateTextObject();
    }
    if (textOYExceedTop) {
      if (!this.execeedTopState) {
        this.emit("execeedtop", this, oy, topTextOY);
      }
    }
    this.execeedTopState = textOYExceedTop;
    if (textOYExeceedBottom) {
      if (!this.execeedBottomState) {
        this.emit("execeedbottom", this, oy, bottomTextOY);
      }
    }
    this.execeedBottomState = textOYExeceedBottom;
  }
  setTextOY(oy) {
    this.textOY = oy;
    return this;
  }
  set t(value) {
    this.textOY = -this.textVisibleHeight * value;
  }
  get t() {
    var textVisibleHeight = this.textVisibleHeight;
    if (textVisibleHeight === 0) {
      return 0;
    }
    return this.textOY / -textVisibleHeight;
  }
  setTextOYByPercentage(percentage) {
    this.t = percentage;
    return this;
  }
};
var CreateDefaultTextObject = function(scene) {
  return scene.add.text(0, 0, "");
};
Object.assign(
  TextBlock.prototype,
  Methods_default30
);
var TextBlock_default = TextBlock;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/InjectProperties.js
var InjectProperties = function(textBlock) {
  Object.defineProperty(textBlock, "childOY", {
    configurable: true,
    get: function() {
      return textBlock.textOY;
    },
    set: function(value) {
      textBlock.textOY = value;
    }
  });
  Object.defineProperty(textBlock, "topChildOY", {
    get: function() {
      return textBlock.topTextOY;
    }
  });
  Object.defineProperty(textBlock, "bottomChildOY", {
    get: function() {
      return textBlock.bottomTextOY;
    }
  });
  Object.defineProperty(textBlock, "childVisibleHeight", {
    get: function() {
      return textBlock.textObjectHeight;
    }
  });
  Object.defineProperty(textBlock, "childHeight", {
    get: function() {
      return textBlock.textHeight;
    }
  });
};
var InjectProperties_default = InjectProperties;

// node_modules/phaser3-rex-plugins/templates/ui/textarea/SetTextMethods.js
var SetTextMethods_default = {
  setText(text) {
    var textBlock = this.childrenMap.child;
    textBlock.setText(text);
    this.resizeController();
    return this;
  },
  appendText(text) {
    this.setText(this.text + text);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/textarea/ScrollMethods.js
var ScrollMethods_default = {
  scrollToLine(lineIndex) {
    this.setChildOY(-this.lineHeight * lineIndex);
    return this;
  },
  scrollToNextLine(lineCount) {
    if (lineCount === void 0) {
      lineCount = 1;
    }
    var lineIndex = this.lineIndex + lineCount;
    this.scrollToLine(lineIndex);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/textarea/TextArea.js
var GetValue150 = Phaser.Utils.Objects.GetValue;
var TextArea = class extends Scrollable_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var textObject = GetValue150(config, "text", void 0);
    var textWidth = GetValue150(config, "textWidth", void 0);
    var textHeight = GetValue150(config, "textHeight", void 0);
    var textCrop = GetValue150(config, "textCrop", !!textObject.setCrop);
    var textMask = GetValue150(config, "textMask", !textCrop);
    var content = GetValue150(config, "content", "");
    var textBlock = new TextBlock_default(scene, {
      width: textWidth,
      height: textHeight,
      text: textObject,
      textMask,
      textCrop: textCrop && !textMask,
      content,
      clampTextOY: GetValue150(config, "clampChildOY", false),
      alwaysScrollable: GetValue150(config, "alwaysScrollable", false)
    });
    scene.add.existing(textBlock);
    InjectProperties_default(textBlock);
    config.scrollMode = 0;
    config.type = "rexTextArea";
    config.child = {
      gameObject: textBlock,
      expandWidth: textWidth === void 0,
      expandHeight: textHeight === void 0
    };
    var spaceConfig = GetValue150(config, "space", void 0);
    if (spaceConfig) {
      spaceConfig.child = GetValue150(spaceConfig, "text", 0);
    }
    super(scene, config);
    this.addChildrenMap("text", textObject);
  }
  get text() {
    return this.childrenMap.child.text;
  }
  get lineHeight() {
    var textBlock = this.childrenMap.child;
    return textBlock.textLineHeight + textBlock.textLineSpacing;
  }
  get lineIndex() {
    return Math.floor(-this.childOY / this.lineHeight);
  }
  get linesCount() {
    var textBlock = this.childrenMap.child;
    return textBlock.linesCount;
  }
  get contentHeight() {
    var textBlock = this.childrenMap.child;
    return textBlock.textHeight;
  }
};
Object.assign(
  TextArea.prototype,
  SetTextMethods_default,
  ScrollMethods_default
);
var TextArea_default = TextArea;

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateTextArea.js
var GetValue151 = Phaser.Utils.Objects.GetValue;
var CreateTextArea = function(scene, config, creators) {
  config = config ? DeepClone_default(config) : {};
  var createBackground = GetValue151(creators, "background", CreateBackground_default);
  var createText = GetValue151(creators, "text", CreateText_default);
  var createTrack = GetValue151(creators, "track", CreateBackground_default);
  var createThumb = GetValue151(creators, "thumb", CreateBackground_default);
  if (createBackground) {
    config.background = createBackground(scene, config.background);
  } else {
    delete config.background;
  }
  if (createText) {
    config.text = createText(scene, config.text);
  } else {
    delete config.text;
  }
  var sliderConfig = config.slider;
  if (sliderConfig !== false && sliderConfig !== null) {
    if (sliderConfig === void 0) {
      sliderConfig = {};
    }
    if (createTrack) {
      sliderConfig.track = createTrack(scene, sliderConfig.track);
    } else {
      delete sliderConfig.track;
    }
    if (createThumb) {
      sliderConfig.thumb = createThumb(scene, sliderConfig.thumb);
    } else {
      delete sliderConfig.thumb;
    }
    config.slider = sliderConfig;
  }
  var gameObject2 = new TextArea_default(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateTextArea_default = CreateTextArea;

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateText.js
var CreateText = function(scene, config) {
  var gameObjectType;
  if (config) {
    if (config.hasOwnProperty("$type")) {
      gameObjectType = config.$type;
    } else {
      if (config.hasOwnProperty("key")) {
        gameObjectType = "bitmaptext";
        config.font = config.key;
      }
    }
  }
  var gameObject2;
  switch (gameObjectType) {
    case "bitmaptext":
    case "bitmap":
      gameObject2 = new StatesBitmapText_default(scene, config);
      break;
    case "bbcodetext":
    case "bbcode":
      gameObject2 = new BBCodeText_default2(scene, 0, 0, "", config);
      break;
    case "label":
      gameObject2 = new SimpleLabel_default(scene, config);
      break;
    case "textarea":
      gameObject2 = CreateTextArea_default(scene, config);
      break;
    default:
      gameObject2 = new StatesText_default(scene, config);
      break;
  }
  DecorateGameObject_default(gameObject2, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateText_default = CreateText;

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateImage.js
var CreateImage2 = function(scene, config) {
  var gameObjectType;
  if (config) {
    if (config.hasOwnProperty("$type")) {
      gameObjectType = config.$type;
    } else {
      if (config.hasOwnProperty("leftWidth")) {
        gameObjectType = "nineSlice";
      } else if (config.hasOwnProperty("color") || config.hasOwnProperty("strokeColor")) {
        gameObjectType = "roundRectangle";
      }
    }
  }
  var gameObject2;
  switch (gameObjectType) {
    case "nineSlice":
      if (!config.hasOwnProperty("stretchMode")) {
        gameObject2 = new StatesNineSlice_default(scene, config);
      } else {
        gameObject2 = new StatesNinePatch_default(scene, config);
      }
      break;
    case "roundRectangle":
      gameObject2 = new StatesRoundRectangle_default(scene, config);
      break;
    default:
      gameObject2 = new StatesImage_default(scene, config);
      break;
  }
  DecorateGameObject_default(gameObject2, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateImage_default = CreateImage2;

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/BuildLabelConfig.js
var GetValue152 = Phaser.Utils.Objects.GetValue;
var BuildLabelConfig = function(scene, config, creators) {
  config = config ? DeepClone_default(config) : {};
  var createBackground = GetValue152(creators, "background", CreateBackground_default);
  var createText = GetValue152(creators, "text", CreateText_default);
  var createIcon = GetValue152(creators, "icon", CreateImage_default);
  var createAction = GetValue152(creators, "action", CreateImage_default);
  if (config.background !== null && createBackground) {
    config.background = createBackground(scene, config.background);
  } else {
    delete config.background;
  }
  if (config.text !== null && createText) {
    config.text = createText(scene, config.text);
  } else {
    delete config.text;
  }
  if (config.icon !== null && createIcon) {
    config.icon = createIcon(scene, config.icon);
  } else {
    delete config.icon;
  }
  if (config.action !== null && createAction) {
    config.action = createAction(scene, config.action);
  } else {
    delete config.action;
  }
  return config;
};
var BuildLabelConfig_default = BuildLabelConfig;

// node_modules/phaser3-rex-plugins/templates/ui/simplelabel/SimpleLabel.js
var SimpleLabel = class extends Label_default {
  constructor(scene, config, creators) {
    config = BuildLabelConfig_default(scene, config, creators);
    super(scene, config);
    this.type = "rexSimpleLabel";
  }
  setActiveState(enable) {
    RunMethod(this.getChildren(), "setActiveState", enable);
    return this;
  }
  setHoverState(enable) {
    RunMethod(this.getChildren(), "setHoverState", enable);
    return this;
  }
  setDisableState(enable) {
    RunMethod(this.getChildren(), "setDisableState", enable);
    return this;
  }
};
var RunMethod = function(children, methodName, enable) {
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var gameObject2 = children[i];
    if (gameObject2 && gameObject2[methodName]) {
      gameObject2[methodName](enable);
    }
  }
};
var SimpleLabel_default = SimpleLabel;

// node_modules/phaser3-rex-plugins/templates/ui/simplelabel/Factory.js
ObjectFactory_default.register("simpleLabel", function(config, creators) {
  var gameObject2 = new SimpleLabel_default(this.scene, config, creators);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.SimpleLabel", SimpleLabel_default);

// node_modules/phaser3-rex-plugins/templates/ui/titlelabel/methods/LayoutMode0.js
var GetValue153 = Phaser.Utils.Objects.GetValue;
var LayoutMode0 = function(config) {
  var scene = this.scene;
  var orientation = GetValue153(config, "orientation", 0);
  this.setOrientation(orientation);
  var icon = GetValue153(config, "icon", void 0);
  var iconMask = GetValue153(config, "iconMask", void 0);
  var innerBackground = GetValue153(config, "innerBackground", void 0);
  var title = GetValue153(config, "title", void 0);
  var separator = GetValue153(config, "separator", void 0);
  var text = GetValue153(config, "text", void 0);
  var action = GetValue153(config, "action", void 0);
  var actionMask = GetValue153(config, "actionMask", void 0);
  if (icon) {
    var align = GetValue153(config, "align.icon", "center");
    var padding;
    if (this.orientation === 0) {
      padding = {
        right: GetValue153(config, "space.icon", 0),
        top: GetValue153(config, "space.iconTop", 0),
        bottom: GetValue153(config, "space.iconBottom", 0),
        left: GetValue153(config, "space.iconLeft", 0)
      };
    } else {
      padding = {
        bottom: GetValue153(config, "space.icon", 0),
        left: GetValue153(config, "space.iconLeft", 0),
        right: GetValue153(config, "space.iconRight", 0),
        top: GetValue153(config, "space.iconTop", 0)
      };
    }
    var fitRatio = GetValue153(config, "squareFitIcon", false) ? 1 : 0;
    this.add(
      icon,
      { proportion: 0, align, padding, fitRatio }
    );
    if (iconMask) {
      iconMask = AddChildMask_default.call(this, icon, icon, 1);
    }
    if (!fitRatio) {
      var iconSize = GetValue153(config, "iconSize", void 0);
      this.setIconSize(
        GetValue153(config, "iconWidth", iconSize),
        GetValue153(config, "iconHeight", iconSize)
      );
    }
  }
  var innerSizer = new Sizer_default(scene, {
    orientation: 1
  });
  if (innerBackground) {
    innerSizer.addBackground(innerBackground);
  }
  var separatorSpace = GetValue153(config, "space.separator", 0);
  if (title) {
    var align = GetValue153(config, "align.title", "left");
    var expandTitleWidth = GetValue153(config, "expandTitleWidth", false);
    var expandTitleHeight = GetValue153(config, "expandTitleHeight", false);
    var proportion, padding, expand;
    proportion = expandTitleHeight ? 1 : 0;
    expand = expandTitleWidth;
    padding = {
      bottom: !separator && text ? GetValue153(config, "space.title", separatorSpace) : 0,
      left: GetValue153(config, "space.titleLeft", 0),
      right: GetValue153(config, "space.titleRight", 0)
    };
    innerSizer.add(
      title,
      { proportion, expand, align, padding }
    );
  }
  if (separator) {
    var padding = {
      top: title ? separatorSpace : 0,
      bottom: text ? separatorSpace : 0,
      left: GetValue153(config, "space.separatorLeft", 0),
      right: GetValue153(config, "space.separatorRight", 0)
    };
    innerSizer.add(
      separator,
      { expand: true, padding }
      // Fixed height, expand width
    );
  }
  if (text) {
    var align = GetValue153(config, "align.text", "left");
    var expandTextWidth = GetValue153(config, "expandTextWidth", false);
    var expandTextHeight = GetValue153(config, "expandTextHeight", false);
    var proportion, padding, expand;
    proportion = expandTextHeight ? 1 : 0;
    expand = expandTextWidth;
    padding = {
      left: GetValue153(config, "space.textLeft", 0),
      right: GetValue153(config, "space.textRight", 0)
    };
    innerSizer.add(
      text,
      { proportion, expand, align, padding }
    );
  }
  var padding = void 0;
  if (action) {
    padding = {
      right: GetValue153(config, "space.text", 0)
    };
  }
  this.add(
    innerSizer,
    { proportion: 1, padding }
  );
  if (action) {
    var align = GetValue153(config, "align.action", "center");
    var padding;
    if (this.orientation === 0) {
      padding = {
        top: GetValue153(config, "space.actionTop", 0),
        bottom: GetValue153(config, "space.actionBottom", 0),
        right: GetValue153(config, "space.actionRight", 0)
      };
    } else {
      padding = {
        left: GetValue153(config, "space.actionLeft", 0),
        right: GetValue153(config, "space.actionRight", 0),
        bottom: GetValue153(config, "space.actionBottom", 0)
      };
    }
    var fitRatio = GetValue153(config, "squareFitAction", false) ? 1 : 0;
    this.add(
      action,
      { proportion: 0, align, padding, fitRatio }
    );
    if (actionMask) {
      actionMask = AddChildMask_default.call(this, action, action, 1);
    }
    if (!fitRatio) {
      var actionSize = GetValue153(config, "actionSize");
      this.setActionSize(
        GetValue153(config, "actionWidth", actionSize),
        GetValue153(config, "actionHeight", actionSize)
      );
    }
  }
  this.addChildrenMap("icon", icon);
  this.addChildrenMap("iconMask", iconMask);
  this.addChildrenMap("innerSizer", innerSizer);
  this.addChildrenMap("innerBackground", innerBackground);
  this.addChildrenMap("title", title);
  this.addChildrenMap("separator", separator);
  this.addChildrenMap("text", text);
  this.addChildrenMap("action", action);
  this.addChildrenMap("actionMask", actionMask);
};
var LayoutMode0_default = LayoutMode0;

// node_modules/phaser3-rex-plugins/templates/ui/titlelabel/methods/LayoutMode1.js
var GetValue154 = Phaser.Utils.Objects.GetValue;
var LayoutMode1 = function(config) {
  this.setOrientation(1);
  this.setRTL(false);
  var scene = this.scene;
  var title = GetValue154(config, "title", void 0);
  var separator = GetValue154(config, "separator", void 0);
  var innerBackground = GetValue154(config, "innerBackground", void 0);
  var icon = GetValue154(config, "icon", void 0);
  var iconMask = GetValue154(config, "iconMask", void 0);
  var text = GetValue154(config, "text", void 0);
  var action = GetValue154(config, "action", void 0);
  var actionMask = GetValue154(config, "actionMask", void 0);
  if (title) {
    var align = GetValue154(config, "align.title", "left");
    var expandTitleWidth = GetValue154(config, "expandTitleWidth", false);
    var expandTitleHeight = GetValue154(config, "expandTitleHeight", false);
    var proportion, padding, expand;
    proportion = expandTitleHeight ? 1 : 0;
    expand = expandTitleWidth;
    padding = {
      bottom: GetValue154(config, "space.title", 0),
      left: GetValue154(config, "space.titleLeft", 0),
      right: GetValue154(config, "space.titleRight", 0)
    };
    this.add(
      title,
      { proportion, expand, align, padding }
    );
  }
  if (separator) {
    var separatorSpace = GetValue154(config, "space.separator", 0);
    var padding = {
      top: title ? separatorSpace : 0,
      bottom: text ? separatorSpace : 0,
      left: GetValue154(config, "space.separatorLeft", 0),
      right: GetValue154(config, "space.separatorRight", 0)
    };
    this.add(
      separator,
      { proportion: 0, expand: true, padding }
      // Fixed height, expand width
    );
  }
  var orientation = GetValue154(config, "orientation", 0);
  var innerSizer = new Sizer_default(scene, {
    orientation,
    rtl: GetValue154(config, "rtl", false),
    space: {
      left: GetValue154(config, "space.innerLeft", 0),
      right: GetValue154(config, "space.innerRight", 0),
      top: GetValue154(config, "space.innerTop", 0),
      bottom: GetValue154(config, "space.innerBottom", 0)
    }
  });
  if (innerBackground) {
    innerSizer.addBackground(innerBackground);
  }
  this.add(
    innerSizer,
    { proportion: 1, expand: true }
  );
  if (icon) {
    var align = GetValue154(config, "align.icon", "center");
    var padding;
    if (innerSizer.orientation === 0) {
      padding = {
        right: GetValue154(config, "space.icon", 0),
        top: GetValue154(config, "space.iconTop", 0),
        bottom: GetValue154(config, "space.iconBottom", 0),
        left: GetValue154(config, "space.iconLeft", 0)
      };
    } else {
      padding = {
        bottom: GetValue154(config, "space.icon", 0),
        left: GetValue154(config, "space.iconLeft", 0),
        right: GetValue154(config, "space.iconRight", 0),
        top: GetValue154(config, "space.iconTop", 0)
      };
    }
    var fitRatio = GetValue154(config, "squareFitIcon", false) ? 1 : 0;
    innerSizer.add(
      icon,
      { proportion: 0, align, padding, fitRatio }
    );
    if (iconMask) {
      iconMask = AddChildMask_default.call(this, icon, icon, 1);
    }
    if (!fitRatio) {
      var iconSize = GetValue154(config, "iconSize", void 0);
      this.setIconSize(
        GetValue154(config, "iconWidth", iconSize),
        GetValue154(config, "iconHeight", iconSize)
      );
    }
  }
  if (text) {
    var align = GetValue154(config, "align.text", "left");
    var textSpace = GetValue154(config, "space.text", 0);
    var expandTextWidth = GetValue154(config, "expandTextWidth", false);
    var expandTextHeight = GetValue154(config, "expandTextHeight", false);
    var proportion, padding, expand;
    if (innerSizer.orientation === 0) {
      proportion = expandTextWidth ? 1 : 0;
      if (action) {
        padding = { right: textSpace };
      }
      expand = expandTextHeight;
    } else {
      proportion = expandTextHeight ? 1 : 0;
      if (action) {
        padding = {
          bottom: textSpace
        };
      }
      expand = expandTextWidth;
    }
    innerSizer.add(
      text,
      { proportion, expand, align, padding }
    );
  }
  if (action) {
    var align = GetValue154(config, "align.action", "center");
    var padding;
    if (innerSizer.orientation === 0) {
      padding = {
        top: GetValue154(config, "space.actionTop", 0),
        bottom: GetValue154(config, "space.actionBottom", 0),
        right: GetValue154(config, "space.actionRight", 0)
      };
    } else {
      padding = {
        left: GetValue154(config, "space.actionLeft", 0),
        right: GetValue154(config, "space.actionRight", 0),
        bottom: GetValue154(config, "space.actionBottom", 0)
      };
    }
    var fitRatio = GetValue154(config, "squareFitAction", false) ? 1 : 0;
    innerSizer.add(
      action,
      { proportion: 0, align, padding, fitRatio }
    );
    if (actionMask) {
      actionMask = AddChildMask_default.call(this, action, action, 1);
    }
    if (!fitRatio) {
      var actionSize = GetValue154(config, "actionSize");
      this.setActionSize(
        GetValue154(config, "actionWidth", actionSize),
        GetValue154(config, "actionHeight", actionSize)
      );
    }
  }
  this.addChildrenMap("title", title);
  this.addChildrenMap("separator", separator);
  this.addChildrenMap("innerSizer", innerSizer);
  this.addChildrenMap("innerBackground", innerBackground);
  this.addChildrenMap("icon", icon);
  this.addChildrenMap("iconMask", iconMask);
  this.addChildrenMap("text", text);
  this.addChildrenMap("action", action);
  this.addChildrenMap("actionMask", actionMask);
};
var LayoutMode1_default = LayoutMode1;

// node_modules/phaser3-rex-plugins/templates/ui/titlelabel/TitleLabel.js
var GetValue155 = Phaser.Utils.Objects.GetValue;
var LayoutCallbacks = [LayoutMode0_default, LayoutMode1_default];
var TitleLabel = class extends Base_default5 {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexTitleLabel";
    var background = GetValue155(config, "background", void 0);
    if (background) {
      this.addBackground(background);
    }
    var title = GetValue155(config, "title", void 0);
    var text = GetValue155(config, "text", void 0);
    if (title) {
      var wrapTitle = GetValue155(config, "wrapTitle", false);
      var adjustTitleFontSize = GetValue155(config, "adjustTitleFontSize", false);
      if (wrapTitle) {
        if (wrapTitle === true) {
          wrapTitle = "word";
        }
        SetWrapMode_default(title, wrapTitle);
        config.expandTitleWidth = true;
        WrapExpandText_default(title);
      } else if (adjustTitleFontSize) {
        config.expandTextWidth = true;
        config.expandTextHeight = true;
        FontSizeExpandText_default(title, { fitHeight: true });
      }
    }
    if (text) {
      var wrapText = GetValue155(config, "wrapText", false);
      var adjustTextFontSize = GetValue155(config, "adjustTextFontSize", false);
      if (wrapText) {
        if (wrapText === true) {
          wrapText = "word";
        }
        SetWrapMode_default(text, wrapText);
        config.expandTextWidth = true;
        WrapExpandText_default(text);
      } else if (adjustTextFontSize) {
        config.expandTextWidth = true;
        config.expandTextHeight = true;
        FontSizeExpandText_default(text, { fitHeight: true });
      }
    }
    var layoutMode = GetValue155(config, "layoutMode", 0);
    var layoutCallback = LayoutCallbacks[layoutMode] || LayoutCallbacks[0];
    layoutCallback.call(this, config);
    this.addChildrenMap("background", config.background);
  }
  // Access title game object
  get title() {
    var textObject = this.childrenMap.title;
    if (!textObject) {
      return "";
    }
    return textObject.title;
  }
  set title(value) {
    var textObject = this.childrenMap.title;
    if (!textObject) {
      return;
    }
    textObject.setText(value);
  }
  setTitle(value) {
    this.title = value;
    return this;
  }
  resetDisplayContent(config) {
    if (config === void 0) {
      config = {};
    } else if (typeof config === "string") {
      config = {
        text: config
      };
    }
    super.resetDisplayContent(config);
    var textObject = this.childrenMap.title;
    if (textObject) {
      if (config.title === void 0) {
      } else if (config.title) {
        this.show(textObject);
        this.setTitle(config.title);
      } else {
        this.hide(textObject);
      }
    }
    return this;
  }
};
var TitleLabel_default = TitleLabel;

// node_modules/phaser3-rex-plugins/templates/ui/titlelabel/Factory.js
ObjectFactory_default.register("titleLabel", function(config) {
  var gameObject2 = new TitleLabel_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TitleLabel", TitleLabel_default);

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/BuildTitleLabelConfig.js
var GetValue156 = Phaser.Utils.Objects.GetValue;
var BuildTitleLabelConfig = function(scene, config, creators) {
  var createInnerBackground = GetValue156(creators, "innerBackground", CreateBackground_default);
  var createSeparator = GetValue156(creators, "separator", CreateBackground_default);
  var createTitle = GetValue156(creators, "title", CreateText_default);
  var innerBackground, separator;
  if (config.innerBackground !== null && createInnerBackground) {
    innerBackground = createInnerBackground(scene, config.innerBackground);
  }
  if (config.separator !== null && createSeparator) {
    separator = createSeparator(scene, config.separator);
  }
  config = BuildLabelConfig_default(scene, config, creators);
  if (innerBackground) {
    config.innerBackground = innerBackground;
  } else {
    delete config.innerBackground;
  }
  if (separator) {
    config.separator = separator;
  } else {
    delete config.separator;
  }
  if (config.title !== null && createTitle) {
    config.title = createTitle(scene, config.title);
  } else {
    delete config.title;
  }
  var background = config.background;
  if (background) {
    if (innerBackground) {
      scene.children.moveBelow(background, innerBackground);
    } else if (separator) {
      scene.children.moveBelow(background, separator);
    }
  }
  return config;
};
var BuildTitleLabelConfig_default = BuildTitleLabelConfig;

// node_modules/phaser3-rex-plugins/templates/ui/simpletitlelabel/SimpleTitleLabel.js
var SimpleTitleLabel = class extends TitleLabel_default {
  constructor(scene, config, creators) {
    config = BuildTitleLabelConfig_default(scene, config, creators);
    super(scene, config);
    this.type = "rexSimpleTitleLabel";
  }
  setActiveState(enable) {
    RunMethod2(this.getChildren(), "setActiveState", enable);
    return this;
  }
  setHoverState(enable) {
    RunMethod2(this.getChildren(), "setHoverState", enable);
    return this;
  }
  setDisableState(enable) {
    RunMethod2(this.getChildren(), "setDisableState", enable);
    return this;
  }
};
var RunMethod2 = function(children, methodName, enable) {
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var gameObject2 = children[i];
    if (gameObject2 && gameObject2[methodName]) {
      gameObject2[methodName](enable);
    }
  }
};
var SimpleTitleLabel_default = SimpleTitleLabel;

// node_modules/phaser3-rex-plugins/templates/ui/simpletitlelabel/Factory.js
ObjectFactory_default.register("simpleTitleLabel", function(config, creators) {
  var gameObject2 = new SimpleTitleLabel_default(this.scene, config, creators);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.SimpleTitleLabel", SimpleTitleLabel_default);

// node_modules/phaser3-rex-plugins/templates/ui/namevaluelabel/methods/Build.js
var GetValue157 = Phaser.Utils.Objects.GetValue;
var IsPlainObject47 = Phaser.Utils.Objects.IsPlainObject;
var Build = function(scene, config) {
  var background = GetValue157(config, "background", void 0);
  var icon = GetValue157(config, "icon", void 0);
  var iconMask = GetValue157(config, "iconMask", void 0);
  var nameText = GetValue157(config, "nameText", void 0);
  var valueText = GetValue157(config, "valueText", void 0);
  var bar = GetValue157(config, "bar", void 0);
  var action = GetValue157(config, "action", void 0);
  var actionMask = GetValue157(config, "actionMask", void 0);
  var isLineBar = GetValue157(config, "barShape", "line") === "line";
  if (IsPlainObject47(bar)) {
    var BarClass = isLineBar ? LineProgressCanvas_default : CircularProgressCanvas_default;
    bar = new BarClass(scene, bar);
    scene.add.existing(bar);
    if (nameText) {
      scene.children.moveBelow(bar, nameText);
    }
    if (valueText) {
      scene.children.moveBelow(bar, valueText);
    }
  }
  var hasTextSizer = nameText || valueText || bar;
  if (background) {
    this.addBackground(background);
  }
  if (icon) {
    var padding = void 0;
    if (this.orientation === 0) {
      if (hasTextSizer || action) {
        padding = {
          right: GetValue157(config, "space.icon", 0),
          top: GetValue157(config, "space.iconTop", 0),
          bottom: GetValue157(config, "space.iconBottom", 0)
        };
      }
    } else {
      if (hasTextSizer || action) {
        padding = {
          bottom: GetValue157(config, "space.icon", 0),
          left: GetValue157(config, "space.iconLeft", 0),
          right: GetValue157(config, "space.iconRight", 0)
        };
      }
    }
    this.add(
      icon,
      { proportion: 0, padding }
    );
    if (iconMask) {
      iconMask = AddChildMask_default.call(this, icon, icon, 1);
    }
  }
  if (hasTextSizer) {
    var textSizer = new Sizer_default(scene, {
      orientation: 1
    });
    var nameValueSizer;
    if (nameText || valueText) {
      nameValueSizer = new Sizer_default(scene, {
        orientation: 0
      });
      if (nameText) {
        if (nameText.text === "") {
          nameText.setText(" ");
        }
        nameText.setOrigin(0, nameText.originY);
        var padding = {
          left: GetValue157(config, "space.name", 0)
        };
        nameValueSizer.add(
          nameText,
          { padding }
        );
      }
      if (valueText) {
        if (valueText.text === "") {
          valueText.setText(" ");
        }
        valueText.setOrigin(1, valueText.originY);
        nameValueSizer.addSpace();
        var padding = {
          right: GetValue157(config, "space.value", 0)
        };
        nameValueSizer.add(
          valueText,
          { padding }
        );
        this.setValueTextFormatCallback(
          GetValue157(config, "valueTextFormatCallback", DefaultValueTextFormatCallback),
          GetValue157(config, "valueTextFormatCallbackScope", void 0)
        );
      }
      textSizer.add(
        nameValueSizer,
        { expand: true }
      );
    }
    if (bar) {
      if (isLineBar) {
        var paddingTop = nameValueSizer ? GetValue157(config, "space.bar") : 0;
        if (paddingTop === void 0) {
          paddingTop = GetValue157(config, "space.barTop", 0);
        }
        var padding = {
          top: paddingTop,
          bottom: GetValue157(config, "space.barBottom", 0),
          left: GetValue157(config, "space.barLeft", 0),
          right: GetValue157(config, "space.barRight", 0)
        };
        textSizer.add(
          bar,
          { expand: true, padding }
        );
      } else {
        var padding = {
          top: GetValue157(config, "space.barTop", 0),
          bottom: GetValue157(config, "space.barBottom", 0),
          left: GetValue157(config, "space.barLeft", 0),
          right: GetValue157(config, "space.barRight", 0)
        };
        this.addBackground(bar, padding);
      }
    }
    var padding = void 0;
    if (action) {
      padding = {
        right: GetValue157(config, "space.text", 0)
      };
    }
    var textAlign = GetValue157(config, "align.text", "bottom");
    this.add(
      textSizer,
      { proportion: 1, align: textAlign, padding }
    );
  }
  if (action) {
    var padding;
    if (this.orientation === 0) {
      padding = {
        top: GetValue157(config, "space.actionTop", 0),
        bottom: GetValue157(config, "space.actionBottom", 0)
      };
    } else {
      padding = {
        left: GetValue157(config, "space.actionLeft", 0),
        right: GetValue157(config, "space.actionRight", 0)
      };
    }
    this.add(
      action,
      { proportion: 0, padding }
    );
    if (actionMask) {
      actionMask = AddChildMask_default.call(this, action, action, 1);
    }
  }
  this.addChildrenMap("background", background);
  this.addChildrenMap("icon", icon);
  this.addChildrenMap("iconMask", iconMask);
  this.addChildrenMap("name", nameText);
  this.addChildrenMap("value", valueText);
  this.addChildrenMap("bar", bar);
  this.addChildrenMap("action", action);
  this.addChildrenMap("actionMask", actionMask);
};
var DefaultValueTextFormatCallback = function(value, min, max) {
  return value.toString();
};
var Build_default = Build;

// node_modules/phaser3-rex-plugins/templates/ui/namevaluelabel/methods/SetValueMethods.js
var Clamp13 = Phaser.Math.Clamp;
var SetValueMethods_default = {
  setValueTextFormatCallback(callback, scope) {
    this.valueTextFormatCallback = callback;
    this.valueTextFormatCallbackScope = scope;
    return this;
  },
  getFormatValueText(value, min, max) {
    if (value === void 0) {
      value = this.value;
    }
    if (min === void 0) {
      min = this.minValue;
    }
    if (max === void 0) {
      max = this.maxValue;
    }
    var text;
    if (this.valueTextFormatCallbackScope) {
      text = this.valueTextFormatCallback(value, min, max);
    } else {
      text = this.valueTextFormatCallback.call(this.valueTextFormatCallbackScope, value, min, max);
    }
    return text;
  },
  updateValueText(value, min, max) {
    var textObject = this.childrenMap.value;
    if (textObject && this.valueTextFormatCallback) {
      textObject.setText(this.getFormatValueText(value, min, max));
      if (textObject.layout) {
        textObject.layout();
      }
    }
    return this;
  },
  setValue(value, min, max) {
    if (min === void 0) {
      min = this.minValue;
    } else {
      this.minValue = min;
    }
    if (max === void 0) {
      max = this.maxValue;
    } else {
      this.maxValue = max;
    }
    value = Clamp13(value, min, max);
    this.value = value;
    this.updateValueText(value, min, max);
    this.setBarValue(value, min, max);
    return this;
  },
  setEaseValueDuration(duration) {
    this.easeValueDuration = duration;
    return this;
  },
  easeValueTo(value, min, max) {
    if (min === void 0) {
      min = this.minValue;
    } else {
      this.minValue = min;
    }
    if (max === void 0) {
      max = this.maxValue;
    } else {
      this.maxValue = max;
    }
    if (this.easeValueTask === void 0) {
      this.easeValueTask = new EaseValueTask_default(this);
      this.easeValueTask.on("update", function() {
        this.setValue(this.value, this.minValue, this.maxValue);
      }, this);
    }
    this.easeValueTask.restart({
      key: "value",
      to: value,
      duration: this.easeValueDuration
    });
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/namevaluelabel/NameValueLabel.js
var NameValueLabel = class extends Sizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexNameValueLabel";
    Build_default.call(this, scene, config);
    this.setEaseValueDuration(1e3);
  }
  // Access nameText game object
  get nameText() {
    var textObject = this.childrenMap.name;
    if (textObject === void 0) {
      return "";
    }
    return textObject.text;
  }
  set nameText(value) {
    var textObject = this.childrenMap.name;
    if (textObject === void 0) {
      return;
    }
    textObject.setText(value);
  }
  setNameText(value) {
    this.nameText = value;
    return this;
  }
  // Access valueText game object
  get valueText() {
    var textObject = this.childrenMap.value;
    if (textObject === void 0) {
      return "";
    }
    return textObject.text;
  }
  set valueText(value) {
    var textObject = this.childrenMap.value;
    if (textObject === void 0) {
      return;
    }
    textObject.setText(value);
  }
  setValueText(value) {
    this.valueText = value;
    return this;
  }
  // Accrss bar game object
  get barValue() {
    var bar = this.childrenMap.bar;
    if (bar === void 0) {
      return;
    }
    return bar.value;
  }
  set barValue(value) {
    var bar = this.childrenMap.bar;
    if (bar === void 0) {
      return;
    }
    bar.setValue(value);
  }
  setBarValue(value, min, max) {
    var bar = this.childrenMap.bar;
    if (bar === void 0) {
      return this;
    }
    bar.setValue(value, min, max);
    return this;
  }
  easeBarValueTo(value, min, max) {
    var bar = this.childrenMap.bar;
    if (bar === void 0) {
      return this;
    }
    bar.easeValueTo(value, min, max);
    return this;
  }
  // Access icon game object
  setTexture(key2, frame) {
    var imageObject = this.childrenMap.icon;
    if (imageObject === void 0) {
      return;
    }
    imageObject.setTexture(key2, frame);
    return this;
  }
  get texture() {
    var imageObject = this.childrenMap.icon;
    if (imageObject === void 0) {
      return void 0;
    }
    return imageObject.texture;
  }
  get frame() {
    var imageObject = this.childrenMap.icon;
    if (imageObject === void 0) {
      return void 0;
    }
    return imageObject.frame;
  }
  postLayout(parent, newWidth, newHeight) {
    var iconMask = this.childrenMap.iconMask;
    if (iconMask) {
      iconMask.setPosition();
      this.resetChildPositionState(iconMask);
    }
    var actionMask = this.childrenMap.actionMask;
    if (actionMask) {
      actionMask.setPosition();
      this.resetChildPositionState(actionMask);
    }
    super.postLayout(parent, newWidth, newHeight);
    return this;
  }
  resize(width, height) {
    super.resize(width, height);
    var iconMask = this.childrenMap.iconMask;
    if (iconMask) {
      iconMask.resize();
    }
    var actionMask = this.childrenMap.actionMask;
    if (actionMask) {
      actionMask.resize();
    }
    return this;
  }
};
Object.assign(
  NameValueLabel.prototype,
  SetValueMethods_default
);
var NameValueLabel_default = NameValueLabel;

// node_modules/phaser3-rex-plugins/templates/ui/namevaluelabel/Factory.js
ObjectFactory_default.register("nameValueLabel", function(config) {
  var gameObject2 = new NameValueLabel_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.NameValueLabel", NameValueLabel_default);

// node_modules/phaser3-rex-plugins/plugins/logic/levelcounter/LevelCounter.js
var LevelCounter = class extends EventEmitter_default {
  constructor(config) {
    super();
    this.setTable(GetValue_default(config, "table"));
    this.setMaxLevel(GetValue_default(config, "maxLevel"));
    var exp = GetValue_default(config, "exp", 0);
    var level = GetValue_default(config, "level", void 0);
    if (level !== void 0 && !this.checkLevel(level, exp)) {
      console.error(`Level ${level} and Exp ${exp} are mismatch`);
      level = void 0;
    }
    this.resetExp(exp, level);
  }
  // Configuration
  setTable(table) {
    this.levelTable = table;
    this.isLevelMapFunction = IsFunction_default(table);
    return this;
  }
  setMaxLevel(maxLevel) {
    if (maxLevel === void 0) {
      if (Array.isArray(this.levelTable)) {
        maxLevel = this.levelTable.length - 1;
      } else {
        maxLevel = -1;
      }
    }
    var maxExp;
    if (maxLevel !== -1) {
      maxExp = this.getExp(maxLevel);
    } else {
      maxExp = -1;
    }
    this.hasMaxLevel = maxLevel !== -1;
    this.maxLevel = maxLevel;
    this.maxExp = maxExp;
    return this;
  }
  resetExp(exp, level) {
    if (this.hasMaxLevel && exp > this.maxExp) {
      exp = this.maxExp;
    }
    if (level === void 0) {
      level = this.getLevel(exp);
    }
    this._exp = exp;
    this._level = level;
    this._requiredExp = this.getRequiredExpToNextLevel(level, exp);
    return this;
  }
  get exp() {
    return this._exp;
  }
  set exp(exp) {
    if (this.hasMaxLevel && exp > this.maxExp) {
      exp = this.maxExp;
    }
    if (exp < this._exp) {
      this.resetExp(exp);
      return;
    }
    if (exp === this._exp) {
      return;
    }
    var level = this.getLevel(exp, this._level);
    var prevLevel = this._level;
    var fromExp = this._exp, toExp;
    while (1) {
      var levelStartExp = this.getExp(prevLevel);
      var levelEndExp = this.getExp(prevLevel + 1);
      toExp = Math.min(levelEndExp, exp);
      this.emit("levelup", prevLevel, fromExp, toExp, levelStartExp, levelEndExp);
      if (prevLevel === level && toExp === exp) {
        break;
      }
      prevLevel++;
      fromExp = levelEndExp;
    }
    this.resetExp(exp, level);
  }
  get level() {
    return this._level;
  }
  set level(value) {
    if (this.hasMaxLevel && value > this.maxLevel) {
      this.exp = this.maxExp;
    } else {
      this.exp = this.getExp(value);
    }
  }
  get requiredExp() {
    return this._requiredExp;
  }
  getExp(level) {
    if (level === void 0) {
      return this._exp;
    }
    if (this.isLevelMapFunction) {
      return this.levelTable(level);
    } else {
      if (this.hasMaxLevel && level > this.maxLevel) {
        level = this.maxLevel;
      }
      return this.levelTable[level];
    }
  }
  getLevel(exp, level) {
    if (exp === void 0) {
      return this._level;
    }
    if (level === void 0) {
      level = 0;
    }
    while (1) {
      var nextLevelExp = this.getExp(level + 1);
      if (nextLevelExp > exp) {
        break;
      }
      level++;
      if (this.hasMaxLevel && nextLevelExp === this.maxExp) {
        break;
      }
    }
    return level;
  }
  getRequiredExpToNextLevel(level, exp) {
    if (level === void 0) {
      level = this.level;
    }
    if (exp === void 0) {
      exp = this.exp;
    }
    return this.getExp(level + 1) - exp;
  }
  checkLevel(level, exp) {
    return exp >= this.getExp(level) && exp < this.getExp(level + 1);
  }
  gainExp(incExp, callback, scope) {
    if (callback) {
      this.on("levelup", callback, scope);
    }
    this.exp += incExp;
    if (callback) {
      this.off("levelup", callback, scope);
    }
    return this;
  }
  setExp(exp, callback, scope) {
    if (callback) {
      this.on("levelup", callback, scope);
    }
    this.exp = exp;
    if (callback) {
      this.off("levelup", callback, scope);
    }
    return this;
  }
  setLevel(level, callback, scope) {
    if (callback) {
      this.on("levelup", callback, scope);
    }
    this.level = level;
    if (callback) {
      this.off("levelup", callback, scope);
    }
    return this;
  }
};
var LevelCounter_default = LevelCounter;

// node_modules/phaser3-rex-plugins/plugins/levelcounter.js
var levelcounter_default = LevelCounter_default;

// node_modules/phaser3-rex-plugins/plugins/clock.js
var clock_default = Clock_default;

// node_modules/phaser3-rex-plugins/plugins/logic/runcommands/RunCommands.js
var RunCommands = function(queue, scope, config) {
  var reverse = GetValue_default(config, "reverse", false);
  var retVal;
  if (IsArray_default(queue[0])) {
    if (!reverse) {
      for (var i = 0, len = queue.length; i < len; i++) {
        retVal = RunCommands(queue[i], scope, config);
      }
    } else {
      for (var len = queue.length, i = len - 1; i >= 0; i--) {
        retVal = RunCommands(queue[i], scope, config);
      }
    }
  } else {
    retVal = RunCommand(queue, scope, config);
  }
  return retVal;
};
var RunCommand = function(cmd, scope, config) {
  var argsConvert = GetValue_default(config, "argsConvert", void 0);
  var argsConvertScope = GetValue_default(config, "argsConvertScope", void 0);
  var fnName = cmd[0];
  ARGS = Copy_default(ARGS, cmd, 1);
  if (argsConvert) {
    if (argsConvert === true) {
      argsConvert = TypeConvert_default;
      argsConvertScope = void 0;
    }
    for (var i = 0, len = ARGS.length; i < len; i++) {
      if (argsConvertScope) {
        ARGS[i] = argsConvert.call(argsConvertScope, ARGS[i], cmd);
      } else {
        ARGS[i] = argsConvert(ARGS[i], cmd);
      }
    }
  }
  var fn;
  if (typeof fnName === "string") {
    fn = scope[fnName];
    if (fn == null) {
      fn = GetValue_default(scope, fnName, null);
    }
  } else {
    fn = fnName;
  }
  var retValue = fn.apply(scope, ARGS);
  return retValue;
};
var ARGS = [];
var RunCommands_default = RunCommands;

// node_modules/phaser3-rex-plugins/plugins/runcommands.js
var runcommands_default = RunCommands_default;

// node_modules/phaser3-rex-plugins/plugins/logic/runcommands/tcrp/Player.js
var GetValue158 = Phaser.Utils.Objects.GetValue;
var Player = class extends ComponentBase_default {
  constructor(parent, config) {
    super(parent, config);
    var clock = GetValue158(config, "clock", void 0);
    if (!clock) {
      clock = new clock_default(parent);
    }
    this.clock = clock;
    this.clock.on("update", this.update, this);
    this.commands = [];
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.clock.resetFromJSON(GetValue158(o, "clock", void 0));
    this.state = GetValue158(o, "state", 0);
    this.commands = GetValue158(o, "commands", []);
    this.scope = GetValue158(o, "scope", void 0);
    this.setTimeUnit(GetValue158(o, "timeUnit", 0));
    this.setDtMode(GetValue158(o, "dtMode", 0));
    this.index = GetValue158(o, "index", 0);
    this.nextTime = GetValue158(o, "nextTime", 0);
    return this;
  }
  toJSON() {
    return {
      clock: this.clock.toJSON(),
      state: this.state,
      commands: this.commands,
      scope: this.scope,
      timeUnit: this.timeUnit,
      dtMode: this.dtMode,
      index: this.index,
      nextTime: this.nextTime
    };
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.clock.shutdown(fromScene);
    this.commands = void 0;
    super.shutdown(fromScene);
  }
  load(commands, scope, config) {
    this.stop();
    var timeUnit = GetValue158(config, "timeUnit", void 0);
    if (timeUnit !== void 0) {
      this.setTimeUnit(timeUnit);
    }
    var dtMode = GetValue158(config, "dtMode", void 0);
    if (dtMode !== void 0) {
      this.setDtMode(dtMode);
    }
    commands = commands.filter(function(item) {
      var dt = item[0];
      return !isNaN(dt);
    }).map(function(item) {
      var dt = item[0];
      if (typeof dt === "string") {
        item[0] = parseFloat(item[0]);
      }
      return item;
    });
    if (this.dtMode === 0) {
      commands.sort(function(itemA, itemB) {
        var dtA = itemA[0], dtB = itemB[0];
        return dtA > dtB ? 1 : dtA < dtB ? -1 : 0;
      });
    }
    Copy_default(this.commands, commands);
    this.scope = scope;
    return this;
  }
  clear() {
    this.commands.length = 0;
    return this;
  }
  append(time, fn, ...params) {
    var command;
    if (Array.isArray(fn)) {
      command = fn;
    } else {
      command = [fn, ...params];
    }
    this.commands.push([time, command]);
    return this;
  }
  start(startAt) {
    if (startAt === void 0) {
      startAt = 0;
    }
    this.stop();
    this.index = 0;
    this.state = 1;
    this.nextTime = this.getNextDt(0);
    this.clock.start(startAt);
    this.update(startAt);
    this.emit("start", this.parent, this);
    return this;
  }
  pause() {
    this.clock.pause();
    this.emit("pause", this.parent, this);
    return this;
  }
  resume() {
    this.clock.resume();
    this.emit("resume", this.parent, this);
    return this;
  }
  stop() {
    this.clock.stop();
    this.state = 0;
    this.emit("stop", this.parent, this);
    return this;
  }
  seek(time) {
    this.clock.seek(time);
    return this;
  }
  seekToNext() {
    this.seek(this.nextTime);
    return this;
  }
  get isPlaying() {
    return this.clock.isRunning;
  }
  get completed() {
    return this.state === 2;
  }
  get timeScale() {
    return this.clock.timeScale;
  }
  set timeScale(timeScale) {
    this.clock.timeScale = timeScale;
  }
  setTimeScale(timeScale) {
    this.timeScale = timeScale;
    return this;
  }
  get now() {
    return this.clock.now;
  }
  update(now) {
    if (this.nextTime > now) {
      return this;
    }
    var commands = this.commands;
    while (1) {
      var item = commands[this.index];
      var command = item[1];
      if (!IsArray_default(command)) {
        command = Copy_default(CMD, item, 1);
      }
      runcommands_default(command, this.scope);
      this.emit("runcommand", command, this.scope);
      if (this.index >= commands.length - 1) {
        this.nextTime = 0;
        this.complete();
        return this;
      } else {
        this.index++;
        this.nextTime = this.getNextDt(this.nextTime);
        if (this.nextTime > now) {
          return this;
        }
      }
    }
  }
  complete() {
    this.clock.stop();
    this.state = 2;
    this.emit("complete", this.parent, this);
  }
  getNextDt(currentDt) {
    var time = this.commands[this.index][0];
    if (this.timeUnit === 1) {
      time = time * 1e3;
    }
    if (this.dtMode === 1) {
      time += currentDt;
    }
    return time;
  }
  setDtMode(dtMode) {
    if (typeof dtMode === "string") {
      dtMode = DTMODE[dtMode];
    }
    this.dtMode = dtMode;
    return this;
  }
  setTimeUnit(timeUnit) {
    if (typeof timeUnit === "string") {
      timeUnit = TIMEUNITMODE[timeUnit];
    }
    this.timeUnit = timeUnit;
    return this;
  }
};
var CMD = [];
var TIMEUNITMODE = {
  ms: 0,
  s: 1,
  sec: 1
};
var DTMODE = {
  abs: 0,
  absolute: 0,
  inc: 1,
  increment: 1
};
var Player_default = Player;

// node_modules/phaser3-rex-plugins/templates/ui/expbar/methods/OnLevelUp.js
var OnLevelUp = function(level, fromExp, toExp, levelStartExp, levelEndExp) {
  var time = (toExp - fromExp) / (levelEndExp - levelStartExp) * this.totalEaseDuration;
  var levelEnd = toExp === levelEndExp ? level + 1 : level;
  this.player.append(0, this.setEaseValueDuration, time).append(0, this.easeValueTo, toExp, levelStartExp, levelEndExp).append(0, this.emit, "levelup.start", level, fromExp, toExp, this).append(time, NOOP_default).append(0, this.emit, "levelup.end", levelEnd, fromExp, toExp, this);
  if (!this.player.isPlaying) {
    this.player.start();
  }
};
var OnLevelUp_default = OnLevelUp;

// node_modules/phaser3-rex-plugins/templates/ui/expbar/methods/ExpMethods.js
var ExpMethods_default = {
  setExpTable(table) {
    this.levelCounter.setTable(table);
    return this;
  },
  resetExp(exp) {
    this.levelCounter.resetExp(exp);
    this.setValue(this.exp, this.getExp(this.level), this.getExp(this.level + 1));
    return this;
  },
  getExp(level) {
    return this.levelCounter.getExp(level);
  },
  getLevel(exp, level) {
    return this.levelCounter.getLevel(exp, level);
  },
  getRequiredExpToNextLevel(level, exp) {
    return this.levelCounter.getRequiredExpToNextLevel(level, exp);
  },
  gainExp(exp) {
    this.levelCounter.gainExp(exp);
    return this;
  },
  setExp(exp) {
    this.levelCounter.setExp(exp);
    return this;
  },
  setLevel(level) {
    this.levelCounter.setLevel(level);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/expbar/ExpBar.js
var GetValue159 = Phaser.Utils.Objects.GetValue;
var ExpBar = class extends NameValueLabel_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexExpBar";
    this.setTotalEaseDuration(GetValue159(config, "easeDuration", 1e3));
    this.levelCounter = new levelcounter_default(GetValue159(config, "levelCounter"));
    this.player = new Player_default(this, {
      scope: this,
      dtMode: 1
    });
    this.levelCounter.on("levelup", OnLevelUp_default, this);
    this.player.on("complete", function() {
      this.player.clear();
      this.emit("levelup.complete", this.level, this);
    }, this);
    this.setValue(this.exp, this.getExp(this.level), this.getExp(this.level + 1));
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.levelCounter.destroy();
    this.levelCounter = void 0;
    this.player.destroy();
    this.player = void 0;
    super.destroy(fromScene);
  }
  get exp() {
    return this.levelCounter.exp;
  }
  set exp(value) {
    this.levelCounter.exp = value;
  }
  get level() {
    return this.levelCounter.level;
  }
  set level(value) {
    this.levelCounter.level = value;
  }
  get requiredExp() {
    return this.levelCounter.requiredExp;
  }
  setTotalEaseDuration(duration) {
    this.totalEaseDuration = duration;
    return this;
  }
};
Object.assign(
  ExpBar.prototype,
  ExpMethods_default
);
var ExpBar_default = ExpBar;

// node_modules/phaser3-rex-plugins/templates/ui/expbar/Factory.js
ObjectFactory_default.register("expBar", function(config) {
  var gameObject2 = new ExpBar_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ExpBar", ExpBar_default);

// node_modules/phaser3-rex-plugins/templates/ui/buttons/AddChildMethods.js
var SizerAdd = Sizer_default.prototype.add;
var SizerAddSpace = Sizer_default.prototype.addSpace;
var Add7 = function(gameObject2) {
  var isNormalGameObject = !gameObject2.isRexSpace;
  var proportion = !isNormalGameObject || this.buttonsExpand ? 1 : 0;
  if (this.sizerChildren.length === 0) {
    if (isNormalGameObject) {
      var hasHeadSpace = !this.buttonsExpand && (this.buttonsAlign === "right" || this.buttonsAlign === "center" || this.buttonsAlign === "bottom");
      if (hasHeadSpace) {
        SizerAddSpace.call(this);
      }
      SizerAdd.call(
        this,
        gameObject2,
        { proportion, expand: true }
      );
      var hasTailSpace = !this.buttonsExpand && this.buttonsAlign === "center";
      if (hasTailSpace) {
        SizerAddSpace.call(this);
      }
      this.hasTailSpace = hasTailSpace;
    } else {
      SizerAdd.call(
        this,
        gameObject2,
        { proportion, expand: true }
      );
      this.hasTailSpace = false;
    }
  } else {
    if (this.hasTailSpace) {
      var lastIndex = this.sizerChildren.length - 1;
      SizerAdd.call(
        this,
        gameObject2,
        { index: lastIndex, proportion, expand: true }
      );
    } else {
      SizerAdd.call(
        this,
        gameObject2,
        { proportion, expand: true }
      );
    }
  }
  if (isNormalGameObject) {
    this.buttonGroup.add(gameObject2);
  }
  return this;
};
var AddChildMethods_default6 = {
  addButton(gameObject2) {
    if (IsArray_default(gameObject2)) {
      var gameObjects = gameObject2;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add7.call(this, gameObjects[i]);
      }
    } else {
      Add7.call(this, gameObject2);
    }
    return this;
  },
  addButtons(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      Add7.call(this, gameObjects[i]);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/buttons/RemoveChildMethods.js
var SizerRmove = Sizer_default.prototype.remove;
var SizerClear = Sizer_default.prototype.clear;
var Remove = function(gameObject2, destroyChild) {
  if (this.getParentSizer(gameObject2) !== this) {
    return this;
  }
  this.buttonGroup.remove(gameObject2);
  SizerRmove.call(this, gameObject2, destroyChild);
  return this;
};
var RemoveChildMethods_default6 = {
  remove(gameObject2, destroyChild) {
    if (IsArray_default(gameObject2)) {
      var gameObjects = gameObject2;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Remove.call(this, gameObjects[i], destroyChild);
      }
    } else {
      Remove.call(this, gameObject2, destroyChild);
    }
    return this;
  },
  clear(destroyChild) {
    var buttons = this.buttonGroup.buttons;
    buttons.length = 0;
    SizerClear.call(this, destroyChild);
    return this;
  },
  removeButton(gameObject2, destroyChild) {
    var gameObject2 = this.getButton(gameObject2);
    if (!gameObject2) {
      return this;
    }
    this.remove(gameObject2, destroyChild);
    return this;
  },
  clearButtons(destroyChild) {
    var buttons = this.buttonGroup.buttons;
    for (var i = buttons.length - 1; i >= 0; i--) {
      Remove.call(this, buttons[i], destroyChild);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/OnButtonStateChange.js
var OnButtonStateChange = function(button, value, previousValue) {
  if (!button) {
    return;
  }
  var callback = this.setValueCallback;
  var scope = this.setValueCallbackScope;
  if (callback) {
    if (scope) {
      callback.call(scope, button, value, previousValue);
    } else {
      callback(button, value, previousValue);
    }
  }
  this.fireEvent("button.statechange", button, value, previousValue);
};
var OnButtonStateChange_default = OnButtonStateChange;

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/InjectSelectedProperty.js
var InjectSelectedProperty = function(gameObject2) {
  var self = this;
  gameObject2._selected = void 0;
  Object.defineProperty(gameObject2, "selected", {
    get: function() {
      return gameObject2._selected;
    },
    set: function(newValue) {
      if (gameObject2._selected === newValue) {
        return;
      }
      var previousValue = gameObject2._selected;
      gameObject2._selected = newValue;
      OnButtonStateChange_default.call(self, gameObject2, newValue, previousValue);
    },
    enumerable: true,
    configurable: true
  });
  gameObject2.selected = false;
};
var InjectSelectedProperty_default = InjectSelectedProperty;

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/AddMethods.js
var AddMethods_default2 = {
  add(gameObject2) {
    this.buttons.push(gameObject2);
    if (!gameObject2._click) {
      gameObject2._click = new Click_default(gameObject2, this.clickConfig);
      gameObject2._click.on("click", function(buttonBehavior, gameObject3, pointer, event) {
        this.fireEvent("button.click", gameObject3, pointer, event);
      }, this).on("enable", function(buttonBehavior, gameObject3) {
        this.fireEvent("button.enable", gameObject3);
      }, this).on("disable", function(buttonBehavior, gameObject3) {
        this.fireEvent("button.disable", gameObject3);
      }, this).on("over", function(buttonBehavior, gameObject3, pointer, event) {
        this.fireEvent("button.over", gameObject3, pointer, event);
      }, this).on("out", function(buttonBehavior, gameObject3, pointer, event) {
        this.fireEvent("button.out", gameObject3, pointer, event);
      }, this).on("down", function(buttonBehavior, gameObject3, pointer, event) {
        this.fireEvent("button.down", gameObject3, pointer, event);
      }, this).on("up", function(buttonBehavior, gameObject3, pointer, event) {
        this.fireEvent("button.up", gameObject3, pointer, event);
      }, this);
      if (gameObject2.isRexContainerLite) {
        gameObject2.sendChildToBack(gameObject2);
      }
    }
    if (this.buttonsType) {
      if (gameObject2.name === void 0) {
        console.error(`${this.parent.constructor.name}: Option button miss value`);
      }
      InjectSelectedProperty_default.call(this, gameObject2);
    }
    return this;
  },
  addMultiple(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      this.add(gameObjects[i]);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/RemoveMethods.js
var RemoveItem15 = Phaser.Utils.Array.Remove;
var RemoveMethods_default2 = {
  remove(gameObject2) {
    if (this.buttonsType) {
      delete gameObject2.selected;
    }
    RemoveItem15(this.buttons, gameObject2);
    return this;
  },
  clear() {
    if (this.buttonsType) {
      var buttons = this.buttons;
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        delete buttons[i].selected;
      }
    }
    this.buttons.length = 0;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/FireEvent.js
var FireEvent3 = function(eventName, button, ...args) {
  if (!this.buttons) {
    return;
  }
  var index;
  if (typeof button === "number") {
    index = button;
    button = this.buttons[index];
    if (!button) {
      return;
    }
  } else {
    index = this.buttons.indexOf(button);
    if (index === -1) {
      return;
    }
  }
  if (this.eventEmitter !== this.parent) {
    this.parent.emit(eventName, button, index, ...args);
  }
  if (this.groupName !== void 0) {
    this.eventEmitter.emit(eventName, button, this.groupName, index, ...args);
  } else {
    this.eventEmitter.emit(eventName, button, index, ...args);
  }
};
var FireEvent_default = FireEvent3;

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/ButtonsTypeMethods.js
var GetValue160 = Phaser.Utils.Objects.GetValue;
var ButtonsTypeMethods_default = {
  setButtonsType(config) {
    if (config === void 0) {
      config = {};
    }
    var buttonsType = GetValue160(config, "buttonsType", config.type);
    this.buttonsType = buttonsType;
    if (!this.buttonsType) {
      return this;
    }
    var setValueCallback, setValueCallbackScope;
    setValueCallback = GetValue160(config, "setValueCallback", void 0);
    setValueCallbackScope = GetValue160(config, "setValueCallbackScope", void 0);
    if (setValueCallback === void 0) {
      setValueCallback = GetValue160(config, "setButtonStateCallback", void 0);
      setValueCallbackScope = GetValue160(config, "setButtonStateCallbackScope", void 0);
    }
    this.setValueCallback = setValueCallback;
    this.setValueCallbackScope = setValueCallbackScope;
    switch (buttonsType) {
      case "radio":
        this.setRadioType();
        break;
      case "checkboxes":
        this.setCheckboxesType();
        break;
    }
    return this;
  },
  setRadioType() {
    var parent = this.parent, buttons = this.buttons;
    parent._value = void 0;
    var selectedIndex = void 0;
    Object.defineProperty(parent, "value", {
      get: function() {
        return parent._value;
      },
      set: function(newValue) {
        if (parent._value === newValue) {
          return;
        }
        parent._value = newValue;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          var button = buttons[i];
          if (button.rexSizer.hidden) {
            continue;
          }
          if (selectedIndex === void 0) {
            if (button.name === newValue) {
              button.selected = true;
            } else {
              button.selected = false;
            }
          } else {
            if (selectedIndex === i) {
              button.selected = true;
            } else {
              button.selected = false;
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    parent.on("button.click", function(button) {
      selectedIndex = this.buttons.indexOf(button);
      parent.value = button.name;
      selectedIndex = void 0;
    }, this);
    return this;
  },
  setCheckboxesType() {
    var parent = this.parent;
    parent.on("button.click", function(button) {
      button.selected = !button.selected;
    });
    return this;
  },
  // Common
  clearAllButtonsState() {
    var buttons = this.buttons;
    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
      var button = buttons[i];
      button.selected = false;
    }
    return this;
  },
  getAllButtonsState() {
    var states = {};
    var buttons = this.buttons;
    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
      var button = buttons[i];
      if (button.rexSizer.hidden) {
        continue;
      }
      states[button.name] = button.selected;
    }
    return states;
  },
  // For radio
  setSelectedButtonName(name2) {
    this.parent.value = name2;
    return this;
  },
  getSelectedButtonName() {
    return this.parent.value;
  },
  // For checkboxes
  setButtonState(name2, state) {
    if (state === void 0) {
      state = true;
    }
    var buttons = this.buttons;
    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
      var button = buttons[i];
      if (button.rexSizer.hidden) {
        continue;
      }
      if (button.name === name2) {
        button.selected = state;
        break;
      }
    }
    return this;
  },
  getButtonState(name2) {
    var buttons = this.buttons;
    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
      var button = buttons[i];
      if (button.rexSizer.hidden) {
        continue;
      }
      if (button.name === name2) {
        return button.selected;
      }
    }
    return void 0;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/system/GetGameObjectByName.js
var GetGameObjectByName = function(children, name2) {
  if (!children) {
    return null;
  } else if (IsArray_default(children)) {
    var child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = TestName(children[i], name2);
      if (child) {
        return child;
      }
    }
  } else {
    var child;
    for (var key2 in children) {
      child = TestName(children[key2], name2);
      if (child) {
        return child;
      }
    }
  }
};
var TestName = function(gameObject2, name2) {
  if (!gameObject2) {
    return null;
  } else if (gameObject2.hasOwnProperty("name")) {
    return gameObject2.name === name2 ? gameObject2 : null;
  } else {
    return GetElementByName(gameObject2, name2);
  }
};
var GetGameObjectByName_default = GetGameObjectByName;

// node_modules/phaser3-rex-plugins/templates/ui/utils/GetGameObjectByName.js
var GetGameObjectByName_default2 = GetGameObjectByName_default;

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/ButtonMethods.js
var ButtonMethods_default = {
  getButton(index) {
    var buttons = this.buttons, button;
    var indexType = typeof index;
    switch (indexType) {
      case "number":
        button = buttons[index];
        break;
      case "string":
        button = GetGameObjectByName_default2(buttons, index);
        break;
      default:
        button = index;
        if (buttons.indexOf(button) === -1) {
          button = void 0;
        }
        break;
    }
    return button;
  },
  getButtons() {
    return this.buttons;
  },
  hasAnyButton() {
    return this.buttons.length > 0;
  },
  setButtonEnable(index, enabled) {
    var buttons = this.buttons;
    if (index === void 0 || typeof index === "boolean") {
      enabled = index;
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        buttons[i]._click.setEnable(enabled);
      }
    } else {
      this.getButton(index)._click.setEnable(enabled);
    }
    return this;
  },
  toggleButtonEnable(index) {
    var buttons = this.buttons;
    if (index === void 0 || typeof index === "boolean") {
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        buttons[i]._click.toggleEnable();
      }
    } else {
      this.getButton(index)._click.toggleEnable();
    }
    return this;
  },
  getButtonEnable(index) {
    if (index === void 0) {
      index = 0;
    }
    return this.getButton(index)._click.enable;
  },
  emitButtonClick(index) {
    var buttonGroup = this.buttonGroup ? this.buttonGroup : this;
    buttonGroup.fireEvent("button.click", index);
    return this;
  },
  emitButtonOver(index) {
    var buttonGroup = this.buttonGroup ? this.buttonGroup : this;
    var buttons = this.buttons;
    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
      var button = buttons[i];
      if (!button._click.isOver) {
        continue;
      }
      button._click.isOver = false;
      buttonGroup.fireEvent("button.out", button);
    }
    var button = this.getButton(index);
    if (button) {
      button._click.isOver = true;
      buttonGroup.fireEvent("button.over", button);
    }
    return this;
  },
  showButton(index) {
    Show(this.getButton(index));
    return this;
  },
  hideButton(index) {
    Hide(this.getButton(index));
    return this;
  },
  isButtonShown(index) {
    IsShown(this.getButton(index));
    return this;
  },
  forEachButtton(callback, scope) {
    var buttons = this.buttons;
    for (var i = 0, cnt = buttons.length; i < cnt; i++) {
      if (scope) {
        callback.call(scope, buttons[i], i, buttons);
      } else {
        callback(buttons[i], i, buttons);
      }
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/ButtonGroup.js
var ButtonGroup = class {
  constructor(config) {
    this.parent = config.parent;
    this.eventEmitter = config.eventEmitter;
    this.groupName = config.groupName;
    this.clickConfig = config.clickConfig;
    this.buttonsType = void 0;
    this.buttons = [];
  }
  destroy() {
    this.parent = void 0;
    this.eventEmitter = void 0;
    this.clickConfig = void 0;
    this.buttons = void 0;
  }
};
var methods29 = {
  fireEvent: FireEvent_default
};
Object.assign(
  ButtonGroup.prototype,
  AddMethods_default2,
  RemoveMethods_default2,
  ButtonsTypeMethods_default,
  ButtonMethods_default,
  methods29
);
var ButtonGroup_default = ButtonGroup;

// node_modules/phaser3-rex-plugins/templates/ui/utils/buttongroup/ButtonStateMethods.js
var ButtonStateMethods_default = {
  // Common
  clearAllButtonsState() {
    this.buttonGroup.clearAllButtonsState();
    return this;
  },
  getAllButtonsState() {
    return this.buttonGroup.getAllButtonsState();
  },
  // For radio
  setSelectedButtonName(name2) {
    this.buttonGroup.setSelectedButtonName(name2);
    return this;
  },
  getSelectedButtonName() {
    return this.buttonGroup.getSelectedButtonName();
  },
  // For checkboxes
  setButtonState(name2, state) {
    this.buttonGroup.setButtonState(name2, state);
    return this;
  },
  getButtonState(name2) {
    return this.buttonGroup.getButtonState(name2);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/buttons/Buttons.js
var GetValue161 = Phaser.Utils.Objects.GetValue;
var Buttons = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var buttonSpace = config.space;
    if (typeof buttonSpace === "number") {
      config.space = { item: buttonSpace };
    }
    super(scene, config);
    this.type = "rexButtons";
    this.buttonGroup = new ButtonGroup_default({
      parent: this,
      eventEmitter: GetValue161(config, "eventEmitter", this),
      groupName: GetValue161(config, "groupName", void 0),
      clickConfig: GetValue161(config, "click", void 0)
    }).setButtonsType(config);
    var background = GetValue161(config, "background", void 0);
    var buttons = GetValue161(config, "buttons", void 0);
    this.buttonsExpand = GetValue161(config, "expand", false);
    this.buttonsAlign = GetValue161(config, "align", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (buttons) {
      this.addButtons(buttons);
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("buttons", this.buttonGroup.buttons);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    this.buttonGroup.destroy();
    this.buttonGroup = void 0;
  }
  get buttons() {
    return this.buttonGroup.buttons;
  }
  get groupName() {
    return this.buttonGroup.groupName;
  }
  set groupName(value) {
    this.buttonGroup.groupName = value;
  }
  get eventEmitter() {
    return this.buttonGroup.eventEmitter;
  }
};
Object.assign(
  Buttons.prototype,
  AddChildMethods_default6,
  RemoveChildMethods_default6,
  ButtonMethods_default,
  ButtonStateMethods_default
);
var Buttons_default = Buttons;

// node_modules/phaser3-rex-plugins/templates/ui/buttons/Factory.js
ObjectFactory_default.register("buttons", function(config) {
  var gameObject2 = new Buttons_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Buttons", Buttons_default);

// node_modules/phaser3-rex-plugins/templates/ui/gridbuttons/AddChildMethods.js
var SizerAdd2 = GridSizer_default.prototype.add;
var AddChildMethods_default7 = {
  addButton(gameObject2, columnIndex, rowIndex) {
    SizerAdd2.call(this, gameObject2, columnIndex, rowIndex, void 0, 0, this.buttonsExpand);
    this.buttonGroup.add(gameObject2);
    return this;
  },
  addButtons(gameObjects, rowThenColumn) {
    for (var i = 0, cnt = gameObjects; i < cnt; i++) {
      this.addButton(gameObjects[i], void 0, rowThenColumn);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/gridbuttons/RemoveChildMethods.js
var SizerRmove2 = GridSizer_default.prototype.remove;
var SizerClear2 = GridSizer_default.prototype.clear;
var Remove2 = function(gameObject2, destroyChild) {
  var gameObject2 = this.getButton(gameObject2);
  if (!gameObject2) {
    return this;
  }
  this.buttonGroup.remove(gameObject2);
  SizerRmove2.call(this, gameObject2, destroyChild);
  return this;
};
var RemoveChildMethods_default7 = {
  remove(gameObject2, destroyChild) {
    if (IsArray_default(gameObject2)) {
      var gameObjects = gameObject2;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Remove2.call(this, gameObjects[i], destroyChild);
      }
    } else {
      Remove2.call(this, gameObject2, destroyChild);
    }
    return this;
  },
  clear(destroyChild) {
    var buttons = this.buttonGroup.buttons;
    buttons.length = 0;
    SizerClear2.call(this, destroyChild);
    return this;
  },
  removeButton(gameObject2, destroyChild) {
    this.remove(gameObject2, destroyChild);
    return this;
  },
  clearButtons(destroyChild) {
    var buttons = this.buttonGroup.buttons;
    for (var i = buttons.length - 1; i >= 0; i--) {
      Remove2.call(this, buttons[i], destroyChild);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/gridbuttons/GridButtons.js
var GetValue162 = Phaser.Utils.Objects.GetValue;
var GridButtons = class extends GridSizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var rowCount = GetValue162(config, "row", 0);
    var columnCount = GetValue162(config, "column", config.col || 0);
    var createCellContainerCallback = GetValue162(config, "createCellContainerCallback");
    var buttons = GetValue162(config, "buttons", void 0);
    var buttonsExpand = GetValue162(config, "expand", true);
    var buttonProportion = buttonsExpand ? 1 : 0;
    if (createCellContainerCallback) {
      config.createCellContainerCallback = void 0;
    }
    if (buttons !== void 0) {
      rowCount = Math.max(rowCount, buttons.length);
      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        columnCount = Math.max(columnCount, buttons[i].length);
      }
    }
    config.row = rowCount;
    config.column = columnCount;
    config.columnProportions = buttonProportion;
    config.rowProportions = buttonProportion;
    super(scene, config);
    this.type = "rexGridButtons";
    this.buttonGroup = new ButtonGroup_default({
      parent: this,
      eventEmitter: GetValue162(config, "eventEmitter", this),
      groupName: GetValue162(config, "groupName", void 0),
      clickConfig: GetValue162(config, "click", void 0)
    }).setButtonsType(config);
    var background = GetValue162(config, "background", void 0);
    this.buttonsExpand = buttonsExpand;
    var space = GetValue162(config, "space", void 0);
    if (typeof space === "number") {
      space = { itemX: space, itemY: space };
    }
    if (background) {
      this.addBackground(background);
    }
    if (buttons) {
      var rowButtons, button;
      for (var r = 0, rcnt = buttons.length; r < rcnt; r++) {
        rowButtons = buttons[r];
        for (var c = 0, ccnt = rowButtons.length; c < ccnt; c++) {
          button = rowButtons[c];
          if (button) {
            this.addButton(button, c, r);
          }
        }
      }
    } else if (createCellContainerCallback) {
      for (var y = 0; y < rowCount; y++) {
        for (var x = 0; x < columnCount; x++) {
          var button = createCellContainerCallback(scene, x, y);
          if (button) {
            this.addButton(button, x, y);
          }
        }
      }
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("buttons", this.buttonGroup.buttons);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    this.buttonGroup.destroy();
    this.buttonGroup = void 0;
  }
  get buttons() {
    return this.buttonGroup.buttons;
  }
  get groupName() {
    return this.buttonGroup.groupName;
  }
  set groupName(value) {
    this.buttonGroup.groupName = value;
  }
  get eventEmitter() {
    return this.buttonGroup.eventEmitter;
  }
};
Object.assign(
  GridButtons.prototype,
  AddChildMethods_default7,
  RemoveChildMethods_default7,
  ButtonMethods_default,
  ButtonStateMethods_default
);
var GridButtons_default = GridButtons;

// node_modules/phaser3-rex-plugins/templates/ui/gridbuttons/Factory.js
ObjectFactory_default.register("gridButtons", function(config) {
  var gameObject2 = new GridButtons_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.GridButtons", GridButtons_default);

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthbuttons/AddChildMethods.js
var SizerAdd3 = FixWidthSizer_default.prototype.add;
var Add8 = function(gameObject2) {
  SizerAdd3.call(this, gameObject2);
  this.buttonGroup.add(gameObject2);
  return this;
};
var AddChildMethods_default8 = {
  addButton(gameObject2) {
    if (IsArray_default(gameObject2)) {
      var gameObjects = gameObject2;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add8.call(this, gameObjects[i]);
      }
    } else {
      Add8.call(this, gameObject2);
    }
    return this;
  },
  addButtons(gameObjects) {
    if (IsArray_default(gameObjects[0])) {
      var lines = gameObjects, line;
      for (var lineIdx = 0, lastLineIdx = lines.length - 1; lineIdx <= lastLineIdx; lineIdx++) {
        line = lines[lineIdx];
        for (var i = 0, cnt = line.length; i < cnt; i++) {
          Add8.call(this, line[i]);
        }
        if (lineIdx > lastLineIdx) {
          SizerAdd3.addNewLine(this);
        }
      }
    } else {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add8.call(this, gameObjects[i]);
      }
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthbuttons/RemoveChildMethods.js
var SizerRmove3 = FixWidthSizer_default.prototype.remove;
var SizerClear3 = FixWidthSizer_default.prototype.clear;
var Remove3 = function(gameObject2, destroyChild) {
  var gameObject2 = this.getButton(gameObject2);
  if (!gameObject2) {
    return this;
  }
  this.buttonGroup.remove(gameObject2);
  SizerRmove3.call(this, gameObject2, destroyChild);
  return this;
};
var RemoveChildMethods_default8 = {
  remove(gameObject2, destroyChild) {
    if (IsArray_default(gameObject2)) {
      var gameObjects = gameObject2;
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Remove3.call(this, gameObjects[i], destroyChild);
      }
    } else {
      Remove3.call(this, gameObject2, destroyChild);
    }
    return this;
  },
  clear(destroyChild) {
    var buttons = this.buttonGroup.buttons;
    buttons.length = 0;
    SizerClear3.call(this, destroyChild);
    return this;
  },
  removeButton(gameObject2, destroyChild) {
    this.remove(gameObject2, destroyChild);
    return this;
  },
  clearButtons(destroyChild) {
    var buttons = this.buttonGroup.buttons;
    for (var i = buttons.length - 1; i >= 0; i--) {
      Remove3.call(this, buttons[i], destroyChild);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthbuttons/FixWidthButtons.js
var GetValue163 = Phaser.Utils.Objects.GetValue;
var Buttons2 = class extends FixWidthSizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var buttonSpace = config.space;
    if (typeof buttonSpace === "number") {
      config.space = { item: buttonSpace, line: buttonSpace };
    }
    super(scene, config);
    this.type = "rexFixWidthButtons";
    this.buttonGroup = new ButtonGroup_default({
      parent: this,
      eventEmitter: GetValue163(config, "eventEmitter", this),
      groupName: GetValue163(config, "groupName", void 0),
      clickConfig: GetValue163(config, "click", void 0)
    }).setButtonsType(config);
    var background = GetValue163(config, "background", void 0);
    var buttons = GetValue163(config, "buttons", void 0);
    this.buttonsAlign = GetValue163(config, "align", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (buttons) {
      this.addButtons(buttons);
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("buttons", this.buttonGroup.buttons);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    this.buttonGroup.destroy();
    this.buttonGroup = void 0;
  }
  get buttons() {
    return this.buttonGroup.buttons;
  }
  get groupName() {
    return this.buttonGroup.groupName;
  }
  set groupName(value) {
    this.buttonGroup.groupName = value;
  }
  get eventEmitter() {
    return this.buttonGroup.eventEmitter;
  }
};
Object.assign(
  Buttons2.prototype,
  AddChildMethods_default8,
  RemoveChildMethods_default8,
  ButtonMethods_default,
  ButtonStateMethods_default
);
var FixWidthButtons_default = Buttons2;

// node_modules/phaser3-rex-plugins/templates/ui/fixwidthbuttons/Factory.js
ObjectFactory_default.register("fixWidthButtons", function(config) {
  var gameObject2 = new FixWidthButtons_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.FixWidthButtons", FixWidthButtons_default);

// node_modules/phaser3-rex-plugins/templates/ui/fileselectorbutton/FileChooserMethods.js
var FileChooserMethods_default = {
  setAccept(accept) {
    this.childrenMap.fileChooser.setAccept(accept);
    return this;
  },
  setMultiple(enabled) {
    this.childrenMap.fileChooser.setMultiple(enabled);
    return this;
  },
  loadFile(file, loaderType, key2, cacheType, onComplete) {
    this.childrenMap.fileChooser.loadFile(file, loaderType, key2, cacheType, onComplete);
    return this;
  },
  loadFilePromise(file, loaderType, key2, cacheType) {
    return this.childrenMap.fileChooser.loadFilePromise(file, loaderType, key2, cacheType);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/fileselectorbutton/FileSelectorButton.js
var GetValue164 = Phaser.Utils.Objects.GetValue;
var FileSelectorButton = class extends Label_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexFileSelectorButton";
    var fileChooser = new FileChooser_default(scene);
    scene.add.existing(fileChooser);
    this.addBackground(fileChooser);
    this.addChildrenMap("fileChooser", fileChooser);
    this.setAccept(GetValue164(config, "accept", ""));
    this.setMultiple(GetValue164(config, "multiple", false));
    fileChooser.on("change", function(gameObject2) {
      var files = gameObject2.files;
      if (files.length === 0) {
        return;
      }
      files = Array.from(files);
      this.emit("select", files, this);
    }, this);
  }
  get files() {
    return this.childrenMap.fileChooser.files;
  }
};
Object.assign(
  FileSelectorButton.prototype,
  FileChooserMethods_default
);
var FileSelectorButton_default = FileSelectorButton;

// node_modules/phaser3-rex-plugins/templates/ui/fileselectorbutton/Factory.js
ObjectFactory_default.register("fileSelectorButton", function(config) {
  var gameObject2 = new FileSelectorButton_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.FileSelectorButton", FileSelectorButton_default);

// node_modules/phaser3-rex-plugins/templates/ui/dialog/methods/ButtonMethods.js
var ButtonMethods_default2 = {
  getChoice(index) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      return choicesSizer.getButton(index);
    } else {
      return void 0;
    }
  },
  getAction(index) {
    return this.childrenMap.actionsSizer.getButton(index);
  },
  getToolbar(index) {
    return this.childrenMap.toolbarSizer.getButton(index);
  },
  getLeftToolbar(index) {
    return this.childrenMap.leftToolbarSizer.getButton(index);
  },
  setChoiceEnable(index, enabled) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.setButtonEnable(index, enabled);
    }
    return this;
  },
  setActionEnable(index, enabled) {
    this.childrenMap.actionsSizer.setButtonEnable(index, enabled);
    return this;
  },
  setToolbarEnable(index, enabled) {
    this.childrenMap.toolbarSizer.setButtonEnable(index, enabled);
    return this;
  },
  setLeftToolbarEnable(index, enabled) {
    this.childrenMap.leftToolbarSizer.setButtonEnable(index, enabled);
    return this;
  },
  toggleChoiceEnable(index) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.toggleButtonEnable(index);
    }
    return this;
  },
  toggleActionEnable(index) {
    this.childrenMap.actionsSizer.toggleButtonEnable(index);
    return this;
  },
  toggleToolbarEnable(index) {
    this.childrenMap.toolbarSizer.toggleButtonEnable(index);
    return this;
  },
  toggleLeftToolbarEnable(index) {
    this.childrenMap.leftToolbarSizer.toggleButtonEnable(index);
    return this;
  },
  getChoiceEnable(index) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      return choicesSizer.getButtonEnable(index);
    } else {
      return false;
    }
  },
  getActionEnable(index) {
    return this.childrenMap.actionsSizer.getButtonEnable(index);
  },
  getToolbarEnable(index) {
    return this.childrenMap.toolbarSizer.getButtonEnable(index);
  },
  getLeftToolbarEnable(index) {
    return this.childrenMap.leftToolbarSizer.getButtonEnable(index);
  },
  emitChoiceClick(index) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.emitButtonClick(index);
    }
    return this;
  },
  emitActionClick(index) {
    this.childrenMap.actionsSizer.emitButtonClick(index);
    return this;
  },
  emitToolbarClick(index) {
    this.childrenMap.toolbarSizer.emitButtonClick(index);
    return this;
  },
  emitLeftToolbarClick(index) {
    this.childrenMap.leftToolbarSizer.emitButtonClick(index);
    return this;
  },
  showChoice(index) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.showButton(index);
    }
    return this;
  },
  showAction(index) {
    this.childrenMap.actionsSizer.showButton(index);
    return this;
  },
  showToolbar(index) {
    this.childrenMap.toolbarSizer.showButton(index);
    return this;
  },
  showLeftToolbar(index) {
    this.childrenMap.leftToolbarSizer.showButton(index);
    return this;
  },
  hideChoice(index) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.hideButton(index);
    }
    return this;
  },
  hideAction(index) {
    this.childrenMap.actionsSizer.hideButton(index);
    return this;
  },
  hideToolbar(index) {
    this.childrenMap.toolbarSizer.hideButton(index);
    return this;
  },
  hideLeftToolbar(index) {
    this.childrenMap.leftToolbarSizer.hideButton(index);
    return this;
  },
  addChoice(gameObject2) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.addButton(gameObject2);
    }
    return this;
  },
  addAction(gameObject2) {
    this.childrenMap.actionsSizer.addButton(gameObject2);
    return this;
  },
  addToolbar(gameObject2) {
    this.childrenMap.toolbarSizer.addButton(gameObject2);
    return this;
  },
  addLeftToolbar(gameObject2) {
    this.childrenMap.leftToolbarSizer.addButton(gameObject2);
    return this;
  },
  removeChoice(index, destroyChild) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.removeButton(index, destroyChild);
    }
    return this;
  },
  removeAction(index, destroyChild) {
    this.childrenMap.actionsSizer.removeButton(index, destroyChild);
    return this;
  },
  removeToolbar(index, destroyChild) {
    this.childrenMap.toolbarSizer.removeButton(index, destroyChild);
    return this;
  },
  removeLeftToolbar(index, destroyChild) {
    this.childrenMap.leftToolbarSizer.removeButton(index, destroyChild);
    return this;
  },
  clearChoices(destroyChild) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.clearButtons(destroyChild);
    }
    return this;
  },
  clearActions(destroyChild) {
    this.childrenMap.actionsSizer.clearButtons(destroyChild);
    return this;
  },
  clearToolbar(destroyChild) {
    this.childrenMap.toolbarSizer.clearButtons(destroyChild);
    return this;
  },
  clearLeftToolbar(destroyChild) {
    this.childrenMap.leftToolbarSizer.clearButtons(destroyChild);
    return this;
  },
  forEachChoice(callback, scope) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.forEachButtton(callback, scope);
    }
    return this;
  },
  forEachAction(callback, scope) {
    this.childrenMap.actionsSizer.forEachButtton(callback, scope);
    return this;
  },
  forEachToolbar(callback, scope) {
    this.childrenMap.toolbarSizer.forEachButtton(callback, scope);
    return this;
  },
  forEachLeftToolbar(callback, scope) {
    this.childrenMap.leftToolbarSizer.forEachButtton(callback, scope);
    return this;
  },
  setAllButtonsEnable(enabled) {
    if (enabled === void 0) {
      enabled = true;
    }
    if (this.childrenMap.toolbarSizer) {
      this.setToolbarEnable(enabled);
    }
    if (this.childrenMap.leftToolbarSizer) {
      this.setLeftToolbarEnable(enabled);
    }
    if (this.childrenMap.actionsSizer) {
      this.setActionEnable(enabled);
    }
    if (this.childrenMap.choicesSizer) {
      this.setChoiceEnable(enabled);
    }
    return this;
  },
  // Checkboxes
  getChoicesButtonStates() {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      return choicesSizer.getAllButtonsState();
    } else {
      return {};
    }
  },
  getChoicesButtonState(name2) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (name2 === void 0) {
      if (choicesSizer) {
        return choicesSizer.getAllButtonsState();
      } else {
        return {};
      }
    } else {
      if (choicesSizer) {
        return choicesSizer.getButtonState(name2);
      } else {
        return false;
      }
    }
  },
  setChoicesButtonState(name2, state) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.setButtonState(name2, state);
    }
    return this;
  },
  clearChoicesButtonStates() {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.clearAllButtonsState();
    }
    return this;
  },
  // Radio buttons
  getChoicesSelectedButtonName() {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      return choicesSizer.getSelectedButtonName();
    } else {
      return "";
    }
  },
  setChoicesSelectedButtonName(name2) {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      choicesSizer.setSelectedButtonName(name2);
    }
    return this;
  },
  hasAnyChoice() {
    var choicesSizer = this.childrenMap.choicesSizer;
    if (choicesSizer) {
      return choicesSizer.hasAnyButton();
    }
    return false;
  },
  hasAnyAction() {
    var actionsSizer = this.childrenMap.actionsSizer;
    if (actionsSizer) {
      return actionsSizer.hasAnyButton();
    }
    return false;
  },
  hasAnyToolbar() {
    var toolbarSizer = this.childrenMap.toolbarSizer;
    if (toolbarSizer) {
      return toolbarSizer.hasAnyButton();
    }
    return false;
  },
  hasAnyLeftToolbar() {
    var leftToolbarSizer = this.childrenMap.leftToolbarSizer;
    if (leftToolbarSizer) {
      return leftToolbarSizer.hasAnyButton();
    }
    return false;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/dialog/methods/ModalMethods.js
var ModalMethods_default2 = {
  onCreateModalBehavior(self) {
    self.on("button.click", function(button, groupName, index, pointer, event) {
      var canClose = false;
      switch (groupName) {
        case "actions":
          canClose = true;
          break;
        case "choices":
          if (!self.hasAnyAction()) {
            canClose = true;
          }
          break;
      }
      if (!canClose) {
        return;
      }
      var closeEventData = {
        index,
        text: button.text,
        button,
        dialog: self
      };
      switch (self.buttonsType) {
        case "radio":
          closeEventData.value = self.getChoicesSelectedButtonName();
          break;
        case "checkboxes":
          closeEventData.value = self.getChoicesButtonStates();
          break;
        default:
          closeEventData.value = void 0;
      }
      self.modalClose(closeEventData);
    });
  },
  modal(config, onClose) {
    if (config && config.defaultBehavior === false) {
      this.onCreateModalBehavior = false;
    } else {
      delete this.onCreateModalBehavior;
    }
    ModalMethods_default.modal.call(this, config, onClose);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/dialog/methods/Methods.js
var Methods15 = {};
Object.assign(
  Methods15,
  ButtonMethods_default2,
  ModalMethods_default2
);
var Methods_default31 = Methods15;

// node_modules/phaser3-rex-plugins/templates/ui/dialog/Dialog.js
var GetValue165 = Phaser.Utils.Objects.GetValue;
var Dialog = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = 1;
    super(scene, config);
    this.type = "rexDialog";
    this.eventEmitter = GetValue165(config, "eventEmitter", this);
    var background = GetValue165(config, "background", void 0);
    var title = GetValue165(config, "title", void 0);
    var toolbar = GetValue165(config, "toolbar", void 0);
    var toolbarBackground = GetValue165(config, "toolbarBackground", void 0);
    var leftToolbar = GetValue165(config, "leftToolbar", void 0);
    var leftToolbarBackground = GetValue165(config, "leftToolbarBackground", void 0);
    var content = GetValue165(config, "content", void 0);
    var description = GetValue165(config, "description", void 0);
    var choicesSizer;
    var choices = GetValue165(config, "choices", void 0);
    var choicesBackground = GetValue165(config, "choicesBackground", void 0);
    var actionsSizer;
    var actions = GetValue165(config, "actions", void 0);
    var actionsBackground = GetValue165(config, "actionsBackground", void 0);
    var clickConfig = GetValue165(config, "click", void 0);
    if (background) {
      this.addBackground(background);
    }
    var toolbarSizer;
    if (toolbar) {
      toolbarSizer = new Buttons_default(scene, {
        groupName: "toolbar",
        background: toolbarBackground,
        buttons: toolbar,
        orientation: 0,
        // Left-right
        space: { item: GetValue165(config, "space.toolbarItem", 0) },
        click: clickConfig,
        eventEmitter: this.eventEmitter
      });
      scene.add.existing(toolbarSizer);
    }
    var leftToolbarSizer;
    if (leftToolbar) {
      leftToolbarSizer = new Buttons_default(scene, {
        groupName: "leftToolbar",
        background: leftToolbarBackground,
        buttons: leftToolbar,
        orientation: 0,
        // Left-right
        space: { item: GetValue165(config, "space.leftToolbarItem", 0) },
        click: clickConfig,
        eventEmitter: this.eventEmitter
      });
      scene.add.existing(leftToolbarSizer);
    }
    if (title || toolbar || leftToolbar) {
      var titleExpandWidth = !!title && GetValue165(config, "expand.title", true);
      var titleAlign = GetValue165(config, "align.title", "center");
      var useOverlapSizer = (
        // Has title, title is not exapnd-width, title align to center
        title && !titleExpandWidth && titleAlign === "center" || // No title
        !title && (toolbar || leftToolbar)
      );
      var useSizer = !useOverlapSizer;
      var titleSizer;
      if (useSizer) {
        titleSizer = new Sizer_default(scene, { orientation: 0 });
      } else {
        titleSizer = new OverlapSizer_default(scene);
      }
      scene.add.existing(titleSizer);
      var titleChildExpand = useSizer ? true : { height: true };
      if (leftToolbarSizer) {
        titleSizer.add(
          leftToolbarSizer,
          { align: "left", expand: titleChildExpand }
        );
      }
      if (title) {
        if (useSizer && !titleExpandWidth && titleAlign === "right") {
          titleSizer.addSpace();
        }
        var padding = {
          left: GetValue165(config, "space.titleLeft", 0),
          right: GetValue165(config, "space.titleRight", 0)
        };
        var proportion = titleExpandWidth ? 1 : 0;
        titleSizer.add(
          title,
          { align: titleAlign, proportion, expand: titleChildExpand, padding }
        );
        if (useSizer && !titleExpandWidth && titleAlign === "left") {
          titleSizer.addSpace();
        }
      }
      if (toolbarSizer) {
        if (useSizer && !title) {
          titleSizer.addSpace();
        }
        titleSizer.add(
          toolbarSizer,
          { align: "right", expand: titleChildExpand }
        );
      }
      var padding;
      if (content || description || choices || actions) {
        padding = {
          bottom: GetValue165(config, "space.title", 0),
          top: GetValue165(config, "space.titleTop", 0)
        };
      }
      var proportion = GetValue165(config, "proportion.title", 0);
      this.add(
        titleSizer,
        { padding, proportion, expand: true }
      );
    }
    if (content) {
      var align = GetValue165(config, "align.content", "center");
      var contentSpace = GetValue165(config, "space.content", 0);
      var padding = {
        left: GetValue165(config, "space.contentLeft", 0),
        right: GetValue165(config, "space.contentRight", 0),
        bottom: description || choices || actions ? contentSpace : 0
      };
      var proportion = GetValue165(config, "proportion.content", 0);
      var expand = GetValue165(config, "expand.content", true);
      this.add(
        content,
        { align, padding, proportion, expand }
      );
    }
    if (description) {
      var align = GetValue165(config, "align.description", "center");
      var descriptionSpace = GetValue165(config, "space.description", 0);
      var padding = {
        left: GetValue165(config, "space.descriptionLeft", 0),
        right: GetValue165(config, "space.descriptionRight", 0),
        bottom: choices || actions ? descriptionSpace : 0
      };
      var proportion = GetValue165(config, "proportion.description", 0);
      var expand = GetValue165(config, "expand.description", true);
      this.add(
        description,
        { align, padding, proportion, expand }
      );
    }
    if (choices) {
      var choicesType = GetValue165(config, "choicesType", "").split("-");
      var ButtonsClass = Contains3(choicesType, "wrap") ? FixWidthButtons_default : Contains3(choicesType, "grid") ? GridButtons_default : Buttons_default;
      var buttonsType = Contains3(choicesType, "radio") ? "radio" : Contains3(choicesType, "checkboxes") ? "checkboxes" : void 0;
      var space = {
        left: GetValue165(config, "space.choicesBackgroundLeft", 0),
        right: GetValue165(config, "space.choicesBackgroundRight", 0),
        top: GetValue165(config, "space.choicesBackgroundTop", 0),
        bottom: GetValue165(config, "space.choicesBackgroundBottom", 0)
      };
      var itemSpace = GetValue165(config, "space.choice", 0);
      if (ButtonsClass === Buttons_default) {
        space.item = itemSpace;
      } else if (ButtonsClass === FixWidthButtons_default) {
        space.item = itemSpace;
        space.line = GetValue165(config, "space.choiceLine", itemSpace);
      } else {
        space.column = GetValue165(config, "space.choiceColumn", itemSpace);
        space.row = GetValue165(config, "space.choiceRow", itemSpace);
      }
      var choicesConfig = {
        width: GetValue165(config, "choicesWidth", void 0),
        height: GetValue165(config, "choicesHeight", void 0),
        groupName: "choices",
        buttonsType,
        background: choicesBackground,
        buttons: choices,
        space,
        click: clickConfig,
        eventEmitter: this.eventEmitter,
        setValueCallback: GetValue165(config, "choicesSetValueCallback", void 0),
        setValueCallbackScope: GetValue165(config, "choicesSetValueCallbackScope", void 0)
      };
      if (ButtonsClass === Buttons_default) {
        choicesConfig.orientation = Contains3(choicesType, "x") ? 0 : 1;
      }
      choicesSizer = new ButtonsClass(scene, choicesConfig);
      scene.add.existing(choicesSizer);
      var choicesSpace = GetValue165(config, "space.choices", 0);
      var padding = {
        left: GetValue165(config, "space.choicesLeft", 0),
        right: GetValue165(config, "space.choicesRight", 0),
        bottom: actions ? choicesSpace : 0
      };
      var align = GetValue165(config, "align.choices", "center");
      var proportion = GetValue165(config, "proportion.choices", 0);
      var expand = GetValue165(config, "expand.choices", true);
      this.add(
        choicesSizer,
        { align, padding, proportion, expand }
      );
      this.buttonsType = buttonsType;
    }
    if (actions) {
      actionsSizer = new Buttons_default(scene, {
        groupName: "actions",
        background: actionsBackground,
        buttons: actions,
        orientation: 0,
        // Left-right
        space: { item: GetValue165(config, "space.action", 0) },
        expand: GetValue165(config, "expand.actions", false),
        align: GetValue165(config, "align.actions", "center"),
        click: clickConfig,
        eventEmitter: this.eventEmitter
      });
      scene.add.existing(actionsSizer);
      var padding = {
        left: GetValue165(config, "space.actionsLeft", 0),
        right: GetValue165(config, "space.actionsRight", 0),
        bottom: GetValue165(config, "space.actionsBottom", 0)
      };
      var proportion = GetValue165(config, "proportion.action", 0);
      this.add(
        actionsSizer,
        { align: "center", padding, proportion, expand: true }
      );
    }
    EmitButtonEvent(this, "click");
    EmitButtonEvent(this, "over");
    EmitButtonEvent(this, "out");
    EmitButtonEvent(this, "enable");
    EmitButtonEvent(this, "disable");
    this.addChildrenMap("background", background);
    this.addChildrenMap("title", title);
    this.addChildrenMap("toolbar", toolbar);
    this.addChildrenMap("leftToolbar", leftToolbar);
    this.addChildrenMap("content", content);
    this.addChildrenMap("description", description);
    this.addChildrenMap("choices", choicesSizer ? choicesSizer.buttons : void 0);
    this.addChildrenMap("actions", actionsSizer ? actionsSizer.buttons : void 0);
    this.addChildrenMap("choicesSizer", choicesSizer);
    this.addChildrenMap("actionsSizer", actionsSizer);
    this.addChildrenMap("toolbarSizer", toolbarSizer);
    this.addChildrenMap("leftToolbarSizer", leftToolbarSizer);
  }
};
var Contains3 = function(arr, item) {
  return arr.indexOf(item) !== -1;
};
var ButtonsGroupEventNameMap = {
  actions: "action",
  choices: "choice",
  toolbar: "toolbar",
  leftToolbar: "leftToolbar"
};
var EmitButtonEvent = function(dialog, postEventName) {
  dialog.on(`button.${postEventName}`, function(button, groupName, index, pointer, event) {
    if (!ButtonsGroupEventNameMap.hasOwnProperty(groupName)) {
      return;
    }
    dialog.emit(`${ButtonsGroupEventNameMap[groupName]}.${postEventName}`, button, index, pointer, event);
  });
};
Object.assign(
  Dialog.prototype,
  Methods_default31
);
var Dialog_default = Dialog;

// node_modules/phaser3-rex-plugins/templates/ui/dialog/Factory.js
ObjectFactory_default.register("dialog", function(config) {
  var gameObject2 = new Dialog_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Dialog", Dialog_default);

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateLabel.js
var CreateLabel = function(scene, config, creators) {
  var gameObject2 = new SimpleLabel_default(scene, config, creators);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateLabel_default = CreateLabel;

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/methods/ResetDisplayContent.js
var ResetDisplayContent2 = function(config) {
  if (config === void 0) {
    config = {};
  }
  ResetTitle.call(this, config);
  ResetContent.call(this, config);
  ResetActions.call(this, config);
  ResetChoices.call(this, config);
  return this;
};
var ResetTitle = function(config) {
  var title = this.childrenMap.title;
  config = config.title;
  if (config === null) {
    title.hide();
  } else {
    title.show();
    title.resetDisplayContent(config);
  }
};
var ResetContent = function(config) {
  var content = this.childrenMap.content;
  config = config.content;
  if (config === null) {
    content.hide();
  } else {
    content.show();
    if (content.resetDisplayContent) {
      content.resetDisplayContent(config);
    } else {
      var text = config || "";
      content.setText(text);
    }
  }
};
var ResetActions = function(config) {
  var actionButtons = this.childrenMap.actions;
  if (!actionButtons) {
    return;
  }
  var buttonContentArray = config.buttons;
  if (!buttonContentArray) {
    var buttonA = actionButtons[0];
    if (buttonA) {
      if (config.buttonA === null) {
        buttonA.hide();
      } else {
        buttonA.show();
        buttonA.resetDisplayContent(config.buttonA);
      }
    }
    var buttonB = actionButtons[1];
    if (buttonB) {
      if (config.buttonB === null) {
        buttonB.hide();
      } else {
        buttonB.show();
        buttonB.resetDisplayContent(config.buttonB);
      }
    }
  } else {
    var scene = this.scene;
    var defaultActionConfig = this.defaultActionConfig;
    var defaultActionButtonCreator = this.defaultActionButtonCreator;
    for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
      var buttonContent = buttonContentArray[i];
      var button = actionButtons[i];
      if (!button) {
        button = CreateLabel_default(scene, defaultActionConfig, defaultActionButtonCreator);
        this.addAction(button);
      }
      button.show().resetDisplayContent(buttonContent);
    }
    this.buttonMode = buttonContentArray.length;
    for (var i = buttonContentArray.length, cnt = actionButtons.length; i < cnt; i++) {
      actionButtons[i].hide();
    }
  }
};
var ResetChoices = function(config) {
  var choices = this.childrenMap.choices;
  if (!choices) {
    return;
  }
  var buttonContentArray = config.choices;
  if (!buttonContentArray) {
    buttonContentArray = [];
  }
  var scene = this.scene;
  var defaultChoiceConfig = this.defaultChoiceConfig;
  var defaultActionButtonCreator = this.defaultActionButtonCreator;
  for (var i = 0, cnt = buttonContentArray.length; i < cnt; i++) {
    var buttonContent = buttonContentArray[i];
    if (typeof buttonContent === "string") {
      buttonContent = { text: buttonContent };
    }
    var button = choices[i];
    if (!button) {
      button = CreateLabel_default(scene, defaultChoiceConfig, defaultActionButtonCreator);
      this.addChoice(button);
    }
    button.show().resetDisplayContent(buttonContent);
    var optionValue;
    if (buttonContent.hasOwnProperty("value")) {
      optionValue = buttonContent.value;
    } else {
      optionValue = buttonContent.text;
    }
    button.setName(optionValue);
  }
  for (var i = buttonContentArray.length, cnt = choices.length; i < cnt; i++) {
    choices[i].hide();
  }
};
var ResetDisplayContent_default2 = ResetDisplayContent2;

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/methods/Modal.js
var Merge3 = Phaser.Utils.Objects.Merge;
var Modal3 = function(config, onClose) {
  if (IsFunction_default(config)) {
    onClose = config;
    config = void 0;
  }
  if (config === void 0) {
    config = {};
  }
  config = Merge3(config, this.modalStyle);
  var zeroButtonMode;
  if (this.buttonMode === 0) {
    if (this.hasAnyChoice()) {
      zeroButtonMode = false;
    } else {
      zeroButtonMode = true;
    }
  } else {
    zeroButtonMode = false;
  }
  if (!config.hasOwnProperty("anyTouchClose")) {
    config.anyTouchClose = zeroButtonMode;
  }
  if (!config.hasOwnProperty("manualClose")) {
    config.manualClose = !zeroButtonMode;
  }
  var self = this;
  var onCloseWrap = function(data) {
    var buttonIndex = data.index;
    if (buttonIndex === self.confirmButtonIndex) {
      self.emit("confirm", data);
    } else if (buttonIndex === self.cancelButtonIndex) {
      self.emit("cancel", data);
    }
    if (onClose) {
      onClose(data);
    }
  };
  ModalMethods_default.modal.call(this, config, onCloseWrap);
  return this;
};
var Modal_default2 = Modal3;

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/methods/SetButtonIndexMethods.js
var SetButtonIndexMethods_default = {
  setConfirmButtonIndex(index) {
    this.confirmButtonIndex = index;
    return this;
  },
  setCancelButtonIndex(index) {
    this.cancelButtonIndex = index;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/methods/Methods.js
var Methods16 = {
  resetDisplayContent: ResetDisplayContent_default2,
  modal: Modal_default2
};
Object.assign(
  Methods16,
  SetButtonIndexMethods_default
);
var Methods_default32 = Methods16;

// node_modules/phaser3-rex-plugins/templates/ui/dialog/utils/RegisterSimpleLabelButtonEvents.js
var OnPointerOverCallback = function(button) {
  if (button.setHoverState) {
    button.setHoverState(true);
  }
};
var OnPointerOutCallback = function(button) {
  if (button.setHoverState) {
    button.setHoverState(false);
  }
};
var OnChoiceButtonStateChange = function(button, groupName, index, value) {
  if (button.setActiveState) {
    button.setActiveState(value);
  }
};
var OnButtonEnable = function(button) {
  if (button.setDisableState) {
    button.setDisableState(false);
  }
};
var OnButtonDisable = function(button) {
  if (button.setDisableState) {
    button.setDisableState(true);
  }
};
var RegisterEvents = function() {
  this.on("button.over", OnPointerOverCallback).on("button.out", OnPointerOutCallback).on("button.enable", OnButtonEnable).on("button.disable", OnButtonDisable).on("button.statechange", OnChoiceButtonStateChange);
};
var RegisterSimpleLabelButtonEvents_default = RegisterEvents;

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/methods/CreateContent.js
var GetValue166 = Phaser.Utils.Objects.GetValue;
var CreateContent = function(scene, config, creators) {
  var type = GetValue166(config, "$type");
  if (type === void 0) {
    if (config && (config.hasOwnProperty("slider") || config.hasOwnProperty("scroller"))) {
      type = "textarea";
    }
  }
  var gameObject2;
  switch (type) {
    case "textarea":
      gameObject2 = new CreateTextArea_default(scene, config, creators);
      break;
    default:
      gameObject2 = new CreateLabel_default(scene, config, creators);
      break;
  }
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateContent_default = CreateContent;

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/ConfirmDialog.js
var GetValue167 = Phaser.Utils.Objects.GetValue;
var ConfirmDialog = class extends Dialog_default {
  constructor(scene, config, creators) {
    config = config ? DeepClone_default(config) : {};
    if (creators === void 0) {
      creators = {};
    }
    var createBackground = GetValue167(creators, "background", CreateBackground_default);
    config.background = createBackground(scene, config.background);
    config.title = CreateLabel_default(scene, config.title, creators.title);
    config.content = CreateContent_default(scene, config.content, creators.content);
    if (config.content instanceof TextArea_default) {
      if (HasValue_default(config, "height") && !HasValue_default(config, "proportion.content")) {
        SetValue_default(config, "proportion.content", 1);
      }
    }
    var defaultButtonConfig = config.button;
    var buttonAConfig = config.buttonA || defaultButtonConfig;
    var buttonBConfig = config.buttonB || defaultButtonConfig;
    var buttonMode = config.buttonMode;
    if (buttonMode === void 0) {
      buttonMode = !!buttonAConfig && !!buttonBConfig ? 2 : !!buttonAConfig ? 1 : 0;
    }
    var defaultButtonCreator = creators.button;
    var buttonACreators = creators.buttonA || defaultButtonCreator;
    var buttonBCreators = creators.buttonB || defaultButtonCreator;
    switch (buttonMode) {
      case 2:
        config.actions = [
          CreateLabel_default(scene, buttonAConfig, buttonACreators),
          CreateLabel_default(scene, buttonBConfig, buttonBCreators)
        ];
        break;
      case 1:
        config.actions = [
          CreateLabel_default(scene, buttonAConfig, buttonACreators)
        ];
        break;
      case 0:
        break;
      default:
        config.actions = [];
        break;
    }
    var defaultChoiceConfig = config.choice;
    if (defaultChoiceConfig) {
      config.choices = [];
    }
    super(scene, config);
    this.type = "rexConfirmDialog";
    this.buttonMode = buttonMode;
    this.defaultActionConfig = defaultButtonConfig;
    this.defaultActionButtonCreator = defaultButtonCreator;
    this.defaultChoiceConfig = defaultChoiceConfig;
    this.defaultChoiceCreator = creators.choice;
    var buttons = this.childrenMap.actions;
    this.addChildrenMap("buttonA", buttons ? buttons[0] : null);
    this.addChildrenMap("buttonB", buttons ? buttons[1] : null);
    RegisterSimpleLabelButtonEvents_default.call(this);
    this.setConfirmButtonIndex(GetValue167(config, "confirmButtonIndex", 0));
    this.setCancelButtonIndex(GetValue167(config, "cancelButtonIndex", 1));
    this.modalStyle = config.modal || {};
  }
};
Object.assign(
  ConfirmDialog.prototype,
  Methods_default32
);
var ConfirmDialog_default = ConfirmDialog;

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/Factory.js
ObjectFactory_default.register("confirmDialog", function(config, creators) {
  var gameObject2 = new ConfirmDialog_default(this.scene, config, creators);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ConfirmDialog", ConfirmDialog_default);

// node_modules/phaser3-rex-plugins/templates/ui/confirmdialog/ConfirmAction.js
var GetValue168 = Phaser.Utils.Objects.GetValue;
var ConfirmAction = function(scene, config) {
  var dialog = config.dialog;
  var newDialogMode = !dialog;
  if (newDialogMode) {
    var dialogStyle = config.style;
    dialogStyle.buttonMode = 2;
    dialog = new ConfirmDialog_default(scene, dialogStyle, config.creators);
    scene.add.existing(dialog);
  }
  dialog.setConfirmButtonIndex(GetValue168(config, "confirmButtonIndex", 0)).setCancelButtonIndex(GetValue168(config, "cancelButtonIndex", 1)).resetDisplayContent(config.content).layout();
  if (newDialogMode && config.onCreateDialog) {
    config.onCreateDialog(dialog);
  }
  var modalConfig = config.modal;
  if (modalConfig && !modalConfig.hasOwnProperty("destroy")) {
    modalConfig.destroy = newDialogMode;
  }
  var confirmCallback = config.confirm;
  var cancelCallback = config.cancel;
  var confirmScope = config.confirmScope;
  var cancelScope = config.cancelScope;
  if (confirmCallback) {
    dialog.once("confirm", confirmCallback, confirmScope);
  }
  if (cancelCallback) {
    dialog.once("cancel", cancelCallback, cancelScope);
  }
  var onClose = function(data) {
    dialog.off("confirm", confirmCallback, confirmScope);
    dialog.off("cancel", cancelCallback, cancelScope);
  };
  dialog.modal(modalConfig, onClose);
  return dialog;
};
var ConfirmAction_default = ConfirmAction;

// node_modules/phaser3-rex-plugins/templates/ui/confirmactionbutton/ConfirmActionButton.js
var ConfirmActionButton = class extends Label_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexConfirmActionButton";
    this.setConfirmDialogEnable();
    this.confirmActionConfig = Clone_default(config.confirmDialog || {});
    if (config.confirm) {
      this.setConfirmCallback(config.confirm, config.confirmScope);
    }
    if (config.cancel) {
      this.setCancelCallback(config.cancel, config.cancelScope);
    }
    this.onClickCallback = function() {
      if (this.confirmDialogEnable) {
        if (this.confirmDialog) {
          return;
        }
        this.confirmDialog = ConfirmAction_default(scene, this.confirmActionConfig);
        this.confirmDialog.once("destroy", function() {
          this.confirmDialog = void 0;
        }, this);
      } else {
        this.runConfirmCallback();
      }
    };
    this.onClick(this.onClickCallback, this);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (this.confirmDialog) {
      this.confirmDialog.destroy();
    }
    super.destroy(fromScene);
    this.confirmActionConfig = void 0;
    this.onClickCallback = void 0;
    this.confirmDialog = void 0;
  }
  setConfirmCallback(callback, scope) {
    this.confirmActionConfig.confirm = callback;
    this.confirmActionConfig.confirmScope = scope;
    return this;
  }
  setCancelCallback(callback, scope) {
    this.confirmActionConfig.cancel = callback;
    this.confirmActionConfig.cancelScope = scope;
    return this;
  }
  setConfirmDialogContent(content) {
    this.confirmActionConfig.content = content;
    return this;
  }
  setConfitmDialogStyle(style) {
    this.confirmActionConfig.style = style;
    return this;
  }
  setConfitmDialogModalConfig(config) {
    this.confirmActionConfig.modal = config;
    return this;
  }
  setConfirmDialogEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.confirmDialogEnable = enable;
    return this;
  }
  runConfirmCallback() {
    var callback = this.confirmActionConfig.confirm;
    var scope = this.confirmActionConfig.confirmScope;
    if (callback) {
      callback.call(scope);
    }
    return this;
  }
};
var ConfirmActionButton_default = ConfirmActionButton;

// node_modules/phaser3-rex-plugins/templates/ui/confirmactionbutton/Factory.js
ObjectFactory_default.register("confirmActionButton", function(config) {
  var gameObject2 = new ConfirmActionButton_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ConfirmActionButton", ConfirmActionButton_default);

// node_modules/phaser3-rex-plugins/templates/ui/nameinputdialog/methods/ResetDisplayContent.js
var ResetDisplayContent3 = function(config) {
  if (config === void 0) {
    config = {};
  }
  ResetTitle2.call(this, config);
  ResetContent2.call(this, config);
  ResetActions2.call(this, config);
  return this;
};
var ResetTitle2 = function(config) {
  var title = this.childrenMap.title;
  if (config.title === null) {
    this.hide(title);
  } else {
    this.show(title);
    title.resetDisplayContent(config.title);
  }
};
var ResetContent2 = function(config) {
  var firstNameTitle = this.childrenMap.firstNameTitle;
  if (config.firstNameTitle === null) {
    this.hide(firstNameTitle);
  } else {
    this.show(firstNameTitle);
    var firstNameTitleConfig = config.firstNameTitle || "";
    firstNameTitle.resetDisplayContent(firstNameTitleConfig);
  }
  var firstNameInput = this.childrenMap.firstNameInput;
  if (config.firstName === null) {
    this.hide(firstNameInput);
  } else {
    this.show(firstNameInput);
    var firstName = config.firstName || "";
    firstNameInput.setText(firstName);
  }
  var lastNameTitle = this.childrenMap.lastNameTitle;
  if (config.lastNameTitle === null) {
    this.hide(lastNameTitle);
  } else {
    this.show(lastNameTitle);
    var lastNameTitleConfig = config.lastNameTitle || "";
    lastNameTitle.resetDisplayContent(lastNameTitleConfig);
  }
  var lastNameInput = this.childrenMap.lastNameInput;
  if (config.lastName === null) {
    this.hide(lastNameInput);
  } else {
    this.show(lastNameInput);
    var lastName = config.lastName || "";
    lastNameInput.setText(lastName);
  }
};
var ResetActions2 = function(config) {
  var action = this.childrenMap.actions[0];
  if (config.button === null) {
    this.hide(action);
  } else {
    this.show(action);
    action.resetDisplayContent(config.button);
  }
};
var ResetDisplayContent_default3 = ResetDisplayContent3;

// node_modules/phaser3-rex-plugins/templates/ui/nameinputdialog/methods/Modal.js
var Merge4 = Phaser.Utils.Objects.Merge;
var Modal4 = function(config, onClose) {
  if (IsFunction_default(config)) {
    onClose = config;
    config = void 0;
  }
  if (config === void 0) {
    config = {};
  }
  config = Merge4(config, this.modalStyle);
  config.anyTouchClose = false;
  config.manualClose = false;
  var self = this;
  var onCloseWrap = function(data) {
    data.firstName = self.firstName;
    data.lastName = self.lastName;
    self.emit("confirm", data);
    if (onClose) {
      onClose(data);
    }
  };
  ModalMethods_default.modal.call(this, config, onCloseWrap);
  return this;
};
var Modal_default3 = Modal4;

// node_modules/phaser3-rex-plugins/templates/ui/nameinputdialog/methods/Methods.js
var methods30 = {
  resetDisplayContent: ResetDisplayContent_default3,
  modal: Modal_default3
};
var Methods_default33 = methods30;

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateInputText.js
var CreateInputText = function(scene, config, deepCloneConfig) {
  if (deepCloneConfig === void 0) {
    deepCloneConfig = true;
  }
  if (deepCloneConfig) {
    config = config ? DeepClone_default(config) : {};
  } else if (!config) {
    config = {};
  }
  var inputText = new CanvasInput_default2(scene, config);
  scene.add.existing(inputText);
  return inputText;
};
var CreateInputText_default = CreateInputText;

// node_modules/phaser3-rex-plugins/templates/ui/nameinputdialog/methods/CreateContent.js
var GetValue169 = Phaser.Utils.Objects.GetValue;
var CreateContent2 = function(scene, config, creators) {
  var layoutMode = GetOrientationMode_default2(GetValue169(config, "layoutMode", 0));
  var isHorizontalLayout = layoutMode === 0;
  var nameSizer = new Sizer_default(scene, {
    orientation: layoutMode,
    space: {
      item: GetValue169(config, "space.firstName", 0)
    }
  });
  scene.add.existing(nameSizer);
  var firstNameSizer = new Sizer_default(scene, { orientation: "x" });
  scene.add.existing(firstNameSizer);
  var firstNameTitleConfig = GetValue169(config, "firstNameTitle", config.nameTitle);
  var firstNameTitle = CreateLabel_default(scene, firstNameTitleConfig, creators.firstNameTitle || creators.nameTitle);
  firstNameSizer.add(
    firstNameTitle,
    {
      expand: true,
      proportion: GetValue169(config, "proportion.firstNameTitle", 0),
      padding: {
        right: GetValue169(config, "space.firstNameTitle", 0)
      }
    }
  );
  var defaultNameInputConfig = config.nameInput || {};
  var firstNameInputConfig = GetValue169(config, "firstNameInput", defaultNameInputConfig);
  var firstNameInput = CreateInputText_default(scene, firstNameInputConfig, creators.firstNameInput || creators.nameInput);
  var expandFirstNameSizer = !firstNameInputConfig.hasOwnProperty("width");
  firstNameSizer.add(
    firstNameInput,
    {
      expand: true,
      proportion: expandFirstNameSizer ? 1 : 0
    }
  );
  var lastNameSizer = new Sizer_default(scene, { orientation: "x" });
  scene.add.existing(lastNameSizer);
  var lastNameTitleConfig = GetValue169(config, "lastNameTitle", config.nameTitle);
  var lastNameTitle = CreateLabel_default(scene, lastNameTitleConfig, creators.lastNameTitle || creators.nameTitle);
  lastNameSizer.add(
    lastNameTitle,
    {
      expand: true,
      proportion: GetValue169(config, "proportion.lastNameTitle", 0),
      padding: {
        right: GetValue169(config, "space.lastNameTitle", 0)
      }
    }
  );
  var lastNameInputConfig = GetValue169(config, "firstNameInput", defaultNameInputConfig);
  var lastNameInput = CreateInputText_default(scene, lastNameInputConfig, creators.lastNameInput || creators.nameInput);
  var expandLastNameSizer = !lastNameInputConfig.hasOwnProperty("width");
  lastNameSizer.add(
    lastNameInput,
    {
      expand: true,
      proportion: expandLastNameSizer ? 1 : 0
    }
  );
  if (isHorizontalLayout) {
    var defaultFirstNameProportion = expandFirstNameSizer ? 1 : 0;
    var firstNameProportion = GetValue169(config, "proportion.firstName", defaultFirstNameProportion);
    nameSizer.add(
      firstNameSizer,
      {
        expand: true,
        proportion: firstNameProportion
      }
    );
    var defaultLastNameProportion = expandLastNameSizer ? 1 : 0;
    var lastNameProportion = GetValue169(config, "proportion.lastName", defaultLastNameProportion);
    nameSizer.add(
      lastNameSizer,
      {
        expand: true,
        proportion: lastNameProportion
      }
    );
  } else {
    nameSizer.add(
      firstNameSizer,
      {
        expand: expandFirstNameSizer,
        proportion: 0
      }
    );
    nameSizer.add(
      lastNameSizer,
      {
        expand: expandLastNameSizer,
        proportion: 0
      }
    );
  }
  nameSizer.addChildrenMap("firstNameTitle", firstNameTitle);
  nameSizer.addChildrenMap("firstNameInput", firstNameInput);
  nameSizer.addChildrenMap("lastNameTitle", lastNameTitle);
  nameSizer.addChildrenMap("lastNameInput", lastNameInput);
  return nameSizer;
};
var CreateContent_default2 = CreateContent2;

// node_modules/phaser3-rex-plugins/templates/ui/nameinputdialog/NameInputDialog.js
var GetValue170 = Phaser.Utils.Objects.GetValue;
var NameInputDialog = class extends Dialog_default {
  constructor(scene, config, creators) {
    if (config === void 0) {
      config = {};
    }
    if (creators === void 0) {
      creators = {};
    }
    config.orientation = "y";
    var spaceConfig = config.space;
    if (spaceConfig) {
      if (spaceConfig.hasOwnProperty("names")) {
        spaceConfig.content = spaceConfig.names;
      }
      if (spaceConfig.hasOwnProperty("namesLeft")) {
        spaceConfig.contentLeft = spaceConfig.namesLeft;
      }
      if (spaceConfig.hasOwnProperty("namesRight")) {
        spaceConfig.contentRight = spaceConfig.namesRight;
      }
    }
    var createBackground = GetValue170(creators, "background", CreateBackground_default);
    config.background = createBackground(scene, config.background);
    config.title = CreateLabel_default(scene, config.title, creators.title);
    config.content = CreateContent_default2(scene, config, creators);
    config.actions = [
      CreateLabel_default(scene, config.button, creators.button)
    ];
    super(scene, config);
    this.type = "rexNameInputDialog";
    var namesSizerChildrenMap = config.content.childrenMap;
    this.addChildrenMap("firstNameTitle", namesSizerChildrenMap.firstNameTitle);
    this.addChildrenMap("firstNameInput", namesSizerChildrenMap.firstNameInput);
    this.addChildrenMap("lastNameTitle", namesSizerChildrenMap.lastNameTitle);
    this.addChildrenMap("lastNameInput", namesSizerChildrenMap.lastNameInput);
    this.addChildrenMap("button", config.actions[0]);
    RegisterSimpleLabelButtonEvents_default.call(this);
    this.modalStyle = config.modal || {};
  }
  get firstName() {
    return this.childrenMap.firstNameInput.text;
  }
  set firstName(value) {
    this.childrenMap.firstNameInput.setText(value);
  }
  setFirstName(value) {
    this.firstName = value;
    return this;
  }
  get lastName() {
    return this.childrenMap.lastNameInput.text;
  }
  set lastName(value) {
    this.childrenMap.lastNameInput.setText(value);
  }
  setLastName(value) {
    this.lastName = value;
    return this;
  }
};
Object.assign(
  NameInputDialog.prototype,
  Methods_default33
);
var NameInputDialog_default = NameInputDialog;

// node_modules/phaser3-rex-plugins/templates/ui/nameinputdialog/Factory.js
ObjectFactory_default.register("nameInputDialog", function(config, creators) {
  var gameObject2 = new NameInputDialog_default(this.scene, config, creators);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.NameInputDialog", NameInputDialog_default);

// node_modules/phaser3-rex-plugins/templates/ui/utils/RemoveFromParent.js
var RemoveFromParent = function(gameObject2, destroyChild) {
  if (!gameObject2) {
    return;
  }
  var parent = GetParent(gameObject2);
  if (!parent) {
    return;
  }
  parent.remove(gameObject2, destroyChild);
};
var RemoveFromParent_default = RemoveFromParent;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/methods/GetAddChildConfig.js
var GetValue171 = Phaser.Utils.Objects.GetValue;
var GetAddChildConfig = function(config, key2, defaultValues) {
  var proportion = GetValue171(config, `proportion.${key2}`, defaultValues.proportion);
  var align = GetValue171(config, `align.${key2}`, "center");
  var padding = GetValue171(config, `space.${key2}`, void 0);
  if (typeof padding === "number" && defaultValues.paddingKey) {
    var paddingNum = padding;
    padding = {};
    padding[defaultValues.paddingKey] = paddingNum;
  }
  var expand = GetValue171(config, `expand.${key2}`, true);
  return {
    proportion,
    align,
    padding,
    expand
  };
};
var GetAddHeaderConfig = function(config) {
  return GetAddChildConfig(config, "header", {
    proportion: 0,
    paddingKey: "bottom"
  });
};
var GetAddLeftSideConfig = function(config) {
  return GetAddChildConfig(config, "leftSide", {
    proportion: 0,
    paddingKey: "right"
  });
};
var GetAddContentConfig = function(config) {
  return GetAddChildConfig(config, "content", {
    proportion: 1
  });
};
var GetAddRightSideConfig = function(config) {
  return GetAddChildConfig(config, "rightSide", {
    proportion: 0,
    paddingKey: "left"
  });
};
var GetAddFooterConfig = function(config) {
  return GetAddChildConfig(config, "footer", {
    proportion: 0,
    paddingKey: "top"
  });
};
var GetAddContainerConfig = function(config) {
  return {
    proportion: 1,
    align: "center",
    padding: 0,
    expand: true
  };
};

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/methods/CreatExpandContainer.js
var CreatExpandContainer = function(scene, orientation) {
  var container = new Sizer_default(scene, {
    orientation
  });
  scene.add.existing(container);
  return container;
};
var CreatExpandContainer_default = CreatExpandContainer;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/methods/LayoutMode0.js
var LayoutMode02 = function(config) {
  var scene = this.scene;
  var header = config.header;
  if (header) {
    this.add(header, GetAddHeaderConfig(config));
  }
  var bodySizer = CreatExpandContainer_default(scene, 0);
  this.add(bodySizer, GetAddContainerConfig(config));
  var leftSide = config.leftSide;
  if (leftSide) {
    bodySizer.add(leftSide, GetAddLeftSideConfig(config));
  }
  var content = config.content;
  if (content) {
    bodySizer.add(content, GetAddContentConfig(config));
  }
  var rightSide = config.rightSide;
  if (rightSide) {
    bodySizer.add(rightSide, GetAddRightSideConfig(config));
  }
  var footer = config.footer;
  if (footer) {
    this.add(footer, GetAddFooterConfig(config));
  }
};
var LayoutMode0_default2 = LayoutMode02;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/methods/LayoutMode1.js
var LayoutMode12 = function(config) {
  var scene = this.scene;
  var header = config.header;
  if (header) {
    this.add(header, GetAddHeaderConfig(config));
  }
  var bodySizer0 = CreatExpandContainer_default(scene, 0);
  this.add(bodySizer0, GetAddContainerConfig(config));
  var leftSide = config.leftSide;
  if (leftSide) {
    bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
  }
  var bodySizer1 = CreatExpandContainer_default(scene, 1);
  bodySizer0.add(bodySizer1, GetAddContainerConfig(config));
  var bodySizer2 = CreatExpandContainer_default(scene, 0);
  bodySizer1.add(bodySizer2, GetAddContainerConfig(config));
  var content = config.content;
  if (content) {
    bodySizer2.add(content, GetAddContentConfig(config));
  }
  var rightSide = config.rightSide;
  if (rightSide) {
    bodySizer2.add(rightSide, GetAddRightSideConfig(config));
  }
  var footer = config.footer;
  if (footer) {
    bodySizer1.add(footer, GetAddFooterConfig(config));
  }
};
var LayoutMode1_default2 = LayoutMode12;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/methods/LayoutMode2.js
var LayoutMode2 = function(config) {
  var scene = this.scene;
  var header = config.header;
  if (header) {
    this.add(header, GetAddHeaderConfig(config));
  }
  var bodySizer0 = CreatExpandContainer_default(scene, 0);
  this.add(bodySizer0, GetAddContainerConfig(config));
  var bodySizer1 = CreatExpandContainer_default(scene, 1);
  bodySizer0.add(bodySizer1, GetAddContainerConfig(config));
  var bodySizer2 = CreatExpandContainer_default(scene, 0);
  bodySizer1.add(bodySizer2, GetAddContainerConfig(config));
  var leftSide = config.leftSide;
  if (leftSide) {
    bodySizer2.add(leftSide, GetAddLeftSideConfig(config));
  }
  var content = config.content;
  if (content) {
    bodySizer2.add(content, GetAddContentConfig(config));
  }
  var footer = config.footer;
  if (footer) {
    bodySizer1.add(footer, GetAddFooterConfig(config));
  }
  var rightSide = config.rightSide;
  if (rightSide) {
    bodySizer0.add(rightSide, GetAddRightSideConfig(config));
  }
};
var LayoutMode2_default = LayoutMode2;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/methods/LayoutMode3.js
var LayoutMode03 = function(config) {
  var scene = this.scene;
  var header = config.header;
  if (header) {
    this.add(header, GetAddHeaderConfig(config));
  }
  var bodySizer0 = CreatExpandContainer_default(scene, 0);
  this.add(bodySizer0, GetAddContainerConfig(config));
  var leftSide = config.leftSide;
  if (leftSide) {
    bodySizer0.add(leftSide, GetAddLeftSideConfig(config));
  }
  var bodySizer1 = CreatExpandContainer_default(scene, 1);
  bodySizer0.add(bodySizer1, GetAddContainerConfig(config));
  var content = config.content;
  if (content) {
    bodySizer1.add(content, GetAddContentConfig(config));
  }
  var footer = config.footer;
  if (footer) {
    bodySizer1.add(footer, GetAddFooterConfig(config));
  }
  var rightSide = config.rightSide;
  if (rightSide) {
    bodySizer0.add(rightSide, GetAddRightSideConfig(config));
  }
};
var LayoutMode3_default = LayoutMode03;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/methods/Build.js
var GetValue172 = Phaser.Utils.Objects.GetValue;
var LayoutCallbacks2 = [LayoutMode0_default2, LayoutMode1_default2, LayoutMode2_default, LayoutMode3_default];
var Build2 = function(config) {
  if (config === void 0) {
    config = {};
  }
  var background = config.background;
  var header = config.header;
  var leftSide = config.leftSide;
  var content = config.content;
  var rightSide = config.rightSide;
  var footer = config.footer;
  RemoveFromParent_default(background);
  RemoveFromParent_default(header);
  RemoveFromParent_default(leftSide);
  RemoveFromParent_default(content);
  RemoveFromParent_default(rightSide);
  RemoveFromParent_default(footer);
  this.clear(true);
  if (background) {
    this.addBackground(background);
  }
  var layoutMode = GetValue172(config, "layoutMode", 0);
  if (typeof layoutMode === "string") {
    layoutMode = LayoutModesMap[layoutMode.toUpperCase()];
  }
  var layoutCallback = LayoutCallbacks2[layoutMode] || LayoutCallbacks2[0];
  layoutCallback.call(this, config);
  this.addChildrenMap("background", background);
  this.addChildrenMap("header", header);
  this.addChildrenMap("leftSide", leftSide);
  this.addChildrenMap("content", content);
  this.addChildrenMap("rightSide", rightSide);
  this.addChildrenMap("footer", footer);
  return this;
};
var LayoutModesMap = {
  "FFF": 0,
  "LFF": 1,
  "FFR": 2,
  "LFR": 3
};
var Build_default2 = Build2;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/HolyGrail.js
var HolyGrail = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = 1;
    super(scene, config);
    this.type = "rexHolyGrail";
    this.build(config);
  }
};
var methods31 = {
  build: Build_default2
};
Object.assign(
  HolyGrail.prototype,
  methods31
);
var HolyGrail_default = HolyGrail;

// node_modules/phaser3-rex-plugins/templates/ui/holygrail/Factory.js
ObjectFactory_default.register("holyGrail", function(config) {
  var gameObject2 = new HolyGrail_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.HolyGrail", HolyGrail_default);

// node_modules/phaser3-rex-plugins/templates/ui/tabs/ButtonMethods.js
var ButtonMethods_default3 = {
  getButtonsSizer(groupName) {
    return this.childrenMap[`${groupName}ButtonsSizer`];
  },
  getButton(groupName, index) {
    var buttonsSizer = this.getButtonsSizer(groupName);
    return buttonsSizer ? buttonsSizer.getButton(index) : void 0;
  },
  setButtonEnable(groupName, index, enabled) {
    this.getButtonsSizer(groupName).setButtonEnable(index, enabled);
    return this;
  },
  setLeftButtonEnable(index, enabled) {
    this.childrenMap.leftButtonsSizer.setButtonEnable(index, enabled);
    return this;
  },
  setRightButtonEnable(index, enabled) {
    this.childrenMap.rightButtonsSizer.setButtonEnable(index, enabled);
    return this;
  },
  setTopButtonEnable(index, enabled) {
    this.childrenMap.topButtonsSizer.setButtonEnable(index, enabled);
    return this;
  },
  setBottomButtonEnable(index, enabled) {
    this.childrenMap.bottomButtonsSizer.setButtonEnable(index, enabled);
    return this;
  },
  toggleButtonEnable(groupName, index) {
    this.getButtonsSizer(groupName).toggleButtonEnable(index);
    return this;
  },
  toggleLeftButtonEnable(index) {
    this.childrenMap.leftButtonsSizer.toggleButtonEnable(index);
    return this;
  },
  toggleRightButtonEnable(index) {
    this.childrenMap.rightButtonsSizer.toggleButtonEnable(index);
    return this;
  },
  toggleTopButtonEnable(index) {
    this.childrenMap.topButtonsSizer.toggleButtonEnable(index);
    return this;
  },
  toggleBottomButtonEnable(index) {
    this.childrenMap.bottomButtonsSizer.toggleButtonEnable(index);
    return this;
  },
  getButtonEnable(groupName, index) {
    return this.getButtonsSizer(groupName).getButtonEnable(index);
  },
  getLeftButtonEnable(index) {
    return this.childrenMap.leftButtonsSizer.getButtonEnable(index);
  },
  getRightButtonEnable(index) {
    return this.childrenMap.rightButtonsSizer.getButtonEnable(index);
  },
  getTopButtonEnable(index) {
    return this.childrenMap.topButtonsSizer.getButtonEnable(index);
  },
  getBottomButtonEnable(index) {
    return this.childrenMap.bottomButtonsSizer.getButtonEnable(index);
  },
  emitButtonClick(groupName, index) {
    var buttonsSizer = this.getButtonsSizer(groupName);
    if (!buttonsSizer) {
      return this;
    }
    buttonsSizer.emitButtonClick(index);
    return this;
  },
  emitLeftButtonClick(index) {
    this.childrenMap.leftButtonsSizer.emitButtonClick(index);
    return this;
  },
  emitRightButtonClick(index) {
    this.childrenMap.rightButtonsSizer.emitButtonClick(index);
    return this;
  },
  emitTopButtonClick(index) {
    this.childrenMap.topButtonsSizer.emitButtonClick(index);
    return this;
  },
  emitBottomButtonClick(index) {
    this.childrenMap.bottomButtonsSizer.emitButtonClick(index);
    return this;
  },
  getLeftButton(index) {
    return this.childrenMap.leftButtonsSizer.getButton(index);
  },
  getRightButton(index) {
    return this.childrenMap.rightButtonsSizer.getButton(index);
  },
  getTopButton(index) {
    return this.childrenMap.topButtonsSizer.getButton(index);
  },
  getBottomButton(index) {
    return this.childrenMap.bottomButtonsSizer.getButton(index);
  },
  showButton(groupName, index) {
    Show(this.getButton(groupName, index));
    return this;
  },
  showLeftButton(index) {
    Show(this.getLeftButton(index));
    return this;
  },
  showRightButton(index) {
    Show(this.getRightButton(index));
    return this;
  },
  showTopButton(index) {
    Show(this.getTopButton(index));
    return this;
  },
  showBottomButton(index) {
    Show(this.getBottomButton(index));
    return this;
  },
  hideButton(groupName, index) {
    Hide(this.getButton(groupName, index));
    return this;
  },
  hideLeftButton(index) {
    Hide(this.getLeftButton(index));
    return this;
  },
  hideRightButton(index) {
    Hide(this.getRightButton(index));
    return this;
  },
  hideTopButton(index) {
    Hide(this.getTopButton(index));
    return this;
  },
  hideBottomButton(index) {
    Hide(this.getBottomButton(index));
    return this;
  },
  addButton(groupName, gameObject2) {
    this.getButtonsSizer(groupName).addButton(gameObject2);
    return this;
  },
  addLeftButton(gameObject2) {
    this.addButton("left", gameObject2);
    return this;
  },
  addRightButton(gameObject2) {
    this.addButton("right", gameObject2);
    return this;
  },
  addTopButton(gameObject2) {
    this.addButton("top", gameObject2);
    return this;
  },
  removeButton(groupName, index, destroyChild) {
    this.getButtonsSizer(groupName).removeButton(index, destroyChild);
    return this;
  },
  removeLeftButton(index, destroyChild) {
    this.removeButton("left", index, destroyChild);
    return this;
  },
  removeRightButton(index, destroyChild) {
    this.removeButton("right", index, destroyChild);
    return this;
  },
  removeTopButton(index, destroyChild) {
    this.removeButton("top", index, destroyChild);
    return this;
  },
  removeBottomButton(index, destroyChild) {
    this.removeButton("bottom", index, destroyChild);
    return this;
  },
  clearButtons(groupName, destroyChild) {
    this.getButtonsSizer(groupName).clearButtons(destroyChild);
    return this;
  },
  clearLeftButtons(destroyChild) {
    this.clearButtons("left", destroyChild);
    return this;
  },
  clearRightButtons(destroyChild) {
    this.clearButtons("right", destroyChild);
    return this;
  },
  clearTopButtons(destroyChild) {
    this.clearButtons("top", destroyChild);
    return this;
  },
  clearBottomButtonss(destroyChild) {
    this.clearButtons("bottom", destroyChild);
    return this;
  },
  forEachButton(groupName, callback, scope) {
    this.getButtonsSizer(groupName).forEachButtton(callback, scope);
    return this;
  },
  forEachLeftButton(callback, scope) {
    this.childrenMap.leftButtonsSizer.forEachButtton(callback, scope);
    return this;
  },
  forEachRightButton(callback, scope) {
    this.childrenMap.rightButtonsSizer.forEachButtton(callback, scope);
    return this;
  },
  forEachTopButton(callback, scope) {
    this.childrenMap.topButtonsSizer.forEachButtton(callback, scope);
    return this;
  },
  forEachBottomButton(callback, scope) {
    this.childrenMap.bottomButtonsSizer.forEachButtton(callback, scope);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tabs/Tabs.js
var GetValue173 = Phaser.Utils.Objects.GetValue;
var Tabs = class extends GridSizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.column = 3;
    config.row = 3;
    config.columnProportions = [0, 0, 0];
    config.rowProportions = [0, 0, 0];
    var expandPanel = GetValue173(config, "expand.panel", false);
    if (expandPanel) {
      config.columnProportions[1] = 1;
      config.rowProportions[1] = 1;
    }
    super(scene, config);
    this.type = "rexTabs";
    this.eventEmitter = GetValue173(config, "eventEmitter", this);
    var background = GetValue173(config, "background", void 0);
    var panel = GetValue173(config, "panel", void 0);
    var leftButtons = GetValue173(config, "leftButtons", void 0);
    var leftButtonsBackground = GetValue173(config, "leftButtonsBackground", void 0);
    var leftButtonsSizer;
    var rightButtons = GetValue173(config, "rightButtons", void 0);
    var rightButtonsBackground = GetValue173(config, "rightButtonsBackground", void 0);
    var rightButtonsSizer;
    var topButtons = GetValue173(config, "topButtons", void 0);
    var topButtonsBackground = GetValue173(config, "topButtonsBackground", void 0);
    var topButtonsSizer;
    var bottomButtons = GetValue173(config, "bottomButtons", void 0);
    var bottomButtonsBackground = GetValue173(config, "bottomButtonsBackground", void 0);
    var bottomButtonsSizer;
    var clickConfig = GetValue173(config, "click", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (panel) {
      this.add(
        panel,
        {
          column: 1,
          row: 1,
          expand: expandPanel
        }
      );
    }
    if (leftButtons) {
      var leftButtonsOffset = GetValue173(config, "space.leftButtonsOffset", 0);
      var leftButtonSpace = GetValue173(config, "space.leftButton", 0);
      var leftButtonExpand = GetValue173(config, "expand.leftButtons", false);
      var leftButtonsAlign = GetValue173(config, "align.leftButtons", "top");
      leftButtonsSizer = new Buttons_default(scene, {
        groupName: "left",
        background: leftButtonsBackground,
        buttons: leftButtons,
        orientation: "y",
        // Top-Bottom
        space: { item: leftButtonSpace },
        expand: leftButtonExpand,
        click: clickConfig,
        eventEmitter: this.eventEmitter
      });
      this.add(
        leftButtonsSizer,
        {
          column: 0,
          row: 1,
          align: leftButtonsAlign,
          padding: { top: leftButtonsOffset },
          expand: leftButtonExpand
        }
      );
    }
    if (rightButtons) {
      var rightButtonsOffset = GetValue173(config, "space.rightButtonsOffset", 0);
      var rightButtonSpace = GetValue173(config, "space.rightButton", 0);
      var rightButtonExpand = GetValue173(config, "expand.rightButtons", false);
      var rightButtonsAlign = GetValue173(config, "align.rightButtons", "top");
      rightButtonsSizer = new Buttons_default(scene, {
        groupName: "right",
        background: rightButtonsBackground,
        buttons: rightButtons,
        orientation: "y",
        // Top-Bottom
        space: { item: rightButtonSpace },
        expand: rightButtonExpand,
        click: clickConfig,
        eventEmitter: this.eventEmitter
      });
      this.add(
        rightButtonsSizer,
        {
          column: 2,
          row: 1,
          align: rightButtonsAlign,
          padding: { top: rightButtonsOffset },
          expand: rightButtonExpand
        }
      );
    }
    if (topButtons) {
      var toptButtonsOffset = GetValue173(config, "space.topButtonsOffset", 0);
      var topButtonSpace = GetValue173(config, "space.topButton", 0);
      var topButtonExpand = GetValue173(config, "expand.topButtons", false);
      var topButtonsAlign = GetValue173(config, "align.topButtons", "left");
      topButtonsSizer = new Buttons_default(scene, {
        groupName: "top",
        background: topButtonsBackground,
        buttons: topButtons,
        orientation: "x",
        // Left-Right
        space: { item: topButtonSpace },
        expand: topButtonExpand,
        align: GetValue173(config, "align.topButtons", void 0),
        click: clickConfig,
        eventEmitter: this.eventEmitter
      });
      this.add(
        topButtonsSizer,
        {
          column: 1,
          row: 0,
          align: topButtonsAlign,
          padding: { left: toptButtonsOffset },
          expand: topButtonExpand
        }
      );
    }
    if (bottomButtons) {
      var bottomButtonsOffset = GetValue173(config, "space.bottomButtonsOffset", 0);
      var bottomButtonSpace = GetValue173(config, "space.bottomButton", 0);
      var bottomButtonExpand = GetValue173(config, "expand.bottomButtons", false);
      var bottomButtonsAlign = GetValue173(config, "align.bottomButtons", "left");
      bottomButtonsSizer = new Buttons_default(scene, {
        groupName: "bottom",
        background: bottomButtonsBackground,
        buttons: bottomButtons,
        orientation: "x",
        // Left-Right
        space: { item: bottomButtonSpace },
        expand: bottomButtonExpand,
        align: GetValue173(config, "align.bottomButtons", void 0),
        click: clickConfig,
        eventEmitter: this.eventEmitter
      });
      this.add(
        bottomButtonsSizer,
        {
          column: 1,
          row: 2,
          align: bottomButtonsAlign,
          padding: { left: bottomButtonsOffset },
          expand: bottomButtonExpand
        }
      );
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("panel", panel);
    this.addChildrenMap("leftButtons", leftButtons);
    this.addChildrenMap("rightButtons", rightButtons);
    this.addChildrenMap("topButtons", topButtons);
    this.addChildrenMap("bottomButtons", bottomButtons);
    this.addChildrenMap("leftButtonsSizer", leftButtonsSizer);
    this.addChildrenMap("rightButtonsSizer", rightButtonsSizer);
    this.addChildrenMap("topButtonsSizer", topButtonsSizer);
    this.addChildrenMap("bottomButtonsSizer", bottomButtonsSizer);
  }
};
Object.assign(
  Tabs.prototype,
  ButtonMethods_default3
);
var Tabs_default = Tabs;

// node_modules/phaser3-rex-plugins/templates/ui/tabs/Factory.js
ObjectFactory_default.register("tabs", function(config) {
  var gameObject2 = new Tabs_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Tabs", Tabs_default);

// node_modules/phaser3-rex-plugins/templates/ui/slider/Factory.js
ObjectFactory_default.register("slider", function(config) {
  var gameObject2 = new Slider_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Slider", Slider_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/table/Cell.js
var Cell = class {
  constructor(parent, config) {
    this.container = null;
    this._deltaHeight = 0;
    this.setParent(parent);
  }
  setParent(parent) {
    this.parent = parent;
    this.parentContainer = parent.getParentContainer();
  }
  // resetFromJSON(o) {
  //     return this;
  // }
  destroy(fromScene) {
    if (fromScene === void 0) {
      fromScene = false;
    }
    if (!fromScene) {
      this.destroyContainer();
    }
    this.deltaHeight = 0;
    this.data = void 0;
    this.container = null;
    this.parent = void 0;
    this.parentContainer = void 0;
  }
  get table() {
    return this.parent;
  }
  get scrollMode() {
    return this.parentContainer.scrollMode;
  }
  get colIndx() {
    return this.parent.cellIndxeToColIndex(this.index);
  }
  get rowIndx() {
    return this.parent.cellIndxeToRowIndex(this.index);
  }
  getContainer() {
    return this.container;
  }
  setContainer(container) {
    if (!container) {
      this.destroyContainer();
      return this;
    }
    if (this.container) {
      this.container.destroy();
    }
    this.container = container;
    this.parentContainer.add(container);
    return this;
  }
  destroyContainer() {
    if (this.container) {
      this.container.destroy();
      this.container = null;
    }
    return this;
  }
  popContainer() {
    if (this.container) {
      var container = this.container;
      this.container = null;
      this.parentContainer.remove(container);
      return container;
    } else {
      return null;
    }
  }
  setXY(x, y) {
    if (this.container) {
      this.parentContainer.setChildLocalPosition(this.container, x, y);
    }
    return this;
  }
  setCellContainerAlign(align) {
    if (typeof align === "string") {
      align = AlignConst_default[align];
    }
    this.cellContainerAlign = align;
    return this;
  }
  get deltaHeight() {
    return this._deltaHeight;
  }
  set deltaHeight(deltaHeight) {
    if (deltaHeight == null) {
      deltaHeight = 0;
    }
    var table = this.parent;
    if (this._deltaHeight === 0 && deltaHeight !== 0) {
      table.nonZeroDeltaHeightCount++;
    } else if (this._deltaHeight !== 0 && deltaHeight === 0) {
      table.nonZeroDeltaHeightCount--;
    }
    var isTableHeightChanged = this._deltaHeight !== deltaHeight;
    this._deltaHeight = deltaHeight;
    if (isTableHeightChanged) {
      table.resetTotalRowsHeight();
      var eventName = this.scrollMode === 0 ? "cellheightchange" : "cellwidthchange";
      this.parentContainer.emit(eventName, this, this.container, this.parentContainer);
    }
  }
  get deltaWidth() {
    return this.deltaHeight;
  }
  set deltaWidth(deltaWidth) {
    this.deltaHeight = deltaWidth;
  }
  setDeltaHeight(deltaHeight) {
    this.deltaHeight = deltaHeight;
    return this;
  }
  setDeltaWidth(deltaWidth) {
    this.deltaHeight = deltaWidth;
    return this;
  }
  get height() {
    if (this.scrollMode === 0) {
      return this.deltaHeight + this.parent.defaultCellHeight;
    } else {
      return this.parent.defaultCellWidth;
    }
  }
  set height(height) {
    if (this.scrollMode === 1) {
      return;
    }
    this.setDeltaHeight(height - this.parent.defaultCellHeight);
  }
  setHeight(height) {
    this.height = height;
    return this;
  }
  get width() {
    if (this.scrollMode === 0) {
      return this.parent.defaultCellWidth;
    } else {
      return this.deltaHeight + this.parent.defaultCellHeight;
    }
  }
  set width(width) {
    if (this.scrollMode === 0) {
      return;
    }
    this.setDeltaHeight(width - this.parent.defaultCellHeight);
  }
  setWidth(width) {
    this.width = width;
    return this;
  }
  get scene() {
    return this.parentContainer.scene;
  }
};
Object.assign(
  Cell.prototype,
  DataMethods_default
);
var Cell_default = Cell;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/table/Table.js
var GetValue174 = Phaser.Utils.Objects.GetValue;
var SpliceOne3 = Phaser.Utils.Array.SpliceOne;
var Table = class {
  constructor(parent, config) {
    this.parent = parent;
    this.cells = [];
    this.cellPool = new pool_default();
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    if (o === void 0) {
      o = {};
    }
    this.colCount = void 0;
    this.nonZeroDeltaHeightCount = 0;
    this.resetTotalRowsHeight();
    var cellHeight = o.cellHeight;
    if (cellHeight === void 0) {
      cellHeight = 60;
    }
    var cellWidth = o.cellWidth;
    if (cellWidth === void 0) {
      cellWidth = 60;
    }
    this.setDefaultCellHeight(cellHeight);
    this.setDefaultCellWidth(cellWidth);
    this.initCells(GetValue174(o, "cellsCount", 0));
    this.setColumnCount(GetValue174(o, "columns", 1));
    return this;
  }
  destroy(fromScene) {
    this.cellPool.destroy();
    this.cells = void 0;
    this.parent = void 0;
  }
  get defaultCellHeightMode() {
    return this.nonZeroDeltaHeightCount === 0;
  }
  setDefaultCellHeight(height) {
    this.defaultCellHeight = height;
    return this;
  }
  setDefaultCellWidth(width) {
    this.defaultCellWidth = width;
    return this;
  }
  initCells(size) {
    var cells = this.cells;
    cells.length = size;
    for (var i = 0; i < size; i++) {
      cells[i] = null;
    }
    return this;
  }
  insertNewCells(cellIdx, count) {
    var cells = this.cells;
    if (cellIdx === cells.length) {
      var endIdx = cellIdx + count;
      cells.legth = endIdx;
      for (var i = cellIdx; i < endIdx; i++) {
        cells[i] = null;
      }
    } else {
      var newCells = [];
      newCells.length = count;
      for (var i = 0; i < count; i++) {
        newCells[i] = null;
      }
      this.cells.splice(cellIdx, 0, ...newCells);
    }
    this.resetTotalRowsHeight();
    return this;
  }
  removeCells(cellIdx, count) {
    var endIdx = cellIdx + count;
    for (var i = cellIdx; i < endIdx; i++) {
      this.freeCell(i);
    }
    if (endIdx === this.cells.length) {
      this.cells.length = cellIdx;
    } else {
      if (count === 1) {
        SpliceOne3(this.cells, cellIdx);
      } else {
        this.cells.splice(cellIdx, count);
      }
      this.buildCellIndex(cellIdx);
    }
    this.resetTotalRowsHeight();
    return this;
  }
  setColumnCount(columns) {
    this.colCount = columns;
    this.resetTotalRowsHeight();
    var parent = this.parent;
    if (parent.expandCellSize) {
      var width = parent.scrollMode === 0 ? parent.width : parent.height;
      var cellWidth = width / columns;
      this.setDefaultCellWidth(cellWidth);
    }
    return this;
  }
  get rowCount() {
    return Math.ceil(this.cells.length / this.colCount);
  }
  get cellsCount() {
    return this.cells.length;
  }
  isValidCellIdx(idx) {
    return idx >= 0 && idx < this.cells.length;
  }
  heightToRowIndex(height, roundMode) {
    if (roundMode === void 0) {
      roundMode = 0;
    }
    if (height === 0) {
      return 0;
    }
    if (this.defaultCellHeightMode) {
      var rowIdx = height / this.defaultCellHeight;
      switch (roundMode) {
        case 1:
          rowIdx = Math.ceil(rowIdx);
          break;
        default:
          rowIdx = Math.floor(rowIdx);
          break;
      }
      return rowIdx;
    }
    var rowCount = this.rowCount;
    var remainder = height, isValidIdx;
    var cell, rowHeight, rowIdx = 0;
    while (1) {
      rowHeight = this.getRowHeight(rowIdx);
      remainder -= rowHeight;
      isValidIdx = rowIdx >= 0 && rowIdx < rowCount;
      if (remainder > 0 && isValidIdx) {
        rowIdx += 1;
      } else if (remainder === 0) {
        if (roundMode === 2) {
          rowIdx += 1;
        }
        return rowIdx;
      } else {
        if (roundMode === 1) {
          var preRowIdx = rowIdx;
          rowIdx += 1;
          isValidIdx = rowIdx >= 0 && rowIdx < rowCount;
          if (!isValidIdx) {
            rowIdx = preRowIdx;
          }
        }
        return rowIdx;
      }
    }
  }
  widthToColIndex(width, isCeil) {
    if (width === 0) {
      return 0;
    }
    var colIdx = width / this.defaultCellWidth;
    if (isCeil) {
      colIdx = Math.ceil(colIdx);
    } else {
      colIdx = Math.floor(colIdx);
    }
    return colIdx;
  }
  colRowToCellIndex(colIdx, rowIdx) {
    if (colIdx >= this.colCount) {
      return null;
    }
    return rowIdx * this.colCount + colIdx;
  }
  rowIndexToHeight(start, end) {
    if (this.defaultCellHeightMode) {
      return (end - start + 1) * this.defaultCellHeight;
    }
    var h, sum = 0;
    for (var i = start; i <= end; i++) {
      h = this.getRowHeight(i);
      sum += h;
    }
    return sum;
  }
  colIndexToWidth(start, end) {
    return (end - start + 1) * this.defaultCellWidth;
  }
  getRowHeight(rowIdx) {
    var cnt = this.colCount;
    if (cnt <= 1) {
      return this.getCellHeight(this.colRowToCellIndex(0, rowIdx));
    }
    var maxHeight = 0, cellHeight;
    for (var i = 0; i < cnt; i++) {
      cellHeight = this.getCellHeight(this.colRowToCellIndex(i, rowIdx));
      if (maxHeight < cellHeight)
        maxHeight = cellHeight;
    }
    return maxHeight;
  }
  getColWidth(idx) {
    return this.defaultCellWidth;
  }
  getCellHeight(cellIdx) {
    if (!this.isValidCellIdx(cellIdx)) {
      return 0;
    }
    var cellHeight;
    if (this.defaultCellHeightMode)
      cellHeight = this.defaultCellHeight;
    else {
      var cell = this.getCell(cellIdx, false);
      var deltaHeight = cell ? cell.deltaHeight : 0;
      cellHeight = this.defaultCellHeight + deltaHeight;
    }
    return cellHeight;
  }
  resetTotalRowsHeight() {
    this._totalRowsHeight = null;
  }
  get totalRowsHeight() {
    if (this._totalRowsHeight === null) {
      this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1);
    }
    return this._totalRowsHeight;
  }
  get totalColumnWidth() {
    return this.colCount * this.defaultCellWidth;
  }
  cellIndxeToColIndex(cellIdx) {
    return cellIdx % this.colCount;
  }
  cellIndxeToRowIndex(cellIdx) {
    return Math.floor(cellIdx / this.colCount);
  }
  getCell(cellIdx, createNewCell) {
    if (!this.isValidCellIdx(cellIdx)) {
      return null;
    }
    if (createNewCell === void 0) {
      createNewCell = true;
    }
    if (this.cells[cellIdx] === null && createNewCell) {
      var cell = this.newCell(cellIdx);
      this.cells[cellIdx] = cell;
    }
    return this.cells[cellIdx];
  }
  newCell(cellIdx) {
    var cell = this.cellPool.pop();
    if (cell === null) {
      cell = new Cell_default(this);
    } else {
      cell.setParent(this);
    }
    cell.index = cellIdx;
    return cell;
  }
  buildCellIndex(startIdx) {
    if (startIdx === void 0) {
      startIdx = 0;
    }
    var cells = this.cells, cell;
    for (var i = startIdx, len = cells.length; i < len; i++) {
      cell = cells[i];
      if (cell) {
        cell.index = i;
      }
    }
    return this;
  }
  getParentContainer() {
    return this.parent;
  }
  freeCell(cell) {
    if (typeof cell === "number") {
      cell = this.cells[cell];
    }
    if (!cell) {
      return this;
    }
    cell.destroy();
    this.cellPool.push(cell);
    return this;
  }
};
var Table_default = Table;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/SetTableOY.js
var SetTableOY = function(oy) {
  var table = this.table;
  var topTableOY = this.topTableOY;
  var bottomTableOY = this.bottomTableOY;
  var tableOYExceedTop = oy > topTableOY;
  var tableOYExeceedBottom = oy < bottomTableOY;
  if (this.clampTableOXY) {
    var rowCount = table.rowCount;
    var visibleRowCount = table.heightToRowIndex(this.instHeight, 1);
    if (rowCount < visibleRowCount) {
      oy = 0;
    } else if (tableOYExceedTop) {
      oy = topTableOY;
    } else if (tableOYExeceedBottom) {
      oy = bottomTableOY;
    }
  }
  if (this._tableOY !== oy) {
    this._tableOY = oy;
  }
  if (tableOYExceedTop) {
    if (!this.execeedTopState) {
      this.emit("execeedtop", this, oy, topTableOY);
    }
  }
  this.execeedTopState = tableOYExceedTop;
  if (tableOYExeceedBottom) {
    if (!this.execeedBottomState) {
      this.emit("execeedbottom", this, oy, bottomTableOY);
    }
  }
  this.execeedBottomState = tableOYExeceedBottom;
  return this;
};
var SetTableOY_default = SetTableOY;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/SetTableOX.js
var SetTableOX = function(ox) {
  var table = this.table;
  var leftTableOX = this.leftTableOX;
  var rightTableOX = this.rightTableOX;
  var tableOXExeceedLeft = ox > this.leftTableOX;
  var tableOXExeceedRight = ox < this.rightTableOX;
  if (this.clampTableOXY) {
    var colCount = table.colCount;
    var visibleColCount = table.widthToColIndex(this.instWidth, true);
    if (colCount < visibleColCount) {
      ox = 0;
    } else if (tableOXExeceedLeft) {
      ox = leftTableOX;
    } else {
      if (tableOXExeceedRight)
        ox = rightTableOX;
    }
  }
  if (this._tableOX !== ox) {
    this._tableOX = ox;
  }
  if (tableOXExeceedLeft) {
    if (!this.execeedLeftState) {
      this.emit("execeedleft", this, ox, leftTableOX);
    }
  }
  this.execeedLeftState = tableOXExeceedLeft;
  if (tableOXExeceedRight) {
    if (!this.execeedRightState) {
      this.emit("execeedright", this, ox, rightTableOX);
    }
  }
  this.execeedRightState = tableOXExeceedRight;
  return this;
};
var SetTableOX_default = SetTableOX;

// node_modules/phaser3-rex-plugins/plugins/utils/mask/MaskToGameObject.js
var MaskToGameObject = function(mask) {
  return mask.hasOwnProperty("geometryMask") ? mask.geometryMask : mask.bitmapMask;
};
var MaskToGameObject_default = MaskToGameObject;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/mask/MaskChildren.js
var Intersects = Phaser.Geom.Intersects.RectangleToRectangle;
var Overlaps = Phaser.Geom.Rectangle.Overlaps;
var MaskChildren = function({
  parent,
  mask,
  children,
  onVisible,
  onInvisible,
  scope
}) {
  if (!mask) {
    return;
  }
  if (children === void 0) {
    children = parent.getAllChildren();
  }
  var hasAnyVisibleCallback = !!onVisible || !!onInvisible;
  var parentBounds = parent.getBounds();
  var maskGameObject = MaskToGameObject_default(mask);
  var child, childBounds, visiblePointsNumber;
  var isChildVisible;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    if (child === maskGameObject) {
      continue;
    }
    if (!IsVisible(child)) {
      continue;
    }
    isChildVisible = child.visible;
    if (child.getBounds) {
      childBounds = child.getBounds(childBounds);
      visiblePointsNumber = ContainsPoints(parentBounds, childBounds);
      switch (visiblePointsNumber) {
        case 4:
          ShowAll(parent, child, mask);
          break;
        case 0:
          if (Intersects(parentBounds, childBounds) || Overlaps(parentBounds, childBounds)) {
            ShowSome(parent, child, mask);
          } else {
            ShowNone(parent, child, mask);
          }
          break;
        default:
          ShowSome(parent, child, mask);
          break;
      }
    } else {
      ShowSome(parent, child, mask);
    }
    if (hasAnyVisibleCallback && child.visible !== isChildVisible) {
      var callback = child.visible ? onVisible : onInvisible;
      if (callback) {
        if (scope) {
          callback.call(scope, child, parent);
        } else {
          callback(child, parent);
        }
      }
    }
  }
};
var IsVisible = function(gameObject2) {
  if (!gameObject2.displayList) {
    return false;
  }
  while (1) {
    var localState = gameObject2.rexContainer;
    if (!localState) {
      return gameObject2.visible;
    } else if (localState.visible) {
      var parent = localState.parent;
      if (parent) {
        gameObject2 = parent;
        continue;
      } else {
        return true;
      }
    } else {
      return false;
    }
  }
};
var ContainsPoints = function(rectA, rectB) {
  var top = rectB.top, bottom = rectB.bottom, left = rectB.left, right = rectB.right;
  var result = 0;
  result += rectA.contains(left, top) ? 1 : 0;
  result += rectA.contains(left, bottom) ? 1 : 0;
  result += rectA.contains(right, top) ? 1 : 0;
  result += rectA.contains(right, bottom) ? 1 : 0;
  return result;
};
var ShowAll = function(parent, child, mask) {
  if (!child.hasOwnProperty("isRexContainerLite")) {
    if (child.clearMask) {
      child.clearMask();
    }
    parent.setChildMaskVisible(child, true);
  } else {
    child.syncChildrenEnable = false;
    parent.setChildMaskVisible(child, true);
    child.syncChildrenEnable = true;
  }
};
var ShowSome = function(parent, child, mask) {
  if (!child.hasOwnProperty("isRexContainerLite")) {
    if (child.setMask) {
      child.setMask(mask);
    }
    parent.setChildMaskVisible(child, true);
  } else {
    child.syncChildrenEnable = false;
    parent.setChildMaskVisible(child, true);
    child.syncChildrenEnable = true;
  }
};
var ShowNone = function(parent, child, mask) {
  if (!child.hasOwnProperty("isRexContainerLite")) {
    if (child.clearMask) {
      child.clearMask();
    }
    parent.setChildMaskVisible(child, false);
  } else {
    child.syncChildrenEnable = false;
    parent.setChildMaskVisible(child, false);
    child.syncChildrenEnable = true;
  }
};
var MaskChildren_default = MaskChildren;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/mask/ChildrenMaskMethods.js
var GetValue175 = Phaser.Utils.Objects.GetValue;
var MASKUPDATEMODE = {
  update: 0,
  everyTick: 1
};
var ChildrenMaskMethods_default = {
  setupChildrenMask(config) {
    if (config === false) {
      return this;
    }
    this.setMaskUpdateMode(GetValue175(config, "updateMode", 0));
    this.enableChildrenMask(GetValue175(config, "padding", 0));
    this.setMaskLayer(GetValue175(config, "layer", void 0));
    this.onMaskGameObjectVisible = GetValue175(config, "onVisible");
    this.onMaskGameObjectInvisible = GetValue175(config, "onInvisible");
    this.maskGameObjectCallbackScope = GetValue175(config, "scope");
    this.startMaskUpdate();
    return this;
  },
  destroyChildrenMask() {
    if (!this.childrenMask) {
      return this;
    }
    this.stopMaskUpdate();
    this.childrenMask.destroy();
    this.childrenMask = void 0;
    this.onMaskGameObjectVisible = null;
    this.onMaskGameObjectInvisible = null;
    this.maskGameObjectCallbackScope = null;
    return this;
  },
  setMaskUpdateMode(mode) {
    if (typeof mode === "string") {
      mode = MASKUPDATEMODE[mode];
    }
    this.maskUpdateMode = mode;
    return this;
  },
  startMaskUpdate() {
    this.scene.game.events.on("poststep", this.maskChildren, this);
  },
  stopMaskUpdate() {
    this.scene.game.events.off("poststep", this.maskChildren, this);
  },
  enableChildrenMask(maskPadding) {
    var maskGameObject = AddChildMask_default.call(this, null, this, 0, maskPadding);
    this.childrenMask = maskGameObject.createGeometryMask();
    return this;
  },
  setMaskChildrenFlag(value) {
    if (value === void 0) {
      value = true;
    }
    this.maskChildrenFlag = value;
    return this;
  },
  setMaskLayer(layer) {
    this.maskLayer = layer;
    return this;
  },
  maskChildren() {
    if (!this.childrenMask || // No childrenMask
    !this.maskChildrenFlag || // No maskChildrenFlag set
    this.alpha === 0 || !this.visible) {
      return this;
    }
    if (this.privateRenderLayer) {
      this.privateRenderLayer.setMask(this.childrenMask);
    } else if (this.maskLayer) {
      this.addToLayer(this.maskLayer);
      this.maskLayer.setMask(this.childrenMask);
    } else {
      MaskChildren_default({
        parent: this,
        mask: this.childrenMask,
        onVisible: this.onMaskGameObjectVisible,
        onInvisible: this.onMaskGameObjectInvisible,
        scope: this.maskGameObjectCallbackScope
      });
    }
    if (this.maskUpdateMode === 0) {
      this.maskChildrenFlag = false;
    }
    return this;
  },
  layoutChildrenMask() {
    if (!this.childrenMask) {
      return this;
    }
    var maskGameObject = MaskToGameObject_default(this.childrenMask);
    maskGameObject.setPosition().resize();
    this.resetChildPositionState(maskGameObject);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/updatetable/ShowCells.js
var ShowCells = function() {
  if (this.cellsCount === 0) {
    return;
  }
  var scaleXSave = this.scaleX;
  var scaleYSave = this.scaleY;
  var scale1 = scaleXSave === 1 && scaleYSave === 1;
  if (!scale1) {
    this.setScale(1);
  }
  var table = this.table;
  var tableOYOffset = this.tableOYOffset;
  var tableOY = this.tableOY + tableOYOffset, tableOX = this.tableOX;
  this.startRowIndex = Math.max(table.heightToRowIndex(-tableOY, 2), 0);
  var rowIndex = this.startRowIndex;
  var startColumnIndex = Math.max(table.widthToColIndex(-tableOX), 0);
  var columnIndex = startColumnIndex;
  var cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
  var bottomBound = this.bottomBound;
  var rightBound = this.rightBound;
  var lastIdx = table.cellsCount - 1;
  var lastColIdx = table.colCount - 1;
  var startCellTLX = this.getCellTLX(columnIndex), cellTLX = startCellTLX;
  var startCellTLY = this.getCellTLY(rowIndex) + tableOYOffset, cellTLY = startCellTLY;
  while (cellTLY < bottomBound && cellIdx <= lastIdx) {
    if (this.table.isValidCellIdx(cellIdx)) {
      var cell = table.getCell(cellIdx, true);
      this.visibleCells.set(cell);
      if (!this.preVisibleCells.contains(cell)) {
        this.showCell(cell);
      }
      var x, y;
      if (this.scrollMode === 0) {
        x = cellTLX;
        y = cellTLY;
      } else {
        x = cellTLY;
        y = cellTLX;
      }
      if (cell.cellContainerAlign == null) {
        cell.setXY(x, y);
      } else {
        var cellContainer = cell.getContainer();
        AlignIn_default(cellContainer, x, y, cell.width, cell.height, cell.cellContainerAlign);
        cell.setXY(cellContainer.x, cellContainer.y);
      }
    }
    if (cellTLX < rightBound && columnIndex < lastColIdx) {
      cellTLX += table.getColWidth(columnIndex);
      columnIndex += 1;
    } else {
      cellTLX = startCellTLX;
      cellTLY += table.getRowHeight(rowIndex);
      columnIndex = startColumnIndex;
      rowIndex += 1;
    }
    cellIdx = table.colRowToCellIndex(columnIndex, rowIndex);
  }
  if (!scale1) {
    this.setScale(scaleXSave, scaleYSave);
  }
};
var ShowCells_default = ShowCells;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/updatetable/ShowCell.js
var ShowCell = function(cell) {
  var reusedCellContainer = null;
  var cellContainer = cell.getContainer();
  if (cellContainer) {
    reusedCellContainer = cellContainer;
    cell.popContainer();
  } else if (this.cellContainersPool) {
    reusedCellContainer = this.cellContainersPool.getFirstDead();
    if (reusedCellContainer !== null) {
      reusedCellContainer.setActive(true).setVisible(true);
    }
  }
  this.emit("cellvisible", cell, reusedCellContainer, this);
  if (this.cellContainersPool) {
    var cellContainer = cell.getContainer();
    if (cellContainer) {
      if (reusedCellContainer === null) {
        this.cellContainersPool.add(cellContainer);
      } else if (reusedCellContainer !== cellContainer) {
        this.cellContainersPool.add(cellContainer);
        this.cellContainersPool.killAndHide(reusedCellContainer);
      }
    } else {
      if (reusedCellContainer !== null) {
        this.cellContainersPool.killAndHide(reusedCellContainer);
      }
    }
  }
};
var ShowCell_default = ShowCell;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/updatetable/GetCellTLX.js
var GetCellTLX = function(colIdx) {
  var ox = this.scrollMode === 0 ? this.topLeftX : this.topLeftY;
  var x = this.tableOX + this.table.colIndexToWidth(0, colIdx - 1) + ox;
  return x;
};
var GetCellTLX_default = GetCellTLX;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/updatetable/GetCellTLY.js
var GetCellTLY = function(rowIdx) {
  var oy = this.scrollMode === 0 ? this.topLeftY : this.topLeftX;
  var y = this.tableOY + this.table.rowIndexToHeight(0, rowIdx - 1) + oy;
  return y;
};
var GetCellTLY_default = GetCellTLY;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/updatetable/HideCells.js
var HideCells = function() {
  var preList = this.preVisibleCells;
  var curList = this.visibleCells;
  preList.iterate(function(cell) {
    if (!curList.contains(cell)) {
      this.hideCell(cell);
    }
  }, this);
};
var HideCells_default = HideCells;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/updatetable/HideCell.js
var HideCell = function(cell) {
  this.emit("cellinvisible", cell);
  if (this.cellContainersPool) {
    var cellContainer = cell.popContainer();
    if (cellContainer) {
      cellContainer.setScale(1).setAlpha(1);
      this.cellContainersPool.killAndHide(cellContainer);
    }
  }
  cell.destroyContainer();
};
var HideCell_default = HideCell;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/updatetable/UpdateTable.js
var UpdateTable = function(refresh, maskChildren) {
  if (refresh === void 0) {
    refresh = false;
  }
  if (maskChildren === void 0) {
    maskChildren = false;
  }
  if (refresh) {
    ClearVisibleCellIndexes.call(this);
    this.hideCells();
  }
  ClearVisibleCellIndexes.call(this);
  this.showCells();
  this.hideCells();
  this.setMaskChildrenFlag();
  if (maskChildren) {
    this.layoutChildrenMask();
    this.maskChildren();
  }
  return this;
};
var ClearVisibleCellIndexes = function() {
  var tmp = this.preVisibleCells;
  this.preVisibleCells = this.visibleCells;
  this.visibleCells = tmp;
  this.visibleCells.clear();
};
var UpdateTable_default = UpdateTable;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/IsCellVisible.js
var IsCellVisible = function(cellIdx) {
  var cell = this.table.getCell(cellIdx, false);
  return cell && this.visibleCells.contains(cell);
};
var IsCellVisible_default = IsCellVisible;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/PointToCell.js
var PointToCellIndex = function(x, y) {
  y -= this.y + this.topLeftY;
  x -= this.x + this.topLeftX;
  var offsetTableOY = this.tableOY - (this.scrollMode === 0 ? y : x);
  var offsetTableOX = this.tableOX - (this.scrollMode === 0 ? x : y);
  var table = this.table;
  var rowIdx = table.heightToRowIndex(-offsetTableOY, 0);
  var colIdx = table.widthToColIndex(-offsetTableOX);
  var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
  if (cellIdx === null) {
    return null;
  }
  if (!this.isCellVisible(cellIdx)) {
    return null;
  }
  return cellIdx;
};
var PointToCellContainer = function(x, y) {
  var cellIdx = PointToCellIndex.call(this, x, y);
  if (cellIdx === null) {
    return void 0;
  }
  return this.getCellContainer(cellIdx);
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/EachCell.js
var EachVisibleCell = function(callback, scope) {
  this.visibleCells.each(callback, scope);
  return this;
};
var IterateVisibleCell = function(callback, scope) {
  this.visibleCells.iterate(callback, scope);
  return this;
};
var EachCell = function(callback, scope) {
  this.table.cells.slice().forEach(callback, scope);
  return this;
};
var IterateCell = function(callback, scope) {
  this.table.cells.forEach(callback, scope);
  return this;
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/SetCellsCount.js
var SetCellsCount = function(count) {
  var cellsCount = this.cellsCount;
  if (cellsCount === count) {
    return this;
  }
  if (cellsCount > count) {
    this.removeCells(count, cellsCount - count);
  } else {
    this.insertNewCells(cellsCount, count - cellsCount);
  }
  return this;
};
var SetCellsCount_default = SetCellsCount;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/InsertNewCells.js
var Clamp14 = Phaser.Math.Clamp;
var InsertNewCells = function(cellIdx, count) {
  if (typeof cellIdx === "object") {
    cellIdx = cellIdx.index;
  }
  if (count === void 0) {
    count = 1;
  }
  if (count <= 0) {
    return this;
  }
  cellIdx = Clamp14(cellIdx, 0, this.cellsCount);
  this.table.insertNewCells(cellIdx, count);
  return this;
};
var InsertNewCells_default = InsertNewCells;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/RemoveCells.js
var RemoveCells = function(cellIdx, count) {
  if (typeof cellIdx === "object") {
    cellIdx = cellIdx.index;
  }
  if (count === void 0) {
    count = 1;
  }
  if (cellIdx < 0) {
    count += cellIdx;
    cellIdx = 0;
  }
  if (count <= 0) {
    return this;
  }
  if (cellIdx > this.cellsCount) {
    return this;
  }
  var cell;
  for (var i = cellIdx, endIdx = cellIdx + count; i < endIdx; i++) {
    cell = this.getCell(i, false);
    if (cell) {
      if (this.visibleCells.contains(cell)) {
        HideCell_default.call(this, cell);
        this.visibleCells.delete(cell);
      }
      this.preVisibleCells.delete(cell);
    }
  }
  this.table.removeCells(cellIdx, count);
  return this;
};
var RemoveCells_default = RemoveCells;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/SetColumnCount.js
var SetColumnCount = function(count) {
  if (this.table.colCount === count) {
    return this;
  }
  this.table.setColumnCount(count);
  return this;
};
var SetColumnCount_default = SetColumnCount;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/SetGridSize.js
var SetGridSize = function(colCount, rowCount) {
  this.setCellsCount(colCount * rowCount);
  this.table.setColumnCount(colCount);
  return this;
};
var SetGridSize_default = SetGridSize;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/UpdateVisibleCell.js
var UpdateVisibleCell = function(cellIdx) {
  var cell = this.table.getCell(cellIdx, false);
  if (!cell || !cell.container) {
    return this;
  }
  ShowCell_default.call(this, cell);
  return this;
};
var UpdateVisibleCell_default = UpdateVisibleCell;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/methods/Methods.js
var methods32 = {
  setTableOY: SetTableOY_default,
  setTableOX: SetTableOX_default,
  showCells: ShowCells_default,
  showCell: ShowCell_default,
  getCellTLX: GetCellTLX_default,
  getCellTLY: GetCellTLY_default,
  hideCells: HideCells_default,
  hideCell: HideCell_default,
  updateTable: UpdateTable_default,
  isCellVisible: IsCellVisible_default,
  pointToCellIndex: PointToCellIndex,
  pointToCellContainer: PointToCellContainer,
  eachVisibleCell: EachVisibleCell,
  iterateVisibleCell: IterateVisibleCell,
  eachCell: EachCell,
  iterateCell: IterateCell,
  setCellsCount: SetCellsCount_default,
  insertNewCells: InsertNewCells_default,
  removeCells: RemoveCells_default,
  setColumnCount: SetColumnCount_default,
  setGridSize: SetGridSize_default,
  updateVisibleCell: UpdateVisibleCell_default
};
Object.assign(
  methods32,
  ChildrenMaskMethods_default
);
var Methods_default34 = methods32;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/gridtable/GridTable.js
var Group2 = Phaser.GameObjects.Group;
var Set = Phaser.Structs.Set;
var GetValue176 = Phaser.Utils.Objects.GetValue;
var GridTable = class extends ContainerLite_default {
  constructor(scene, x, y, width, height, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, x, y, width, height);
    this.type = "rexGridTable";
    this._tableOX = 0;
    this._tableOY = 0;
    this.visibleCells = new Set();
    this.preVisibleCells = new Set();
    this.execeedTopState = false;
    this.execeedBottomState = false;
    this.execeedLeftState = false;
    this.execeedRightState = false;
    var reuseCellContainer = GetValue176(config, "reuseCellContainer", false);
    if (reuseCellContainer) {
      this.cellContainersPool = new Group2(scene);
    }
    var callback = GetValue176(config, "cellVisibleCallback", null);
    if (callback !== null) {
      var scope = GetValue176(config, "cellVisibleCallbackScope", void 0);
      this.on("cellvisible", callback, scope);
    }
    callback = GetValue176(config, "cellInvisibleCallback", null);
    if (callback !== null) {
      var scope = GetValue176(config, "cellInvisibleCallbackScope", void 0);
      this.on("cellinvisible", callback, scope);
    }
    if (GetValue176(config, "enableLayer", false)) {
      this.enableLayer();
    }
    this.setupChildrenMask(GetValue176(config, "mask", void 0));
    this.setScrollMode(GetValue176(config, "scrollMode", 0));
    this.setClampMode(GetValue176(config, "clampTableOXY", true));
    this.setStartFromBottomEnable(GetValue176(config, "startFromBottom", false));
    var cellWidth, cellHeight, columns;
    var scrollY = this.scrollMode === 0;
    if (scrollY) {
      cellWidth = config.cellWidth;
      cellHeight = config.cellHeight;
      columns = config.columns;
    } else {
      cellWidth = config.cellHeight;
      cellHeight = config.cellWidth;
      columns = GetValue176(config, "rows", config.columns);
    }
    this.fixedCellSize = GetValue176(config, "fixedCellSize", false);
    this.expandCellSize = !this.fixedCellSize && cellWidth === void 0;
    if (!columns) {
      columns = 1;
    }
    if (this.fixedCellSize) {
      columns = Math.max(Math.floor(this.instWidth / cellWidth), 1);
    } else if (this.expandCellSize) {
      var width = scrollY ? this.width : this.height;
      cellWidth = width / columns;
    }
    config.cellWidth = cellWidth;
    config.cellHeight = cellHeight;
    config.columns = columns;
    this.table = new Table_default(this, config);
    this.updateTable();
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.destroyChildrenMask();
    this.table.destroy(fromScene);
    this.table = void 0;
    if (this.cellContainersPool) {
      this.cellContainersPool.destroy(true);
      this.cellContainersPool = void 0;
    }
    super.destroy(fromScene);
  }
  setScrollMode(mode) {
    if (typeof mode === "string") {
      mode = SCROLLMODE[mode.toLowerCase()];
    }
    this.scrollMode = mode;
    return this;
  }
  setClampMode(mode) {
    if (mode === void 0) {
      mode = true;
    }
    this.clampTableOXY = mode;
    return this;
  }
  setStartFromBottomEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.startFromBottomEnable = enable;
    return this;
  }
  get tableOY() {
    return this._tableOY;
  }
  get tableOX() {
    return this._tableOX;
  }
  set tableOY(oy) {
    this.setTableOY(oy).updateTable();
  }
  set tableOX(ox) {
    this.setTableOX(ox).updateTable();
  }
  setTableOXY(ox, oy) {
    this.setTableOY(oy).setTableOX(ox);
    return this;
  }
  addTableOY(dy) {
    this.setTableOY(this.tableOY + dy);
    return this;
  }
  addTableOX(dx) {
    this.setTableOX(this.tableOX + dx);
    return this;
  }
  addTableOXY(dx, dy) {
    this.addTableOY(dy).addTableOX(dx);
    return this;
  }
  setTableOYByPercentage(percentage) {
    this.setTableOY(-this.tableVisibleHeight * percentage);
    return this;
  }
  getTableOYPercentage() {
    var tableVisibleHeight = this.tableVisibleHeight;
    if (tableVisibleHeight === 0) {
      return 0;
    }
    return this.tableOY / -tableVisibleHeight;
  }
  setTableOXByPercentage(percentage) {
    this.setTableOX(-this.tableVisibleWidth * percentage);
    return this;
  }
  getTableOXPercentage() {
    var tableVisibleWidth = this.tableVisibleWidth;
    if (tableVisibleWidth === 0) {
      return 0;
    }
    return this.tableOX / -tableVisibleWidth;
  }
  set t(value) {
    this.setTableOYByPercentage(value).updateTable();
  }
  get t() {
    return this.getTableOYPercentage();
  }
  set s(value) {
    this.setTableOXByPercentage(value).updateTable();
  }
  get s() {
    return this.getTableOXPercentage();
  }
  scrollToBottom() {
    this.t = 1;
    if (this.t === 0) {
      return this;
    }
    do {
      this.t = 1;
    } while (this.t !== 1);
    return this;
  }
  scrollToRow(rowIndex) {
    this.scrollToBottom();
    var height = this.table.rowIndexToHeight(0, rowIndex - 1);
    this.setTableOY(-height).updateTable();
    return this;
  }
  scrollToNextRow(rowCount) {
    if (rowCount === void 0) {
      rowCount = 1;
    }
    this.scrollToRow(this.startRowIndex + rowCount);
    return this;
  }
  getCell(cellIdx) {
    return this.table.getCell(cellIdx, true);
  }
  getCellContainer(cellIdx) {
    var cell = this.table.getCell(cellIdx, false);
    var container;
    if (cell) {
      container = cell.getContainer();
    }
    return container;
  }
  get cellsCount() {
    return this.table.cellsCount;
  }
  get columnCount() {
    return this.table.colCount;
  }
  setCellHeight(cellIdx, height) {
    var cell;
    if (typeof cellIdx === "number") {
      cell = this.table.getCell(cellIdx, true);
    } else {
      cell = cellIdx;
    }
    cell.height = height;
    return this;
  }
  setCellWidth(cellIdx, width) {
    var cell;
    if (typeof cellIdx === "number") {
      cell = this.table.getCell(cellIdx, true);
    } else {
      cell = cellIdx;
    }
    cell.width = width;
    return this;
  }
  resetAllCellsSize(width, height) {
    if (this.scrollMode === 1) {
      var temp = width;
      width = height;
      height = temp;
    }
    this.table.setDefaultCellHeight(height).setDefaultCellWidth(width);
    var cells = this.table.cells;
    for (var i = 0, cnt = cells.length; i < cnt; i++) {
      var cell = cells[i];
      if (!cell) {
        continue;
      }
      cell.deltaHeight = 0;
    }
    if (this.fixedCellSize) {
      var colCount = Math.floor(this.instWidth / width);
      this.table.setColumnCount(colCount);
    }
    this.updateTable(true, true);
    return this;
  }
  get instHeight() {
    return this.scrollMode === 0 ? this.height : this.width;
  }
  get instWidth() {
    return this.scrollMode === 0 ? this.width : this.height;
  }
  get tableHeight() {
    return this.table.totalRowsHeight;
  }
  get tableWidth() {
    return this.table.totalColumnWidth;
  }
  get tableOYOffset() {
    if (this.startFromBottomEnable) {
      var h = this.tableHeight - this.instHeight;
      if (h < 0) {
        return -h;
      }
    }
    return 0;
  }
  get topTableOY() {
    return 0;
  }
  get bottomTableOY() {
    return -this.tableVisibleHeight;
  }
  get leftTableOX() {
    return 0;
  }
  get rightTableOX() {
    return -this.tableVisibleWidth;
  }
  get tableVisibleHeight() {
    var h = this.tableHeight - this.instHeight;
    if (h < 0) {
      h = 0;
    }
    return h;
  }
  get tableVisibleWidth() {
    var w = this.tableWidth - this.instWidth;
    if (w < 0) {
      w = 0;
    }
    return w;
  }
  get bottomLeftY() {
    return -(this.displayHeight * this.originY) + this.displayHeight;
  }
  get topRightX() {
    return -(this.displayWidth * this.originX) + this.displayWidth;
  }
  get topLeftX() {
    return -(this.displayWidth * this.originX);
  }
  get topLeftY() {
    return -(this.displayHeight * this.originY);
  }
  get bottomBound() {
    if (this.scrollMode === 0) {
      return this.bottomLeftY;
    } else {
      return this.topRightX;
    }
  }
  get rightBound() {
    if (this.scrollMode === 0) {
      return this.topRightX;
    } else {
      return this.bottomLeftY;
    }
  }
  resize(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }
    super.resize(width, height);
    if (this.fixedCellSize) {
      var colCount = Math.floor(this.instWidth / this.table.defaultCellWidth);
      this.table.setColumnCount(colCount);
    } else if (this.expandCellSize) {
      this.table.setDefaultCellWidth(this.instWidth / this.table.colCount);
    }
    this.updateTable(true, true);
    return this;
  }
};
Object.assign(
  GridTable.prototype,
  Methods_default34
);
var SCROLLMODE = {
  v: 0,
  vertical: 0,
  h: 1,
  horizontal: 1
};
var GridTable_default = GridTable;

// node_modules/phaser3-rex-plugins/plugins/gridtable.js
var gridtable_default = GridTable_default;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/InjectProperties.js
var InjectProperties2 = function(table) {
  Object.defineProperty(table, "childOY", {
    configurable: true,
    get: function() {
      return table.tableOY;
    },
    set: function(value) {
      table.tableOY = value;
    }
  });
  Object.defineProperty(table, "childOX", {
    configurable: true,
    get: function() {
      return table.tableOX;
    },
    set: function(value) {
      table.tableOX = value;
    }
  });
  Object.defineProperty(table, "topChildOY", {
    get: function() {
      return table.topTableOY;
    }
  });
  Object.defineProperty(table, "bottomChildOY", {
    get: function() {
      return table.bottomTableOY;
    }
  });
  Object.defineProperty(table, "leftChildOX", {
    get: function() {
      return table.leftTableOX;
    }
  });
  Object.defineProperty(table, "rightChildOX", {
    get: function() {
      return table.rightTableOX;
    }
  });
  Object.defineProperty(table, "childVisibleHeight", {
    get: function() {
      return table.instHeight;
    }
  });
  Object.defineProperty(table, "childHeight", {
    get: function() {
      return table.tableHeight;
    }
  });
  Object.defineProperty(table, "childVisibleWidth", {
    get: function() {
      return table.instWidth;
    }
  });
  Object.defineProperty(table, "childWidth", {
    get: function() {
      return table.tableWidth;
    }
  });
};
var InjectProperties_default2 = InjectProperties2;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/TableOnCellVisible.js
var TableOnCellVisible = function(table) {
  table.on("cellvisible", function(cell, cellContainer, table2) {
    var callback = this.createCellContainerCallback;
    var scope = this.createCellContainerCallbackScope;
    cell.item = this.items[cell.index];
    cell.items = this.items;
    var cellContainer;
    if (scope) {
      cellContainer = callback.call(scope, cell, cellContainer, table2);
    } else {
      cellContainer = callback(cell, cellContainer, table2);
    }
    if (cellContainer) {
      if (cell.cellContainerAlign == null && cellContainer.setOrigin) {
        cellContainer.setOrigin(0);
      }
      if (cellContainer.isRexSizer) {
        cellContainer.layout();
      }
    }
    cell.item = void 0;
    cell.items = void 0;
    cell.setContainer(cellContainer);
  }, this);
};
var TableOnCellVisible_default = TableOnCellVisible;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/EmitCellEvent.js
var EmitCellEvent = function(eventEmitter, eventName, table, worldX, worldY, pointer, event) {
  var cellIndex;
  if (worldY === void 0) {
    cellIndex = worldX;
  } else {
    var camera = pointer.camera;
    var px = worldX + camera.scrollX * (table.scrollFactorX - 1);
    var py = worldY + camera.scrollY * (table.scrollFactorY - 1);
    cellIndex = table.pointToCellIndex(px, py);
  }
  if (cellIndex === null || cellIndex === void 0) {
    return;
  }
  var cellContainer = table.getCellContainer(cellIndex);
  if (cellContainer) {
    eventEmitter.emit(eventName, cellContainer, cellIndex, pointer, event);
  }
};
var EmitCellEvent_default = EmitCellEvent;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/PointerUpDownCell.js
var PointerUpDownCell = function(table, tableConfig) {
  table.on("pointerdown", function(pointer, localX, localY, event) {
    EmitCellEvent_default(this.eventEmitter, "cell.down", table, pointer.worldX, pointer.worldY, pointer, event);
  }, this).on("pointerup", function(pointer, localX, localY, event) {
    EmitCellEvent_default(this.eventEmitter, "cell.up", table, pointer.worldX, pointer.worldY, pointer, event);
  }, this);
};
var PointerUpDownCell_default = PointerUpDownCell;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/OverCell.js
var OverCell = function(table, tableConfig) {
  table.on("pointermove", OnMove2, this).on("pointerover", OnMove2, this).on("pointerout", OnOut2, this);
};
var OnMove2 = function(pointer, localX, localY, event) {
  var table = this.childrenMap.child;
  var camera = pointer.camera;
  var px = pointer.worldX + camera.scrollX * (table.scrollFactorX - 1);
  var py = pointer.worldY + camera.scrollY * (table.scrollFactorY - 1);
  var cellIndex = table.pointToCellIndex(px, py);
  if (cellIndex === table.input.lastOverCellIndex) {
    return;
  }
  var preCellIndex = table.input.lastOverCellIndex;
  table.input.lastOverCellIndex = cellIndex;
  EmitCellEvent_default(this.eventEmitter, "cell.out", table, preCellIndex, void 0, pointer, event);
  EmitCellEvent_default(this.eventEmitter, "cell.over", table, cellIndex, void 0, pointer, event);
};
var OnOut2 = function(pointer, event) {
  var table = this.childrenMap.child;
  var cellIndex = table.input.lastOverCellIndex;
  table.input.lastOverCellIndex = void 0;
  EmitCellEvent_default(this.eventEmitter, "cell.out", table, cellIndex, void 0, pointer, event);
};
var OverCell_default = OverCell;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/ClickCell.js
var GetValue177 = Phaser.Utils.Objects.GetValue;
var ClickCell = function(table, tableConfig) {
  var buttonConfig = GetValue177(tableConfig, "click", void 0);
  if (buttonConfig === false) {
    return;
  } else if (buttonConfig === void 0) {
    buttonConfig = {};
  }
  buttonConfig.threshold = 10;
  table._click = new Button_default(table, buttonConfig);
  table._click.on("click", function(button, gameObject2, pointer, event) {
    EmitCellEvent_default(this.eventEmitter, "cell.click", gameObject2, pointer.worldX, pointer.worldY, pointer, event);
  }, this);
};
var ClickCell_default = ClickCell;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/TapCell.js
var GetValue178 = Phaser.Utils.Objects.GetValue;
var TapCell = function(table, tableConfig) {
  var tapConfig = GetValue178(tableConfig, "tap", void 0);
  if (tapConfig === false) {
    return;
  }
  table._tap = new Tap_default2(table, tapConfig);
  table._tap.on("tap", function(tap, gameObject2, lastPointer) {
    var eventName = `cell.${tap.tapsCount}tap`;
    EmitCellEvent_default(this.eventEmitter, eventName, tap.gameObject, tap.worldX, tap.worldY, lastPointer);
  }, this);
};
var TapCell_default = TapCell;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/PressCell.js
var GetValue179 = Phaser.Utils.Objects.GetValue;
var PressCell = function(table, tableConfig) {
  var pressConfig = GetValue179(tableConfig, "press", void 0);
  if (pressConfig === false) {
    return;
  }
  table._press = new Press_default2(table, pressConfig);
  table._press.on("pressstart", function(press, gameObject2, lastPointer) {
    EmitCellEvent_default(this.eventEmitter, "cell.pressstart", table, press.worldX, press.worldY, lastPointer);
  }, this).on("pressend", function(press, gameObject2, lastPointer) {
    EmitCellEvent_default(this.eventEmitter, "cell.pressend", table, press.worldX, press.worldY, lastPointer);
  }, this);
};
var PressCell_default = PressCell;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/SwipeCell.js
var GetValue180 = Phaser.Utils.Objects.GetValue;
var SwipeCell = function(table, tableConfig) {
  var swipeConfig = GetValue180(tableConfig, "swipe", void 0);
  if (swipeConfig === false) {
    return;
  } else if (swipeConfig === void 0) {
    swipeConfig = {};
  }
  swipeConfig.dir = "4dir";
  table._swipe = new Swipe_default2(table, swipeConfig);
  table._swipe.on("swipe", function(swipe, gameObject2, lastPointer) {
    var dirName = swipe.left ? "left" : swipe.right ? "right" : swipe.up ? "up" : "down";
    EmitCellEvent_default(this.eventEmitter, `cell.swipe${dirName}`, table, swipe.worldX, swipe.worldY, lastPointer);
  }, this);
};
var SwipeCell_default = SwipeCell;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/input/TableSetInteractive.js
var TableSetInteractive = function(table, tableConfig) {
  table.setInteractive();
  PointerUpDownCell_default.call(this, table, tableConfig);
  OverCell_default.call(this, table, tableConfig);
  ClickCell_default.call(this, table, tableConfig);
  TapCell_default.call(this, table, tableConfig);
  PressCell_default.call(this, table, tableConfig);
  SwipeCell_default.call(this, table, tableConfig);
};
var TableSetInteractive_default = TableSetInteractive;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/SetItems.js
var SetItems = function(items, updateTable) {
  if (items === void 0) {
    this.items = [];
  } else {
    this.items = items;
  }
  if (updateTable === void 0) {
    updateTable = true;
  }
  var table = this.childrenMap.child;
  table.setCellsCount(this.items.length);
  if (updateTable) {
    table.updateTable(true);
    this.resizeController();
  }
  return this;
};
var SetItems_default = SetItems;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/ScrollMethods.js
var ScrollMethods_default2 = {
  scrollToRow(rowIndex) {
    var table = this.childrenMap.child;
    table.scrollToRow(rowIndex);
    return this;
  },
  scrollToNextRow(rowCount) {
    var table = this.childrenMap.child;
    table.scrollToNextRow(rowCount);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/GridTable.js
var GetValue181 = Phaser.Utils.Objects.GetValue;
var GridTable2 = class extends Scrollable_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var scrollMode = GetScrollMode_default(config);
    var tableConfig = GetValue181(config, "table", void 0);
    if (tableConfig === void 0) {
      tableConfig = {};
    }
    tableConfig.scrollMode = scrollMode === 2 ? 0 : scrollMode;
    tableConfig.clampTableOXY = GetValue181(config, "clampChildOY", false);
    var tableWidth = GetValue181(tableConfig, "width", void 0);
    var tableHeight = GetValue181(tableConfig, "height", void 0);
    var table = new gridtable_default(scene, 0, 0, tableWidth, tableHeight, tableConfig);
    scene.add.existing(table);
    var expandWidth, expandHeight;
    if (tableConfig.scrollMode === 0) {
      expandWidth = tableWidth === void 0;
      expandHeight = tableHeight === void 0;
    } else {
      expandWidth = tableHeight === void 0;
      expandHeight = tableWidth === void 0;
    }
    InjectProperties_default2(table);
    table._minWidth = tableWidth === void 0 ? 0 : void 0;
    table._minHeight = tableHeight === void 0 ? 0 : void 0;
    config.type = "rexGridTable";
    config.child = {
      gameObject: table,
      expandWidth,
      expandHeight
    };
    var spaceConfig = GetValue181(config, "space", void 0);
    if (spaceConfig) {
      spaceConfig.child = GetValue181(spaceConfig, "table", 0);
    }
    super(scene, config);
    this.addChildrenMap("table", table);
    this.addChildrenMap("tableLayer", table.maskLayer);
    this.eventEmitter = GetValue181(config, "eventEmitter", this);
    var callback = GetValue181(config, "createCellContainerCallback", NOOP_default);
    var scope = GetValue181(config, "createCellContainerCallbackScope", void 0);
    this.setCreateCellContainerCallback(callback, scope);
    TableOnCellVisible_default.call(this, table);
    this.resizeControllerFlag = false;
    var eventName = scrollMode === 0 ? "cellheightchange" : "cellwidthchange";
    table.on(eventName, function() {
      this.resizeControllerFlag = true;
    }, this);
    if (GetValue181(tableConfig, "interactive", true)) {
      TableSetInteractive_default.call(this, table, tableConfig);
    }
    this.setItems(GetValue181(config, "items", []), false);
    scene.game.events.on("poststep", this.onPostStep, this);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.scene.game.events.off("poststep", this.onPostStep, this);
    super.destroy(fromScene);
  }
  setCreateCellContainerCallback(callback, scope) {
    this.createCellContainerCallback = callback;
    this.createCellContainerCallbackScope = scope;
    return this;
  }
  refresh() {
    this.setItems(this.items);
    return this;
  }
  getCell(cellIdx) {
    var table = this.childrenMap.child;
    return table.getCell(cellIdx);
  }
  getCellContainer(cellIdx) {
    var table = this.childrenMap.child;
    return table.getCellContainer(cellIdx);
  }
  updateVisibleCell(cellIdx) {
    var table = this.childrenMap.child;
    return table.updateVisibleCell(cellIdx);
  }
  resetAllCellsSize(width, height) {
    var table = this.childrenMap.child;
    table.resetAllCellsSize(width, height);
    return this;
  }
  onPostStep() {
    if (this.resizeControllerFlag) {
      this.resizeController();
      this.resizeControllerFlag = false;
    }
  }
  get startRowIndex() {
    var table = this.childrenMap.child;
    return table.startRowIndex;
  }
};
var methods33 = {
  setItems: SetItems_default
};
Object.assign(
  GridTable2.prototype,
  ScrollMethods_default2,
  methods33
);
var GridTable_default2 = GridTable2;

// node_modules/phaser3-rex-plugins/templates/ui/gridtable/Factory.js
ObjectFactory_default.register("gridTable", function(config) {
  var gameObject2 = new GridTable_default2(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.GridTable", GridTable_default2);

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/GetEaseConfig.js
var GetEaseConfig = function(easeConfig, menu) {
  if (easeConfig.sameOrientation) {
    easeConfig.orientation = menu.orientation;
  } else {
    easeConfig.orientation = menu.orientation === 0 ? 1 : 0;
  }
  return easeConfig;
};
var GetEaseConfig_default = GetEaseConfig;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/SetTransitCallbackMethods.js
var PopUp2 = function(menu, duration) {
  menu.popUp(GetEaseConfig_default(menu.root.easeIn, menu));
};
var ScaleDown = function(menu, duration) {
  menu.scaleDown(GetEaseConfig_default(menu.root.easeOut, menu));
};
var SetTransitCallbackMethods_default = {
  setTransitInCallback(callback) {
    if (callback === void 0) {
      callback = PopUp2;
    }
    this.transitInCallback = callback;
    return this;
  },
  setTransitOutCallback(callback) {
    if (callback === void 0) {
      callback = ScaleDown;
    }
    this.transitOutCallback = callback;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/utils/time/PostUpdateDelayCall.js
var PostUpdateDelayCall = function(gameObject2, delay, callback, scope, args) {
  var scene = GetSceneObject_default(gameObject2);
  var timer = scene.time.delayedCall(delay, function() {
    scene.sys.events.once("postupdate", function() {
      callback.call(scope, args);
    });
  });
  return timer;
};
var PostUpdateDelayCall_default = PostUpdateDelayCall;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/DelayCallMethods.js
var DelayCallMethods_default3 = {
  delayCall(delay, callback, scope) {
    this.timer = PostUpdateDelayCall_default(this, delay, callback, scope);
    return this;
  },
  removeDelayCall() {
    if (this.timer) {
      this.timer.remove(false);
      this.timer = void 0;
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/ExpandSubMenu.js
var ExpandSubMenu = function(parentButton, items) {
  var subMenu = this.childrenMap.subMenu;
  if (subMenu && subMenu.parentButton === parentButton) {
    return this;
  }
  this.collapseSubMenu();
  var orientation;
  if (this.root.toggleOrientation) {
    orientation = this.orientation === 0 ? 1 : 0;
  } else {
    orientation = this.orientation;
  }
  var subMenu = new this.constructor(this.scene, {
    items,
    orientation,
    space: this.space,
    createBackgroundCallback: this.root.createBackgroundCallback,
    createBackgroundCallbackScope: this.root.createBackgroundCallbackScope,
    createButtonCallback: this.root.createButtonCallback,
    createButtonCallbackScope: this.root.createButtonCallbackScope,
    easeIn: this.root.easeIn,
    easeOut: this.root.easeOut,
    _rootMenu: this.root,
    _parentMenu: this,
    _parentButton: parentButton
  });
  this.pin(subMenu);
  this.childrenMap.subMenu = subMenu;
  this.root.emit("expand", subMenu, parentButton, this);
  return this;
};
var ExpandSubMenu_default = ExpandSubMenu;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/Collapse.js
var Collapse = function() {
  var root = this.root;
  root.emit("collapse", this, this.parentButton, root);
  var duration = root.easeOut.duration;
  root.transitOutCallback(this, duration);
  this.collapseSubMenu();
  this.delayCall(duration, this.destroy, this);
  return this;
};
var Collapse_default = Collapse;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/CollapseSubMenu.js
var CollapseSubMenu = function() {
  var subMenu = this.childrenMap.subMenu;
  if (subMenu === void 0) {
    return this;
  }
  this.childrenMap.subMenu = void 0;
  this.remove(subMenu);
  subMenu.collapse();
  return this;
};
var CollapseSubMenu_default = CollapseSubMenu;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/Methods.js
var Methods17 = {
  expandSubMenu: ExpandSubMenu_default,
  collapse: Collapse_default,
  collapseSubMenu: CollapseSubMenu_default
};
Object.assign(
  Methods17,
  SetTransitCallbackMethods_default,
  DelayCallMethods_default3
);
var Methods_default35 = Methods17;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/CreateBackground.js
var CreateBackground2 = function(scene, items, callback, scope) {
  var background;
  if (callback) {
    items.scene = scene;
    if (scope) {
      background = callback.call(scope, items);
    } else {
      background = callback(items);
    }
    items.scene = void 0;
  }
  return background;
};
var CreateBackground_default2 = CreateBackground2;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/CreateButtons.js
var CreateButtons = function(scene, items, callback, scope) {
  var item;
  var buttons = [], button;
  if (items && callback) {
    for (var i = 0, cnt = items.length; i < cnt; i++) {
      item = items[i];
      item.scene = scene;
      if (scope) {
        button = callback.call(scope, item, i, items);
      } else {
        button = callback(item, i, items);
      }
      item.scene = void 0;
      buttons.push(button);
    }
  }
  return buttons;
};
var CreateButtons_default = CreateButtons;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/MenuSetInteractive.js
var MenuSetInteractive = function(menu) {
  menu.on(menu.root.expandEventName, function(button, index) {
    if (this._isPassedEvent) {
      return;
    }
    var childrenKey = this.root.childrenKey;
    var subItems = this.items[index][childrenKey];
    if (subItems) {
      this.expandSubMenu(button, subItems);
    } else {
    }
  }, menu).on("button.click", function(button, index, pointer, event) {
    if (this !== this.root) {
      this.root._isPassedEvent = true;
      this.root.emit("button.click", button, index, pointer, event);
      this.root._isPassedEvent = false;
    }
  }, menu).on("button.over", function(button, index, pointer, event) {
    if (this !== this.root) {
      this.root._isPassedEvent = true;
      this.root.emit("button.over", button, index, pointer, event);
      this.root._isPassedEvent = false;
    }
  }, menu).on("button.out", function(button, index, pointer, event) {
    if (this !== this.root) {
      this.root._isPassedEvent = true;
      this.root.emit("button.out", button, index, pointer, event);
      this.root._isPassedEvent = false;
    }
  }, menu);
};
var MenuSetInteractive_default = MenuSetInteractive;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/ParseEaseConfig.js
var ParseEaseConfig = function(menu, easeConfig) {
  if (typeof easeConfig === "number") {
    easeConfig = {
      duration: easeConfig
    };
  }
  if (easeConfig.hasOwnProperty("orientation") && easeConfig.orientation !== void 0) {
    easeConfig.sameOrientation = GetOrientationMode_default2(easeConfig.orientation) === menu.orientation;
  } else {
    easeConfig.sameOrientation = true;
  }
  easeConfig.destroy = false;
  return easeConfig;
};
var ParseEaseConfig_default = ParseEaseConfig;

// node_modules/phaser3-rex-plugins/templates/ui/menu/methods/Expand.js
var Expand = function() {
  var root = this.root;
  var duration = root.easeIn.duration;
  root.transitInCallback(this, duration);
  if (this !== this.root) {
    this.delayCall(duration, function() {
      this.root.emit("popup.complete", this);
    }, this);
  }
};
var Expand_default = Expand;

// node_modules/phaser3-rex-plugins/templates/ui/menu/Menu.js
var GetValue182 = Phaser.Utils.Objects.GetValue;
var Menu = class extends Buttons_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("orientation")) {
      config.orientation = 1;
    }
    var rootMenu = config._rootMenu;
    var parentMenu = config._parentMenu;
    var parentButton = config._parentButton;
    var popUp = GetValue182(config, "popup", true);
    var items = GetValue182(config, "items", void 0);
    var createBackgroundCallback = GetValue182(config, "createBackgroundCallback", void 0);
    var createBackgroundCallbackScope = GetValue182(config, "createBackgroundCallbackScope", void 0);
    config.background = CreateBackground_default2(scene, items, createBackgroundCallback, createBackgroundCallbackScope);
    var createButtonCallback = GetValue182(config, "createButtonCallback", void 0);
    var createButtonCallbackScope = GetValue182(config, "createButtonCallbackScope", void 0);
    config.buttons = CreateButtons_default(scene, items, createButtonCallback, createButtonCallbackScope);
    super(scene, config);
    this.type = "rexMenu";
    this.items = items;
    this.root = rootMenu === void 0 ? this : rootMenu;
    this.isRoot = this.root === this;
    this.parentMenu = parentMenu;
    this.parentButton = parentButton;
    this.timer = void 0;
    if (this.isRoot) {
      this.isPopUpMode = popUp;
      var bounds = config.bounds;
      if (bounds === void 0) {
        bounds = GetViewport_default(scene);
      }
      this.bounds = bounds;
      this.subMenuSide = [
        this.y < bounds.centerY ? SUBMENU_DOWN : SUBMENU_UP,
        this.x < bounds.centerX ? SUBMENU_RIGHT : SUBMENU_LEFT
      ];
      var subMenuSide = GetValue182(config, "subMenuSide", void 0);
      if (subMenuSide !== void 0) {
        if (typeof subMenuSide === "string") {
          subMenuSide = SubMenuSideMode[subMenuSide];
        }
        this.subMenuSide[this.orientation] = subMenuSide;
      }
      this.toggleOrientation = GetValue182(config, "toggleOrientation", false);
      this.expandEventName = GetValue182(config, "expandEvent", "button.click");
      this.easeIn = ParseEaseConfig_default(this, GetValue182(config, "easeIn", 0));
      this.easeOut = ParseEaseConfig_default(this, GetValue182(config, "easeOut", 0));
      this.setTransitInCallback(GetValue182(config, "transitIn"));
      this.setTransitOutCallback(GetValue182(config, "transitOut"));
      this.createBackgroundCallback = createBackgroundCallback;
      this.createBackgroundCallbackScope = createBackgroundCallbackScope;
      this.createButtonCallback = createButtonCallback;
      this.createButtonCallbackScope = createButtonCallbackScope;
      this.childrenKey = GetValue182(config, "childrenKey", "children");
      this._isPassedEvent = false;
      this.pointerDownOutsideCollapsing = GetValue182(config, "pointerDownOutsideCollapsing", true);
      if (this.pointerDownOutsideCollapsing) {
        scene.input.on("pointerdown", this.onPointerDownOutside, this);
      }
    } else {
    }
    var originX = 0, originY = 0;
    if (!this.root.easeIn.sameOrientation) {
      var easeOrientation = GetEaseConfig_default(this.root.easeIn, this).orientation;
      var menuOrientation = parentMenu ? parentMenu.orientation : this.orientation;
      var subMenuSide = this.root.subMenuSide[menuOrientation];
      if (easeOrientation === 0 && subMenuSide === SUBMENU_LEFT) {
        originX = 1;
      }
      if (easeOrientation === 1 && subMenuSide === SUBMENU_UP) {
        originY = 1;
      }
    }
    if (popUp) {
      this.setOrigin(originX, originY).layout();
    }
    if (!this.isRoot) {
      this.setScale(this.root.scaleX, this.root.scaleY);
      var subMenuSide = this.root.subMenuSide[parentMenu.orientation];
      switch (subMenuSide) {
        case SUBMENU_LEFT:
          this.alignTop(parentButton.top).alignRight(parentButton.left);
          break;
        case SUBMENU_RIGHT:
          this.alignTop(parentButton.top).alignLeft(parentButton.right);
          break;
        case SUBMENU_UP:
          this.alignLeft(parentButton.left).alignBottom(parentButton.top);
          break;
        case SUBMENU_DOWN:
          this.alignLeft(parentButton.left).alignTop(parentButton.bottom);
          break;
      }
    }
    MenuSetInteractive_default(this);
    if (popUp) {
      this.pushIntoBounds(this.root.bounds);
      Expand_default.call(this);
    }
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (this.isRoot && this.pointerDownOutsideCollapsing) {
      this.scene.input.off("pointerdown", this.onPointerDownOutside, this);
    }
    super.destroy(fromScene);
    this.removeDelayCall();
  }
  isInTouching(pointer) {
    if (super.isInTouching(pointer)) {
      return true;
    } else if (this.childrenMap.subMenu) {
      return this.childrenMap.subMenu.isInTouching(pointer);
    } else {
      return false;
    }
  }
  onPointerDownOutside(pointer) {
    if (this.isInTouching(pointer)) {
      return;
    }
    if (this.isPopUpMode) {
      this.collapse();
    } else {
      this.collapseSubMenu();
    }
  }
};
var SUBMENU_LEFT = 2;
var SUBMENU_RIGHT = 0;
var SUBMENU_UP = 3;
var SUBMENU_DOWN = 1;
var SubMenuSideMode = {
  up: SUBMENU_UP,
  down: SUBMENU_DOWN,
  left: SUBMENU_LEFT,
  right: SUBMENU_RIGHT
};
Object.assign(
  Menu.prototype,
  Methods_default35
);
var Menu_default = Menu;

// node_modules/phaser3-rex-plugins/templates/ui/menu/Factory.js
ObjectFactory_default.register("menu", function(config) {
  var gameObject2 = new Menu_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Menu", Menu_default);

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/listpanel/ConfigurationMethods.js
var methods34 = {
  setWrapEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.listWrapEnable = enable;
    return this;
  },
  setCreateButtonCallback(callback) {
    this.listCreateButtonCallback = callback;
    return this;
  },
  setCreateListBackgroundCallback(callback) {
    this.listCreateBackgroundCallback = callback;
    return this;
  },
  setCreateListSliderTrackCallback(callback) {
    this.listCreateSliderTrackCallback = callback;
    return this;
  },
  setCreateListSliderThumbCallback(callback) {
    this.listCreateSliderThumbCallback = callback;
    return this;
  },
  setListSliderAdaptThumbSizeEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.listSliderAdaptThumbSizeEnable = enable;
    return this;
  },
  setListScrollerConfig(config) {
    if (config === void 0) {
      config = {};
    }
    this.listScrollerConfig = config;
    return this;
  },
  setListMouseWheelScrollerConfig(config) {
    this.listMouseWheelScrollerConfig = config;
    return this;
  },
  setButtonClickCallback(callback) {
    this.listOnButtonClick = callback;
    return this;
  },
  setButtonOverCallback(callback) {
    this.listOnButtonOver = callback;
    return this;
  },
  setButtonOutCallback(callback) {
    this.listOnButtonOut = callback;
    return this;
  },
  setListExpandDirection(direction) {
    if (typeof direction === "string") {
      direction = ListExpandDirections[direction];
    }
    this.listExpandDirection = direction;
    return this;
  },
  setListEaseInDuration(duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.listEaseInDuration = duration;
    return this;
  },
  setListEaseOutDuration(duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.listEaseOutDuration = duration;
    return this;
  },
  setListTransitInCallback(callback) {
    this.listTransitInCallback = callback;
    return this;
  },
  settListTransitOutCallback(callback) {
    this.listTransitOutCallback = callback;
    return this;
  },
  setListBounds(bounds) {
    this.listBounds = bounds;
    return this;
  },
  setListWidth(width) {
    this.listWidth = width;
    return this;
  },
  setListHeight(height) {
    this.listHeight = height;
    return this;
  },
  setListSize(width, height) {
    this.setListWidth(width).setListHeight(height);
    return this;
  },
  setListMaxHeight(height) {
    this.listMaxHeight = height;
    return this;
  },
  setListAlignmentMode(mode) {
    this.listAlignMode = mode;
    return this;
  },
  setListAlignmentSide(side) {
    if (side === void 0) {
      side = "";
    }
    this.listAlignSide = side;
    return this;
  },
  setListSpace(space) {
    if (space === void 0) {
      space = {};
    }
    this.listSpace = space;
    return this;
  },
  setListDraggable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.listDraggable = enable;
    return this;
  }
};
var ListExpandDirections = {
  down: 0,
  up: 1
};
var ConfigurationMethods_default2 = methods34;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/GetChildrenWidth.js
var GetChildrenWidth6 = function() {
  if (this.rexSizer.hidden) {
    return 0;
  }
  var childWidth;
  var child = this.child, childConfig = child.rexSizer;
  var hasUnknownChildWidth = false;
  if (childConfig.hidden) {
    childWidth = 0;
  } else {
    switch (this.scrollMode) {
      case 0:
        childWidth = this.getChildWidth(child);
        if (childWidth === void 0) {
          hasUnknownChildWidth = true;
        }
        break;
      case 1:
        childWidth = 0;
        break;
      default:
        childWidth = 0;
        break;
    }
  }
  if (hasUnknownChildWidth) {
    return void 0;
  }
  return childWidth;
};
var GetChildrenWidth_default6 = GetChildrenWidth6;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/GetChildrenHeight.js
var GetChildrenHeight6 = function() {
  if (this.rexSizer.hidden) {
    return 0;
  }
  var childHeight;
  var child = this.child, childConfig = child.rexSizer;
  var hasUnknownChildHeight = false;
  if (childConfig.hidden) {
    childHeight = 0;
  } else {
    switch (this.scrollMode) {
      case 0:
        childHeight = 0;
        break;
      case 1:
        childHeight = this.getChildHeight(child);
        if (childHeight === void 0) {
          hasUnknownChildHeight = true;
        }
        break;
      default:
        childHeight = 0;
        break;
    }
  }
  if (hasUnknownChildHeight) {
    return void 0;
  }
  return childHeight;
};
var GetChildrenHeight_default6 = GetChildrenHeight6;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/GetChildrenSizers.js
var GetChildrenSizers6 = function(out2) {
  if (out2 === void 0) {
    out2 = [];
  }
  if (this.child && this.child.isRexSizer) {
    out2.push(this.child);
  }
  return out2;
};
var GetChildrenSizers_default6 = GetChildrenSizers6;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/ResetChildPosition.js
var ResetChildPosition = function() {
  var x = this.left;
  var y = this.top;
  switch (this.scrollMode) {
    case 0:
      y += this.childOY;
      break;
    case 1:
      x += this.childOY;
      break;
    default:
      y += this.childOY;
      x += this.childOX;
      break;
  }
  this.child.setPosition(x, y);
  this.resetChildPositionState(this.child);
  this.setMaskChildrenFlag();
};
var ResetChildPosition_default = ResetChildPosition;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/LayoutChildren.js
var LayoutChildren7 = function() {
  var child = this.child;
  var childWidth, childHeight;
  if (!child.rexSizer.hidden) {
    switch (this.scrollMode) {
      case 0:
        childWidth = this.width * this.scaleX;
        break;
      case 1:
        childHeight = this.height * this.scaleY;
        break;
      default:
        break;
    }
    if (child.isRexSizer) {
      child.runLayout(this, childWidth, childHeight);
    } else {
      ResizeGameObject_default(child, childWidth, childHeight);
    }
    this.resetChildPosition();
    this.layoutChildrenMask();
    this.maskChildren();
  }
};
var LayoutChildren_default7 = LayoutChildren7;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/RemoveChildCallback.js
var RemoveChildCallback = function(gameObject2, destroyChild) {
  if (destroyChild) {
    return;
  }
  if (gameObject2.clearMask) {
    gameObject2.clearMask(false);
  }
};
var RemoveChildCallback_default = RemoveChildCallback;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/Methods.js
var methods35 = {
  getChildrenWidth: GetChildrenWidth_default6,
  getChildrenHeight: GetChildrenHeight_default6,
  getChildrenSizers: GetChildrenSizers_default6,
  resetChildPosition: ResetChildPosition_default,
  layoutChildren: LayoutChildren_default7,
  removeChildCallback: RemoveChildCallback_default
};
Object.assign(
  methods35,
  ChildrenMaskMethods_default
);
var Methods_default36 = methods35;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/scrollableblock/ScrollableBlock.js
var IsPlainObject48 = Phaser.Utils.Objects.IsPlainObject;
var GetValue183 = Phaser.Utils.Objects.GetValue;
var ALIGN_LEFTTOP2 = Phaser.Display.Align.TOP_LEFT;
var ScrollableBlock = class extends BaseSizer_default {
  constructor(scene, x, y, minWidth, minHeight, config) {
    if (IsPlainObject48(x)) {
      config = x;
      x = GetValue183(config, "x", 0);
      y = GetValue183(config, "y", 0);
      minWidth = GetValue183(config, "width", void 0);
      minHeight = GetValue183(config, "height", void 0);
    } else if (IsPlainObject48(minWidth)) {
      config = minWidth;
      minWidth = GetValue183(config, "width", void 0);
      minHeight = GetValue183(config, "height", void 0);
    }
    super(scene, x, y, minWidth, minHeight, config);
    this.type = "rexScrollableBlock";
    this.child = void 0;
    this.childrenMask = void 0;
    this._childOY = 0;
    this._childOX = 0;
    this.execeedTopState = false;
    this.execeedBottomState = false;
    this.execeedLeftState = false;
    this.execeedRightState = false;
    this.setScrollMode(GetValue183(config, "scrollMode", 0));
    var clampChildOY = GetValue183(config, "clampChildOY", true);
    var clampChildOX = GetValue183(config, "clampChildOX", clampChildOY);
    this.setClampMode(clampChildOY, clampChildOX);
    var child = GetValue183(config, "child", void 0);
    var expand = GetValue183(config, "expand", true);
    if (child.setOrigin) {
      child.setOrigin(0);
    }
    this.add(child);
    this.sizerChildren = [child];
    var sizerConfig = this.getSizerConfig(child);
    sizerConfig.align = ALIGN_LEFTTOP2;
    sizerConfig.expand = expand;
    this.child = child;
    var maskConfig = GetValue183(config, "mask");
    this.setupChildrenMask(maskConfig);
    if (this.childrenMask) {
      this.maskGameObject = MaskToGameObject_default(this.childrenMask);
    }
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.destroyChildrenMask();
    this.child = void 0;
    super.destroy(fromScene);
  }
  setScrollMode(mode) {
    if (typeof mode === "string") {
      mode = ScrollModeConst_default[mode.toLowerCase()];
    }
    this.scrollMode = mode;
    return this;
  }
  setClampMode(clampChildOY, clampChildOX) {
    this.clampChildOY = clampChildOY;
    this.clampChildOX = clampChildOX;
    return this;
  }
  get instHeight() {
    if (this.scrollMode === 0 || this.scrollMode === 2) {
      return this.displayHeight;
    } else {
      return this.displayWidth;
    }
  }
  get instWidth() {
    if (this.scrollMode === 0 || this.scrollMode === 2) {
      return this.displayWidth;
    } else {
      return this.displayHeight;
    }
  }
  get childHeight() {
    if (this.scrollMode === 0 || this.scrollMode === 2) {
      return GetDisplayHeight(this.child);
    } else {
      return GetDisplayWidth(this.child);
    }
  }
  get childWidth() {
    if (this.scrollMode === 0 || this.scrollMode === 2) {
      return GetDisplayWidth(this.child);
    } else {
      return GetDisplayHeight(this.child);
    }
  }
  get topChildOY() {
    return 0;
  }
  get bottomChildOY() {
    return -this.visibleHeight;
  }
  get leftChildOX() {
    return 0;
  }
  get rightChildOX() {
    return -this.visibleWidth;
  }
  get childVisibleHeight() {
    return this.instHeight;
  }
  get childVisibleWidth() {
    return this.instWidth;
  }
  get visibleHeight() {
    var h = this.childHeight - this.childVisibleHeight;
    if (h < 0) {
      h = 0;
    }
    return h;
  }
  get visibleWidth() {
    var w = this.childWidth - this.childVisibleWidth;
    if (w < 0) {
      w = 0;
    }
    return w;
  }
  childOYExceedTop(oy) {
    if (oy === void 0) {
      oy = this.childOY;
    }
    return oy > this.topChildOY;
  }
  childOYExeceedBottom(oy) {
    if (oy === void 0) {
      oy = this.childOY;
    }
    return oy < this.bottomChildOY;
  }
  childOXExceedLeft(ox) {
    if (ox === void 0) {
      ox = this.childOX;
    }
    return ox > this.leftChildOX;
  }
  childOXExeceedRight(ox) {
    if (ox === void 0) {
      ox = this.childOX;
    }
    return ox < this.rightChildOX;
  }
  get childOY() {
    return this._childOY;
  }
  set childOY(oy) {
    var topChildOY = this.topChildOY;
    var bottomChildOY = this.bottomChildOY;
    var childOYExceedTop = this.childOYExceedTop(oy);
    var childOYExeceedBottom = this.childOYExeceedBottom(oy);
    if (this.clampChildOY) {
      if (this.childVisibleHeight > this.childHeight) {
        oy = 0;
      } else if (childOYExceedTop) {
        oy = topChildOY;
      } else if (childOYExeceedBottom) {
        oy = bottomChildOY;
      }
    }
    if (this._childOY !== oy) {
      this._childOY = oy;
      this.resetChildPosition();
    }
    if (childOYExceedTop) {
      if (!this.execeedTopState) {
        this.emit("execeedtop", this, oy, topChildOY);
      }
    }
    this.execeedTopState = childOYExceedTop;
    if (childOYExeceedBottom) {
      if (!this.execeedBottomState) {
        this.emit("execeedbottom", this, oy, bottomChildOY);
      }
    }
    this.execeedBottomState = childOYExeceedBottom;
  }
  get childOX() {
    return this._childOX;
  }
  set childOX(ox) {
    var leftChildOX = this.leftChildOX;
    var rightChildOX = this.rightChildOX;
    var childOXExceedLeft = this.childOXExceedLeft(ox);
    var childOXExeceedRight = this.childOXExeceedRight(ox);
    if (this.clampChildOX) {
      if (this.childVisibleWidth > this.childWidth) {
        ox = 0;
      } else if (childOXExceedLeft) {
        ox = leftChildOX;
      } else if (childOXExeceedRight) {
        ox = rightChildOX;
      }
    }
    if (this._childOX !== ox) {
      this._childOX = ox;
      this.resetChildPosition();
    }
    if (childOXExceedLeft) {
      if (!this.execeedLeftState) {
        this.emit("execeedleft", this, ox, leftChildOX);
      }
    }
    this.execeedLeftState = childOXExceedLeft;
    if (childOXExeceedRight) {
      if (!this.execeedRightState) {
        this.emit("execeedright", this, ox, rightChildOX);
      }
    }
    this.execeedRightState = childOXExeceedRight;
  }
  setChildOY(oy) {
    this.childOY = oy;
    return this;
  }
  setChildOX(ox) {
    this.childOX = ox;
    return this;
  }
  set t(value) {
    this.childOY = -this.visibleHeight * value;
  }
  get t() {
    var visibleHeight = this.visibleHeight;
    if (visibleHeight === 0) {
      return 0;
    }
    return this.childOY / -visibleHeight;
  }
  set s(value) {
    this.childOX = -this.visibleWidth * value;
  }
  get s() {
    var visibleWidth = this.visibleWidth;
    if (visibleWidth === 0) {
      return 0;
    }
    return this.childOX / -visibleWidth;
  }
  setChildOYByPercentage(percentage) {
    this.t = percentage;
    return this;
  }
  setChildOXByPercentage(percentage) {
    this.s = percentage;
    return this;
  }
};
Object.assign(
  ScrollableBlock.prototype,
  Methods_default36
);
var ScrollableBlock_default = ScrollableBlock;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/methods/ScrollToChild.js
var ScrollToChild = function(child, align, duration, ease) {
  if (!this.hasChild(child)) {
    return this;
  }
  var newChildOY, newChildOX;
  switch (this.scrollMode) {
    case 0:
      newChildOY = this.childOY + AlignChild.call(this, child, "y", align);
      break;
    case 1:
      newChildOY = this.childOY + AlignChild.call(this, child, "x", align);
      break;
    default:
      newChildOY = this.childOY + AlignChild.call(this, child, "y", align);
      newChildOX = this.childOX + AlignChild.call(this, child, "x", align);
      break;
  }
  if (duration === void 0 || duration <= 0) {
    this.childOY = newChildOY;
    if (this.scrollMode === 2) {
      this.childOX = newChildOX;
    }
  } else {
    if (this._easeScrollChildOY === void 0) {
      this._easeScrollChildOY = new EaseValueTask_default(this);
    }
    this._easeScrollChildOY.restart({
      key: "childOY",
      to: newChildOY,
      duration,
      ease
    });
    if (this.scrollMode === 2) {
      if (this._easeScrollChildOX === void 0) {
        this._easeScrollChildOX = new EaseValueTask_default(this);
      }
      this._easeScrollChildOX.restart({
        key: "childOX",
        to: newChildOX,
        duration,
        ease
      });
    }
  }
  return this;
};
var AlignYModes = ["top", "bottom", "centerY", "center"];
var AlignXModes = ["left", "right", "centerX", "center"];
var AlignChild = function(child, axis, align) {
  axis = axis.toUpperCase();
  var isAxisY = axis === "Y";
  var scrollableBlock = this.childrenMap.child;
  var delta;
  if (isAxisY) {
    if (align) {
      for (var i = 0, cnt = AlignYModes.length; i < cnt; i++) {
        var modeName = AlignYModes[i];
        if (align.indexOf(modeName) !== -1) {
          align = modeName;
          break;
        }
      }
    }
    switch (align) {
      case "top":
        delta = scrollableBlock.top - GetTopLeft(child).y;
        break;
      case "bottom":
        delta = scrollableBlock.bottom - GetBottomLeft(child).y;
        break;
      case "centerY":
      case "center":
        delta = scrollableBlock.centerY - GetCenter(child).y;
        break;
      default:
        var dTop = scrollableBlock.top - GetTopLeft(child).y;
        var dBottom = scrollableBlock.bottom - GetBottomLeft(child).y;
        if (dTop <= 0 && dBottom >= 0) {
          delta = 0;
        } else {
          delta = Math.abs(dTop) <= Math.abs(dBottom) ? dTop : dBottom;
        }
        break;
    }
  } else {
    if (align) {
      for (var i = 0, cnt = AlignXModes.length; i < cnt; i++) {
        var modeName = AlignXModes[i];
        if (align.indexOf(modeName) !== -1) {
          align = modeName;
          break;
        }
      }
    }
    switch (align) {
      case "left":
        delta = scrollableBlock.left - GetTopLeft(child).x;
        break;
      case "right":
        delta = scrollableBlock.right - GetTopRight(child).x;
        break;
      case "centerX":
      case "center":
        delta = scrollableBlock.centerX - GetCenter(child).x;
        break;
      default:
        var dLeft = scrollableBlock.left - GetTopLeft(child).x;
        var dRight = scrollableBlock.right - GetTopRight(child).x;
        if (dLeft <= 0 && dRight >= 0) {
          delta = 0;
        } else {
          delta = Math.abs(dLeft) <= Math.abs(dRight) ? dLeft : dRight;
        }
        break;
    }
  }
  return delta;
};
var ScrollToChild_default = ScrollToChild;

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/ScrollablePanel.js
var GetValue184 = Phaser.Utils.Objects.GetValue;
var ScrollablePanel = class extends Scrollable_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var scrollMode = GetScrollMode_default(config);
    var panelConfig = GetValue184(config, "panel", void 0);
    if (panelConfig === void 0) {
      panelConfig = {};
    }
    panelConfig.scrollMode = scrollMode;
    panelConfig.clampChildOY = GetValue184(config, "clampChildOY", false);
    panelConfig.clampChildOX = GetValue184(config, "clampChildOX", false);
    var scrollableBlock = new ScrollableBlock_default(scene, panelConfig);
    scene.add.existing(scrollableBlock);
    var expandPanelWidth, expandPanelHeight;
    switch (scrollMode) {
      case 0:
        expandPanelWidth = GetValue184(config, "expand.panel", true);
        expandPanelHeight = true;
        break;
      case 1:
        expandPanelWidth = true;
        expandPanelHeight = GetValue184(config, "expand.panel", true);
        break;
      default:
        expandPanelWidth = true;
        expandPanelHeight = true;
    }
    config.type = "rexScrollablePanel";
    config.child = {
      gameObject: scrollableBlock,
      expandWidth: expandPanelWidth,
      expandHeight: expandPanelHeight,
      align: GetValue184(config, "align.panel", "center")
    };
    var spaceConfig = GetValue184(config, "space", void 0);
    if (spaceConfig) {
      spaceConfig.child = GetValue184(spaceConfig, "panel", 0);
    }
    super(scene, config);
    this.addChildrenMap("panel", scrollableBlock.child);
    this.addChildrenMap("panelLayer", scrollableBlock.maskLayer);
    this.addChildrenMap("mask", scrollableBlock.maskGameObject);
    this.addChildrenMap("scrollableBlock", scrollableBlock);
  }
  setChildrenInteractive(config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("eventEmitter")) {
      config.eventEmitter = this;
    }
    if (!config.hasOwnProperty("targets")) {
      config.targets = [this.childrenMap.panel];
    }
    SetChildrenInteractive_default2(this.childrenMap.child, config);
    return this;
  }
};
var methods36 = {
  scrollToChild: ScrollToChild_default
};
Object.assign(
  ScrollablePanel.prototype,
  methods36
);
var ScrollablePanel_default = ScrollablePanel;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/listpanel/CreateListPanel.js
var GetValue185 = Phaser.Utils.Objects.GetValue;
var CreateListPanel = function() {
  var scene = this.scene;
  var background;
  var createBackgroundCallback = this.listCreateBackgroundCallback;
  if (createBackgroundCallback) {
    background = createBackgroundCallback.call(this, scene);
    scene.add.existing(background);
  }
  var buttons = [];
  var createButtonCallback = this.listCreateButtonCallback;
  if (createButtonCallback) {
    var options = this.options;
    for (var i = 0, cnt = options.length; i < cnt; i++) {
      var button = createButtonCallback.call(this, scene, options[i], i, options);
      if (!button) {
        continue;
      }
      scene.add.existing(button);
      buttons.push(button);
    }
  }
  var width = this.listWidth;
  if (width === void 0) {
    if (this.listAlignMode === "text") {
      width = this.getElement("text").width;
    } else {
      width = this.width;
    }
  }
  var height = this.listHeight;
  var buttonConfig = {
    width,
    buttons,
    space: this.listSpace
  };
  var buttons, listPanel;
  var isScrollable;
  if (this.listCreateSliderThumbCallback) {
    isScrollable = height > 0 || this.listMaxHeight > 0;
  } else {
    isScrollable = false;
  }
  if (!isScrollable) {
    buttonConfig.height = height;
    buttons = CreateButtons2(scene, buttonConfig, this.listWrapEnable);
    listPanel = buttons;
  } else {
    var buttons = CreateButtons2(scene, buttonConfig, this.listWrapEnable);
    if (this.listMaxHeight > 0) {
      buttons.layout();
      if (buttons.height <= this.listMaxHeight) {
        listPanel = buttons;
      }
    }
    if (!listPanel) {
      if (height === 0) {
        height = this.listMaxHeight;
      }
      var track = CreateGameObject(scene, this.listCreateSliderTrackCallback);
      var thumb = CreateGameObject(scene, this.listCreateSliderThumbCallback);
      listPanel = new ScrollablePanel_default(scene, {
        height,
        scrollMode: 0,
        panel: {
          child: buttons,
          mask: {
            padding: 1
          }
        },
        slider: {
          track,
          thumb,
          adaptThumbSize: this.listSliderAdaptThumbSizeEnable
        },
        scrollDetectionMode: 1,
        scroller: this.listScrollerConfig,
        mouseWheelScroller: this.listMouseWheelScrollerConfig,
        space: {
          panel: GetValue185(this.listSpace, "panel", 0)
        }
      });
      scene.add.existing(listPanel);
    }
  }
  if (background) {
    listPanel.addBackground(background, "background");
  }
  if (this.listDraggable) {
    listPanel.setDraggable(true);
  }
  if (listPanel !== buttons) {
    buttons.on("button.over", function(button2, index, pointer, event) {
      listPanel.emit("button.over", button2, index, pointer, event);
    }).on("button.out", function(button2, index, pointer, event) {
      listPanel.emit("button.out", button2, index, pointer, event);
    }).on("button.click", function(button2, index, pointer, event) {
      listPanel.emit("button.click", button2, index, pointer, event);
    });
  }
  return listPanel;
};
var CreateButtons2 = function(scene, config, isWrapEnable) {
  var gameObject2;
  if (!isWrapEnable) {
    config.orientation = "y";
    gameObject2 = new Buttons_default(scene, config);
  } else {
    config.orientation = "x";
    gameObject2 = new FixWidthButtons_default(scene, config);
  }
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateGameObject = function(scene, callback, scope) {
  var gameObject2;
  if (callback) {
    gameObject2 = callback.call(scope, scene);
    scene.add.existing(gameObject2);
  }
  return gameObject2;
};
var CreateListPanel_default = CreateListPanel;

// node_modules/phaser3-rex-plugins/plugins/behaviors/scale/ScaleDown.js
var ScaleDown2 = function(gameObject2, duration, orientation, ease, scale) {
  if (ease === void 0) {
    ease = "Linear";
  }
  var config = {};
  config.mode = 0;
  switch (orientation) {
    case 0:
    case "x":
      config.end = {
        x: 0
      };
      break;
    case 1:
    case "y":
      config.end = {
        y: 0
      };
      break;
    default:
      config.end = 0;
      break;
  }
  config.duration = duration;
  config.ease = ease;
  if (scale === void 0) {
    scale = new Scale_default3(gameObject2, config);
  } else {
    scale.resetFromJSON(config);
  }
  scale.restart();
  return scale;
};
var ScaleDown_default = ScaleDown2;

// node_modules/phaser3-rex-plugins/plugins/utils/object/GetValueFromAliasKeys.js
var GetValueFromAliasKeys = function(source, key0, key1, key2, defaultValue) {
  if (HasValue_default(source, key0)) {
    return GetValue_default(source, key0);
  } else if (key1 && HasValue_default(source, key1)) {
    return GetValue_default(source, key1);
  } else if (key2 && HasValue_default(source, key2)) {
    return GetValue_default(source, key2);
  } else {
    return defaultValue;
  }
};
var GetValueFromAliasKeys_default = GetValueFromAliasKeys;

// node_modules/phaser3-rex-plugins/plugins/behaviors/dropdown/SetPosition.js
var GetValue186 = Phaser.Utils.Objects.GetValue;
var SetPosition2 = function(gameObject2, config) {
  var expandDirection = GetValue186(config, "expandDirection", void 0);
  if (typeof expandDirection === "string") {
    expandDirection = ExpandDirections[expandDirection];
  }
  var alignTargetX = GetValueFromAliasKeys_default(config, "alignTarget", "alignTargetX");
  var alignTargetY = GetValue186(config, "alignTargetY", alignTargetX);
  var alignOffsetX = GetValue186(config, "alignOffsetX", 0);
  var alignOffsetY = GetValue186(config, "alignOffsetY", 0);
  var alignSide = GetValue186(config, "alignSide", "");
  var alignRight = alignSide.includes("right");
  var positionBounds = GetValue186(config, "bounds");
  var isExpandDown = expandDirection === 0;
  var isExpandUp = expandDirection === 1;
  var flexExpand = !isExpandDown && !isExpandUp;
  var originX = alignRight ? 1 : 0;
  var originY = isExpandDown || flexExpand ? 0 : 1;
  gameObject2.setOrigin(originX, originY);
  var x, y;
  if (alignRight) {
    x = alignTargetX.getTopRight().x;
  } else {
    x = alignTargetX.getTopLeft().x;
  }
  y = alignTargetY.getBottomLeft().y;
  gameObject2.setPosition(
    x + alignOffsetX,
    y + alignOffsetY
  );
  var bounds = positionBounds;
  if (!bounds) {
    bounds = GetViewport_default(gameObject2.scene);
  }
  if (flexExpand && gameObject2.getBottomLeft().y > bounds.bottom) {
    y = alignTargetY.getTopLeft().y;
    gameObject2.setOrigin(0, 1).setPosition(
      x + alignOffsetX,
      y + alignOffsetY
    );
  }
};
var ExpandDirections = {
  down: 0,
  up: 1
};
var SetPosition_default2 = SetPosition2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/dropdown/DropDown.js
var GetValue187 = Phaser.Utils.Objects.GetValue;
var DropDown = class extends OpenCloseTransition_default {
  constructor(gameObject2, config) {
    if (config === void 0) {
      config = {};
    }
    if (config.transitIn == null) {
      config.transitIn = function(gameObject3, duration) {
        popup_default(gameObject3, duration, "y", "Cubic");
      };
    }
    if (config.transitOut == null) {
      config.transitOut = function(gameObject3, duration) {
        ScaleDown_default(gameObject3, duration, "y", "Linear");
      };
    }
    config.manualClose = true;
    config.clickOutsideClose = true;
    config.destroy = true;
    super(gameObject2, config);
    SetPosition_default2(gameObject2, config);
    if (gameObject2.isRexSizer) {
      gameObject2.layout();
    }
    var touchOutsideClose = GetValue187(config, "touchOutsideClose", false);
    var anyTouchClose = GetValue187(config, "anyTouchClose", false);
    if (anyTouchClose) {
      touchOutsideClose = false;
    }
    if (anyTouchClose) {
      this.once("open", this.anyTouchClose, this);
    } else if (touchOutsideClose) {
      this.once("open", this.touchOutsideClose, this);
    }
    this.requestOpen();
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.scene.input.off("pointerup", this.touchCloseCallback, this);
    super.shutdown(fromScene);
  }
  touchOutsideClose() {
    this.scene.input.on("pointerup", this.touchCloseCallback, this);
    this.clickOutsideTest = true;
    return this;
  }
  anyTouchClose() {
    this.scene.input.once("pointerup", this.touchCloseCallback, this);
    return this;
  }
  touchCloseCallback(pointer) {
    if (this.clickOutsideTest && IsPointInBounds_default(this.parent, pointer.worldX, pointer.worldY)) {
      return;
    }
    this.requestClose();
  }
  onOpen() {
    this.emit("open", this.parent, this);
    super.onOpen();
  }
  onClose() {
    this.emit("close", this.parent, this);
    super.onClose();
  }
};
var DropDown_default = DropDown;

// node_modules/phaser3-rex-plugins/plugins/dropdown.js
var dropdown_default = DropDown_default;

// node_modules/phaser3-rex-plugins/templates/ui/dropdown/DropDown.js
var DropDown_default2 = dropdown_default;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/listpanel/OpenListPanel.js
var OpenListPanel = function() {
  if (this.listPanel) {
    return this;
  }
  if (this.options.length === 0) {
    return this;
  }
  var listPanel = CreateListPanel_default.call(this);
  listPanel.on("button.over", function(button, index, pointer, event) {
    this.currentOverIndex = index;
    if (this.listOnButtonOver) {
      this.listOnButtonOver.call(this, button, index, pointer, event);
    }
    this.emit("button.over", this, listPanel, button, index, pointer, event);
  }, this).on("button.out", function(button, index, pointer, event) {
    if (this.currentOverIndex === index) {
      this.currentOverIndex = void 0;
    }
    if (this.listOnButtonOut) {
      this.listOnButtonOut.call(this, button, index, pointer, event);
    }
    this.emit("button.out", this, listPanel, button, index, pointer, event);
  }, this);
  var alignTargetX;
  if (!this.listAlignMode || this.listAlignMode === "label") {
    alignTargetX = this;
  } else {
    alignTargetX = this.getElement(this.listAlignMode);
  }
  var dropDownBehavior = new DropDown_default2(listPanel, {
    // Transition
    duration: {
      in: this.listEaseInDuration,
      out: this.listEaseOutDuration
    },
    transitIn: this.listTransitInCallback,
    transitOut: this.listTransitOutCallback,
    // Position
    expandDirection: this.listExpandDirection,
    alignTargetX,
    alignTargetY: this,
    alignSide: this.listAlignSide,
    bounds: this.listBounds
    // Close condition        
  }).on("open", function() {
    listPanel.on("button.click", function(button, index, pointer, event) {
      if (this.listOnButtonClick) {
        this.listOnButtonClick.call(this, button, index, pointer, event);
      }
      this.emit("button.click", this, listPanel, button, index, pointer, event);
      this.dropDownBehavior.requestClose();
    }, this);
    this.emit("list.open", this, listPanel);
  }, this).on("close", function() {
    this.listPanel = void 0;
    this.dropDownBehavior = void 0;
    this.emit("list.close", this);
  }, this);
  listPanel.onClickOutside(function() {
    dropDownBehavior.requestClose();
  });
  this.listPanel = listPanel;
  this.dropDownBehavior = dropDownBehavior;
  this.pin(listPanel);
  return this;
};
var OpenListPanel_default = OpenListPanel;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/listpanel/CloseListPanel.js
var CloseListPanel = function() {
  if (!this.dropDownBehavior) {
    return this;
  }
  this.dropDownBehavior.requestClose();
  this.currentOverIndex = void 0;
  return this;
};
var CloseListPanel_default = CloseListPanel;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/listpanel/ToggleListPanel.js
var ToggleListPanel = function() {
  if (!this.listPanel) {
    this.openListPanel();
  } else {
    this.closeListPanel();
  }
  return this;
};
var ToggleListPanel_default = ToggleListPanel;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/EmitButtonClick.js
var EmitListButtonClick = function(index) {
  if (index === void 0) {
    index = this.currentOverIndex;
  }
  if (index === void 0) {
    return this;
  }
  var listPanel = this.listPanel;
  var button = listPanel ? listPanel.getButton(index) : this.options[index];
  if (this.listOnButtonClick) {
    this.listOnButtonClick.call(this, button, index);
  }
  this.emit("button.click", this, listPanel, button, index);
  return this;
};
var EmitButtonClick_default = EmitListButtonClick;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/EmitButtonOver.js
var EmitButtonOver = function(index) {
  var listPanel = this.listPanel;
  if (!listPanel) {
    return this;
  }
  listPanel.emitButtonOver(index);
  return this;
};
var EmitButtonOver_default = EmitButtonOver;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/FocusButtonMethods.js
var FocusButtonMethods_default = {
  focusNextButton() {
    if (!this.isOpened) {
      return this;
    }
    var currentIndex = this.currentOverIndex;
    var nextIndex;
    if (currentIndex === void 0) {
      nextIndex = 0;
    } else {
      var total = this.listPanel.getButtons().length;
      nextIndex = (currentIndex + 1) % total;
    }
    this.emitButtonOver(nextIndex);
    return this;
  },
  focusPrevButton() {
    if (!this.isOpened) {
      return this;
    }
    var currentIndex = this.currentOverIndex;
    var nextIndex;
    if (currentIndex === void 0) {
      nextIndex = 0;
    } else {
      var total = this.listPanel.getButtons().length;
      nextIndex = (currentIndex - 1 + total) % total;
    }
    this.emitButtonOver(nextIndex);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/methods/Methods.js
var Methods18 = {
  openListPanel: OpenListPanel_default,
  closeListPanel: CloseListPanel_default,
  toggleListPanel: ToggleListPanel_default,
  emitButtonClick: EmitButtonClick_default,
  emitButtonOver: EmitButtonOver_default
};
Object.assign(
  Methods18,
  ConfigurationMethods_default2,
  FocusButtonMethods_default
);
var Methods_default37 = Methods18;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/DropDownList.js
var GetValue188 = Phaser.Utils.Objects.GetValue;
var DropDownList = class extends Label_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexDropDownList";
    this.timer = void 0;
    this.listPanel = void 0;
    this.currentOverIndex = void 0;
    this.setOptions(GetValue188(config, "options"));
    var listConfig = GetValue188(config, "list");
    this.setWrapEnable(GetValue188(listConfig, "wrap", false));
    this.setCreateButtonCallback(GetValue188(listConfig, "createButtonCallback"));
    this.setCreateListBackgroundCallback(GetValue188(listConfig, "createBackgroundCallback"));
    this.setCreateListSliderTrackCallback(GetValue188(listConfig, "createTrackCallback"));
    this.setCreateListSliderThumbCallback(GetValue188(listConfig, "createThumbCallback"));
    this.setListSliderAdaptThumbSizeEnable(GetValue188(listConfig, "sliderAdaptThumbSize", false));
    this.setListScrollerConfig(GetValue188(listConfig, "scroller"));
    this.setListMouseWheelScrollerConfig(GetValue188(listConfig, "mouseWheelScroller"));
    this.setButtonClickCallback(GetValue188(listConfig, "onButtonClick"));
    this.setButtonOverCallback(GetValue188(listConfig, "onButtonOver"));
    this.setButtonOutCallback(GetValue188(listConfig, "onButtonOut"));
    this.setListExpandDirection(GetValue188(listConfig, "expandDirection"));
    this.setListEaseInDuration(GetValue188(listConfig, "easeIn", 500));
    this.setListEaseOutDuration(GetValue188(listConfig, "easeOut", 100));
    this.setListTransitInCallback(GetValue188(listConfig, "transitIn"));
    this.settListTransitOutCallback(GetValue188(listConfig, "transitOut"));
    this.setListMaxHeight(GetValue188(listConfig, "maxHeight", 0));
    this.setListSize(GetValue188(listConfig, "width"), GetValue188(listConfig, "height", 0));
    this.setListAlignmentMode(GetValue188(listConfig, "alignParent", "text"));
    this.setListAlignmentSide(GetValue188(listConfig, "alignSide", ""));
    this.setListBounds(GetValue188(listConfig, "bounds"));
    this.setListSpace(GetValue188(listConfig, "space"));
    this.setListDraggable(GetValue188(listConfig, "draggable", false));
    this.setValueChangeCallback(
      GetValue188(config, "setValueCallback"),
      GetValue188(config, "setValueCallbackScope")
    );
    this.setValue(GetValue188(config, "value"));
    this.onClick(this.toggleListPanel, this);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    if (this.listPanel) {
      this.listPanel.destroy(fromScene);
      this.listPanel = void 0;
    }
    super.destroy(fromScene);
  }
  get isOpened() {
    return !!this.listPanel;
  }
  setOptions(options) {
    if (options === void 0) {
      options = [];
    }
    this.options = options;
    return this;
  }
  setValueChangeCallback(callback, scope) {
    this.valueChangeCallback = callback;
    this.valueChangeCallbackScope = scope;
    return this;
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value === value) {
      return;
    }
    var previousValue = this._value;
    this._value = value;
    var callback = this.valueChangeCallback, scope = this.valueChangeCallbackScope;
    if (callback) {
      if (scope) {
        callback.call(scope, this, value, previousValue);
      } else {
        callback(this, value, previousValue);
      }
    }
    this.emit("valuechange", this, value, previousValue);
  }
};
Object.assign(
  DropDownList.prototype,
  Methods_default37
);
var DropDownList_default = DropDownList;

// node_modules/phaser3-rex-plugins/templates/ui/dropdownlist/Factory.js
ObjectFactory_default.register("dropDownList", function(config) {
  var gameObject2 = new DropDownList_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.DropDownList", DropDownList_default);

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/BuildListConfig.js
var BuildListConfig = function(scene, config, creators) {
  config = config ? DeepClone_default(config) : {};
  if (creators === void 0) {
    creators = {};
  }
  var labelConfig = config.label || config.button;
  var listButtonConfig = config.button || config.label;
  delete config.label;
  delete config.button;
  var labelCreator = creators.label || creators.button || creators;
  var listButtonCreator = creators.button || creators.label || creators;
  var listConfig = BuildLabelConfig_default(scene, labelConfig, labelCreator);
  listConfig.list = config.list || {};
  listConfig.list.createButtonCallback = function(scene2, option) {
    var gameObject2 = CreateLabel_default(scene2, listButtonConfig, listButtonCreator).resetDisplayContent(option);
    if (option.hasOwnProperty("value")) {
      gameObject2.value = option.value;
    }
    return gameObject2;
  };
  var trackConfig = config.track;
  if (trackConfig) {
    listConfig.list.createTrackCallback = function(scene2) {
      return CreateBackground_default(scene2, trackConfig);
    };
    delete config.track;
  }
  var thumbConfig = config.thumb;
  if (thumbConfig) {
    listConfig.list.createThumbCallback = function(scene2) {
      return CreateBackground_default(scene2, thumbConfig);
    };
    delete config.thumb;
  }
  listConfig.list.onButtonOver = function(button, index, pointer, event) {
    if (button.setHoverState) {
      button.setHoverState(true);
    }
  };
  listConfig.list.onButtonOut = function(button, index, pointer, event) {
    if (button.setHoverState) {
      button.setHoverState(false);
    }
  };
  return listConfig;
};
var BuildListConfig_default = BuildListConfig;

// node_modules/phaser3-rex-plugins/templates/ui/simpledropdownlist/SimpleDropDownList.js
var SimpleDropDownList = class extends DropDownList_default {
  constructor(scene, config, creators) {
    config = BuildListConfig_default(scene, config, creators);
    super(scene, config);
    this.type = "rexSimpleDropDownList";
  }
  setOptions(options) {
    if (options === void 0) {
      options = [];
    }
    for (var i = 0, cnt = options.length; i < cnt; i++) {
      var option = options[i];
      if (typeof option === "string") {
        options[i] = { text: option, value: option };
      }
    }
    super.setOptions(options);
    return this;
  }
};
var SimpleDropDownList_default = SimpleDropDownList;

// node_modules/phaser3-rex-plugins/templates/ui/simpledropdownlist/Factory.js
ObjectFactory_default.register("simpleDropDownList", function(config, creators) {
  var gameObject2 = new SimpleDropDownList_default(this.scene, config, creators);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.SimpleDropDownList", SimpleDropDownList_default);

// node_modules/phaser3-rex-plugins/plugins/utils/text/TextHeightToLineCount.js
var TextHeightToLinesCount2 = function(textObject) {
  var textObjectType = GetTextObjectType_default(textObject);
  var height, lineSpacing, lineHeight;
  switch (textObjectType) {
    case TextType:
    case TagTextType:
      height = textObject.height - textObject.padding.top - textObject.padding.bottom;
      lineSpacing = textObject.lineSpacing;
      lineHeight = textObject.style.metrics.fontSize + textObject.style.strokeThickness;
      break;
    case BitmapTextType:
      height = textObject.height;
      lineSpacing = 0;
      var scale = textObject.fontSize / textObject.fontData.size;
      lineHeight = textObject.fontData.lineHeight * scale;
      break;
  }
  return (height - lineSpacing) / (lineHeight + lineSpacing);
};
var TextHeightToLineCount_default = TextHeightToLinesCount2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textpage/methods/GetLines.js
var GetLines2 = function(startLineIndex, endLineIdx) {
  if (startLineIndex === void 0) {
    startLineIndex = this.startLineIndex;
  }
  if (endLineIdx === void 0) {
    var pageLinesCount = this.pageLinesCount;
    if (pageLinesCount > 0) {
      endLineIdx = startLineIndex + pageLinesCount;
    } else {
      endLineIdx = this.totalLinesCount;
    }
  }
  if (endLineIdx > this.totalLinesCount) {
    endLineIdx = this.totalLinesCount;
  }
  var text;
  switch (this.textObjectType) {
    case TextType:
    case BitmapTextType:
      text = this.lines.slice(startLineIndex, endLineIdx).join("\n");
      break;
    case TagTextType:
      var startIdx = this.lines.getLineStartIndex(startLineIndex);
      var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
      text = this.lines.getSliceTagText(startIdx, endIdx, true);
      var newLineCharCount = (text.match(/\n/g) || []).length;
      if (newLineCharCount > endLineIdx - startLineIndex - 1) {
        text = text.substring(0, text.length - 1);
      }
      break;
  }
  return text;
};
var GetLines_default2 = GetLines2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textpage/methods/SetContentMethods.js
var SetContentMethods_default = {
  clearText() {
    this.sections.length = 0;
    this.pageStartIndexes.length = 0;
    this.lines.length = 0;
    return this;
  },
  appendPage(text) {
    var pageStartIndex = this.totalLinesCount;
    this.sections.push(GetString_default(text));
    var text = this.sections.join("\n");
    this.lines = TextToLines_default(this.parent, text, this.lines);
    var newLinesCount = this.totalLinesCount - pageStartIndex;
    var pageLinesCount = this.pageLinesCount;
    var pageCount;
    if (pageLinesCount > 0) {
      pageCount = Math.ceil(newLinesCount / this.pageLinesCount);
    } else {
      pageCount = 1;
    }
    for (var i = 0; i < pageCount; i++) {
      this.pageStartIndexes.push(
        pageStartIndex + i * this.pageLinesCount
      );
    }
    return this;
  },
  setText(text, resetIndex) {
    if (resetIndex === void 0) {
      resetIndex = true;
    }
    if (resetIndex) {
      this.resetIndex();
    }
    this.clearText();
    var sections = GetString_default(text).split(this.pageBreak);
    for (var i = 0, cnt = sections.length; i < cnt; i++) {
      this.appendPage(sections[i]);
    }
    return this;
  },
  appendText(text) {
    var content = this.content + GetString_default(text);
    this.setText(content, false);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/textpage/methods/GetPageMethods.js
var Clamp15 = Phaser.Math.Clamp;
var GetPageMethods_default = {
  resetIndex() {
    this.pageIndex = -1;
    this.startLineIndex = -1;
    this.endLineIndex = void 0;
    return this;
  },
  setPageIndex(idx) {
    idx = Clamp15(idx, 0, this.lastPageIndex);
    this.pageIndex = idx;
    this.startLineIndex = this.pageStartIndexes[idx];
    this.endLineIndex = this.pageStartIndexes[idx + 1];
    return this;
  },
  getPage(idx) {
    if (idx === void 0) {
      idx = this.pageIndex;
    }
    return this.setPageIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
  },
  getNextPage() {
    return this.getPage(this.pageIndex + 1);
  },
  getPreviousPage() {
    return this.getPage(this.pageIndex - 1);
  },
  getFirstPage() {
    return this.getPage(0);
  },
  getLastPage() {
    return this.getPage(this.lastPageIndex);
  },
  setStartLineIndex(idx) {
    var lastStartLineIndex = Math.max(this.totalLinesCount - this.pageLinesCount, 0);
    idx = Clamp15(idx, 0, lastStartLineIndex);
    this.startLineIndex = idx;
    this.endLineIndex = idx + this.pageLinesCount;
    return this;
  },
  getPageByLineIndex(idx) {
    return this.setStartLineIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
  },
  getPageOfNextLine() {
    return this.getPageByLineIndex(this.startLineIndex + 1);
  },
  getPageOfPreviousLine() {
    return this.getPageByLineIndex(this.startLineIndex - 1);
  },
  getPageOfFirstLine() {
    return this.getPageByLineIndex(0);
  },
  getPageOfLastLine() {
    return this.getPageByLineIndex(this.totalLinesCount);
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/textpage/methods/ShowMethods.js
var ShowMethods_default = {
  showPage(idx) {
    this.displayText(
      this.getPage(idx)
    );
    return this;
  },
  showNextPage() {
    this.displayText(
      this.getNextPage()
    );
    return this;
  },
  showPreviousPage() {
    this.displayText(
      this.getPreviousPage()
    );
    return this;
  },
  showFirstPage() {
    this.displayText(
      this.getFirstPage()
    );
    return this;
  },
  showLastPage() {
    this.displayText(
      this.getLastPage()
    );
    return this;
  },
  show() {
    this.displayText(
      this.getLines()
    );
    return this;
  },
  showPageByLineIndex(lineIndex) {
    this.displayText(
      this.getPageByLineIndex(lineIndex)
    );
    return this;
  },
  showNextLine() {
    this.displayText(
      this.getPageOfNextLine()
    );
    return this;
  },
  showPreviousLine() {
    this.displayText(
      this.getPageOfPreviousLine()
    );
    return this;
  },
  showFirstLine() {
    this.displayText(
      this.getPageOfFirstLine()
    );
    return this;
  },
  showLastLine() {
    this.displayText(
      this.getPageOfLastLine()
    );
    return this;
  },
  displayText(text) {
    SetNoWrapText_default(this.parent, text);
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/textpage/methods/Methods.js
var Methods19 = {
  getLines: GetLines_default2
};
Object.assign(
  Methods19,
  SetContentMethods_default,
  GetPageMethods_default,
  ShowMethods_default
);
var Methods_default38 = Methods19;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textpage/TextPage.js
var GetValue189 = Phaser.Utils.Objects.GetValue;
var Clamp16 = Phaser.Math.Clamp;
var TextPage = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, { eventEmitter: false });
    this.textObjectType = GetTextObjectType_default(this.parent);
    this.pageStartIndexes = [];
    this.lines = TextToLines_default(this.parent, "");
    this.sections = [];
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.setMaxLines(GetValue189(o, "maxLines", void 0));
    this.setPageBreak(GetValue189(o, "pageBreak", "\f\n"));
    this.setText(GetValue189(o, "text", ""));
    this.startLineIndex = GetValue189(o, "start", -1);
    this.endLineIndex = GetValue189(o, "end", void 0);
    var pageIndex = GetValue189(o, "page");
    if (pageIndex === void 0) {
      this.resetIndex();
    } else {
      this.setPageIndex(pageIndex);
    }
    return this;
  }
  toJSON() {
    return {
      maxLines: this.maxLines,
      text: this.content,
      start: this.startLineIndex,
      end: this.endLineIndex,
      page: this.pageIndex,
      pageBreak: this.pageBreak
    };
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    switch (this.textObjectType) {
      case TextType:
        this.lines.length = 0;
        break;
      case TagTextType:
        this.lines.destroy();
        break;
      case BitmapTextType:
        this.lines.length = 0;
        break;
    }
    this.pageStartIndexes.length = 0;
    this.sections.length = 0;
    this.lines = void 0;
    this.pageStartIndexes = void 0;
    this.sections = void 0;
    super.shutdown(fromScene);
  }
  setMaxLines(maxLines) {
    this.maxLines = maxLines;
    return this;
  }
  setPageBreak(pageBreak) {
    this.pageBreak = pageBreak;
    return this;
  }
  get pageCount() {
    return this.pageStartIndexes.length;
  }
  get lastPageIndex() {
    return this.pageCount - 1;
  }
  get isFirstPage() {
    return this.pageIndex <= 0;
  }
  get isLastPage() {
    return this.pageIndex >= this.pageCount - 1;
  }
  get totalLinesCount() {
    return this.lines ? this.lines.length : 0;
  }
  get pageLinesCount() {
    if (this.maxLines !== void 0) {
      return this.maxLines;
    } else {
      var count;
      switch (this.textObjectType) {
        case TextType:
        case TagTextType:
          var maxLines = this.parent.style.maxLines;
          if (maxLines > 0) {
            count = maxLines;
          } else {
            count = Math.floor(TextHeightToLineCount_default(this.parent));
          }
          break;
        case BitmapTextType:
          count = this.totalLinesCount;
          break;
      }
      return count;
    }
  }
  get isFirstLine() {
    return this.startLineIndex <= 0;
  }
  get isLastLine() {
    return this.endLineIndex === this.totalLinesCount;
  }
  get content() {
    return this.sections.join(this.pageBreak);
  }
};
Object.assign(
  TextPage.prototype,
  Methods_default38
);
var TextPage_default = TextPage;

// node_modules/phaser3-rex-plugins/plugins/textpage.js
var textpage_default = TextPage_default;

// node_modules/phaser3-rex-plugins/templates/ui/textpage/TextPage.js
var TextPage_default2 = textpage_default;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/methods/SetTextMethods.js
var SetTextMethods_default2 = {
  setText(text) {
    if (this.setTextCallback) {
      if (this.setTextCallbackScope) {
        text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIndex);
      } else {
        text = this.setTextCallback(text, this.isLastChar, this.insertIndex);
      }
    }
    if (this.textWrapEnable) {
      SetNoWrapText_default(this.parent, text);
    } else {
      this.parent.setText(text);
    }
  },
  appendText(text) {
    var newText = this.text.concat(GetString_default(text));
    if (this.isTyping) {
      this.setTypingContent(newText);
    } else {
      this.start(newText, void 0, this.textLength);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/methods/StartTyping.js
var StartTyping = function(text, speed, startIndex, timerStartAt) {
  if (text !== void 0) {
    this.setTypingContent(text);
  }
  if (speed !== void 0) {
    this.speed = speed;
  }
  if (startIndex === void 0) {
    startIndex = 0;
  }
  this.typingIndex = startIndex + 1;
  if (this.speed === 0) {
    this.stop(true);
  } else {
    this.setText("");
    this.startTimer(timerStartAt);
  }
  return this;
};
var StartTyping_default = StartTyping;

// node_modules/phaser3-rex-plugins/plugins/utils/text/GetPlainText.js
var GetPlainText = function(textObject, text) {
  if (textObject.getPlainText) {
    text = textObject.getPlainText(text);
  }
  return text;
};
var GetPlainText_default = GetPlainText;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/methods/StartTypingFromLine.js
var StartTypingFromLine = function(text, lineIndex, speed, offsetIndex, timerStartAt) {
  var startIdx;
  if (lineIndex > 0) {
    if (offsetIndex === void 0) {
      offsetIndex = 0;
    }
    var plainText = GetPlainText_default(this.parent, text);
    startIdx = GetNewLineIndex(plainText, lineIndex) + offsetIndex;
  }
  return this.start(text, speed, startIdx, timerStartAt);
};
var GetNewLineIndex = function(s, n) {
  var index = void 0;
  for (var i = 0; i < n; i++) {
    index = s.indexOf("\n", index + 1);
    if (index === -1) {
      break;
    }
  }
  return index;
};
var StartTypingFromLine_default = StartTypingFromLine;

// node_modules/phaser3-rex-plugins/plugins/utils/text/GetSubString.js
var GetSubString = function(textObject, text, startIdx, endIdx) {
  var result;
  if (textObject.getSubString) {
    result = textObject.getSubString(text, startIdx, endIdx);
  } else {
    result = text.slice(startIdx, endIdx);
  }
  return result;
};
var GetSubString_default = GetSubString;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/utils/GetTypingString.js
var GetTypingString = function(text, typeIdx, textLength, typeMode) {
  var textObject = this.parent;
  var result;
  if (typeMode === 0) {
    var startIdx = 0;
    var endIdx = typeIdx;
    this.insertIndex = endIdx;
    result = GetSubString_default(textObject, text, startIdx, endIdx);
  } else if (typeMode === 1) {
    var endIdx = textLength;
    var startIdx = endIdx - typeIdx;
    this.insertIndex = 0;
    result = GetSubString_default(textObject, text, startIdx, endIdx);
  } else if (typeMode === 2) {
    var midIdx = textLength / 2;
    var startIdx = Math.floor(midIdx - typeIdx / 2);
    var endIdx = startIdx + typeIdx;
    this.insertIndex = typeIdx % 2 ? typeIdx : 0;
    result = GetSubString_default(textObject, text, startIdx, endIdx);
  } else if (typeMode === 3) {
    var lowerLen = Math.floor(typeIdx / 2);
    var lowerResult;
    if (lowerLen > 0) {
      var endIdx = textLength;
      var startIdx = endIdx - lowerLen;
      lowerResult = GetSubString_default(textObject, text, startIdx, endIdx);
    } else {
      lowerResult = "";
    }
    var upperLen = typeIdx - lowerLen;
    var upperResult;
    if (upperLen > 0) {
      var startIdx = 0;
      var endIdx = startIdx + upperLen;
      this.insertIndex = endIdx;
      upperResult = GetSubString_default(textObject, text, startIdx, endIdx);
    } else {
      upperResult = "";
      this.insertIndex = 0;
    }
    result = upperResult + lowerResult;
  }
  this.insertChar = result.charAt(this.insertIndex - 1);
  return result;
};
var GetTypingString_default = GetTypingString;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/methods/StopTyping.js
var StopTyping = function(showAllText) {
  var timer = this.getTimer();
  if (timer) {
    this.freeTimer();
  }
  if (showAllText) {
    while (!this.isLastChar) {
      GetTypingString_default.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);
      this.emit("typechar", this.insertChar);
      this.typingIndex++;
    }
    this.setText(this.text);
    this.emit("type");
    this.emit("complete", this, this.parent);
  }
  return this;
};
var StopTyping_default = StopTyping;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/methods/PauseTyping.js
var PauseTyping2 = function() {
  var timer = this.getTimer();
  if (timer) {
    timer.paused = true;
  }
  return this;
};
var PauseTyping_default2 = PauseTyping2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/methods/ResumeTyping.js
var ResumeTyping2 = function() {
  var timer = this.getTimer();
  if (timer) {
    timer.paused = false;
  }
  return this;
};
var ResumeTyping_default2 = ResumeTyping2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/methods/Methods.js
var methods37 = {
  start: StartTyping_default,
  startFromLine: StartTypingFromLine_default,
  stop: StopTyping_default,
  pause: PauseTyping_default2,
  resumeTyping: ResumeTyping_default2
};
Object.assign(
  methods37,
  SetTextMethods_default2
);
var Methods_default39 = methods37;

// node_modules/phaser3-rex-plugins/plugins/utils/text/GetWrapText.js
var GetWrapText = function(textObject, text) {
  var textObjectType = GetTextObjectType_default(textObject);
  switch (textObjectType) {
    case TextType:
      textObject.style.syncFont(textObject.canvas, textObject.context);
      text = textObject.runWordWrap(text);
      break;
    case TagTextType:
      text = textObject.getText(text, void 0, void 0, true);
      break;
    case BitmapTextType:
      text = textObject.setText(text).getTextBounds().wrappedText;
      break;
  }
  return text;
};
var GetWrapText_default = GetWrapText;

// node_modules/phaser3-rex-plugins/plugins/behaviors/texttyping/TextTyping.js
var GetFastValue3 = Phaser.Utils.Objects.GetFastValue;
var GetValue190 = Phaser.Utils.Objects.GetValue;
var TextTyping = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.timer = null;
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.setTextWrapEnable(GetValue190(o, "wrap", false));
    this.setTypeMode(GetValue190(o, "typeMode", 0));
    this.setTypingSpeed(GetValue190(o, "speed", 333));
    this.setTextCallback = GetFastValue3(o, "setTextCallback", null);
    this.setTextCallbackScope = GetFastValue3(o, "setTextCallbackScope", null);
    this.setTypingContent(GetFastValue3(o, "text", ""));
    this.typingIndex = GetFastValue3(o, "typingIndex", 0);
    this.insertIndex = null;
    this.insertChar = null;
    var elapsed = GetFastValue3(o, "elapsed", null);
    if (elapsed !== null) {
      this.start(void 0, void 0, this.typingIndex, elapsed);
    }
    return this;
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.freeTimer();
    super.shutdown(fromScene);
  }
  setTypeMode(m) {
    if (typeof m === "string") {
      m = TYPEMODE[m];
    }
    this.typeMode = m;
    return this;
  }
  setTypeSpeed(speed) {
    this.speed = speed;
    return this;
  }
  setTypingSpeed(speed) {
    this.speed = speed;
    return this;
  }
  setTextWrapEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.textWrapEnable = enable;
    return this;
  }
  set text(value) {
    var text = GetString_default(value);
    if (this.textWrapEnable) {
      text = GetWrapText_default(this.parent, text);
    }
    this._text = text;
  }
  get text() {
    return this._text;
  }
  get isTyping() {
    return this.getTimer() !== null;
  }
  get isLastChar() {
    return this.typingIndex === this.textLength;
  }
  setTypingContent(text) {
    this.text = text;
    this.textLength = GetPlainText_default(this.parent, this.text).length;
    return this;
  }
  onTyping() {
    var newText = GetTypingString_default.call(this, this.text, this.typingIndex, this.textLength, this.typeMode);
    this.setText(newText);
    this.emit("typechar", this.insertChar);
    this.emit("type");
    if (this.isLastChar) {
      this.freeTimer();
      this.scene.sys.events.once("preupdate", function() {
        this.emit("complete", this, this.parent);
      }, this);
    } else {
      this.timer.delay = this.speed;
      this.typingIndex++;
    }
  }
  startTimer(timerStartAt) {
    if (this.timer) {
      this.freeTimer();
    }
    var delay, startAt;
    if (timerStartAt === void 0) {
      delay = 0;
      startAt = 0;
    } else {
      delay = this.speed;
      startAt = timerStartAt;
    }
    this.timer = this.scene.time.addEvent({
      delay: 1e-4,
      startAt,
      loop: true,
      callback: this.onTyping,
      callbackScope: this
    });
    return this;
  }
  getTimer() {
    return this.timer;
  }
  freeTimer() {
    if (this.timer) {
      this.timer.remove();
      this.timer = null;
    }
    return this;
  }
  setText(text) {
    if (this.setTextCallback) {
      if (this.setTextCallbackScope) {
        text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIndex);
      } else {
        text = this.setTextCallback(text, this.isLastChar, this.insertIndex);
      }
    }
    if (this.textWrapEnable) {
      SetNoWrapText_default(this.parent, text);
    } else {
      this.parent.setText(text);
    }
  }
};
var TYPEMODE = {
  "left-to-right": 0,
  "right-to-left": 1,
  "middle-to-sides": 2,
  "sides-to-middle": 3
};
Object.assign(
  TextTyping.prototype,
  Methods_default39
);
var TextTyping_default = TextTyping;

// node_modules/phaser3-rex-plugins/plugins/texttyping.js
var texttyping_default = TextTyping_default;

// node_modules/phaser3-rex-plugins/templates/ui/texttyping/TextTyping.js
var TextTyping_default2 = texttyping_default;

// node_modules/phaser3-rex-plugins/templates/ui/textbox/Base.js
var GetValue191 = Phaser.Utils.Objects.GetValue;
var TextBoxBase = function(GOClass, type) {
  if (type === void 0) {
    type = "rexTextBox";
  }
  class TextBox2 extends GOClass {
    constructor(scene, config) {
      super(scene, config);
      this.type = type;
      this.isRunning = false;
      this._isPageEnd = false;
      var text = this.childrenMap.text;
      var expandTextWidth = GetValue191(config, "expandTextWidth", false);
      var expandTextHeight = GetValue191(config, "expandTextHeight", false);
      if (expandTextWidth || expandTextHeight) {
        var textObjectType = GetTextObjectType_default(text);
        switch (textObjectType) {
          case TextType:
          case TagTextType:
            text.resize = function(width, height) {
              var fixedWidth = expandTextWidth ? width : 0;
              var fixedHeight = expandTextHeight ? height : 0;
              text.setFixedSize(fixedWidth, fixedHeight);
              if (fixedWidth > 0) {
                text.setWordWrapWidth(fixedWidth);
              }
            };
            if (textObjectType === TagTextType) {
              var style = text.style;
              if (style.wrapMode === 0) {
                style.wrapMode = 1;
              }
            }
            break;
        }
        if (expandTextWidth) {
          text._minWidth = 0;
        }
        if (expandTextHeight) {
          text._minHeight = 0;
        }
      }
      this.setTypingMode(GetValue191(config, "typingMode", "page"));
      this.page = new TextPage_default2(text, GetValue191(config, "page", void 0));
      this.typing = new TextTyping_default2(text, GetValue191(config, "typing", config.type));
      this.typing.on("complete", this.onTypingComplete, this).on("type", this.onType, this).on("typechar", this.onTypeChar, this);
      this.textWidthSave = text.width;
      this.textHeightSave = text.height;
    }
    setTypingMode(mode) {
      if (typeof mode === "string") {
        mode = TypingMode[mode];
      }
      this.typingMode = mode;
      return this;
    }
    start(text, speed) {
      if (speed !== void 0) {
        this.setTypingSpeed(speed);
      }
      this.isRunning = true;
      this.page.setText(text);
      this.emit("start");
      if (this.typingMode === 0) {
        this.typeNextPage();
      } else {
        this.typeNextLine();
      }
      return this;
    }
    more(text, speed) {
      if (speed !== void 0) {
        this.setTypingSpeed(speed);
      }
      if (this.isRunning) {
        this.page.appendText(text);
        this.typing.appendText(text);
      } else {
        this.isRunning = true;
        this.page.appendText(text);
        this.emit("start");
        if (this.typingMode === 0) {
          this._isPageEnd = false;
          var txt = this.page.getPage();
          var startIndex = this.typing.textLength;
          this.typing.start(txt, void 0, startIndex);
        } else {
        }
        return this;
      }
    }
    typeNextPage() {
      if (!this.isRunning) {
        return this;
      }
      if (!this.isLastPage) {
        this._isPageEnd = false;
        var txt = this.page.getNextPage();
        this.typing.start(txt);
      } else {
        this.emit("complete");
      }
      return this;
    }
    typeNextLine() {
      if (!this.isRunning) {
        return this;
      }
      if (!this.isLastLine) {
        var txt = this.page.getPageOfNextLine();
        var startLineIndex;
        if (this.isFirstLine) {
          startLineIndex = 0;
        } else {
          startLineIndex = this.page.pageLinesCount - 1;
        }
        this.typing.startFromLine(txt, startLineIndex);
      } else {
        this.isRunning = false;
        this.emit("pageend");
        this.emit("complete");
      }
    }
    pause() {
      if (!this.isRunning) {
        return this;
      }
      if (this.isTyping) {
        this.typing.pause();
        this.emit("pause");
      }
      return this;
    }
    resume() {
      if (!this.isRunning) {
        return this;
      }
      if (!this.isTyping) {
        this.emit("resume");
        this.typing.resume();
      }
      return this;
    }
    stop(showAllText) {
      if (!this.isRunning) {
        return this;
      }
      this.typing.stop(showAllText);
      return this;
    }
    showLastPage() {
      if (!this.isRunning) {
        return this;
      }
      this.typing.stop();
      if (this.typingMode === 0) {
        this.page.showLastPage();
      } else {
        this.page.showLastLine();
      }
      this.emit("type");
      this.onTypingComplete();
      return this;
    }
    setTypeSpeed(speed) {
      this.typing.setTypingSpeed(speed);
      return this;
    }
    setTypingSpeed(speed) {
      this.typing.setTypingSpeed(speed);
      return this;
    }
    get isTyping() {
      return this.typing.isTyping;
    }
    get isPageEnd() {
      return this._isPageEnd;
    }
    get isLastPage() {
      return this.page.isLastPage;
    }
    get isFirstPage() {
      return this.page.isFirstPage;
    }
    get pageCount() {
      return this.page.pageCount;
    }
    get pageIndex() {
      return this.page.pageIndex;
    }
    get isLastLine() {
      return this.page.isLastLine;
    }
    get isFirstLine() {
      return this.page.isFirstLine;
    }
    get lineCound() {
      return this.page.totalLinesCount;
    }
    get startLineIndex() {
      return this.page.startLineIndex;
    }
    get endLineIndex() {
      return this.page.endLineIndex;
    }
    get typingSpeed() {
      return this.typing.speed;
    }
    onType() {
      var text = this.childrenMap.text;
      if (this.textWidthSave !== text.width || this.textHeightSave !== text.height) {
        this.textWidthSave = text.width;
        this.textHeightSave = text.height;
        this.getTopmostSizer().layout();
      }
      this.emit("type");
    }
    onTypeChar(char) {
      this.emit("typechar", char);
    }
    onTypingComplete() {
      if (this.typingMode === 0) {
        this._isPageEnd = true;
        var isLastPage = this.isLastPage;
        this.isRunning = !isLastPage;
        this.emit("pageend");
        if (isLastPage) {
          this.emit("complete");
        }
      } else {
        this.typeNextLine();
      }
    }
  }
  return TextBox2;
};
var TypingMode = {
  page: 0,
  line: 1
};
var Base_default6 = TextBoxBase;

// node_modules/phaser3-rex-plugins/templates/ui/textbox/TextBox.js
var TextBox = class extends Base_default6(TitleLabel_default) {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("layoutMode")) {
      config.layoutMode = 1;
    }
    super(scene, config);
  }
};
var TextBox_default = TextBox;

// node_modules/phaser3-rex-plugins/templates/ui/textbox/Factory.js
ObjectFactory_default.register("textBox", function(config) {
  var gameObject2 = new TextBox_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TextBox", TextBox_default);

// node_modules/phaser3-rex-plugins/templates/ui/simpletextbox/SimpleTextBox.js
var SimpleTextBox = class extends TextBox_default {
  constructor(scene, config, creators) {
    config = BuildTitleLabelConfig_default(scene, config, creators);
    super(scene, config);
  }
};
var SimpleTextBox_default = SimpleTextBox;

// node_modules/phaser3-rex-plugins/templates/ui/simpletextbox/Factory.js
ObjectFactory_default.register("simpleTextBox", function(config) {
  var gameObject2 = new SimpleTextBox_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.SimpleTextBox", SimpleTextBox_default);

// node_modules/phaser3-rex-plugins/templates/ui/numberbar/NumberBar.js
var GetValue192 = Phaser.Utils.Objects.GetValue;
var NumberBar = class extends Sizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexNumberBar";
    var background = GetValue192(config, "background", void 0);
    var icon = GetValue192(config, "icon", void 0);
    var iconMask = GetValue192(config, "iconMask", void 0);
    var sliderConfig = GetValue192(config, "slider", void 0);
    var text = GetValue192(config, "text", void 0);
    var iconSpace = GetValue192(config, "space.icon", 0);
    var sliderSpace = GetValue192(config, "space.slider", 0);
    if (background) {
      this.addBackground(background);
    }
    if (icon) {
      var padding;
      if (this.orientation === 0) {
        if (sliderConfig || text) {
          padding = { right: iconSpace };
        }
      } else {
        if (sliderConfig || text) {
          padding = { bottom: iconSpace };
        }
      }
      this.add(
        icon,
        {
          proportion: 0,
          align: "center",
          padding
        }
      );
      if (iconMask) {
        iconMask = AddChildMask_default.call(this, icon, icon, 1);
      }
    }
    var slider;
    if (sliderConfig) {
      sliderConfig.orientation = this.orientation;
      sliderConfig.eventEmitter = this;
      sliderConfig.value = null;
      if (!sliderConfig.hasOwnProperty("input")) {
        sliderConfig.input = -1;
      }
      slider = new Slider_default(scene, sliderConfig);
      scene.add.existing(slider);
      var padding;
      if (this.orientation === 0) {
        if (text) {
          padding = { right: sliderSpace };
        }
      } else {
        if (text) {
          padding = { bottom: sliderSpace };
        }
      }
      var proportion;
      if (this.orientation === 0) {
        var sliderWidth = GetValue192(sliderConfig, "width", void 0);
        proportion = sliderWidth === void 0 ? 1 : 0;
      } else {
        var sliderHeight = GetValue192(sliderConfig, "height", void 0);
        proportion = sliderHeight === void 0 ? 1 : 0;
      }
      this.add(
        slider,
        {
          proportion,
          align: "center",
          padding
        }
      );
    }
    if (text) {
      this.add(text);
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("icon", icon);
    this.addChildrenMap("iconMask", iconMask);
    this.addChildrenMap("slider", slider);
    this.addChildrenMap("text", text);
    var callback = GetValue192(config, "valuechangeCallback", null);
    if (callback !== null) {
      var scope = GetValue192(config, "valuechangeCallbackScope", void 0);
      this.on("valuechange", callback, scope);
    }
    this.setEnable(GetValue192(config, "enable", void 0));
    this.setValue(GetValue192(config, "value", 0));
  }
  get enable() {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.enable;
    } else {
      return false;
    }
  }
  set enable(value) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setEnable(value);
    }
  }
  setEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.enable = enable;
    return this;
  }
  get value() {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.value;
    } else {
      return 0;
    }
  }
  set value(value) {
    if (!this.childrenMap.slider) {
      return;
    }
    this.childrenMap.slider.value = value;
  }
  setValue(value, min, max) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setValue(value, min, max);
    }
    return this;
  }
  addValue(inc, min, max) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.addValue(inc, min, max);
    }
    return this;
  }
  getValue(min, max) {
    if (this.childrenMap.slider) {
      return this.childrenMap.slider.getValue(min, max);
    } else {
      return 0;
    }
  }
  easeValueTo(value, min, max) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.easeValueTo(value, min, max);
    }
    return this;
  }
  stopEaseValue() {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.stopEaseValue();
    }
    return this;
  }
  setEaseValueDuration(duration) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setEaseValueDuration(duration);
    }
    return this;
  }
  setEaseValueFunction(ease) {
    if (this.childrenMap.slider) {
      this.childrenMap.slider.setEaseValueFunction(ease);
    }
    return this;
  }
  get text() {
    var textObject = this.childrenMap.text;
    if (textObject === void 0) {
      return "";
    }
    var value;
    if (textObject.text) {
      value = textObject.text;
    } else {
      value = textObject.getData("text");
    }
    return value;
  }
  set text(value) {
    var textObject = this.childrenMap.text;
    if (textObject === void 0) {
      return;
    }
    if (textObject.setText) {
      textObject.setText(value);
    } else {
      textObject.setData("text", value);
    }
  }
  setText(value) {
    this.text = value;
    return this;
  }
};
var NumberBar_default = NumberBar;

// node_modules/phaser3-rex-plugins/templates/ui/numberbar/Factory.js
ObjectFactory_default.register("numberBar", function(config) {
  var gameObject2 = new NumberBar_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.NumberBar", NumberBar_default);

// node_modules/phaser3-rex-plugins/templates/ui/scrollbar/Factory.js
ObjectFactory_default.register("scrollBar", function(config) {
  var gameObject2 = new ScrollBar_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ScrollBar", ScrollBar_default);

// node_modules/phaser3-rex-plugins/templates/ui/badgelabel/BadgeLabel.js
var GetValue193 = Phaser.Utils.Objects.GetValue;
var BadgeKeys = {
  leftTop: "left-top",
  centerTop: "center-top",
  rightTop: "right-top",
  leftCenter: "left-center",
  center: "center",
  rightCenter: "right-center",
  leftBottom: "left-bottom",
  centerBottom: "center-bottom",
  rightBottom: "right-bottom"
};
var Badge = class extends OverlapSizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexBadge";
    var background = GetValue193(config, "background", void 0);
    if (background) {
      this.addBackground(background);
    }
    this.addChildrenMap("background", background);
    var main = GetValue193(config, "main", void 0);
    if (main) {
      this.add(main, {
        key: "main",
        align: "center",
        expand: false
      });
    }
    this.addChildrenMap("main", main);
    for (var key2 in BadgeKeys) {
      var badge = GetValue193(config, key2, void 0);
      if (badge) {
        this.add(badge, {
          key: key2,
          align: BadgeKeys[key2],
          expand: false
        });
        this.addChildrenMap(key2, badge);
      }
    }
  }
};
var BadgeLabel_default = Badge;

// node_modules/phaser3-rex-plugins/templates/ui/badgelabel/Factory.js
ObjectFactory_default.register("badgeLabel", function(config) {
  var gameObject2 = new BadgeLabel_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.BadgeLabel", BadgeLabel_default);

// node_modules/phaser3-rex-plugins/templates/ui/pages/methods/AddChildMethods.js
var OverlapSizerAdd = OverlapSizer_default.prototype.add;
var Add9 = function(gameObject2, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY) {
  gameObject2.setVisible(false);
  OverlapSizerAdd.call(this, gameObject2, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY);
  return this;
};
var AddChildMethods_default9 = {
  add: Add9,
  addPage: Add9
};

// node_modules/phaser3-rex-plugins/templates/ui/pages/methods/GetPage.js
var GetPage = function(key2) {
  if (key2 === void 0) {
    return null;
  } else if (!this.sizerChildren.hasOwnProperty(key2)) {
    return null;
  } else {
    return this.sizerChildren[key2];
  }
};
var GetPage_default = GetPage;

// node_modules/phaser3-rex-plugins/templates/ui/pages/methods/SwapPage.js
var ContainerSetChildVisible = Container_default.prototype.setChildVisible;
var SwapPage = function(key2, fadeInDuration) {
  this._previousKey = this._currentKey;
  var prevoiusPage = this.previousPage;
  if (prevoiusPage) {
    if (this.swapMode === 0) {
      ContainerSetChildVisible.call(this, prevoiusPage, false);
      this.emit("pageinvisible", prevoiusPage, this._previousKey, this);
    } else {
      prevoiusPage.destroy();
    }
  }
  if (key2 && !this.sizerChildren.hasOwnProperty(key2)) {
    this.emit("createpage", key2, this);
  }
  this._currentKey = key2;
  var currentPage = this.currentPage;
  if (currentPage) {
    ContainerSetChildVisible.call(this, currentPage, true);
    this.emit("pagevisible", currentPage, this._currentKey, this);
    if (fadeInDuration === void 0) {
      fadeInDuration = this.fadeInDuration;
    }
    if (fadeInDuration > 0) {
      currentPage.setAlpha(0).fadeIn(fadeInDuration, 1);
    }
  }
  return this;
};
var SwapPage_default = SwapPage;

// node_modules/phaser3-rex-plugins/templates/ui/pages/methods/HasPage.js
var HasPage = function(key2) {
  return this.sizerChildren.hasOwnProperty(key2);
};
var HasPage_default = HasPage;

// node_modules/phaser3-rex-plugins/templates/ui/pages/methods/Methods.js
var methods38 = {
  getPage: GetPage_default,
  swapPage: SwapPage_default,
  hasPage: HasPage_default
};
Object.assign(
  methods38,
  AddChildMethods_default9
);
var Methods_default40 = methods38;

// node_modules/phaser3-rex-plugins/templates/ui/pages/Pages.js
var GetValue194 = Phaser.Utils.Objects.GetValue;
var Pages = class extends OverlapSizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexPages";
    this.childrenMap = this.sizerChildren;
    this._previousKey = void 0;
    this._currentKey = void 0;
    this.setSwapMode(GetValue194(config, "swapMode", 0));
    this.setFadeInDuration(GetValue194(config, "fadeIn", 0));
  }
  setSwapMode(mode) {
    if (typeof mode === "string") {
      mode = SWAPMODE[mode];
    }
    this.swapMode = mode;
    return this;
  }
  setFadeInDuration(duration) {
    this.fadeInDuration = duration;
    return this;
  }
  get previousKey() {
    return this._previousKey;
  }
  get currentKey() {
    return this._currentKey;
  }
  set currentKey(key2) {
    this.swapPage(key2);
  }
  get currentPage() {
    return this.getPage(this.currentKey);
  }
  get previousPage() {
    return this.getPage(this.previousKey);
  }
  get keys() {
    return Object.keys(this.sizerChildren);
  }
};
Object.assign(
  Pages.prototype,
  Methods_default40
);
var SWAPMODE = {
  invisible: 0,
  destroy: 1
};
var Pages_default = Pages;

// node_modules/phaser3-rex-plugins/templates/ui/pages/Factory.js
ObjectFactory_default.register("pages", function(config) {
  var gameObject2 = new Pages_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Pages", Pages_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/utils/MeshBase.js
var Mesh = Phaser.GameObjects.Mesh;
var MeshBase = class extends Mesh {
  get tint() {
    if (this.vertices.length === 0) {
      return 16777215;
    } else {
      return this.vertices[0].color;
    }
  }
  forceUpdate() {
    this.dirtyCache[10] = 1;
    return this;
  }
};
var MeshBase_default = MeshBase;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/utils/TransformVerts.js
var Vector3 = Phaser.Math.Vector3;
var Matrix4 = Phaser.Math.Matrix4;
var tempPosition = new Vector3();
var tempRotation = new Vector3();
var tempMatrix3 = new Matrix4();
var TransformVerts = function(mesh, x, y, z, rotateX, rotateY, rotateZ) {
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  if (z === void 0) {
    z = 0;
  }
  if (rotateX === void 0) {
    rotateX = 0;
  }
  if (rotateY === void 0) {
    rotateY = 0;
  }
  if (rotateZ === void 0) {
    rotateZ = 0;
  }
  tempPosition.set(x, y, z);
  tempRotation.set(rotateX, rotateY, rotateZ);
  tempMatrix3.fromRotationXYTranslation(tempRotation, tempPosition, true);
  for (var i = 0, cnt = mesh.vertices.length; i < cnt; i++) {
    mesh.vertices[i].transformMat4(tempMatrix3);
  }
};
var TransformVerts_default = TransformVerts;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/image/Image.js
var IsPlainObject49 = Phaser.Utils.Objects.IsPlainObject;
var GetValue195 = Phaser.Utils.Objects.GetValue;
var GenerateGridVerts = Phaser.Geom.Mesh.GenerateGridVerts;
var RadToDeg13 = Phaser.Math.RadToDeg;
var DegToRad17 = Phaser.Math.DegToRad;
var FOV = 45;
var PanZ = 1 + 1 / Math.sin(DegToRad17(FOV));
var Image2 = class extends MeshBase_default {
  constructor(scene, x, y, key2, frame, config) {
    if (IsPlainObject49(x)) {
      config = x;
      x = GetValue195(config, "x", 0);
      y = GetValue195(config, "y", 0);
      key2 = GetValue195(config, "key", null);
      frame = GetValue195(config, "frame", null);
    }
    super(scene, x, y, key2, frame);
    this.type = "rexPerspectiveImage";
    this.setSizeToFrame();
    this.resetPerspective();
    this.panZ(PanZ);
    this.hideCCW = GetValue195(config, "hideCCW", true);
    var gridWidth = GetValue195(config, "gridWidth", 0);
    var gridHeight = GetValue195(config, "gridHeight", gridWidth);
    this.resetVerts(gridWidth, gridHeight);
    this.prevFrame = this.frame;
  }
  preUpdate(time, delta) {
    if (this.prevFrame !== this.frame) {
      this.prevFrame = this.frame;
      this.syncSize();
    }
    super.preUpdate(time, delta);
  }
  get originX() {
    return 0.5;
  }
  get originY() {
    return 0.5;
  }
  resetPerspective() {
    this.setPerspective(this.width, this.height, FOV);
    return this;
  }
  resetVerts(gridWidth, gridHeight) {
    if (gridWidth !== void 0) {
      this.gridWidth = gridWidth;
    }
    if (gridHeight !== void 0) {
      this.gridHeight = gridHeight;
    }
    this.clear();
    this.dirtyCache[9] = -1;
    if (this.width === 0 || this.height === 0) {
      return this;
    }
    var frameWidth = this.frame.cutWidth, frameHeight = this.frame.cutHeight;
    var gridWidth, gridHeight;
    if (this.gridWidth === 0) {
      gridWidth = Math.max(frameWidth / 8, 32);
    } else {
      gridHeight = this.gridWidth;
    }
    if (this.gridHeight === 0) {
      gridHeight = Math.max(frameHeight / 8, 32);
    } else {
      gridHeight = this.gridHeight;
    }
    GenerateGridVerts({
      mesh: this,
      width: frameWidth / this.height,
      height: frameHeight / this.height,
      widthSegments: Math.ceil(frameWidth / gridWidth),
      heightSegments: Math.ceil(frameHeight / gridHeight)
    });
    var transformInfo = this.transformInfo;
    if (transformInfo) {
      this.transformVerts(
        transformInfo.x,
        transformInfo.y,
        transformInfo.z,
        transformInfo.rotateX,
        transformInfo.rotateY,
        transformInfo.rotateZ
      );
    }
    return this;
  }
  syncSize() {
    this.setSizeToFrame();
    this.resetPerspective();
    this.resetVerts();
    return this;
  }
  get rotationX() {
    return this.modelRotation.x;
  }
  set rotationX(value) {
    this.modelRotation.x = value;
  }
  get angleX() {
    return RadToDeg13(this.rotationX);
  }
  set angleX(value) {
    this.rotationX = DegToRad17(value);
  }
  get rotationY() {
    return this.modelRotation.y;
  }
  set rotationY(value) {
    this.modelRotation.y = value;
  }
  get angleY() {
    return RadToDeg13(this.rotationY);
  }
  set angleY(value) {
    this.rotationY = DegToRad17(value);
  }
  get rotationZ() {
    return this.modelRotation.z;
  }
  set rotationZ(value) {
    this.modelRotation.z = value;
  }
  get angleZ() {
    return RadToDeg13(this.rotationZ);
  }
  set angleZ(value) {
    this.rotationZ = DegToRad17(value);
  }
  transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (rotateX === void 0) {
      rotateX = 0;
    }
    if (rotateY === void 0) {
      rotateY = 0;
    }
    if (rotateZ === void 0) {
      rotateZ = 0;
    }
    if (!this.transformInfo) {
      this.transformInfo = {};
    }
    this.transformInfo.x = x;
    this.transformInfo.y = y;
    this.transformInfo.rotateX = rotateX;
    this.transformInfo.rotateY = rotateY;
    this.transformInfo.rotateZ = rotateZ;
    TransformVerts_default(this, x, y, z, rotateX, rotateY, rotateZ);
    return this;
  }
};
var Image_default = Image2;

// node_modules/phaser3-rex-plugins/plugins/utils/rendertexture/CreateDynamicTexture.js
var DynamicTexture = Phaser.Textures.DynamicTexture;
var CreateDynamicTexture = function(scene, width, height) {
  if (width === void 0) {
    width = 2;
  }
  if (height === void 0) {
    height = 2;
  }
  var dt = new DynamicTexture(scene.sys.textures, null, width, height);
  return dt;
};
var CreateDynamicTexture_default = CreateDynamicTexture;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/rendertexture/RenderTexture.js
var IsPlainObject50 = Phaser.Utils.Objects.IsPlainObject;
var GetValue196 = Phaser.Utils.Objects.GetValue;
var RenderTexture2 = class extends Image_default {
  constructor(scene, x, y, width, height, config) {
    if (IsPlainObject50(x)) {
      config = x;
      x = GetValue196(config, "x", 0);
      y = GetValue196(config, "y", 0);
      width = GetValue196(config, "width", 32);
      height = GetValue196(config, "height", 32);
    }
    var texture = CreateDynamicTexture_default(scene, width, height);
    super(scene, x, y, texture, null, config);
    this.type = "rexPerspectiveRenderTexture";
    this.rt = this.texture;
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    this.rt.destroy();
    this.rt = null;
  }
  snapshot(gameObjects, config) {
    if (config === void 0) {
      config = {};
    }
    config.gameObjects = gameObjects;
    config.renderTexture = this.rt;
    Snapshot_default(config);
    if (this.width !== this.frame.realWidth || this.height !== this.frame.realHeight) {
      this.syncSize();
    }
    return this;
  }
};
var RenderTexture_default2 = RenderTexture2;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/sprite/Sprite.js
var AnimationState = Phaser.Animations.AnimationState;
var IsPlainObject51 = Phaser.Utils.Objects.IsPlainObject;
var GetValue197 = Phaser.Utils.Objects.GetValue;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/utils/ForEachFace.js
var ForEachFace = function(faces, callback, scope, ignoreInvalid) {
  if (Array.isArray(faces)) {
    var isBreak = false;
    for (var i = 0, cnt = faces.length; i < cnt; i++) {
      var face2 = faces[i];
      if (ignoreInvalid && !face2) {
        continue;
      }
      if (scope) {
        isBreak = callback.call(scope, face2, i, faces);
      } else {
        isBreak = callback(face2, i, faces);
      }
      if (isBreak) {
        return;
      }
    }
  } else {
    var isBreak = false;
    for (var name2 in faces) {
      var face2 = faces[name2];
      if (ignoreInvalid && !face2) {
        continue;
      }
      if (scope) {
        isBreak = callback.call(scope, face2, name2, faces);
      } else {
        isBreak = callback(face2, name2, faces);
      }
      if (isBreak) {
        return;
      }
    }
  }
};
var ForEachFace_default = ForEachFace;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/utils/FaceContainer.js
var RadToDeg14 = Phaser.Math.RadToDeg;
var DegToRad18 = Phaser.Math.DegToRad;
var FaceContainer = class extends ContainerLite_default {
  constructor(scene, x, y, width, height, faces) {
    super(scene, x, y, width, height);
    this.faces = faces;
    ForEachFace_default(faces, function(face2) {
      face2.setPosition(x, y);
      this.add(face2);
    }, this, true);
  }
  // Override
  get rotationX() {
    return 0;
  }
  // Override
  set rotationX(value) {
  }
  get angleX() {
    return RadToDeg14(this.rotationX);
  }
  set angleX(value) {
    this.rotationX = DegToRad18(value);
  }
  get rotateX() {
    return RadToDeg14(this.rotationX);
  }
  set rotateX(value) {
    this.rotationX = DegToRad18(value);
  }
  // Override
  get rotationY() {
    return 0;
  }
  // Override
  set rotationY(value) {
  }
  get angleY() {
    return RadToDeg14(this.rotationY);
  }
  set angleY(value) {
    this.rotationY = DegToRad18(value);
  }
  get rotateY() {
    return RadToDeg14(this.rotationY);
  }
  set rotateY(value) {
    this.rotationY = DegToRad18(value);
  }
  // Override
  get rotationZ() {
    return 0;
  }
  // Override
  set rotationZ(value) {
  }
  get angleZ() {
    return RadToDeg14(this.rotationZ);
  }
  set angleZ(value) {
    this.rotationZ = DegToRad18(value);
  }
  get rotateZ() {
    return RadToDeg14(this.rotationZ);
  }
  set rotateZ(value) {
    this.rotationZ = DegToRad18(value);
  }
  setDebug(graphic, callback) {
    ForEachFace_default(this.faces, function(face2) {
      face2.setDebug(graphic, callback);
    }, null, true);
    return this;
  }
  panX(v) {
    ForEachFace_default(this.faces, function(face2) {
      face2.panX(v);
    }, null, true);
    return this;
  }
  panY(v) {
    ForEachFace_default(this.faces, function(face2) {
      face2.panY(v);
    }, null, true);
    return this;
  }
  panZ(v) {
    ForEachFace_default(this.faces, function(face2) {
      face2.panZ(v);
    }, null, true);
    return this;
  }
  transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
    ForEachFace_default(this.faces, function(face2) {
      face2.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
    }, null, true);
    return this;
  }
  forEachFace(callback, scope, ignoreInvalid) {
    ForEachFace_default(this.faces, callback, scope, ignoreInvalid);
    return this;
  }
};
var FaceContainer_default = FaceContainer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/utils/CreatePerspectiveObject.js
var IsPlainObject52 = Phaser.Utils.Objects.IsPlainObject;
var DefaultImageConfig = { key: "__WHITE" };
var ClassMap = {
  image: Image_default,
  rendertexture: RenderTexture_default2
};
var CreatePerspectiveObject = function(scene, config) {
  if (config === void 0) {
    config = DefaultImageConfig;
  }
  var perspectiveObject;
  if (IsPlainObject52(config)) {
    if (!config.hasOwnProperty("type")) {
      if (config.hasOwnProperty("key")) {
        config.type = "image";
      } else if (config.hasOwnProperty("width")) {
        config.type = "rendertexture";
      }
    }
    perspectiveObject = new ClassMap[config.type](scene, config);
    scene.add.existing(perspectiveObject);
  } else {
    perspectiveObject = config;
  }
  return perspectiveObject;
};
var CreatePerspectiveObject_default = CreatePerspectiveObject;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/utils/CreateFaces.js
var CreateFaces = function(scene, config, faceNames) {
  var faces;
  if (faceNames === void 0) {
    faces = [];
    var face2, faceConfig;
    for (var i = 0, cnt = config.length; i < cnt; i++) {
      faceConfig = config[i];
      if (faceConfig) {
        face2 = CreatePerspectiveObject_default(scene, faceConfig);
      } else {
        face2 = null;
      }
      faces.push(face2);
    }
  } else {
    faces = {};
    var face2, name2;
    for (var i = 0, cnt = faceNames.length; i < cnt; i++) {
      name2 = faceNames[i];
      if (config.hasOwnProperty(name2)) {
        face2 = CreatePerspectiveObject_default(scene, config[name2]);
      } else {
        face2 = null;
      }
      faces[name2] = face2;
    }
  }
  return faces;
};
var CreateFaces_default = CreateFaces;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/card/LayoutFaces.js
var DegToRad19 = Phaser.Math.DegToRad;
var RAD180 = DegToRad19(180);
var LayoutFaces = function(parent, faces) {
  var backFace = faces.back;
  if (backFace) {
    if (parent.orientation === 0) {
      backFace.transformVerts(0, 0, 0, 0, RAD180, 0);
    } else {
      backFace.transformVerts(0, 0, 0, RAD180, 0, 0);
    }
  }
};
var LayoutFaces_default = LayoutFaces;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/card/Flip.js
var GetValue198 = Phaser.Utils.Objects.GetValue;
var Linear25 = Phaser.Math.Linear;
var Flip = class extends EaseValueTaskBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setEase(GetValue198(o, "ease", "Cubic"));
    this.setFrontToBackDirection(GetValue198(o, "frontToBack", 0));
    this.setBackToFrontDirection(GetValue198(o, "backToFront", 1));
    return this;
  }
  setFrontToBackDirection(direction) {
    if (typeof direction === "string") {
      direction = DIRMODE[direction];
    }
    this.endAngleFB = direction === 0 ? 180 : -180;
    return this;
  }
  setBackToFrontDirection(direction) {
    if (typeof direction === "string") {
      direction = DIRMODE[direction];
    }
    this.endAngleBF = direction === 0 ? -180 : 180;
    return this;
  }
  start(duration, repeat) {
    if (this.timer.isRunning) {
      return this;
    }
    this.timer.setDelay(this.delay).setDuration(duration);
    var loop = repeat + 1;
    var gameObject2 = this.parent;
    if (gameObject2.face === 0) {
      this.startAngle = 0;
      this.endAngle = this.endAngleFB * loop;
    } else {
      this.startAngle = this.endAngleBF;
      this.endAngle = this.startAngle - this.endAngleBF * loop;
    }
    super.start();
    return this;
  }
  flip(duration, repeat) {
    if (this.isRunning) {
      return this;
    }
    if (duration === void 0) {
      duration = this.duration;
    }
    if (repeat === void 0) {
      repeat = 0;
    }
    this.start(duration, repeat);
    this.emit("start", this.parent, this);
    this.parent.currentFaceIndex = (this.parent.currentFaceIndex + repeat + 1) % 2;
    return this;
  }
  flipRight(duration, repeat) {
    if (this.parent.currentFaceIndex === 0) {
      this.setFrontToBackDirection(0);
    } else {
      this.setBackToFrontDirection(0);
    }
    this.flip(duration, repeat);
    return this;
  }
  flipLeft(duration, repeat) {
    if (this.parent.currentFaceIndex === 0) {
      this.setFrontToBackDirection(1);
    } else {
      this.setBackToFrontDirection(1);
    }
    this.flip(duration, repeat);
    return this;
  }
  updateTarget(gameObject2, timer) {
    var t = this.easeFn(timer.t);
    var value = Linear25(this.startAngle, this.endAngle, t);
    if (gameObject2.orientation === 0) {
      gameObject2.angleY = value;
    } else {
      gameObject2.angleX = value;
    }
  }
};
var DIRMODE = {
  "right": 0,
  "left-to-right": 0,
  "left": 1,
  "right-to-left": 1
};
var Flip_default = Flip;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/card/Card.js
var IsPlainObject53 = Phaser.Utils.Objects.IsPlainObject;
var GetValue199 = Phaser.Utils.Objects.GetValue;
var FaceNames = ["back", "front"];
var Card = class extends FaceContainer_default {
  constructor(scene, x, y, config) {
    if (IsPlainObject53(x)) {
      config = x;
      x = GetValue199(config, "x", 0);
      y = GetValue199(config, "y", 0);
    }
    var faces = CreateFaces_default(scene, config, FaceNames);
    var backFace = faces.back;
    var frontFace = faces.front;
    var width = GetValue199(config, "width");
    var height = GetValue199(config, "height");
    if (width === void 0 || height === void 0) {
      if (width === void 0) {
        var frontFaceWidth = frontFace ? frontFace.width : 0;
        var backFaceWidth = backFace ? backFace.width : 0;
        width = Math.max(frontFaceWidth, backFaceWidth);
      }
      if (height === void 0) {
        var frontFaceHeight = frontFace ? frontFace.height : 0;
        var backFaceHeight = backFace ? backFace.height : 0;
        height = Math.max(frontFaceHeight, backFaceHeight);
      }
    }
    super(scene, x, y, width, height, faces);
    this.type = "rexPerspectiveCard";
    this.frontFaceRotationX = 0;
    this.frontFaceRotationY = 0;
    this.frontFaceRotationZ = 0;
    ForEachFace_default(faces, function(face2, name2) {
      this[`${name2}Face`] = face2;
    }, this);
    var flipConfig = GetValue199(config, "flip", void 0);
    if (flipConfig !== false) {
      this.flip = new Flip_default(this, flipConfig);
    }
    this.setOrientation(GetValue199(config, "orientation", 0));
    LayoutFaces_default(this, faces);
    this.setFace(GetValue199(config, "face", 0));
  }
  get rotationX() {
    return this.frontFaceRotationX;
  }
  set rotationX(value) {
    if (this.frontFaceRotationX === value) {
      return;
    }
    this.frontFaceRotationX = value;
    ForEachFace_default(this.faces, function(face2) {
      face2.rotationX = value;
    }, null, true);
  }
  get rotationY() {
    return this.frontFaceRotationY;
  }
  set rotationY(value) {
    if (this.frontFaceRotationY === value) {
      return;
    }
    this.frontFaceRotationY = value;
    ForEachFace_default(this.faces, function(face2) {
      face2.rotationY = value;
    }, null, true);
  }
  get rotationZ() {
    return this.frontFaceRotationZ;
  }
  set rotationZ(value) {
    if (this.frontFaceRotationZ === value) {
      return;
    }
    this.frontFaceRotationZ = value;
    ForEachFace_default(this.faces, function(face2) {
      face2.rotationZ = value;
    }, null, true);
  }
  setOrientation(orientation) {
    if (typeof orientation === "string") {
      orientation = ORIENTATIONMODE2[orientation];
    }
    this.orientation = orientation;
    return this;
  }
  get face() {
    return this.currentFaceIndex;
  }
  set face(index) {
    if (typeof index === "string") {
      index = FACEMODE[index];
    }
    this.currentFaceIndex = index;
    var isBackFace = index === 1;
    var angle = isBackFace ? 180 : 0;
    if (this.orientation === 0) {
      this.angleY = angle;
    } else {
      this.angleX = angle;
    }
  }
  setFace(face2) {
    this.face = face2;
    return this;
  }
  toggleFace() {
    var newFace = this.face === 0 ? 1 : 0;
    this.setFace(newFace);
    return this;
  }
};
var ORIENTATIONMODE2 = {
  x: 0,
  horizontal: 0,
  h: 0,
  y: 1,
  vertical: 1,
  v: 1
};
var FACEMODE = {
  front: 0,
  back: 1
};
var Card_default = Card;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/carousel/Roll.js
var GetValue200 = Phaser.Utils.Objects.GetValue;
var RadToDeg15 = Phaser.Math.RadToDeg;
var DegToRad20 = Phaser.Math.DegToRad;
var WrapDegrees3 = Phaser.Math.Angle.WrapDegrees;
var ShortestBetween3 = Phaser.Math.Angle.ShortestBetween;
var Wrap5 = Phaser.Math.Wrap;
var Linear26 = Phaser.Math.Linear;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/carousel/Carousel.js
var IsPlainObject54 = Phaser.Utils.Objects.IsPlainObject;
var GetValue201 = Phaser.Utils.Objects.GetValue;
var DegToRad21 = Phaser.Math.DegToRad;
var RadToDeg16 = Phaser.Math.RadToDeg;
var WrapDegrees4 = Phaser.Math.Angle.WrapDegrees;
var Linear27 = Phaser.Math.Linear;
var Wrap6 = Phaser.Math.Wrap;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/perspective/imagecarousel/ImageCarousel.js
var IsPlainObject55 = Phaser.Utils.Objects.IsPlainObject;
var GetValue202 = Phaser.Utils.Objects.GetValue;
var Wrap7 = Phaser.Math.Wrap;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/rendertexture/Init.js
var GetValue203 = Phaser.Utils.Objects.GetValue;
var Init = function(parentContainer, rtOwner, config) {
  rtOwner.visibleSibling = [];
  rtOwner.isRunning = false;
  rtOwner.useParentBounds = GetValue203(config, "useParentBounds", false);
  rtOwner.setPosition(parentContainer.x, parentContainer.y).setVisible(false);
  parentContainer.pin(rtOwner);
};
var Init_default = Init;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/rendertexture/Exit.js
var Exit = function(parentContainer, rtOwner) {
  if (!parentContainer) {
    return false;
  }
  var visibleSibling = rtOwner.visibleSibling;
  for (var i = 0, cnt = visibleSibling.length; i < cnt; i++) {
    parentContainer.setChildVisible(visibleSibling[i], true);
  }
  visibleSibling.length = 0;
  parentContainer.setChildVisible(rtOwner, false);
  rtOwner.isRunning = false;
  return true;
};
var Exit_default = Exit;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/rendertexture/Enter.js
var Enter = function(parentContainer, rtOwner) {
  if (!parentContainer) {
    return false;
  }
  Exit_default(parentContainer, rtOwner);
  var useParentBounds = rtOwner.useParentBounds;
  Snapshot_default({
    gameObjects: parentContainer.getAllVisibleChildren(),
    renderTexture: rtOwner.rt,
    x: rtOwner.x,
    y: rtOwner.y,
    width: useParentBounds ? parentContainer.displayWidth : void 0,
    height: useParentBounds ? parentContainer.displayHeighth : void 0,
    originX: useParentBounds ? parentContainer.originX : void 0,
    originY: useParentBounds ? parentContainer.originY : void 0
  });
  parentContainer.setChildVisible(rtOwner, true);
  var visibleSibling = rtOwner.visibleSibling;
  var children = parentContainer.children;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (child.visible && child !== rtOwner) {
      parentContainer.setChildVisible(child, false);
      visibleSibling.push(child);
    }
  }
  rtOwner.isRunning = true;
  return true;
};
var Enter_default = Enter;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/container/containerlite/rendertexture/MeshRenderTextureBase.js
var MeshRenderTextureBase = function(RenderTextureOwnerClass) {
  return class Base extends RenderTextureOwnerClass {
    constructor(parentContainer, config) {
      var scene = parentContainer.scene;
      super(scene, 0, 0, 1, 1, config);
      scene.add.existing(this);
      Init_default(parentContainer, this, config);
    }
    destroy(fromScene) {
      if (!this.scene || this.ignoreDestroy) {
        return;
      }
      this.exit();
      super.destroy(fromScene);
    }
    enter() {
      var result = Enter_default(this.rexContainer.parent, this);
      if (result) {
        this.syncSize();
      }
      return this;
    }
    exit() {
      Exit_default(this.rexContainer.parent, this);
      return this;
    }
  };
};
var MeshRenderTextureBase_default = MeshRenderTextureBase;

// node_modules/phaser3-rex-plugins/plugins/behaviors/containerperspective/ContainerPerspective.js
var ContainerPerspective = class extends MeshRenderTextureBase_default(RenderTexture_default2) {
  get perspectiveState() {
    return this.isRunning;
  }
};
var ContainerPerspective_default = ContainerPerspective;

// node_modules/phaser3-rex-plugins/templates/ui/perspectivecard/CreatePerspectiveCardMesh.js
var GetValue204 = Phaser.Utils.Objects.GetValue;
var CreatePerspectiveCardMesh = function(config) {
  var scene = this.scene;
  this.setSnapshotPadding(GetValue204(config, "snapshotPadding", 0));
  config = Clone_default(config);
  delete config.width;
  delete config.height;
  config.front = { width: 1, height: 1 };
  config.back = { width: 1, height: 1 };
  var card = new Card_default(scene, config);
  scene.add.existing(card);
  var flip = card.flip;
  if (flip) {
    var parent = this;
    flip.on("start", function() {
      parent.enterPerspectiveMode();
    }).on("complete", function() {
      parent.exitPerspectiveMode();
    });
  }
  return card;
};
var CreatePerspectiveCardMesh_default = CreatePerspectiveCardMesh;

// node_modules/phaser3-rex-plugins/templates/ui/perspectivecard/PerspectiveMethods.js
var FaceIndexMap = ["front", "back"];
var PerspectiveMethods_default = {
  enterPerspectiveMode() {
    if (this.isInPerspectiveMode) {
      return this;
    }
    this.setChildVisible(this.perspectiveCard, true);
    this.snapshotFace(0);
    this.snapshotFace(1);
    this.setChildVisible(this.childrenMap.front, false);
    this.setChildVisible(this.childrenMap.back, false);
    this.perspectiveCard.setSize(this.width, this.height);
    return this;
  },
  exitPerspectiveMode() {
    if (!this.isInPerspectiveMode) {
      return this;
    }
    this.setChildVisible(this.perspectiveCard, false);
    var isFrontFace = this.perspectiveCard.face === 0;
    this.setChildVisible(this.childrenMap.front, isFrontFace);
    this.setChildVisible(this.childrenMap.back, !isFrontFace);
    return this;
  },
  setSnapshotPadding(padding) {
    this.snapshotPadding = padding;
    return this;
  },
  snapshotFace(face2) {
    if (typeof face2 === "number") {
      face2 = FaceIndexMap[face2];
    }
    var cardFace = this.perspectiveCard.faces[face2];
    var faceChild = this.childrenMap[face2];
    cardFace.rt.clear();
    var faceChildVisibleSave = faceChild.visible;
    faceChild.visible = true;
    var gameObjects = faceChild.isRexContainerLite ? faceChild.getAllVisibleChildren() : faceChild;
    cardFace.snapshot(
      gameObjects,
      { padding: this.snapshotPadding }
    );
    faceChild.visible = faceChildVisibleSave;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/perspectivecard/PerspectiveCard.js
var GetValue205 = Phaser.Utils.Objects.GetValue;
var PerspectiveCard = class extends OverlapSizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexPerspectiveCard";
    var backFace = config.back;
    var backFaceExpand = GetValue205(config, "expand.back", true);
    this.add(
      backFace,
      { key: "back", expand: backFaceExpand }
    );
    var frontFace = config.front;
    var frontFaceExpand = GetValue205(config, "expand.front", true);
    this.add(
      frontFace,
      { key: "front", expand: frontFaceExpand }
    );
    this.perspectiveCard = CreatePerspectiveCardMesh_default.call(this, config);
    this.pin(this.perspectiveCard);
    this.exitPerspectiveMode(false);
  }
  get flip() {
    return this.perspectiveCard.flip;
  }
  get face() {
    return this.perspectiveCard.face;
  }
  set face(index) {
    if (this.flip && this.flip.isRunning) {
      return;
    }
    this.perspectiveCard.face = index;
    var isFrontFace = index === 0;
    var frontFace = this.childrenMap.front;
    var backFace = this.childrenMap.back;
    this.setChildVisible(frontFace, isFrontFace);
    this.setChildVisible(backFace, !isFrontFace);
  }
  setFace(face2) {
    this.face = face2;
    return this;
  }
  toggleFace() {
    var newFace = this.face === 0 ? 1 : 0;
    this.setFace(newFace);
    return this;
  }
  get isInPerspectiveMode() {
    return this.perspectiveCard.visible;
  }
  get rotationX() {
    return this.perspectiveCard.rotationX;
  }
  set rotationX(value) {
    this.enterPerspectiveMode();
    this.perspectiveCard.rotationX = value;
  }
  get angleX() {
    return this.perspectiveCard.angleX;
  }
  set angleX(value) {
    this.enterPerspectiveMode();
    this.perspectiveCard.angleX = value;
  }
  get rotationY() {
    return this.perspectiveCard.rotationY;
  }
  set rotationY(value) {
    this.enterPerspectiveMode();
    this.perspectiveCard.rotationY = value;
  }
  get angleY() {
    return this.perspectiveCard.angleY;
  }
  set angleY(value) {
    this.enterPerspectiveMode();
    this.perspectiveCard.angleY = value;
  }
  get rotationZ() {
    return this.perspectiveCard.rotationZ;
  }
  set rotationZ(value) {
    this.enterPerspectiveMode();
    this.perspectiveCard.rotationZ = value;
  }
  get angleZ() {
    return this.perspectiveCard.angleZ;
  }
  set angleZ(value) {
    this.enterPerspectiveMode();
    this.perspectiveCard.angleZ = value;
  }
  panX(v) {
    this.enterPerspectiveMode();
    this.perspectiveCard.panX(v);
    return this;
  }
  panY(v) {
    this.enterPerspectiveMode();
    this.perspectiveCard.panY(v);
    return this;
  }
  panZ(v) {
    this.enterPerspectiveMode();
    this.perspectiveCard.panZ(v);
    return this;
  }
  transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
    this.enterPerspectiveMode();
    this.perspectiveCard.transformVerts(x, y, z, rotateX, rotateY, rotateZ);
    return this;
  }
  forEachFace(callback, scope, ignoreInvalid) {
    this.enterPerspectiveMode();
    this.perspectiveCard.forEachFace(callback, scope, ignoreInvalid);
    return this;
  }
};
Object.assign(
  PerspectiveCard.prototype,
  PerspectiveMethods_default
);
var PerspectiveCard_default = PerspectiveCard;

// node_modules/phaser3-rex-plugins/templates/ui/perspectivecard/Factory.js
ObjectFactory_default.register("perspectiveCard", function(config) {
  var gameObject2 = new PerspectiveCard_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.PerspectiveCard", PerspectiveCard_default);

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/GetPageKeyByIndex.js
var GetPageKeyByIndex = function(index) {
  var buttons = this.getElement("tabs.buttons");
  if (index >= buttons.length) {
    return void 0;
  }
  return buttons[index].name;
};
var GetPageKeyByIndex_default = GetPageKeyByIndex;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/GetPageIndexByKey.js
var GetPageIndexByKey = function(key2) {
  var buttons = this.getElement("tabs.buttons");
  for (var i = 0, cnt = buttons.length; i < cnt; i++) {
    if (buttons[i].name === key2) {
      return i;
    }
  }
  return void 0;
};
var GetPageIndexByKey_default = GetPageIndexByKey;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/AddPage.js
var IsPlainObject56 = Phaser.Utils.Objects.IsPlainObject;
var GetValue206 = Phaser.Utils.Objects.GetValue;
var UUID4 = Phaser.Utils.String.UUID;
var AddPage = function(key2, tabGameObject, pageGameObject) {
  if (IsPlainObject56(key2)) {
    var config = key2;
    key2 = GetValue206(config, "key");
    tabGameObject = GetValue206(config, "tab");
    pageGameObject = GetValue206(config, "page");
  }
  if (!key2) {
    key2 = UUID4();
  }
  tabGameObject.name = key2;
  this.childrenMap.tabs.addButton(tabGameObject);
  this.childrenMap.pages.addPage(pageGameObject, { key: key2 });
  return this;
};
var AddPage_default = AddPage;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/SwapPageMethods.js
var SwapPage2 = function(key2, fadeInDuration) {
  var index;
  if (typeof key2 === "number") {
    index = key2;
  } else {
    index = this.getPageIndex(key2);
  }
  if (index != null) {
    var fadeInDurationSave;
    if (fadeInDuration !== void 0) {
      fadeInDurationSave = this.childrenMap.pages.fadeInDuration;
      this.childrenMap.pages.fadeInDuration = fadeInDuration;
    }
    this.childrenMap.tabs.emitButtonClick(index);
    if (fadeInDurationSave !== void 0) {
      this.childrenMap.pages.fadeInDuration = fadeInDurationSave;
    }
  }
  return this;
};
var SwapFirstPage = function(fadeInDuration) {
  this.swapPage(0, fadeInDuration);
  return this;
};
var SwapLastPage = function(fadeInDuration) {
  var index = this.getElement("tabs.buttons").length - 1;
  this.swapPage(index, fadeInDuration);
  return this;
};
var SwapPageMethods_default = {
  swapPage: SwapPage2,
  swapFirstPage: SwapFirstPage,
  swapLastPage: SwapLastPage
};

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/RemovePageMethods.js
var RemovePageMethods_default = {
  removePage(key2, destroyChild) {
    if (typeof key2 === "number") {
      key2 = this.getPageKey(key2);
    }
    var tabs = this.childrenMap.tabs;
    var tabGameObject = tabs.getByName(key2);
    var pages = this.childrenMap.pages;
    var pageGameObject = pages.getElement(key2);
    if (!tabGameObject || !pageGameObject) {
      return this;
    }
    pages.removeChildrenMap(key2);
    tabs.removeButton(tabGameObject, destroyChild);
    pages.remove(pageGameObject, destroyChild);
    return this;
  },
  removeAllPages(destroyChild) {
    var buttons = this.getElement("tabs.buttons");
    for (var i = buttons.length - 1; i >= 0; i--) {
      this.removePage(buttons[i].name, destroyChild);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/GetPage.js
var GetPage2 = function(key2) {
  if (typeof key2 === "number") {
    key2 = this.getPageKey(key2);
  }
  return this.childrenMap.pages.getPage(key2);
};
var GetPage_default2 = GetPage2;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/GetTab.js
var GetTab = function(key2) {
  var index;
  if (typeof key2 === "number") {
    index = key2;
  } else {
    index = this.getPageIndex(key2);
  }
  return this.getElement("tabs.buttons")[index];
};
var GetTab_default = GetTab;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/SetTabPosition.js
var TabsPositionToIndex = {
  top: 1,
  left: 3,
  right: 5,
  bottom: 7
};
var TabsPositionToTabsPaddingKey = {
  top: "bottom",
  left: "right",
  right: "left",
  bottom: "top"
};
var SetTabPosition = function(tabsPosition) {
  var newIndex = TabsPositionToIndex[tabsPosition];
  if (newIndex === void 0) {
    return this;
  }
  var tabs = this.childrenMap.tabs;
  var currentIndex = this.sizerChildren.indexOf(tabs);
  if (currentIndex === newIndex) {
    return this;
  }
  this.sizerChildren[currentIndex] = null;
  this.sizerChildren[newIndex] = tabs;
  var tabPadding = this.getSizerConfig(tabs).padding;
  var currentPaddingKey = TabsPositionToTabsPaddingKey[this.tabsPosition];
  var newPaddingKey = TabsPositionToTabsPaddingKey[tabsPosition];
  tabPadding[newPaddingKey] = tabPadding[currentPaddingKey];
  tabPadding[currentPaddingKey] = 0;
  this.tabsPosition = tabsPosition;
  return this;
};
var SetTabPosition_default = SetTabPosition;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/TabPaddingMethods.js
var TabPaddingMethods_default = {
  setTabsPadding(key2, value) {
    var tabs = this.childrenMap.tabs;
    tabs.setOuterPadding(key2, value);
    return this;
  },
  getTabsPadding(key2) {
    var tabs = this.childrenMap.tabs;
    return tabs.getOuterPadding(key2);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/methods/Methods.js
var methods39 = {
  getPageKey: GetPageKeyByIndex_default,
  getPageIndex: GetPageIndexByKey_default,
  addPage: AddPage_default,
  getPage: GetPage_default2,
  getTab: GetTab_default,
  setTabPosition: SetTabPosition_default
};
Object.assign(
  methods39,
  SwapPageMethods_default,
  RemovePageMethods_default,
  TabPaddingMethods_default
);
var Methods_default41 = methods39;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/TabPages.js
var GetValue207 = Phaser.Utils.Objects.GetValue;
var SizerAdd4 = GridSizer_default.prototype.add;
var TabPages = class extends GridSizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.column = 3;
    config.row = 3;
    config.columnProportions = [0, 0, 0];
    config.rowProportions = [0, 0, 0];
    var expandPages = GetValue207(config, "expand.pages", true);
    if (expandPages) {
      config.columnProportions[1] = 1;
      config.rowProportions[1] = 1;
    }
    super(scene, config);
    this.type = "rexTabPages";
    var background = GetValue207(config, "background", void 0);
    if (background) {
      this.addBackground(background);
    }
    var pagesConfig = GetValue207(config, "pages");
    var pages = new Pages_default(scene, pagesConfig);
    scene.add.existing(pages);
    var tabsPosition = GetValue207(config, "tabsPosition", void 0);
    if (tabsPosition === void 0) {
      tabsPosition = GetValue207(config, "tabPosition", "top");
    }
    var wrapTabs = GetValue207(config, "wrapTabs", false);
    var ButtonsClass = wrapTabs ? FixWidthButtons_default : Buttons_default;
    var tabsConfig = GetValue207(config, "tabs", void 0);
    if (tabsConfig === void 0) {
      tabsConfig = {};
    }
    tabsConfig.orientation = tabsPosition === "top" || tabsPosition === "bottom" ? "x" : "y";
    tabsConfig.buttonsType = "radio";
    if (!wrapTabs && !tabsConfig.hasOwnProperty("expand")) {
      tabsConfig.expand = GetValue207(config, "expand.tabs", false);
    }
    var tabs = new ButtonsClass(scene, tabsConfig);
    scene.add.existing(tabs);
    SizerAdd4.call(this, pages, {
      column: 1,
      row: 1,
      expand: expandPages
    });
    var tabColumnIndex, tabRowIndex;
    var tabPadding = GetValue207(config, "space.item", 0);
    switch (tabsPosition) {
      case "top":
        tabColumnIndex = 1;
        tabRowIndex = 0;
        tabPadding = { bottom: tabPadding };
        break;
      case "bottom":
        tabColumnIndex = 1;
        tabRowIndex = 2;
        tabPadding = { top: tabPadding };
        break;
      case "left":
        tabColumnIndex = 0;
        tabRowIndex = 1;
        tabPadding = { right: tabPadding };
        break;
      case "right":
        tabColumnIndex = 2;
        tabRowIndex = 1;
        tabPadding = { left: tabPadding };
        break;
    }
    SizerAdd4.call(this, tabs, {
      column: tabColumnIndex,
      row: tabRowIndex,
      padding: tabPadding,
      expand: wrapTabs ? true : GetValue207(config, "expand.tabs", false),
      align: GetValue207(config, "align.tabs", "left")
    });
    this.addChildrenMap("background", background);
    this.addChildrenMap("tabs", tabs);
    this.addChildrenMap("pages", pages);
    this.tabsPosition = tabsPosition;
    tabs.on("button.click", function(tab) {
      var key2 = tab.name;
      if (pages.hasPage(key2)) {
        pages.swapPage(key2);
      }
    });
    tabs.on("button.statechange", function(tab, index, value, previousValue) {
      var eventName = value ? "tab.focus" : "tab.blur";
      this.emit(eventName, tab, tab.name);
    }, this);
    pages.on("pagevisible", function(pageObject, key2, pages2) {
      this.emit("page.focus", pageObject, key2);
    });
    pages.on("pageinvisible", function(pageObject, key2, pages2) {
      this.emit("page.blur", pageObject, key2);
    });
  }
  get currentKey() {
    return this.getElement("pages").currentKey;
  }
  set currentKey(key2) {
    this.showPage(key2);
  }
  get keys() {
    return this.getElement("pages").keys;
  }
  get currentPage() {
    return this.getElement("pages").currentPage;
  }
  get previousPage() {
    return this.getElement("pages").previousPage;
  }
};
Object.assign(
  TabPages.prototype,
  Methods_default41
);
var TabPages_default = TabPages;

// node_modules/phaser3-rex-plugins/templates/ui/tabpages/Factory.js
ObjectFactory_default.register("tabPages", function(config) {
  var gameObject2 = new TabPages_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TabPages", TabPages_default);

// node_modules/phaser3-rex-plugins/templates/ui/folder/methods/ChildTransition.js
var Transition = class extends OpenCloseTransition_default {
  constructor(gameObject2, config) {
    if (config === void 0) {
      config = {};
    }
    config.destroy = false;
    super(gameObject2, config);
  }
  onOpen() {
    this.emit("open", this.parent, this);
    super.onOpen();
  }
  onClose() {
    this.emit("close", this.parent, this);
    super.onClose();
  }
};
var ChildTransition_default = Transition;

// node_modules/phaser3-rex-plugins/templates/ui/folder/methods/ExpandMethods.js
var ExpandMethods_default2 = {
  expand(duration) {
    if (this.expanded === true) {
      return this;
    }
    if (duration === void 0) {
      duration = this.transitionDuration;
    }
    this.expanded = true;
    var title = this.childrenMap.title;
    var child = this.childrenMap.child;
    this.show(child);
    if (this.reLayoutEnable) {
      var layoutTarget = this.reLayoutTarget ? this.reLayoutTarget : this.getTopmostSizer();
      layoutTarget.layout();
    }
    title.emit("folder.expand", duration, this);
    child.emit("folder.expand", duration, this);
    this.emit("expand.start", this);
    this.childTransition.once("open", function() {
      this.emit("expand.complete", this);
    }, this).requestOpen(null, duration);
    return this;
  },
  collapse(duration) {
    if (this.expanded === false) {
      return this;
    }
    if (duration === void 0) {
      duration = this.transitionDuration;
    }
    this.expanded = false;
    var title = this.childrenMap.title;
    var child = this.childrenMap.child;
    title.emit("folder.collapse", duration, this);
    child.emit("folder.collapse", duration, this);
    this.emit("collapse.start", this);
    this.childTransition.once("close", function() {
      this.setChildScale(child, 1, 1).hide(child);
      if (this.reLayoutEnable) {
        var layoutTarget = this.reLayoutTarget ? this.reLayoutTarget : this.getTopmostSizer();
        layoutTarget.layout();
      }
      this.emit("collapse.complete", this);
    }, this).requestClose(null, duration);
    return this;
  },
  toggle(duration) {
    if (this.expanded) {
      this.collapse(duration);
    } else {
      this.expand(duration);
    }
    return this;
  },
  setExpandedState(expanded) {
    this.reLayoutEnable = false;
    if (expanded === void 0) {
      this.expanded = void 0;
    } else if (expanded) {
      this.expand(0);
    } else {
      this.collapse(0);
    }
    this.reLayoutEnable = true;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/folder/methods/ConfigurationMethods.js
var DefaultExpandCallback = function(gameObject2, duration) {
  ScaleMethods_default2.popUp.call(gameObject2, duration, this.expandDirection);
};
var DefaultCollapseCallback = function(gameObject2, duration) {
  ScaleMethods_default2.scaleDown.call(gameObject2, duration, this.expandDirection);
};
var ConfigurationMethods_default3 = {
  setTransitionDuration(duration) {
    this.transitionDuration = duration;
    this.childTransition.setTransitInTime(duration).setTransitOutTime(duration);
    return this;
  },
  setExpandCallback(callback) {
    if (callback === void 0) {
      callback = DefaultExpandCallback.bind(this);
    }
    this.childTransition.setTransitInCallback(callback);
    return this;
  },
  setCollapseCallback(callback) {
    if (callback === void 0) {
      callback = DefaultCollapseCallback.bind(this);
    }
    this.childTransition.setTransitOutCallback(callback);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/folder/Folder.js
var GetValue208 = Phaser.Utils.Objects.GetValue;
var Folder = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("orientation")) {
      config.orientation = 1;
    }
    super(scene, config);
    this.type = "rexFolder";
    this.reLayoutEnable = true;
    this.expanded = void 0;
    this.expandDirection = this.orientation === 1 ? "y" : "x";
    var background = config.background;
    var title = config.title;
    var child = config.child;
    if (background) {
      this.addBackground(background);
    }
    var spaceConfig = GetValue208(config, "space");
    var defaultAlign = this.orientation === 1 ? "left" : "top";
    var align = GetValue208(config, "align.title", defaultAlign);
    var expand = GetValue208(config, "expand.title", true);
    this.add(
      title,
      {
        proportion: 0,
        align,
        expand,
        padding: {
          left: GetValue208(spaceConfig, "titleLeft", 0),
          right: GetValue208(spaceConfig, "titleRight", 0),
          top: GetValue208(spaceConfig, "titleTop", 0),
          bottom: GetValue208(spaceConfig, "titleBottom", 0)
        }
      }
    );
    var toggleByTarget = GetValue208(config, "toggleByTarget", void 0);
    var toggleClickConfig = GetValue208(config, "toggleClickConfig");
    if (toggleByTarget === void 0) {
      toggleByTarget = title;
    }
    if (toggleByTarget) {
      ClickMethods_default.onClick.call(
        toggleByTarget,
        function() {
          this.toggle();
        },
        this,
        toggleClickConfig
      );
    }
    this.childTransition = new ChildTransition_default(child);
    var customOrigin = GetValue208(config, "customChildOrigin", false);
    if (!customOrigin) {
      var origin = !this.rtl ? 0 : 1;
      child.setOrigin(origin);
    }
    var align = GetValue208(config, "align.child", "left");
    var expand = GetValue208(config, "expand.child", true);
    var proportion = expand ? 1 : 0;
    this.add(
      child,
      {
        proportion,
        align,
        expand,
        padding: {
          left: GetValue208(spaceConfig, "childLeft", 0),
          right: GetValue208(spaceConfig, "childRight", 0),
          top: GetValue208(spaceConfig, "childTop", 0),
          bottom: GetValue208(spaceConfig, "childBottom", 0)
        }
      }
    );
    this.addChildrenMap("title", title);
    this.addChildrenMap("child", child);
    this.addChildrenMap("background", background);
    var transitionConfig = config.transition;
    this.setTransitionDuration(GetValue208(transitionConfig, "duration", 200));
    this.setExpandCallback(GetValue208(transitionConfig, "expandCallback", void 0));
    this.setCollapseCallback(GetValue208(transitionConfig, "collapseCallback", void 0));
    this.reLayoutTarget = GetValue208(config, "reLayoutTarget", void 0);
    var onExpandStart = config.onExpandStart;
    if (onExpandStart) {
      this.on("expand.start", onExpandStart);
    }
    var onExpandComplete = config.onExpandComplete;
    if (onExpandComplete) {
      this.on("expand.complete", onExpandComplete);
    }
    var onCollapseStart = config.onCollapseStart;
    if (onCollapseStart) {
      this.on("collapse.start", onCollapseStart);
    }
    var onCollapseComplete = config.onCollapseComplete;
    if (onCollapseComplete) {
      this.on("collapse.complete", onCollapseComplete);
    }
    var expanded = GetValue208(config, "expanded", void 0);
    if (expanded !== void 0) {
      this.setExpandedState(expanded);
    }
  }
};
Object.assign(
  Folder.prototype,
  ExpandMethods_default2,
  ConfigurationMethods_default3
);
var Folder_default = Folder;

// node_modules/phaser3-rex-plugins/templates/ui/folder/Factory.js
ObjectFactory_default.register("folder", function(config) {
  var gameObject2 = new Folder_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Folder", Folder_default);

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/PointToChild.js
var PointToChild2 = function(x, y, preTest, postTest) {
  for (var nodeKey2 in this.treesMap) {
    var tree = this.treesMap[nodeKey2];
    if (ContainsPoint_default(tree.nodeBody, x, y, preTest, postTest)) {
      return tree;
    }
    var child = tree.pointToChild(x, y, preTest, postTest);
    if (child) {
      return child;
    }
  }
  return null;
};
var PointToChild_default2 = PointToChild2;

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/SetChildrenInteractive.js
var SetChildrenInteractive3 = function(config) {
  if (config === void 0) {
    config = {};
  }
  config.targetMode = "parent";
  config.targetSizers = [this];
  SetChildrenInteractive_default2(this, config);
  return this;
};
var SetChildrenInteractive_default4 = SetChildrenInteractive3;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/node/NodeBase.js
var ExtendNodeClass = function(GOClass) {
  return class Base extends GOClass {
    get isTree() {
      return false;
    }
    get isNode() {
      return false;
    }
    // Wrap text/setText() from nodeBody
    setText(text) {
      this.text = text;
      return this;
    }
    get text() {
      var textObject = this.nodeBody;
      return textObject.text;
    }
    set text(value) {
      var textObject = this.nodeBody;
      if (textObject.setText) {
        textObject.setText(value);
      }
    }
    // Wrap setTexture() from nodeBody
    setTexture(key2, frame) {
      var imageObject = this.nodeBody;
      if (imageObject.setTexture) {
        imageObject.setTexture(key2, frame);
      }
      return this;
    }
    get texture() {
      var imageObject = this.nodeBody;
      if (!imageObject) {
        return void 0;
      }
      return imageObject.texture;
    }
    get frame() {
      var imageObject = this.nodeBody;
      if (!imageObject) {
        return void 0;
      }
      return imageObject.frame;
    }
  };
};
var NodeBase_default = ExtendNodeClass;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/methods/PointToChild.js
var PointToChild3 = function(x, y, preTest, postTest) {
  for (var nodeKey2 in this.nodesMap) {
    var node = this.nodesMap[nodeKey2];
    if (this.isTreeObject(node)) {
      var tree = node;
      if (ContainsPoint_default(tree.nodeBody, x, y, preTest, postTest)) {
        return tree;
      }
      var child = tree.pointToChild(x, y, preTest, postTest);
      if (child) {
        return child;
      }
    } else {
      if (ContainsPoint_default(node, x, y, preTest, postTest)) {
        return node;
      }
    }
  }
  return null;
};
var PointToChild_default3 = PointToChild3;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/methods/ParentMethods.js
var ParentMethods_default = {
  getTreePatent(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    if (!gameObject2.rexSizer) {
      return void 0;
    }
    return gameObject2.rexSizer.treeParent;
  },
  getTreeRoot(gameObject2) {
    if (gameObject2 === void 0) {
      gameObject2 = this;
    }
    var treeParent;
    while (1) {
      if (!gameObject2.rexSizer) {
        return void 0;
      }
      treeParent = gameObject2.rexSizer.treeParent;
      if (treeParent === null) {
        return gameObject2;
      }
      gameObject2 = treeParent;
    }
    return void 0;
  },
  getTreesSizer(gameObject2) {
    var root = this.getTreeRoot(gameObject2);
    return root ? root.getParentSizer() : null;
  },
  isGrandsonNode(gameObject2) {
    if (gameObject2 === void 0 || !gameObject2.rexSizer) {
      return false;
    }
    var treeParent;
    while (1) {
      if (!gameObject2.rexSizer) {
        return false;
      }
      treeParent = gameObject2.rexSizer.treeParent;
      if (treeParent === this) {
        return true;
      } else if (treeParent === null) {
        return false;
      }
      gameObject2 = treeParent;
    }
    return false;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/trees/builders/CreateGameObjectFromConfig.js
var CreateGameObjectFromConfig = function(scene, config, callbackData, defaultCallback, isRequired = false) {
  var gameObject2;
  if (IsGameObject_default(config)) {
    gameObject2 = config;
    delete config[key];
  } else if (IsFunction_default(config)) {
    var callback = config;
    gameObject2 = callback(scene, callbackData);
    if (gameObject2) {
      scene.add.existing(gameObject2);
    }
  } else if ((isRequired || config) && defaultCallback) {
    gameObject2 = defaultCallback(scene, config, callbackData);
  }
  return gameObject2;
};
var CreateGameObjectFromConfig_default = CreateGameObjectFromConfig;

// node_modules/phaser3-rex-plugins/templates/ui/trees/builders/DefaultCreateBackgroundCallback.js
var DefaultCreateBackgroundCallback = function(scene, config, createCallbackData) {
  var gameObject2 = CreateBackground_default(scene, config);
  return gameObject2;
};
var DefaultCreateBackgroundCallback_default = DefaultCreateBackgroundCallback;

// node_modules/phaser3-rex-plugins/templates/ui/trees/builders/DefaultCreateNodeBodyCallback.js
var DefaultCreateNodeBodyCallback = function(scene, config, createCallbackData) {
  var gameObject2 = new SimpleLabel_default(scene, config);
  scene.add.existing(gameObject2);
  gameObject2.resetDisplayContent("");
  return gameObject2;
};
var DefaultCreateNodeBodyCallback_default = DefaultCreateNodeBodyCallback;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/node/Node.js
var GetValue209 = Phaser.Utils.Objects.GetValue;
var Node = class extends NodeBase_default(Sizer_default) {
  constructor(scene, config, createCallbackData) {
    var spaceConfig = config.space;
    super(scene, {
      orientation: "x",
      space: {
        left: GetValue209(spaceConfig, "nodeLeft", 0),
        right: GetValue209(spaceConfig, "nodeRight", 0),
        top: GetValue209(spaceConfig, "nodeTop", 0),
        bottom: GetValue209(spaceConfig, "nodeBottom", 0)
      }
    });
    this.type = "rexTreeNode";
    var background = CreateGameObjectFromConfig_default(
      scene,
      GetValue209(config, "nodeBackground"),
      // config
      createCallbackData,
      // callbackData
      DefaultCreateBackgroundCallback_default,
      // defaultCallback
      false
      // isRequired
    );
    var nodeBody = CreateGameObjectFromConfig_default(
      scene,
      GetValue209(config, "nodeBody"),
      // config
      createCallbackData,
      // callbackData
      DefaultCreateNodeBodyCallback_default,
      // defaultCallback
      true
      // isRequired
    );
    if (background) {
      this.addBackground(background);
    }
    this.add(
      nodeBody,
      { proportion: 1 }
    );
    this.nodeBody = nodeBody;
    this.addChildrenMap("background", background);
    this.addChildrenMap("nodeBody", nodeBody);
  }
  get isNode() {
    return true;
  }
  getTreePatent() {
    return this.rexSizer.treeParent;
  }
  getTreeRoot() {
    var treeParent = this.rexSizer.treeParent;
    if (!treeParent) {
      return null;
    }
    return treeParent.getTreeRoot();
  }
  getTreesSizer() {
    var root = this.getTreeRoot();
    return root ? root.getParentSizer() : null;
  }
};
var Node_default = Node;

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/SyncDisplayList.js
var SyncDisplayList2 = function(sourceGameObject, targetGameObject) {
  var p3Container = sourceGameObject.parentContainer;
  if (p3Container) {
    if (targetGameObject.isRexContainerLite) {
      targetGameObject.addToContainer(p3Container);
    } else {
      p3Container.add(targetGameObject);
    }
    return;
  }
  var layer = sourceGameObject.displayList;
  if (IsLayerGameObject_default(layer)) {
    if (targetGameObject.isRexContainerLite) {
      targetGameObject.addToLayer(layer);
    } else {
      layer.add(targetGameObject);
    }
    return;
  }
  sourceGameObject.scene.add.existing(targetGameObject);
};
var SyncDisplayList_default = SyncDisplayList2;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/methods/AddNodeMethods.js
var UUID5 = Phaser.Utils.String.UUID;
var AddNodeMethods_default = {
  addTree(config, nodeKey2) {
    if (IsGameObject_default(config)) {
      var nodeBody = config;
      config = {
        nodeBody,
        nodeKey: nodeKey2
      };
    }
    return this.insertTree(void 0, config);
  },
  insertTree(index, config) {
    var nodeKey2;
    if (typeof config === "string") {
      nodeKey2 = config;
      config = void 0;
    } else if (config) {
      nodeKey2 = config.nodeKey;
      delete config.nodeKey;
    }
    if (nodeKey2 === void 0) {
      nodeKey2 = UUID5();
    }
    var tree = this.createTree(config);
    SyncDisplayList_default(this, tree);
    this.insertNode(index, tree, { expand: true });
    tree._postAddCallback();
    return tree;
  },
  addNode(gameObject2, config) {
    return this.insertNode(void 0, gameObject2, config);
  },
  insertNode(index, gameObject2, config) {
    var nodeKey2;
    if (!IsGameObject_default(gameObject2)) {
      config = gameObject2;
      gameObject2 = new Node_default(this.scene, this.configSave, { isLeaf: true });
    }
    if (typeof config === "string") {
      nodeKey2 = config;
      config = void 0;
    } else if (config) {
      nodeKey2 = config.nodeKey;
      delete config.nodeKey;
    }
    if (nodeKey2 === void 0) {
      nodeKey2 = UUID5();
    }
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("expand")) {
      config.expand = true;
    }
    this.removeNode(gameObject2, false);
    gameObject2.rexSizer.treeParent = this;
    if (this.nodesMap.hasOwnProperty(nodeKey2)) {
      console.error(`[Trees] Duplicate nodeKey '${nodeKey2}'`);
      this.removeNode(this.nodesMap[nodeKey2], true);
    }
    gameObject2.nodeKey = nodeKey2;
    this.nodesMap[nodeKey2] = gameObject2;
    var childrenSizer = this.childrenMap.child;
    childrenSizer.insert(index, gameObject2, config);
    return gameObject2;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/methods/RemoveNodeMethods.js
var RemoveNodeMethods_default = {
  removeNode(gameObject2, destroyChild) {
    if (typeof gameObject2 === "string") {
      gameObject2 = this.getTree(gameObject2);
    }
    if (!gameObject2) {
      return this;
    }
    var treeParent = this.getTreePatent(gameObject2);
    if (!treeParent) {
      return this;
    }
    delete treeParent.nodesMap[gameObject2.nodeKey];
    gameObject2.nodeKey = null;
    gameObject2.rexSizer.treeParent = null;
    var childrenSizer = treeParent.childrenMap.child;
    childrenSizer.remove(gameObject2, destroyChild);
    return this;
  },
  removeAllNodes(destroyChild) {
    var nodesMap = this.nodesMap;
    for (var nodeKey2 in nodesMap) {
      this.removeNode(nodesMap[nodeKey2], destroyChild);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/methods/GetNodeMethods.js
var GetNodeMethods_default = {
  getNode(mapNameList) {
    if (typeof mapNameList === "string") {
      mapNameList = mapNameList.split(".");
    }
    if (mapNameList.length === 0) {
      return void 0;
    }
    var name2 = mapNameList.shift();
    var element = this.nodesMap[name2];
    if (mapNameList.length === 0) {
      return element;
    } else if (element && this.isTreeObject(element)) {
      return element.getNode(mapNameList);
    } else {
      return null;
    }
  },
  getNodes(out2) {
    var nodesMap = this.nodesMap;
    if (!out2) {
      out2 = nodes;
    } else {
      for (var nodeKey2 in nodesMap) {
        out2.push(nodesMap[nodeKey2]);
      }
    }
    return out2;
  },
  getAllNodes(out2) {
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/methods/Methods.js
var methods40 = {
  pointToChild: PointToChild_default3
};
Object.assign(
  methods40,
  ParentMethods_default,
  AddNodeMethods_default,
  RemoveNodeMethods_default,
  GetNodeMethods_default
);
var Methods_default42 = methods40;

// node_modules/phaser3-rex-plugins/templates/ui/trees/builders/DefaultCreateToggleButtonCallback.js
var DefaultCreateToggleButtonCallback = function(scene, config, createCallbackData) {
  var gameObject2 = new Triangle_default3(scene, config);
  scene.add.existing(gameObject2);
  gameObject2.on("expand.start", function(gameObject3) {
    gameObject3.setDirection("down");
  }).on("collapse.complete", function(gameObject3) {
    gameObject3.setDirection("right");
  });
  return gameObject2;
};
var DefaultCreateToggleButtonCallback_default = DefaultCreateToggleButtonCallback;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/node/CreateTitleSizer.js
var GetValue210 = Phaser.Utils.Objects.GetValue;
var CreateTitleSizer = function(scene, config) {
  var nodeSizer = new Node_default(scene, config, { isLeaf: false });
  scene.add.existing(nodeSizer);
  var toggleButton = CreateGameObjectFromConfig_default(
    scene,
    GetValue210(config, "toggleButton"),
    // config
    { isLeaf: false },
    // callbackData
    DefaultCreateToggleButtonCallback_default,
    // defaultCallback
    true
    // isRequired
  );
  nodeSizer.insert(
    0,
    toggleButton,
    {
      padding: {
        right: GetValue210(config, "space.toggleButton", 0)
      },
      fitRatio: 1
    }
  );
  nodeSizer.addChildrenMap("toggleButton", toggleButton);
  return nodeSizer;
};
var CreateTitleSizer_default = CreateTitleSizer;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/node/CreateChildrenSizer.js
var GetValue211 = Phaser.Utils.Objects.GetValue;
var CreateChildrenSizer = function(scene, config) {
  var childrenSizer = new Sizer_default(scene, {
    orientation: GetValue211(config, "childrenOrientation", "y")
  });
  scene.add.existing(childrenSizer);
  var childrenBackground = CreateGameObjectFromConfig_default(
    scene,
    GetValue211(config, "childrenBackground"),
    // config
    { isLeaf: false },
    // callbackData
    DefaultCreateBackgroundCallback_default,
    // defaultCallback
    false
    // isRequired
  );
  if (childrenBackground) {
    childrenSizer.addBackground(childrenBackground);
  }
  return childrenSizer;
};
var CreateChildrenSizer_default = CreateChildrenSizer;

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/Merge.js
var Clone2 = Phaser.Utils.Objects.Clone;
var Merge5 = function(defaultConfig, overrideConfig) {
  var config = defaultConfig ? Clone2(defaultConfig) : {};
  if (!overrideConfig) {
    return config;
  }
  for (var name2 in overrideConfig) {
    config[name2] = overrideConfig[name2];
  }
  return config;
};
var Merge_default = Merge5;

// node_modules/phaser3-rex-plugins/templates/ui/trees/tree/Tree.js
var GetValue212 = Phaser.Utils.Objects.GetValue;
var Tree = class _Tree extends NodeBase_default(Folder_default) {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var background = CreateGameObjectFromConfig_default(
      scene,
      GetValue212(config, "background"),
      // config
      { isLeaf: false },
      // callbackData
      DefaultCreateBackgroundCallback_default,
      // defaultCallback
      false
      // isRequired
    );
    var child = CreateChildrenSizer_default(scene, config);
    var childrenNodes = child.childrenMap.items;
    var title = CreateTitleSizer_default(scene, config);
    var toggleButton = title.childrenMap.toggleButton;
    var nodeBody = title.childrenMap.nodeBody;
    var orientation = GetOrientationMode_default2(GetValue212(config, "orientation", "y"));
    var spaceConfig = config.space;
    if (spaceConfig) {
      var indent = GetValue212(spaceConfig, "indent", 0);
      spaceConfig.childLeft = GetValue212(spaceConfig, "indentLeft", orientation === 1 ? indent : 0);
      spaceConfig.childRight = GetValue212(spaceConfig, "indentRight", 0);
      spaceConfig.childTop = GetValue212(spaceConfig, "indentTop", orientation === 0 ? indent : 0);
      spaceConfig.childBottom = GetValue212(spaceConfig, "indentBottom", 0);
    }
    var folderConfig = {
      background,
      title,
      child,
      toggleByTarget: toggleButton,
      transition: config.transition,
      orientation,
      space: spaceConfig,
      align: config.align,
      expand: config.expand
    };
    super(scene, folderConfig);
    this.type = "rexTree";
    this.rexSizer.treeParent = null;
    this.nodesMap = {};
    this.configSave = config;
    this.nodeBody = nodeBody;
    this.addChildrenMap("toggleButton", toggleButton);
    this.addChildrenMap("nodeBody", nodeBody);
    this.addChildrenMap("childrenNodes", childrenNodes);
    this.on("expand.start", function() {
      toggleButton.emit("expand.start", toggleButton);
      FireTreesSizerEvent(this, "expand.start");
    }, this).on("expand.complete", function() {
      toggleButton.emit("expand.complete", toggleButton);
      FireTreesSizerEvent(this, "expand.complete");
    }).on("collapse.start", function() {
      toggleButton.emit("collapse.start", toggleButton);
      FireTreesSizerEvent(this, "collapse.start");
    }).on("collapse.complete", function() {
      toggleButton.emit("collapse.complete", toggleButton);
      FireTreesSizerEvent(this, "collapse.complete");
    });
    var tree = this;
    tree._postAddCallback = function() {
      var expanded = GetValue212(config, "expanded", true);
      if (expanded !== void 0) {
        tree.setExpandedState(expanded);
      }
      delete tree._postAddCallback;
    };
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.configSave = void 0;
    Clear(this.nodesMap);
    this.nodesMap = void 0;
    super.destroy(fromScene);
  }
  get isTree() {
    return true;
  }
  createTree(config) {
    return _Tree.CreateTree(this.scene, this.configSave, config);
  }
  isTreeObject(gameObject2) {
    return gameObject2 && gameObject2 instanceof _Tree;
  }
};
Tree.CreateTree = function(scene, defaultConfig, overrideConfig) {
  return new Tree(scene, Merge_default(defaultConfig, overrideConfig));
};
var FireTreesSizerEvent = function(tree, eventName) {
  var treesSizer = tree.getTreesSizer();
  if (treesSizer) {
    treesSizer.emit(eventName, tree);
  }
};
Object.assign(
  Tree.prototype,
  Methods_default42
);
var Tree_default = Tree;

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/AddTreeMethods.js
var UUID6 = Phaser.Utils.String.UUID;
var AddTreeMethods_default = {
  addTree(config) {
    if (IsGameObject_default(config)) {
      var nodeBody = config;
      config = {
        nodeBody,
        nodeKey
      };
    }
    return this.insertTree(void 0, config);
  },
  insertTree(index, config) {
    var nodeKey2;
    if (typeof config === "string") {
      nodeKey2 = config;
      config = void 0;
    } else if (config) {
      nodeKey2 = config.nodeKey;
      delete config.nodeKey;
    }
    if (nodeKey2 === void 0) {
      nodeKey2 = UUID6();
    }
    var tree = Tree_default.CreateTree(this.scene, this.treeConfig, config);
    SyncDisplayList_default(this, tree);
    tree.nodeKey = nodeKey2;
    this.treesMap[nodeKey2] = tree;
    this.insert(index, tree, { expand: true });
    tree._postAddCallback();
    return tree;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/RemoveTreeMethods.js
var RemoveTreeMethods_default = {
  removeTree(gameObject2, destroyChild) {
    if (typeof gameObject2 === "string") {
      gameObject2 = this.getTree(gameObject2);
    }
    if (!gameObject2) {
      return this;
    }
    delete this.treesMap[gameObject2.nodeKey];
    gameObject2.nodeKey = null;
    this.remove(gameObject2, destroyChild);
    return this;
  },
  removeAllNodes(destroyChild) {
    var treesMap = this.treesMap;
    for (var nodeKey2 in treesMap) {
      this.removeTree(treesMap[nodeKey2], destroyChild);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/GetTreeMethods.js
var GetTreeMethods_default = {
  getTree(nodeKey2) {
    return this.treesMap[nodeKey2];
  },
  getTrees(out2) {
    if (out2 === void 0) {
      out2 = [];
    }
    for (var nodeKey2 in this.treesMap) {
      out2.push(this.treesMap[nodeKey2]);
    }
    return out2;
  },
  getNode(nodeKey2) {
    var dotIndex = nodeKey2.indexOf(".");
    if (dotIndex === -1) {
      return this.getTree(nodeKey2);
    }
    var tree = this.getTree(nodeKey2.substring(0, dotIndex));
    if (!tree) {
      return void 0;
    }
    return tree.getNode(nodeKey2.substring(dotIndex + 1));
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/trees/methods/Methods.js
var methods41 = {
  pointToChild: PointToChild_default2,
  setChildrenInteractive: SetChildrenInteractive_default4
};
Object.assign(
  methods41,
  AddTreeMethods_default,
  RemoveTreeMethods_default,
  GetTreeMethods_default
);
var Methods_default43 = methods41;

// node_modules/phaser3-rex-plugins/templates/ui/trees/Trees.js
var GetValue213 = Phaser.Utils.Objects.GetValue;
var Trees = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("orientation")) {
      config.orientation = "y";
    }
    super(scene, config);
    this.type = "rexTrees";
    this.treesMap = {};
    this.treeConfig = GetValue213(config, "tree");
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.treeConfig = void 0;
    Clear(this.treesMap);
    this.treesMap = void 0;
    super.destroy(fromScene);
  }
};
Object.assign(
  Trees.prototype,
  Methods_default43
);
var Trees_default = Trees;

// node_modules/phaser3-rex-plugins/templates/ui/trees/Factory.js
ObjectFactory_default.register("trees", function(config) {
  var gameObject2 = new Trees_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Trees", Trees_default);

// node_modules/phaser3-rex-plugins/templates/ui/textarea/Factory.js
ObjectFactory_default.register("textArea", function(config) {
  var gameObject2 = new TextArea_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TextArea", TextArea_default);

// node_modules/phaser3-rex-plugins/templates/ui/textareainput/InjectProperties.js
var InjectProperties3 = function(inputText) {
  Object.defineProperty(inputText, "childOY", {
    configurable: true,
    get: function() {
      return inputText.textOY;
    },
    set: function(value) {
      inputText.textOY = value;
    }
  });
  Object.defineProperty(inputText, "topChildOY", {
    get: function() {
      return inputText.topTextOY;
    }
  });
  Object.defineProperty(inputText, "bottomChildOY", {
    get: function() {
      return inputText.bottomTextOY;
    }
  });
  Object.defineProperty(inputText, "childVisibleHeight", {
    get: function() {
      return inputText.textVisibleHeight;
    }
  });
  Object.defineProperty(inputText, "childHeight", {
    get: function() {
      return inputText.contentHeight;
    }
  });
};
var InjectProperties_default3 = InjectProperties3;

// node_modules/phaser3-rex-plugins/templates/ui/textareainput/SetTextMethods.js
var SetTextMethods_default3 = {
  setText(text) {
    var inputText = this.childrenMap.child;
    inputText.setText(text);
    return this;
  },
  appendText(text) {
    this.setText(this.text + text);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/textareainput/ScrollMethods.js
var ScrollMethods_default3 = {
  scrollToLine(lineIndex) {
    this.setChildOY(-this.lineHeight * lineIndex);
    return this;
  },
  scrollToNextLine(lineCount) {
    if (lineCount === void 0) {
      lineCount = 1;
    }
    var lineIndex = this.lineIndex + lineCount;
    this.scrollToLine(lineIndex);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/textareainput/TextAreaInput.js
var GetValue214 = Phaser.Utils.Objects.GetValue;
var TextAreaInput = class extends Scrollable_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    var inputTextConfig = GetValue214(config, "text");
    var inputText;
    if (IsGameObject_default(inputTextConfig)) {
      inputText = inputTextConfig;
    } else {
      if (inputTextConfig === void 0) {
        inputTextConfig = {};
      }
      inputTextConfig.textArea = true;
      inputText = new CanvasInput_default2(scene, inputTextConfig);
      scene.add.existing(inputText);
    }
    InjectProperties_default3(inputText);
    var expandInputTextWidth = inputTextConfig.width === void 0;
    var expandInputTextHeight = inputTextConfig.height === void 0;
    if (expandInputTextWidth) {
      inputText.minWidth = 0;
    }
    if (expandInputTextHeight) {
      inputText.minHeight = 0;
    }
    config.scrollMode = 0;
    config.type = "rexTextAreaInput";
    config.child = {
      gameObject: inputText,
      expandWidth: expandInputTextWidth,
      expandHeight: expandInputTextHeight
    };
    var spaceConfig = GetValue214(config, "space", void 0);
    if (spaceConfig) {
      spaceConfig.child = GetValue214(spaceConfig, "text", 0);
    }
    config.scroller = false;
    super(scene, config);
    this.addChildrenMap("text", inputText);
    var prevTextOY, prevContentHeight;
    inputText.on("cursorin", function() {
      var textOY = inputText.textOY, contentHeight = inputText.contentHeight;
      var isTextOYChanged = prevTextOY !== textOY;
      var isContentHeightChanged = prevContentHeight !== contentHeight;
      prevTextOY = textOY;
      prevContentHeight = contentHeight;
      if (isContentHeightChanged) {
        this.resizeController();
      }
      if (isTextOYChanged || isContentHeightChanged) {
        this.t = inputText.t;
      }
    }, this);
    inputText.on("textchange", function(text) {
      this.emit("textchange", text, this);
    }, this).on("close", function() {
      this.emit("close", this.text, this);
    }, this);
    var content = GetValue214(config, "content", void 0);
    if (content) {
      this.setText(content);
    }
  }
  get text() {
    return this.childrenMap.child.text;
  }
  set text(value) {
    if (value == null) {
      value = "";
    } else {
      value = value.toString();
    }
    if (this.childrenMap.child.text === value) {
      return;
    }
    this.setText(value);
  }
  get lineHeight() {
    var inputText = this.childrenMap.child;
    return inputText.lineHeight;
  }
  get lineIndex() {
    return Math.floor(-this.childOY / this.lineHeight);
  }
  get linesCount() {
    var inputText = this.childrenMap.child;
    return inputText.linesCount;
  }
  get contentHeight() {
    var inputText = this.childrenMap.child;
    return inputText.contentHeight;
  }
  get readOnly() {
    var inputText = this.childrenMap.child;
    return inputText.readOnly;
  }
  set readOnly(value) {
    var inputText = this.childrenMap.child;
    inputText.readOnly = value;
  }
  setReadOnly(value) {
    var inputText = this.childrenMap.child;
    inputText.setReadOnly(value);
    return this;
  }
  get value() {
    return this.text;
  }
  set value(value) {
    this.text = value;
  }
};
Object.assign(
  TextAreaInput.prototype,
  SetTextMethods_default3,
  ScrollMethods_default3
);
var TextAreaInput_default = TextAreaInput;

// node_modules/phaser3-rex-plugins/templates/ui/textareainput/Factory.js
ObjectFactory_default.register("textAreaInput", function(config) {
  var gameObject2 = new TextAreaInput_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.TextAreaInput", TextAreaInput_default);

// node_modules/phaser3-rex-plugins/templates/ui/scrollablepanel/Factory.js
ObjectFactory_default.register("scrollablePanel", function(config) {
  var gameObject2 = new ScrollablePanel_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ScrollablePanel", ScrollablePanel_default);

// node_modules/phaser3-rex-plugins/templates/ui/toast/methods/DefaultTransitionCallbacks.js
var DefaultTransitionCallbacks_default = {
  popUp: function(gameObject2, duration) {
    gameObject2.popUp(duration);
  },
  scaleDown: function(gameObject2, duration) {
    gameObject2.scaleDown(duration);
  },
  fadeIn: function(gameObject2, duration) {
    gameObject2.fadeIn(duration);
  },
  fadeOut: function(gameObject2, duration) {
    gameObject2.fadeOut(duration);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/toast/methods/TransitionMode.js
var TransitionMode2 = {
  popUp: 0,
  fadeIn: 1,
  scaleDown: 0,
  fadeOut: 1
};
var TransitionMode_default = TransitionMode2;

// node_modules/phaser3-rex-plugins/templates/ui/toast/methods/ConfigurationMethods.js
var ConfigurationMethods_default4 = {
  setDisplayTime(time) {
    this.displayTime = time;
    return this;
  },
  setTransitOutTime(time) {
    this.transitOutTime = time;
    return this;
  },
  setTransitInTime(time) {
    this.transitInTime = time;
    return this;
  },
  setTransitInCallback(callback) {
    if (typeof callback === "string") {
      callback = TransitionMode_default[callback];
    }
    switch (callback) {
      case TransitionMode_default.popUp:
        callback = DefaultTransitionCallbacks_default.popUp;
        break;
      case TransitionMode_default.fadeIn:
        callback = DefaultTransitionCallbacks_default.fadeIn;
        break;
    }
    if (!callback) {
      callback = NOOP_default;
    }
    this.transitInCallback = callback;
    return this;
  },
  setTransitOutCallback(callback) {
    if (typeof callback === "string") {
      callback = TransitionMode_default[callback];
    }
    switch (callback) {
      case TransitionMode_default.scaleDown:
        callback = DefaultTransitionCallbacks_default.scaleDown;
        break;
      case TransitionMode_default.fadeOut:
        callback = DefaultTransitionCallbacks_default.fadeOut;
        break;
    }
    if (!callback) {
      callback = NOOP_default;
    }
    this.transitOutCallback = callback;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/toast/methods/MessageMethods.js
var MessageMethods_default = {
  showMessage(message) {
    if (this.scaleX0 === void 0) {
      this.scaleX0 = this.scaleX;
    }
    if (this.scaleY0 === void 0) {
      this.scaleY0 = this.scaleY;
    }
    if (message === void 0) {
      if (this.messages.length === 0) {
        return this;
      }
      message = this.messages.shift();
    }
    if (this.player.isPlaying) {
      this.messages.push(message);
      return this;
    }
    this.setScale(this.scaleX0, this.scaleY0).setVisible(true);
    if (typeof message === "string") {
      this.setText(message);
    } else {
      message(this);
    }
    this.layout();
    var commands = [
      [
        // Transit-in
        0,
        // time
        [this.transitInCallback, this, this.transitInTime]
        // [callback, param, ...]
      ],
      [
        // Transit-in event
        0,
        // time
        [this.emit, "transitin", this, this.transitInTime]
        // [callback, param, ...]
      ],
      [
        // Hold
        this.transitInTime,
        [NOOP_default]
      ],
      [
        // Transit-out
        this.displayTime,
        [this.transitOutCallback, this, this.transitOutTime]
      ],
      // Transit-out event
      [
        0,
        // time
        [this.emit, "transitout", this, this.transitOutTime]
        // [callback, param, ...]
      ],
      [
        // End
        this.transitOutTime,
        [this.setVisible, false]
      ],
      [
        // Complete - show next message
        30,
        // Add a small delay before complete
        [NOOP_default]
      ]
    ];
    this.player.load(commands, this).once("complete", function() {
      this.showMessage();
    }, this).start();
    return this;
  },
  removeAllMessages() {
    this.messages.length = 0;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/toast/Toast.js
var GetValue215 = Phaser.Utils.Objects.GetValue;
var Toast = class extends Label_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {
        text: createDefaultTextObject(scene)
      };
    }
    super(scene, config);
    this.type = "rexToast";
    this.setTransitInTime(GetValue215(config, "duration.in", 200));
    this.setDisplayTime(GetValue215(config, "duration.hold", 1200));
    this.setTransitOutTime(GetValue215(config, "duration.out", 200));
    this.setTransitInCallback(GetValue215(config, "transitIn", TransitionMode_default.popUp));
    this.setTransitOutCallback(GetValue215(config, "transitOut", TransitionMode_default.scaleDown));
    this.player = new Player_default(this, { dtMode: 1 });
    this.messages = [];
    this.scaleX0 = void 0;
    this.scaleY0 = void 0;
    this.setVisible(false);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.player.destroy();
    this.player = void 0;
    this.messages = void 0;
    super.destroy(fromScene);
  }
  setScale(scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    this.scaleX0 = scaleX;
    this.scaleY0 = scaleY;
    super.setScale(scaleX, scaleY);
    return this;
  }
  get isShowingMessage() {
    return this.player.isPlaying;
  }
};
Object.assign(
  Toast.prototype,
  ConfigurationMethods_default4,
  MessageMethods_default
);
var Toast_default = Toast;

// node_modules/phaser3-rex-plugins/templates/ui/toast/Factory.js
ObjectFactory_default.register("toast", function(config) {
  var gameObject2 = new Toast_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Toast", Toast_default);

// node_modules/phaser3-rex-plugins/templates/ui/toastqueue/methods/ConfigurationMethods.js
var QueueDirectionMap = {
  "bottom-to-top": 1,
  "top-to-bottom": 0,
  "right-to-left": 1,
  "left-to-right": 0
};
var ConfigurationMethods_default5 = {
  setQueueDirection(direction) {
    if (typeof direction === "string") {
      direction = QueueDirectionMap[direction];
    }
    this.rtl = direction === 0;
    if (this.orientation === 1) {
      if (direction) {
        this.queueDirection = 0;
      } else {
        this.queueDirection = 1;
      }
    } else {
      if (direction) {
        this.queueDirection = 2;
      } else {
        this.queueDirection = 3;
      }
    }
    return this;
  },
  setCreateMessageLabelCallback(callback) {
    this.createMessageLabelCallback = callback;
    return this;
  },
  setDisplayTime(time) {
    this.displayTime = time;
    return this;
  },
  setTransitOutTime(time) {
    this.transitOutTime = time;
    return this;
  },
  setTransitInTime(time) {
    this.transitInTime = time;
    return this;
  },
  setTransitInCallback(callback) {
    if (!callback) {
      callback = NOOP_default;
    }
    this.transitInCallback = callback;
    return this;
  },
  setTransitOutCallback(callback) {
    if (!callback) {
      callback = NOOP_default;
    }
    this.transitOutCallback = callback;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/toastqueue/methods/MessageMethods.js
var OnClick = ClickMethods_default.onClick;
var DelayCall = DelayCallMethods_default.delayCall;
var MoveTo = EaseMoveMethods_default2.moveTo;
var CreateChild = function(parent, callback, message) {
  var child = callback(parent.scene, message, parent);
  OnClick.call(child, function() {
    parent.removeMessage(child);
  });
  if (parent.displayTime) {
    var delay = parent.transitInTime + parent.displayTime + 10;
    DelayCall.call(child, delay, function() {
      parent.removeMessage(child);
    });
  }
  return child;
};
var GetChildrenPosition = function(parent) {
  var children = parent.childrenMap.items, child;
  var positionList = [];
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    positionList.push({ x: child.x, y: child.y });
  }
  return positionList;
};
var RunLayout2 = function(parent) {
  var children = parent.childrenMap.items, child;
  var scaleList = [];
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    child = children[i];
    scaleList.push({ x: child.scaleX, y: child.scaleY });
    child.setScale(1);
  }
  parent.layout();
  var newPositionList = GetChildrenPosition(parent);
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var scaleData = scaleList[i];
    children[i].setScale(scaleData.x, scaleData.y);
  }
  return newPositionList;
};
var EaseChildren = function(parent, prevPositionList, newPositionList, duration) {
  var children = parent.childrenMap.items;
  var listLength = Math.min(prevPositionList.length, newPositionList.length, children.length);
  var child, prevPositionData, newPostionData;
  var queueDirection = parent.queueDirection;
  for (var i = 0; i < listLength; i++) {
    child = children[i];
    prevPositionData = prevPositionList[i];
    newPostionData = newPositionList[i];
    child.setPosition(prevPositionData.x, prevPositionData.y);
    switch (queueDirection) {
      case 0:
        if (prevPositionData.y <= newPostionData.y) {
          continue;
        }
        break;
      case 1:
        if (prevPositionData.y >= newPostionData.y) {
          continue;
        }
        break;
      case 2:
        if (prevPositionData.x <= newPostionData.x) {
          continue;
        }
        break;
      case 3:
        if (prevPositionData.x >= newPostionData.x) {
          continue;
        }
        break;
    }
    MoveTo.call(child, duration, newPostionData.x, newPostionData.y);
  }
};
var PushChild = function(parent, child, duration) {
  var prevPositionList = GetChildrenPosition(parent);
  parent.add(child);
  var newPositionList = RunLayout2(parent);
  EaseChildren(parent, prevPositionList, newPositionList, duration);
  parent.transitInCallback(child, duration, parent);
};
var MessageMethods_default2 = {
  showMessage(message) {
    var child = CreateChild(this, this.createMessageLabelCallback, message);
    PushChild(this, child, this.transitInTime);
    return this;
  },
  removeMessage(messageLabel) {
    if (this.getParentSizer(messageLabel) !== this) {
      return this;
    }
    if (messageLabel.__isDestroying) {
      return;
    }
    messageLabel.__isDestroying = true;
    var duration = this.transitOutTime;
    this.transitOutCallback(messageLabel, duration, this);
    DelayCall.call(messageLabel, duration + 10, function() {
      delete messageLabel.__isDestroying;
      messageLabel.destroy();
    });
    return this;
  },
  removeAllMessages() {
    var children = this.childrenMap.items;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      this.removeMessage(children[i]);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/toastqueue/methods/Methods.js
var Methods20 = {};
Object.assign(
  Methods20,
  ConfigurationMethods_default5,
  MessageMethods_default2
);
var Methods_default44 = Methods20;

// node_modules/phaser3-rex-plugins/templates/ui/toastqueue/methods/DefaultTransitionMethods.js
var DefaultTransitionMethods_default = {
  transitIn(gameObject2, duration, parent) {
    switch (parent.queueDirection) {
      case 0:
        gameObject2.setOrigin(0.5, 1);
        ScaleMethods_default2.popUp.call(gameObject2, duration, "y");
        break;
      case 1:
        gameObject2.setOrigin(0.5, 0);
        ScaleMethods_default2.popUp.call(gameObject2, duration, "y");
        break;
      case 2:
        gameObject2.setOrigin(1, 0.5);
        ScaleMethods_default2.popUp.call(gameObject2, duration, "x");
        break;
      case 3:
        gameObject2.setOrigin(0, 0.5);
        ScaleMethods_default2.popUp.call(gameObject2, duration, "x");
        break;
    }
    FadeMethods_default3.fadeIn.call(gameObject2, duration);
  },
  transitOut(gameObject2, duration, parent) {
    FadeMethods_default3.fadeOut.call(gameObject2, duration);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/toastqueue/ToastQueue.js
var GetValue216 = Phaser.Utils.Objects.GetValue;
var ToastQueue = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    if (!config.hasOwnProperty("orientation")) {
      config.orientation = 1;
    }
    super(scene, config);
    this.type = "rexToastQueue";
    this.setCreateMessageLabelCallback(GetValue216(config, "createMessageLabelCallback"));
    this.setQueueDirection(GetValue216(config, "queueDirection", 1));
    this.setTransitInTime(GetValue216(config, "duration.in", 200));
    this.setDisplayTime(GetValue216(config, "duration.hold", 2e3));
    this.setTransitOutTime(GetValue216(config, "duration.out", 200));
    this.setTransitInCallback(GetValue216(config, "transitIn", DefaultTransitionMethods_default.transitIn));
    this.setTransitOutCallback(GetValue216(config, "transitOut", DefaultTransitionMethods_default.transitOut));
  }
};
Object.assign(
  ToastQueue.prototype,
  Methods_default44
);
var ToastQueue_default = ToastQueue;

// node_modules/phaser3-rex-plugins/templates/ui/toastqueue/Factory.js
ObjectFactory_default.register("toastQueue", function(config) {
  var gameObject2 = new ToastQueue_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ToastQueue", ToastQueue_default);

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinputbase/methods/CreateSwatch.js
var CreateSwatch = function(scene, config) {
  if (config === false) {
    return null;
  } else if (IsGameObject_default(config)) {
    return config;
  }
  var swatch = new RoundRectangle_default3(scene, config);
  scene.add.existing(swatch);
  return swatch;
};
var CreateSwatch_default = CreateSwatch;

// node_modules/phaser3-rex-plugins/plugins/utils/color/GetHexColorString.js
var Pad2 = Phaser.Utils.String.Pad;
var GetHexColorString = function(value, prefix) {
  if (prefix === void 0) {
    prefix = "0x";
  }
  var colorString = value.toString(16).toUpperCase();
  colorString = Pad2(colorString, 6, 0, 1);
  colorString = prefix + colorString;
  return colorString;
};
var GetHexColorString_default = GetHexColorString;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinputbase/methods/SetSwatchColor.js
var SetSwatchColor = function(swatch, color) {
  if (!swatch) {
    return;
  }
  if (swatch.setTint) {
    swatch.setTint(color);
  } else if (swatch.setFillStyle) {
    swatch.setFillStyle(color);
  }
};
var SetSwatchColor_default = SetSwatchColor;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinputbase/ColorInputBase.js
var GetValue217 = Phaser.Utils.Objects.GetValue;
var IsPlainObject57 = Phaser.Utils.Objects.IsPlainObject;
var Clamp17 = Phaser.Math.Clamp;
var ColorInput = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = 0;
    super(scene, config);
    this.type = "rexColorInputLite";
    var background = GetValue217(config, "background", void 0);
    var swatchConfig = GetValue217(config, "swatch");
    var swatchSize;
    if (IsPlainObject57(swatchConfig)) {
      swatchSize = GetValue217(swatchConfig, "size");
    }
    var swatch = CreateSwatch_default(scene, GetValue217(config, "swatch"));
    var inputTextConfig = GetValue217(config, "inputText", {});
    var inputText;
    if (inputTextConfig) {
      inputText = CreateInputText_default(scene, inputTextConfig);
    }
    if (background) {
      this.addBackground(background);
    }
    if (swatch) {
      swatchSize = GetValue217(config, "swatchSize", swatchSize);
      var squareExpandSwatch;
      if (swatchSize !== void 0) {
        ResizeGameObject_default(swatch, swatchSize, swatchSize);
        squareExpandSwatch = false;
      } else {
        squareExpandSwatch = GetValue217(config, "squareExpandSwatch", true);
      }
      var fitRatio = squareExpandSwatch ? 1 : 0;
      this.add(
        swatch,
        { proportion: 0, expand: true, fitRatio }
      );
    }
    if (inputText) {
      var proportion = GetValue217(inputTextConfig, "width") === void 0 ? 1 : 0;
      var expand = GetValue217(inputTextConfig, "height") === void 0 ? true : false;
      this.add(
        inputText,
        { proportion, expand }
      );
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("swatch", swatch);
    this.addChildrenMap("inputText", inputText);
    if (inputText) {
      inputText.on("close", function() {
        this.setValue(inputText.value);
      }, this);
    }
    var callback = GetValue217(config, "valuechangeCallback", null);
    if (callback !== null) {
      var scope = GetValue217(config, "valuechangeCallbackScope", void 0);
      this.on("valuechange", callback, scope);
    }
    this.setValue(GetValue217(config, "value", 0));
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (typeof value === "string") {
      value = ColorStringToInteger_default(value);
      if (value == null) {
        var inputText = this.childrenMap.inputText;
        if (inputText) {
          inputText.setText(GetHexColorString_default(this._value));
        }
        return;
      }
    } else {
      value = Clamp17(Math.floor(value), 0, 16777215);
    }
    if (this._value === value) {
      return;
    }
    this._value = value;
    var swatch = this.childrenMap.swatch;
    if (swatch) {
      SetSwatchColor_default(swatch, value);
    }
    var inputText = this.childrenMap.inputText;
    if (inputText) {
      inputText.setText(GetHexColorString_default(value));
    }
    this.emit("valuechange", this._value);
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  get color() {
    return this._value;
  }
  set color(color) {
    this.value = color;
  }
  setColor(color) {
    this.color = color;
    return this;
  }
};
var ColorInputBase_default = ColorInput;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinput/methods/ConfigurationMethods.js
var methods42 = {
  // Color picker
  setCreateColorPickerBackgroundCallback(callback) {
    this.colorPickerCreateBackgroundCallback = callback;
    return this;
  },
  setColorPickerHPalettePosition(position) {
    this.colorPickerHPalettePosition = position;
    return this;
  },
  setColorPickerExpandDirection(direction) {
    if (typeof direction === "string") {
      direction = ColorPickerExpandDirections[direction];
    }
    this.colorPickerExpandDirection = direction;
    return this;
  },
  setColorPickerEaseInDuration(duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.colorPickerEaseInDuration = duration;
    return this;
  },
  setColorPickerEaseOutDuration(duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.colorPickerEaseOutDuration = duration;
    return this;
  },
  setColorPickerTransitInCallback(callback) {
    this.colorPickerTransitInCallback = callback;
    return this;
  },
  setColorPickerTransitOutCallback(callback) {
    this.colorPickerTransitOutCallback = callback;
    return this;
  },
  setColorPickerBounds(bounds) {
    this.colorPickerBounds = bounds;
    return this;
  },
  setColorPickerWidth(width) {
    this.colorPickerWidth = width;
    return this;
  },
  setColorPickerHeight(height) {
    this.colorPickerHeight = height;
    return this;
  },
  setColorPickerSize(width, height) {
    this.setColorPickerWidth(width).setColorPickerHeight(height);
    return this;
  },
  setColorPickerSpace(space) {
    if (space === void 0) {
      space = {};
    }
    this.colorPickerSpace = space;
    return this;
  },
  // Color components
  setColorComponentsHeight(height) {
    this.colorComponentsHeight = height;
    return this;
  },
  setColorComponentsFormatLabelConfig(config) {
    this.colorComponentsFormatLabelConfig = config;
    return this;
  },
  setColorComponentsInputTextConfig(config) {
    this.colorComponentsInputTextConfig = config;
    return this;
  },
  setColorComponentsSpace(space) {
    if (space === void 0) {
      space = {};
    }
    this.colorComponentsSpace = space;
    return this;
  }
};
var ColorPickerExpandDirections = {
  down: 0,
  up: 1
};
var ConfigurationMethods_default6 = methods42;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/DrawHSVPalette.js
var Color2 = Phaser.Display.Color;
var Percent4 = Phaser.Math.Percent;
var DrawHPalette = function(canvas, context, verticalMode) {
  if (verticalMode === void 0) {
    verticalMode = false;
  }
  var width = canvas.width;
  var height = canvas.height;
  var color = new Color2();
  if (verticalMode) {
    for (var iy = 0; iy < height; iy++) {
      var h = Percent4(iy, 0, height);
      color.setFromHSV(h, 1, 1);
      context.fillStyle = color.rgba;
      context.fillRect(0, iy, width, 1);
    }
  } else {
    for (var ix = 0; ix < width; ix++) {
      var h = Percent4(ix, 0, width);
      color.setFromHSV(h, 1, 1);
      context.fillStyle = color.rgba;
      context.fillRect(ix, 0, 1, height);
    }
  }
};
var DrawSVPalette = function(canvas, context, h) {
  var width = canvas.width;
  var height = canvas.height;
  var imgData = context.getImageData(0, 0, width, height);
  var data = imgData.data;
  var color = new Color2();
  for (var iy = 0; iy < height; iy++) {
    for (var ix = 0; ix < width; ix++) {
      var s = Percent4(ix, 0, width);
      var v = 1 - Percent4(iy, 0, height);
      color.setFromHSV(h, s, v);
      var i = (iy * width + ix) * 4;
      data[i] = color.red;
      data[i + 1] = color.green;
      data[i + 2] = color.blue;
      data[i + 3] = 255;
    }
  }
  context.putImageData(imgData, 0, 0);
};

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorpicker/methods/HPaletteCanvas.js
var Color3 = Phaser.Display.Color;
var Percent5 = Phaser.Math.Percent;
var ColorToRGBA = Phaser.Display.Color.ColorToRGBA;
var HSVToRGB = Phaser.Display.Color.HSVToRGB;
var HPaletteCanvas = class extends Canvas_default3 {
  constructor(scene, x, y, width, height, orientation) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 2;
    }
    if (height === void 0) {
      height = 2;
    }
    super(scene, x, y, width, height);
    this.type = "rexColorPicker.HPaletteCanvas";
    this.colorObject = new Color3();
    this.setOrientation(orientation);
    this.setSize(width, height);
  }
  setOrientation(orientation) {
    this.orientation = GetOrientationMode_default2(orientation);
    return this;
  }
  updateTexture() {
    DrawHPalette(this.canvas, this.context, this.orientation);
    super.updateTexture();
    return this;
  }
  get color() {
    return this.colorObject.color;
  }
  get hue() {
    return this._hue;
  }
  set hue(value) {
    this._hue = value;
  }
  getHue(localX, localY) {
    if (localX === void 0) {
      return this.hue;
    }
    if (this.orientation === 0) {
      this.hue = Percent5(localX, 0, this.width);
    } else {
      this.hue = Percent5(localY, 0, this.height);
    }
    return this.hue;
  }
  getColor(localX, localY) {
    if (localX === void 0) {
      return this.color;
    }
    var h = this.getHue(localX, localY);
    this.colorObject.setFromRGB(HSVToRGB(h, 1, 1));
    return this.colorObject.color;
  }
  setColor(color) {
    if (this.color === color) {
      return this;
    }
    return this;
  }
  colorToLocalPosition(color, out2) {
    if (out2 === void 0) {
      out2 = {};
    } else if (out2 === true) {
      if (LocalXY === void 0) {
        LocalXY = {};
      }
      out2 = LocalXY;
    }
    this.colorObject.setFromRGB(ColorToRGBA(color));
    if (this.orientation === 0) {
      out2.x = this.width * this.colorObject.h;
      out2.y = this.height / 2;
    } else {
      out2.x = this.width / 2;
      out2.y = this.height * this.colorObject.h;
    }
    return out2;
  }
};
var LocalXY = void 0;
var HPaletteCanvas_default = HPaletteCanvas;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorpicker/methods/Transform.js
var RotateAround8 = Phaser.Math.RotateAround;
var LocalToWorld = function(gameObject2, localX, localY, out2) {
  if (out2 === void 0) {
    out2 = {};
  } else if (out2 === true) {
    if (GlobOut === void 0) {
      GlobOut = {};
    }
    out2 = GlobOut;
  }
  localX -= gameObject2.width * gameObject2.originX;
  localY -= gameObject2.height * gameObject2.originY;
  var point = {
    x: localX * gameObject2.scaleX,
    y: localY * gameObject2.scaleY
  };
  RotateAround8(point, 0, 0, -gameObject2.rotation);
  out2.x = gameObject2.x + localX;
  out2.y = gameObject2.y + localY;
  return out2;
};
var GlobOut;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorpicker/methods/HPalette.js
var HPalette = class extends OverlapSizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    var orientation = config.width != null ? 1 : 0;
    var paletteCanvas = new HPaletteCanvas_default(scene).setOrientation(orientation);
    scene.add.existing(paletteCanvas);
    this.type = "rexColorPicker.HPalette";
    paletteCanvas.setInteractive().on("pointerdown", this.onPaletteCanvasPointerDown, this).on("pointermove", this.onPaletteCanvasPointerDown, this);
    var marker = new RoundRectangle_default3(scene, { strokeColor: 16777215, strokeWidth: 2 });
    scene.add.existing(marker);
    this.add(
      paletteCanvas,
      { key: "paletteCanvas", expand: true }
    ).add(
      marker,
      { key: "marker", expand: false }
    );
  }
  resize(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }
    super.resize(width, height);
    var size = Math.min(width, height);
    this.childrenMap.marker.setSize(size, size);
    return this;
  }
  onPaletteCanvasPointerDown(pointer, localX, localY, event) {
    if (!pointer.isDown) {
      return;
    }
    var paletteCanvas = this.childrenMap.paletteCanvas;
    var color = paletteCanvas.getColor(localX, localY);
    this.setMarkerPosition(color);
    this.emit("input", color);
  }
  get color() {
    return this.childrenMap.paletteCanvas.color;
  }
  setColor(color) {
    if (this.color === color) {
      return this;
    }
    var paletteCanvas = this.childrenMap.paletteCanvas;
    paletteCanvas.setColor(color);
    this.setMarkerPosition(color);
    return this;
  }
  setMarkerPosition(color) {
    var paletteCanvas = this.childrenMap.paletteCanvas;
    var marker = this.childrenMap.marker;
    var localXY = paletteCanvas.colorToLocalPosition(color, true);
    LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
    this.resetChildPositionState(marker);
    return this;
  }
  getHue(localX, localY) {
    var paletteCanvas = this.childrenMap.paletteCanvas;
    return paletteCanvas.getHue(localX, localY);
  }
};
var HPalette_default = HPalette;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorpicker/methods/SVPaletteCanvas.js
var Color4 = Phaser.Display.Color;
var Percent6 = Phaser.Math.Percent;
var ColorToRGBA2 = Phaser.Display.Color.ColorToRGBA;
var HSVToRGB2 = Phaser.Display.Color.HSVToRGB;
var SVPaletteCanvas = class extends Canvas_default3 {
  constructor(scene, x, y, width, height, hue) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = 2;
    }
    if (height === void 0) {
      height = 2;
    }
    super(scene, x, y, width, height);
    this.type = "rexColorPicker.SVPaletteCanvas";
    if (hue === void 0) {
      hue = 1;
    }
    this.colorObject = new Color4();
    this.setHue(hue);
    this.setSize(width, height);
  }
  get color() {
    return this.colorObject.color;
  }
  get hue() {
    return this._hue;
  }
  set hue(hue) {
    if (this._hue === hue) {
      return;
    }
    this._hue = hue;
    this.colorObject.h = hue;
    this.dirty = true;
  }
  setHue(hue) {
    this.hue = hue;
    return this;
  }
  updateTexture() {
    DrawSVPalette(this.canvas, this.context, this.hue);
    super.updateTexture();
    return this;
  }
  getColor(localX, localY) {
    if (localX === void 0) {
      return this.colorObject.color;
    }
    var s = Percent6(localX, 0, this.width);
    var v = 1 - Percent6(localY, 0, this.height);
    this.colorObject.setFromRGB(HSVToRGB2(this.hue, s, v));
    return this.colorObject.color;
  }
  setColor(color) {
    if (this.color === color) {
      return this;
    }
    this.colorObject.setFromRGB(ColorToRGBA2(color));
    this.setHue(this.colorObject.h);
    return this;
  }
  colorToLocalPosition(color, out2) {
    if (out2 === void 0) {
      out2 = {};
    } else if (out2 === true) {
      if (LocalXY2 === void 0) {
        LocalXY2 = {};
      }
      out2 = LocalXY2;
    }
    this.colorObject.setFromRGB(ColorToRGBA2(color));
    out2.x = this.width * this.colorObject.s;
    out2.y = this.height * (1 - this.colorObject.v);
    return out2;
  }
};
var LocalXY2 = void 0;
var SVPaletteCanvas_default = SVPaletteCanvas;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorpicker/methods/SVPalette.js
var SVPalette = class extends OverlapSizer_default {
  constructor(scene, config) {
    super(scene, config);
    var paletteCanvas = new SVPaletteCanvas_default(scene);
    scene.add.existing(paletteCanvas);
    this.type = "rexColorPicker.SVPalette";
    paletteCanvas.setInteractive().on("pointerdown", this.onPaletteCanvasPointerDown, this).on("pointermove", this.onPaletteCanvasPointerDown, this);
    var marker = new RoundRectangle_default3(scene, { radius: 5, strokeColor: 16777215, strokeWidth: 2 });
    scene.add.existing(marker);
    this.add(
      paletteCanvas,
      { key: "paletteCanvas", expand: true }
    ).add(
      marker,
      { key: "marker", expand: false }
    );
  }
  onPaletteCanvasPointerDown(pointer, localX, localY, event) {
    if (!pointer.isDown) {
      return;
    }
    var paletteCanvas = this.childrenMap.paletteCanvas;
    var color = paletteCanvas.getColor(localX, localY);
    this.setMarkerPosition(color);
    this.emit("input", color);
  }
  get color() {
    return this.childrenMap.paletteCanvas.color;
  }
  setHue(hue) {
    var paletteCanvas = this.childrenMap.paletteCanvas;
    paletteCanvas.setHue(hue);
    return this;
  }
  setColor(color) {
    if (this.color === color) {
      return this;
    }
    var paletteCanvas = this.childrenMap.paletteCanvas;
    paletteCanvas.setColor(color);
    this.setMarkerPosition(color);
    return this;
  }
  setMarkerPosition(color) {
    var paletteCanvas = this.childrenMap.paletteCanvas;
    var marker = this.childrenMap.marker;
    var localXY = paletteCanvas.colorToLocalPosition(color, true);
    LocalToWorld(paletteCanvas, localXY.x, localXY.y, marker);
    this.resetChildPositionState(marker);
    return this;
  }
};
var SVPalette_default = SVPalette;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorpicker/ColorPicker.js
var GetValue218 = Phaser.Utils.Objects.GetValue;
var ColorPicker = class extends Sizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexColorPicker";
    this.freezePalettes = false;
    var hPalettePosition = GetValue218(config, "hPalette.position", 0);
    if (typeof hPalettePosition === "string") {
      hPalettePosition = HPalettePositionNamesMap[hPalettePosition];
    }
    var orientation = hPalettePosition === 0 || // bottom
    hPalettePosition === 2 ? 1 : (
      // y
      0
    );
    this.setOrientation(orientation);
    var background = GetValue218(config, "background", void 0);
    var hPaletteWidth, hPaletteHeight;
    if (this.orientation === 0) {
      var hPaletteWidth = GetValue218(config, "hPalette.width", void 0);
      if (hPaletteWidth === void 0) {
        hPaletteWidth = GetValue218(config, "hPalette.size", 10);
      }
    } else {
      hPaletteHeight = GetValue218(config, "hPalette.height", void 0);
      if (hPaletteHeight === void 0) {
        hPaletteHeight = GetValue218(config, "hPalette.size", 10);
      }
    }
    var hPalette = new HPalette_default(scene, {
      width: hPaletteWidth,
      height: hPaletteHeight
    });
    scene.add.existing(hPalette);
    var svPaletteWidth = GetValue218(config, "svPalette.width", void 0);
    var svPaletteHeight = GetValue218(config, "svPalette.height", void 0);
    var svPalette = new SVPalette_default(scene, {
      width: svPaletteWidth,
      height: svPaletteHeight
    });
    scene.add.existing(svPalette);
    if (background) {
      this.addBackground(background);
    }
    var hPaletteAddConfig = {
      proportion: 0,
      expand: true
    };
    var svPaletteProportion, svPaletteExpand;
    if (this.orientation === 0) {
      svPaletteProportion = svPaletteWidth === void 0 ? 1 : 0;
      svPaletteExpand = svPaletteHeight === void 0 ? true : false;
    } else {
      svPaletteProportion = svPaletteHeight === void 0 ? 1 : 0;
      svPaletteExpand = svPaletteWidth === void 0 ? true : false;
    }
    var svPaletteAddConfig = {
      proportion: svPaletteProportion,
      expand: svPaletteExpand
    };
    if (hPalettePosition === 0 || hPalettePosition === 3) {
      this.add(svPalette, svPaletteAddConfig).add(hPalette, hPaletteAddConfig);
    } else {
      this.add(hPalette, hPaletteAddConfig).add(svPalette, svPaletteAddConfig);
    }
    hPalette.on("input", function() {
      svPalette.setHue(hPalette.getHue());
      this.setValue(svPalette.color, true);
    }, this);
    svPalette.on("input", function() {
      this.setValue(svPalette.color, true);
    }, this);
    this.addChildrenMap("background", background);
    this.addChildrenMap("hPalette", hPalette);
    this.addChildrenMap("svPalette", svPalette);
    var callback = GetValue218(config, "valuechangeCallback", null);
    if (callback !== null) {
      var scope = GetValue218(config, "valuechangeCallbackScope", void 0);
      this.on("valuechange", callback, scope);
    }
    this.setValue(GetValue218(config, "value", 16777215));
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value === value) {
      return;
    }
    var oldValue = this._value;
    this._value = value;
    if (!this.freezePalettes) {
      this.updatePalettes();
    }
    this.emit("valuechange", value, oldValue, this);
  }
  setValue(value, freezePalettes) {
    this.freezePalettes = !!freezePalettes;
    this.value = value;
    this.freezePalettes = false;
    return this;
  }
  get color() {
    return this._value;
  }
  set color(color) {
    this.value = color;
  }
  setColor(color) {
    this.color = color;
    return this;
  }
  updatePalettes() {
    this.childrenMap.hPalette.setColor(this.color);
    this.childrenMap.svPalette.setColor(this.color);
    return this;
  }
  postLayout(parent, newWidth, newHeight) {
    this.childrenMap.hPalette.setMarkerPosition(this.value);
    this.childrenMap.svPalette.setMarkerPosition(this.value);
    super.postLayout(parent, newWidth, newHeight);
    return this;
  }
};
var HPalettePositionNamesMap = {
  bottom: 0,
  left: 1,
  top: 2,
  right: 3
};
var ColorPicker_default = ColorPicker;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorcomponents/ColorComponents.js
var GetValue219 = Phaser.Utils.Objects.GetValue;
var Color5 = Phaser.Display.Color;
var ColorToRGBA3 = Phaser.Display.Color.ColorToRGBA;
var HSVToRGB3 = Phaser.Display.Color.HSVToRGB;
var Clamp18 = Phaser.Math.Clamp;
var ColorComponents = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = 0;
    super(scene, config);
    this.type = "rexColorComponents";
    this.colorObject = new Color5();
    var background = GetValue219(config, "background", void 0);
    var formatLabel = GetValue219(config, "formatLabel", void 0);
    if (!IsGameObject_default(formatLabel)) {
      formatLabel = CreateLabel_default(scene, formatLabel).resetDisplayContent();
    }
    var components = [];
    if (config.inputText0 && config.inputText1 && config.inputText2) {
      components.push(config.inputText0);
      components.push(config.inputText1);
      components.push(config.inputText2);
    } else {
      var inputTextConfig = GetValue219(config, "inputText");
      for (var i = 0; i < 3; i++) {
        var inputText = CreateInputText_default(scene, inputTextConfig).setMaxLength(3).setNumberInput();
        components.push(inputText);
      }
    }
    if (background) {
      this.addBackground(background);
    }
    var proportion = GetValue219(config, "proportion.formatLabel", 0);
    var defaultExpand = formatLabel.isRexContainerLite ? true : false;
    var expand = GetValue219(config, "expand.formatLabel", defaultExpand);
    this.add(
      formatLabel,
      { proportion, expand }
    );
    var proportion = GetValue219(inputTextConfig, "width") === void 0 ? 1 : 0;
    var expand = GetValue219(inputTextConfig, "height") === void 0 ? true : false;
    for (var i = 0, cnt = components.length; i < cnt; i++) {
      this.add(
        components[i],
        { proportion, expand }
      );
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("formatLabel", formatLabel);
    this.addChildrenMap("components", components);
    this.onClick(formatLabel, this.toggleColorFormat, this);
    for (var i = 0, cnt = components.length; i < cnt; i++) {
      components[i].on("close", function() {
        this.updateColorObject();
        this.setValue(this.colorObject.color);
      }, this);
    }
    var callback = GetValue219(config, "valuechangeCallback", null);
    if (callback !== null) {
      var scope = GetValue219(config, "valuechangeCallbackScope", void 0);
      this.on("valuechange", callback, scope);
    }
    formatLabel.setText("RGB");
    this.setValue(GetValue219(config, "value", 16777215));
  }
  get value() {
    return this._value;
  }
  set value(value) {
    value = Clamp18(Math.floor(value), 0, 16777215);
    if (this._value === value) {
      return;
    }
    this._value = value;
    this.colorObject.setFromRGB(ColorToRGBA3(value));
    this.updateComponents();
    this.emit("valuechange", this._value);
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  get color() {
    return this._value;
  }
  set color(color) {
    this.value = color;
  }
  setColor(color) {
    this.color = color;
    return this;
  }
  get colorFormat() {
    return this.childrenMap.formatLabel.text;
  }
  set colorFormat(value) {
    if (this.colorFormat === value) {
      return;
    }
    this.childrenMap.formatLabel.setText(value);
    this.updateComponents();
  }
  setColorFormat(colrType) {
    this.colorFormat = colrType;
    return this;
  }
  toggleColorFormat() {
    this.colorFormat = this.colorFormat === "RGB" ? "HSV" : "RGB";
    return this;
  }
  updateComponents() {
    var components = this.childrenMap.components;
    var value0, value1, value2;
    if (this.colorFormat === "RGB") {
      value0 = this.colorObject.red;
      value1 = this.colorObject.green;
      value2 = this.colorObject.blue;
    } else {
      value0 = Math.floor(this.colorObject.h * 360);
      value1 = Math.floor(this.colorObject.s * 100);
      value2 = Math.floor(this.colorObject.v * 100);
    }
    components[0].setValue(value0);
    components[1].setValue(value1);
    components[2].setValue(value2);
    return this;
  }
  updateColorObject() {
    var components = this.childrenMap.components;
    if (this.colorFormat === "RGB") {
      var red = Clamp18(components[0].value, 0, 255);
      var green = Clamp18(components[1].value, 0, 255);
      var blue = Clamp18(components[2].value, 0, 255);
      this.colorObject.setTo(red, green, blue);
    } else {
      var h = Clamp18(components[0].value, 0, 359) / 360;
      var s = Clamp18(components[1].value, 0, 100) / 100;
      var v = Clamp18(components[2].value, 0, 100) / 100;
      this.colorObject.setFromRGB(HSVToRGB3(h, s, v));
    }
    return this;
  }
};
var ColorComponents_default = ColorComponents;

// node_modules/phaser3-rex-plugins/templates/ui/toucheventstop/TouchEventStop.js
var TouchEventStop_default2 = toucheventstop_default;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinput/methods/ColorPicker.js
var GetValue220 = Phaser.Utils.Objects.GetValue;
var ColorPickerPanel = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = 1;
    super(scene, config);
    this.type = "rexColorInput.ColorPickerPanel";
    var background = GetValue220(config, "background", void 0);
    var colorPicker = new ColorPicker_default(scene, {
      hPalette: config.hPalette || {},
      svPalette: config.svPalette || {},
      space: {
        item: GetValue220(config, "space.hPalette", 8)
      }
    });
    scene.add.existing(colorPicker);
    var colorComponents;
    if (config.colorComponents) {
      colorComponents = new ColorComponents_default(scene, config.colorComponents);
      scene.add.existing(colorComponents);
    }
    if (background) {
      this.addBackground(background);
      var touchEventStop = new TouchEventStop_default2(background, {
        stopAllLevels: false
      });
    }
    this.add(
      colorPicker,
      { proportion: 1, expand: true }
    );
    if (colorComponents) {
      this.add(
        colorComponents,
        { proportion: 0, expand: true }
      );
    }
    this.addChildrenMap("background", background);
    this.addChildrenMap("colorPicker", colorPicker);
    this.addChildrenMap("colorComponents", colorComponents);
    colorPicker.on("valuechange", function(value) {
      this.setValue(value);
    }, this);
    if (colorComponents) {
      colorComponents.on("valuechange", function(value) {
        this.setValue(value);
      }, this);
    }
    this.setValue(GetValue220(config, "value", 16777215));
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value === value) {
      return;
    }
    this._value = value;
    var colorPicker = this.childrenMap.colorPicker;
    colorPicker.setValue(value);
    var colorComponents = this.childrenMap.colorComponents;
    if (colorComponents) {
      colorComponents.setValue(value);
    }
    this.emit("valuechange", value);
  }
  setValue(value) {
    this.value = value;
    return this;
  }
};
var ColorPicker_default2 = ColorPickerPanel;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinput/methods/CreateColorPicker.js
var GetValue221 = Phaser.Utils.Objects.GetValue;
var CreateColorPicker = function(scene) {
  var scene = this.scene;
  var background;
  var createBackgroundCallback = this.colorPickerCreateBackgroundCallback;
  if (createBackgroundCallback) {
    background = createBackgroundCallback.call(this, scene);
    scene.add.existing(background);
  }
  var width = this.colorPickerWidth;
  if (width === void 0) {
    width = this.width;
  }
  var height = this.colorPickerHeight;
  if (height === void 0) {
    height = width;
  }
  var colorComponentsConfig;
  if (this.colorComponentsHeight > 0) {
    colorComponentsConfig = {
      height: this.colorComponentsHeight,
      formatLabel: this.colorComponentsFormatLabelConfig,
      inputText: this.colorComponentsInputTextConfig,
      space: this.colorComponentsSpace
    };
  } else {
    colorComponentsConfig = false;
  }
  var colorPicker = new ColorPicker_default2(scene, {
    width,
    height,
    background,
    space: this.colorPickerSpace,
    hPalette: {
      position: this.colorPickerHPalettePosition
    },
    colorComponents: colorComponentsConfig,
    value: this.value
  });
  scene.add.existing(colorPicker);
  return colorPicker;
};
var CreateColorPicker_default = CreateColorPicker;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinput/methods/OpenColorPicker.js
var OpenColorPicker = function() {
  if (this.colorPicker) {
    return;
  }
  var colorPicker = CreateColorPicker_default.call(this).layout();
  var dropDownBehavior = new DropDown_default2(colorPicker, {
    // Transition
    duration: {
      in: this.colorPickerEaseInDuration,
      out: this.colorPickerEaseOutDuration
    },
    transitIn: this.colorPickerTransitInCallback,
    transitOut: this.colorPickerTransitOutCallback,
    // Position
    expandDirection: this.colorPickerExpandDirection,
    alignTargetX: this,
    alignTargetY: this,
    bounds: this.colorPickerBounds,
    // Close condition
    touchOutsideClose: true
  }).on("open", function() {
    colorPicker.on("valuechange", function(value) {
      this.setValue(value);
    }, this);
  }, this).on("close", function() {
    this.colorPicker = void 0;
    this.dropDownBehavior = void 0;
  }, this);
  this.colorPicker = colorPicker;
  this.dropDownBehavior = dropDownBehavior;
  this.pin(colorPicker);
  return this;
};
var OpenColorPicker_default = OpenColorPicker;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinput/methods/Methods.js
var methods43 = {
  openColorPicker: OpenColorPicker_default
};
Object.assign(
  methods43,
  ConfigurationMethods_default6
);
var Methods_default45 = methods43;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinput/ColorInput.js
var GetValue222 = Phaser.Utils.Objects.GetValue;
var ColorInput2 = class extends ColorInputBase_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexColorInput";
    if (!config.hasOwnProperty("colorPicker")) {
      config.colorPicker = {
        background: { color: 0 }
      };
    }
    var colorPickerConfig = config.colorPicker;
    var hasColorPicker = colorPickerConfig !== false && colorPickerConfig !== null;
    if (hasColorPicker) {
      this.setColorPickerSize(
        GetValue222(colorPickerConfig, "width", 160),
        GetValue222(colorPickerConfig, "height", 170)
      );
      var createBackgroundCallback;
      var background = GetValue222(colorPickerConfig, "background");
      if (background) {
        createBackgroundCallback = function(scene2) {
          return CreateBackground_default(scene2, background);
        };
      } else {
        createBackgroundCallback = GetValue222(colorPickerConfig, "createBackgroundCallback");
      }
      this.setCreateColorPickerBackgroundCallback(createBackgroundCallback);
      this.setColorPickerHPalettePosition(GetValue222(colorPickerConfig, "hPalettePosition", 0));
      this.setColorPickerExpandDirection(GetValue222(colorPickerConfig, "expandDirection"));
      this.setColorPickerEaseInDuration(GetValue222(colorPickerConfig, "easeIn", 200));
      this.setColorPickerEaseOutDuration(GetValue222(colorPickerConfig, "easeOut", 200));
      this.setColorPickerTransitInCallback(GetValue222(colorPickerConfig, "transitIn"));
      this.setColorPickerTransitOutCallback(GetValue222(colorPickerConfig, "transitOut"));
      this.setColorPickerBounds(GetValue222(colorPickerConfig, "bounds"));
      var colorPickerSpaceConfig = GetValue222(colorPickerConfig, "space");
      if (colorPickerSpaceConfig === void 0) {
        colorPickerSpaceConfig = { left: 10, right: 10, top: 10, bottom: 10, item: 8 };
      }
      this.setColorPickerSpace(colorPickerSpaceConfig);
    }
    var colorComponentsConfig = config.colorComponents;
    var hasColorComponents = colorComponentsConfig !== false && colorComponentsConfig !== null;
    if (hasColorPicker && hasColorComponents) {
      this.setColorComponentsHeight(GetValue222(colorComponentsConfig, "height", 30));
      this.setColorComponentsFormatLabelConfig(GetValue222(colorComponentsConfig, "formatLabel"));
      var colorComponentsInputTextConfig = GetValue222(colorComponentsConfig, "inputText");
      if (!colorComponentsInputTextConfig) {
        colorComponentsInputTextConfig = GetValue222(config, "inputText");
      }
      this.setColorComponentsInputTextConfig(colorComponentsInputTextConfig);
      var colorComponentsSpace = GetValue222(colorComponentsConfig, "space");
      if (colorComponentsSpace === void 0) {
        colorComponentsSpace = { item: 8 };
      }
      this.setColorComponentsSpace(colorComponentsSpace);
    }
    var swatch = this.childrenMap.swatch;
    if (swatch && hasColorPicker) {
      this.onClick(swatch, this.openColorPicker, this);
    }
  }
};
Object.assign(
  ColorInput2.prototype,
  Methods_default45
);
var ColorInput_default = ColorInput2;

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinput/Factory.js
ObjectFactory_default.register("colorInput", function(config) {
  var gameObject2 = new ColorInput_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ColorInput", ColorInput_default);

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorinputbase/Factory.js
ObjectFactory_default.register("colorInputLite", function(config) {
  var gameObject2 = new ColorInputBase_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ColorInputBase", ColorInputBase_default);

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorpicker/Factory.js
ObjectFactory_default.register("colorPicker", function(config) {
  var gameObject2 = new ColorPicker_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ColorPicker", ColorPicker_default);

// node_modules/phaser3-rex-plugins/templates/ui/colorinput/colorcomponents/Factory.js
ObjectFactory_default.register("colorComponents", function(config) {
  var gameObject2 = new ColorComponents_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.ColorComponents", ColorComponents_default);

// node_modules/phaser3-rex-plugins/plugins/utils/input/RequestDrag.js
var RequestDrag = function(gameObject2) {
  var inputPlugin = gameObject2.scene.input;
  var inputManager = inputPlugin.manager;
  var pointersTotal = inputManager.pointersTotal;
  var pointers = inputManager.pointers, pointer;
  for (var i = 0; i < pointersTotal; i++) {
    pointer = pointers[i];
    if (!pointer.primaryDown || inputPlugin.getDragState(pointer) !== 0 || !IsPointerInHitArea_default(gameObject2, pointer)) {
      continue;
    }
    inputPlugin.setDragState(pointer, 1);
    inputPlugin._drag[pointer.id] = [gameObject2];
    if (inputPlugin.dragDistanceThreshold === 0 || inputPlugin.dragTimeThreshold === 0) {
      inputPlugin.setDragState(pointer, 3);
      inputPlugin.processDragStartList(pointer);
    } else {
      inputPlugin.setDragState(pointer, 2);
    }
    return true;
  }
  return false;
};
var RequestDrag_default = RequestDrag;

// node_modules/phaser3-rex-plugins/plugins/input/drag/Drag.js
var GetValue223 = Phaser.Utils.Objects.GetValue;
var DistanceBetween8 = Phaser.Math.Distance.Between;
var RotateAroundDistance = Phaser.Math.RotateAroundDistance;
var Drag = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, { eventEmitter: false });
    this._enable = void 0;
    gameObject2.setInteractive(GetValue223(config, "inputConfig", void 0));
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    this.pointer = void 0;
    this.setEnable(GetValue223(o, "enable", true));
    this.setAxisMode(GetValue223(o, "axis", 0));
    this.setAxisRotation(GetValue223(o, "rotation", 0));
    return this;
  }
  toJSON() {
    return {
      enable: this.enable,
      axis: this.axisMode,
      rotation: this.axisRotation
    };
  }
  boot() {
    var gameObject2 = this.parent;
    gameObject2.on("dragstart", this.onDragStart, this);
    gameObject2.on("drag", this.onDrag, this);
    gameObject2.on("dragend", this.onDragEnd, this);
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.pointer = void 0;
    super.shutdown(fromScene);
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    if (this._enable === e) {
      return;
    }
    if (!e) {
      this.dragend();
    }
    this._enable = e;
    this.scene.input.setDraggable(this.parent, e);
    return this;
  }
  setEnable(e) {
    if (e === void 0) {
      e = true;
    }
    this.enable = e;
    return this;
  }
  toggleEnable() {
    this.setEnable(!this.enable);
    return this;
  }
  setAxisMode(m) {
    if (typeof m === "string") {
      m = DIRECTIONNODE2[m];
    }
    this.axisMode = m;
    return this;
  }
  setAxisRotation(a) {
    this.axisRotation = a;
    return this;
  }
  drag() {
    RequestDrag_default(this.parent);
    return this;
  }
  dragend() {
    if (!this.isDragging) {
      return;
    }
    this.scene.input.setDragState(this.pointer, 5);
    return this;
  }
  onDragStart(pointer, dragX, dragY) {
    if (this.isDragging) {
      return;
    }
    this.pointer = pointer;
  }
  onDrag(pointer, dragX, dragY) {
    if (this.pointer !== pointer) {
      return;
    }
    var gameObject2 = this.parent;
    if (this.axisMode === 0) {
      gameObject2.x = dragX;
      gameObject2.y = dragY;
    } else if (this.axisRotation === 0) {
      if (this.axisMode === 1) {
        gameObject2.x = dragX;
      } else if (this.axisMode === 2) {
        gameObject2.y = dragY;
      }
    } else {
      var dist;
      var p1 = { x: dragX, y: dragY };
      dist = DistanceBetween8(p1.x, p1.y, gameObject2.x, gameObject2.y);
      p1 = RotateAroundDistance(p1, gameObject2.x, gameObject2.y, -this.axisRotation, dist);
      if (this.axisMode === 1) {
        p1.y = gameObject2.y;
      } else if (this.axisMode === 2) {
        p1.x = gameObject2.x;
      }
      dist = DistanceBetween8(p1.x, p1.y, gameObject2.x, gameObject2.y);
      p1 = RotateAroundDistance(p1, gameObject2.x, gameObject2.y, this.axisRotation, dist);
      gameObject2.x = p1.x;
      gameObject2.y = p1.y;
    }
  }
  onDragEnd(pointer, dragX, dragY, dropped) {
    if (this.pointer !== pointer) {
      return;
    }
    this.pointer = void 0;
  }
  get isDragging() {
    return this.pointer !== void 0;
  }
};
var DIRECTIONNODE2 = {
  "both": 0,
  "h&v": 0,
  "x&y": 0,
  "horizontal": 1,
  "h": 1,
  "x": 1,
  "vertical": 2,
  "v": 2,
  "y": 2
};
var Drag_default = Drag;

// node_modules/phaser3-rex-plugins/templates/ui/splitpanels/methods/OnDragSplitter.js
var OnDragSplitter = function() {
  var firstChild = this.sizerChildren[0];
  var splitter = this.sizerChildren[1];
  var secondChild = this.sizerChildren[2];
  var firstChildSizerPadding = this.getSizerConfig(firstChild).padding, splitterSizerPadding = this.getSizerConfig(splitter).padding, secondChildSizerPadding = this.getSizerConfig(secondChild).padding;
  if (this.orientation === 0) {
    var firstChildInnerLeft = this.innerLeft + firstChildSizerPadding.left;
    var secondChildInnerRight = this.innerRight - secondChildSizerPadding.right;
    var splitterWidth = GetDisplayWidth(splitter);
    var splitterLeft = splitter.x + splitterWidth * (0 - splitter.originX);
    var splitterRight = splitter.x + splitterWidth * (1 - splitter.originX);
    var firstChildInnerRight = splitterLeft - splitterSizerPadding.left - this.space.item - firstChildSizerPadding.right;
    var secondChildInnerLeft = splitterRight + splitterSizerPadding.right + this.space.item + secondChildSizerPadding.left;
    var firstChildInnerWidth = firstChildInnerRight - firstChildInnerLeft;
    var secondChildInnerWidth = secondChildInnerRight - secondChildInnerLeft;
    var totalChildrenInnerWidth = firstChildInnerWidth + secondChildInnerWidth;
    if (this.minFirstChildSize > 0 && firstChildInnerWidth < this.minFirstChildSize) {
      firstChildInnerWidth = this.minFirstChildSize;
      secondChildInnerWidth = totalChildrenInnerWidth - firstChildInnerWidth;
    }
    if (this.minSecondChildSize > 0 && secondChildInnerWidth < this.minSecondChildSize) {
      secondChildInnerWidth = this.minSecondChildSize;
      firstChildInnerWidth = totalChildrenInnerWidth - secondChildInnerWidth;
    }
    this.setSplitRatio(firstChildInnerWidth / totalChildrenInnerWidth);
  } else {
    var firstChildInnerTop = this.innerTop + firstChildSizerPadding.top;
    var secondChildInnerBottom = this.innerBottom - secondChildSizerPadding.bottom;
    var splitterHeight = GetDisplayHeight(splitter);
    var splitterTop = splitter.y + splitterHeight * (0 - splitter.originY);
    var splitterBottom = splitter.y + splitterHeight * (1 - splitter.originY);
    var firstChildInnerBottom = splitterTop - splitterSizerPadding.top - this.space.item - firstChildSizerPadding.bottom;
    var secondChildInnerTop = splitterBottom + splitterSizerPadding.bottom + this.space.item + secondChildSizerPadding.top;
    var firstChildInnerHeight = firstChildInnerBottom - firstChildInnerTop;
    var secondChildInnerHeight = secondChildInnerBottom - secondChildInnerTop;
    var totalChildrenInnerHeight = firstChildInnerHeight + secondChildInnerHeight;
    if (this.minFirstChildSize > 0 && firstChildInnerHeight < this.minFirstChildSize) {
      firstChildInnerHeight = this.minFirstChildSize;
      secondChildInnerHeight = totalChildrenInnerHeight - firstChildInnerHeight;
    }
    if (this.minSecondChildSize > 0 && secondChildInnerHeight < this.minSecondChildSize) {
      secondChildInnerHeight = this.minSecondChildSize;
      firstChildInnerHeight = totalChildrenInnerHeight - secondChildInnerHeight;
    }
    this.setSplitRatio(firstChildInnerHeight / totalChildrenInnerHeight);
  }
  var minWidthSave = this.minWidth, minHeightSave = this.minHeight;
  this.setMinSize(this.width, this.height).layout().setMinSize(minWidthSave, minHeightSave);
};
var OnDragSplitter_default = OnDragSplitter;

// node_modules/phaser3-rex-plugins/templates/ui/splitpanels/SplitPanels.js
var GetValue224 = Phaser.Utils.Objects.GetValue;
var Clamp19 = Phaser.Math.Clamp;
var SplitPanels = class extends Sizer_default {
  constructor(scene, config) {
    if (!config.hasOwnProperty("orientation")) {
      config.orientation = config.hasOwnProperty("leftPanel") ? 0 : 1;
    }
    super(scene, config);
    this.type = "rexSplit";
    var background = GetValue224(config, "background", void 0);
    var firstChildKey, secondChildKey;
    var minFirstChildSizeKey, minSecondChildSizeKey;
    if (this.orientation === 0) {
      firstChildKey = "leftPanel";
      secondChildKey = "rightPanel";
      minFirstChildSizeKey = "minLeftPanelWidth";
      minSecondChildSizeKey = "minRightPanelWidth";
    } else {
      firstChildKey = "topPanel";
      secondChildKey = "bottomPanel";
      minFirstChildSizeKey = "minTopPanelHeight";
      minSecondChildSizeKey = "minBottomPanelHeight";
    }
    var firstChild = GetValue224(config, firstChildKey, void 0);
    var splitter = GetValue224(config, "splitter", void 0);
    var secondChild = GetValue224(config, secondChildKey, void 0);
    if (background) {
      this.addBackground(background);
    }
    var spaceConfig = GetValue224(config, "space", void 0);
    this.add(
      firstChild,
      {
        proportion: 1,
        expand: true,
        padding: {
          left: GetValue224(spaceConfig, `${firstChildKey}Left`, 0),
          right: GetValue224(spaceConfig, `${firstChildKey}Right`, 0),
          top: GetValue224(spaceConfig, `${firstChildKey}Top`, 0),
          bottom: GetValue224(spaceConfig, `${firstChildKey}Bottom`, 0)
        }
      }
    );
    this.add(
      splitter,
      {
        proportion: 0,
        expand: true,
        padding: {
          left: GetValue224(spaceConfig, "splitterLeft", 0),
          right: GetValue224(spaceConfig, "splitterRight", 0),
          top: GetValue224(spaceConfig, "splitterTop", 0),
          bottom: GetValue224(spaceConfig, "splitterBottom", 0)
        }
      }
    );
    this.add(
      secondChild,
      {
        proportion: 1,
        expand: true,
        padding: {
          left: GetValue224(spaceConfig, `${secondChildKey}Left`, 0),
          right: GetValue224(spaceConfig, `${secondChildKey}Right`, 0),
          top: GetValue224(spaceConfig, `${secondChildKey}Top`, 0),
          bottom: GetValue224(spaceConfig, `${secondChildKey}Bottom`, 0)
        }
      }
    );
    this.addChildrenMap("background", background);
    this.addChildrenMap(firstChildKey, firstChild);
    this.addChildrenMap("splitter", splitter);
    this.addChildrenMap(secondChildKey, secondChild);
    this.minFirstChildSize = GetValue224(config, minFirstChildSizeKey, 0);
    this.minSecondChildSize = GetValue224(config, minSecondChildSizeKey, 0);
    this.setSplitRatio(GetValue224(config, "splitRatio", 0.5));
    this.splitterDragBehavior = new Drag_default(splitter, {
      axis: this.orientation === 0 ? 1 : 2
    });
    splitter.on("dragstart", function() {
      this.emit("splitter.dragstart", splitter, this.splitRatio);
    }, this).on("dragend", function() {
      this.emit("splitter.dragend", splitter, this.splitRatio);
    }, this).on("drag", function() {
      OnDragSplitter_default.call(this);
      this.emit("splitter.drag", splitter, this.splitRatio);
    }, this).on("pointerover", function() {
      this.emit("splitter.over", splitter, this.splitRatio);
    }, this).on("pointerout", function() {
      this.emit("splitter.out", splitter, this.splitRatio);
    }, this);
  }
  get splitterEnable() {
    return this.splitterDragBehavior.enable;
  }
  set splitterEnable(value) {
    this.splitterDragBehavior.setEnable(value);
  }
  setSplitterEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.splitterEnable = enable;
    return this;
  }
  set minLeftPanelWidth(value) {
    this.minFirstChildSize = value;
  }
  get minLeftPanelWidth() {
    return this.minFirstChildSize;
  }
  set minRightPanelWidth(value) {
    this.minSecondChildSize = value;
  }
  get minRightPanelWidth() {
    return this.minSecondChildSize;
  }
  set minTopPanelHeight(value) {
    this.minFirstChildSize = value;
  }
  get minTopPanelHeight() {
    return this.minFirstChildSize;
  }
  set minBottomPanelHeight(value) {
    this.minSecondChildSize = value;
  }
  get minBottomPanelHeight() {
    return this.minSecondChildSize;
  }
  setMinLeftPanelWidth(value) {
    this.minLeftPanelWidth = value;
    return this;
  }
  setMinRightPanelWidth(value) {
    this.minRightPanelWidth = value;
    return this;
  }
  setMinTopPanelHeight(value) {
    this.minTopPanelHeight = value;
    return this;
  }
  setMinBottomPanelHeight(value) {
    this.minBottomPanelHeight = value;
    return this;
  }
  get splitRatio() {
    return this._splitRatio;
  }
  set splitRatio(value) {
    value = Clamp19(value, 0, 1);
    if (this._splitRatio === value) {
      return;
    }
    this._splitRatio = value;
    this.getSizerConfig(this.sizerChildren[0]).proportion = value;
    this.getSizerConfig(this.sizerChildren[2]).proportion = 1 - value;
  }
  setSplitRatio(value) {
    this.splitRatio = value;
    return this;
  }
};
var SplitPanels_default = SplitPanels;

// node_modules/phaser3-rex-plugins/templates/ui/splitpanels/Factory.js
ObjectFactory_default.register("splitPanels", function(config) {
  var gameObject2 = new SplitPanels_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.SplitPanels", SplitPanels_default);

// node_modules/phaser3-rex-plugins/templates/ui/sides/defaultcallbacks/VisibleCallbacks.js
var GetShowCallback = function() {
  return function(child, key2, sides, reset) {
    if (key2 !== "panel") {
      sides.setChildVisible(child, true);
    }
  };
};
var GetHideCallback = function() {
  return function(child, key2, sides, reset) {
    if (key2 !== "panel") {
      sides.setChildVisible(child, false);
    }
  };
};
var VisibleCallbacks_default = {
  show: GetShowCallback,
  hide: GetHideCallback
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/defaultcallbacks/FadeCallbacks.js
var GetShowCallback2 = function(duration, alpha) {
  if (alpha === void 0) {
    alpha = 1;
  }
  return function(child, key2, sides, reset) {
    if (key2 !== "panel") {
      sides.fadeChild(child, reset ? 0 : duration, alpha);
    }
  };
};
var GetHideCallback2 = function(duration, alpha) {
  if (alpha === void 0) {
    alpha = 0;
  }
  return function(child, key2, sides, reset) {
    if (key2 !== "panel") {
      sides.fadeChild(child, reset ? 0 : duration, alpha);
    }
  };
};
var FadeCallbacks_default = {
  show: GetShowCallback2,
  hide: GetHideCallback2
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/defaultcallbacks/MoveCallbacks.js
var GetCallback = function(duration, ease) {
  return function(child, key2, sides, reset) {
    if (key2 !== "panel") {
      sides.moveChild(child, reset ? 0 : duration, ease);
    }
  };
};
var MoveCallbacks_default = {
  show: GetCallback,
  hide: GetCallback
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/defaultcallbacks/MovePanelCallbacks.js
var GetCallback2 = function(duration, ease) {
  return function(child, key2, sides, reset) {
    if (key2 === "panel") {
      sides.moveChild(child, reset ? 0 : duration, ease);
    }
  };
};
var MovePanelCallbacks_default = {
  show: GetCallback2,
  hide: GetCallback2
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/defaultcallbacks/GetDefaultCallbacks.js
var DefaultCallbacks = {
  visible: VisibleCallbacks_default,
  fade: FadeCallbacks_default,
  move: MoveCallbacks_default,
  "move-panel": MovePanelCallbacks_default
};
var GetDefaultCallbacks = function(config) {
  var callbackType, callbackParams;
  [callbackType, ...callbackParams] = typeof config === "string" ? [config] : config;
  var showCallback, hideCallback;
  if (DefaultCallbacks.hasOwnProperty(callbackType)) {
    showCallback = DefaultCallbacks[callbackType].show.apply(null, callbackParams);
    hideCallback = DefaultCallbacks[callbackType].hide.apply(null, callbackParams);
  } else {
    showCallback = NOOP_default;
    hideCallback = NOOP_default;
  }
  return {
    show: showCallback,
    hide: hideCallback
  };
};
var GetDefaultCallbacks_default = GetDefaultCallbacks;

// node_modules/phaser3-rex-plugins/templates/ui/sides/ShowChildMethods.js
var ShowChildMethods_default = {
  showChild(key2, reset) {
    var child = this.sizerChildren[key2];
    if (child) {
      this.emit("showchild", child, key2, this, reset);
      this.resetChildState(child);
    }
    return this;
  },
  hideChild(key2, reset) {
    var child = this.sizerChildren[key2];
    if (child) {
      this.emit("hidechild", child, key2, this, reset);
      this.resetChildState(child);
    }
    return this;
  },
  swapChild(key2, reset) {
    if (this.currentChildKey === key2) {
    } else if (this.currentChildKey === "panel" || key2 === "panel") {
      this.previousChildKey = this.currentChildKey;
      this.currentChildKey = key2;
      this.hideChild(this.previousChildKey, reset);
      this.showChild(this.currentChildKey, reset);
    } else {
      this.swapChild("panel", reset);
      this.swapChild(key2, reset);
    }
    return this;
  },
  showPanel(reset) {
    this.swapChild("panel", reset);
    return this;
  },
  showLeftSide() {
    this.swapChild("leftSide");
    return this;
  },
  showRightSide() {
    this.swapChild("rightSide");
    return this;
  },
  showTopSide() {
    this.swapChild("topSide");
    return this;
  },
  showBottomSide() {
    this.swapChild("bottomSide");
    return this;
  },
  hideLeftSide() {
    if (this.currentChildKey == "leftSide") {
      this.showPanel();
    }
    return this;
  },
  hideRightSide() {
    if (this.currentChildKey == "rightSide") {
      this.showPanel();
    }
    return this;
  },
  hideTopSide() {
    if (this.currentChildKey == "topSide") {
      this.showPanel();
    }
    return this;
  },
  hideBottomSide() {
    if (this.currentChildKey == "bottomSide") {
      this.showPanel();
    }
    return this;
  },
  toggleLeftSide() {
    var key2 = this.currentChildKey !== "panel" ? "panel" : "leftSide";
    this.swapChild(key2);
    return this;
  },
  toggleRightSide() {
    var key2 = this.currentChildKey !== "panel" ? "panel" : "rightSide";
    this.swapChild(key2);
    return this;
  },
  toggleTopSide() {
    var key2 = this.currentChildKey !== "panel" ? "panel" : "topSide";
    this.swapChild(key2);
    return this;
  },
  toggleBottomSide() {
    var key2 = this.currentChildKey !== "panel" ? "panel" : "bottomSide";
    this.swapChild(key2);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/childbehaviors/Visible.js
var ContainerSetChildVisible2 = Container_default.prototype.setChildVisible;
var Visible_default2 = {
  setChildVisible(child, visible) {
    var key2;
    if (typeof child === "string") {
      var key2 = child;
      child = this.sizerChildren[key2];
    } else {
      key2 = IndexOf_default(this.sizerChildren, child);
    }
    if (visible === void 0) {
      visible = this.currentChildKey === key2 ? true : false;
    }
    ContainerSetChildVisible2.call(this, child, visible);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/childbehaviors/Fade.js
var Fade_default3 = {
  fadeChild(child, duration, alpha) {
    var key2;
    if (typeof child === "string") {
      key2 = child;
      child = this.sizerChildren[key2];
    } else {
      key2 = IndexOf_default(this.sizerChildren, child);
    }
    if (duration === void 0) {
      duration = 500;
    }
    if (alpha === void 0) {
      alpha = this.currentChildKey === key2 ? 1 : 0;
    }
    child.fadeIn(duration, { start: child.alpha, end: alpha });
    return this;
  },
  fadeChildPromise(child, duration, alpha) {
    if (typeof child === "string") {
      child = this.sizerChildren[key];
    }
    this.fadeChild(child, duration, alpha);
    if (child._fade) {
      return WaitComplete(child._fade);
    } else {
      return Promise.resolve();
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/childbehaviors/Move.js
var Move_default = {
  moveChild(child, duration, ease, distance) {
    var key2;
    if (typeof child === "string") {
      key2 = child;
      child = this.sizerChildren[key2];
    } else {
      key2 = IndexOf_default(this.sizerChildren, child);
    }
    if (duration === void 0) {
      duration = 500;
    }
    var isShownChild = this.currentChildKey === key2;
    if (distance === void 0) {
      switch (key2) {
        case "leftSide":
        case "rightSide":
          distance = GetDisplayWidth(child);
          break;
        case "topSide":
        case "bottomSide":
          distance = GetDisplayHeight(child);
          break;
        default:
          if (isShownChild) {
            switch (this.previousChildKey) {
              case "leftSide":
              case "rightSide":
                distance = GetDisplayWidth(this.sizerChildren[this.previousChildKey]);
                break;
              case "topSide":
              case "bottomSide":
                distance = GetDisplayHeight(this.sizerChildren[this.previousChildKey]);
                break;
              default:
                distance = 0;
                break;
            }
          } else {
            switch (this.currentChildKey) {
              case "leftSide":
              case "rightSide":
                distance = GetDisplayWidth(this.sizerChildren[this.currentChildKey]);
                break;
              case "topSide":
              case "bottomSide":
                distance = GetDisplayHeight(this.sizerChildren[this.currentChildKey]);
                break;
              default:
                distance = 0;
                break;
            }
          }
          break;
      }
    }
    var moveLeft, moveRight, moveUp, moveDown;
    if (isShownChild) {
      switch (key2) {
        case "panel":
          switch (this.previousChildKey) {
            case "leftSide":
              moveLeft = true;
              break;
            case "rightSide":
              moveRight = true;
              break;
            case "topSide":
              moveUp = true;
              break;
            case "bottomSide":
              moveDown = true;
              break;
          }
          break;
        case "leftSide":
          moveRight = true;
          break;
        case "rightSide":
          moveLeft = true;
          break;
        case "topSide":
          moveDown = true;
          break;
        case "bottomSide":
          moveUp = true;
          break;
      }
    } else {
      switch (key2) {
        case "panel":
          switch (this.currentChildKey) {
            case "leftSide":
              moveRight = true;
              break;
            case "rightSide":
              moveLeft = true;
              break;
            case "topSide":
              moveDown = true;
              break;
            case "bottomSide":
              moveUp = true;
              break;
          }
          break;
        case "leftSide":
          moveLeft = true;
          break;
        case "rightSide":
          moveRight = true;
          break;
        case "topSide":
          moveUp = true;
          break;
        case "bottomSide":
          moveDown = true;
          break;
      }
    }
    if (moveLeft) {
      child.moveTo(duration, `-=${distance}`, void 0, ease);
    } else if (moveRight) {
      child.moveTo(duration, `+=${distance}`, void 0, ease);
    } else if (moveUp) {
      child.moveTo(duration, void 0, `-=${distance}`, ease);
    } else if (moveDown) {
      child.moveTo(duration, void 0, `+=${distance}`, ease);
    } else {
      child.moveTo(0);
    }
    return this;
  },
  moveChildPromise(child, duration, ease, distance) {
    if (typeof child === "string") {
      child = this.sizerChildren[key];
    }
    this.moveChild(child, duration, ease, distance);
    if (child._easeMove) {
      return WaitComplete(child._easeMove);
    } else {
      return Promise.resolve();
    }
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/sides/childbehaviors/index.js
var methods44 = {};
Object.assign(
  methods44,
  Visible_default2,
  Fade_default3,
  Move_default
);
var childbehaviors_default = methods44;

// node_modules/phaser3-rex-plugins/templates/ui/sides/Sides.js
var GetValue225 = Phaser.Utils.Objects.GetValue;
var Sides = class extends OverlapSizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexSides";
    this.childrenMap = this.sizerChildren;
    this.previousChildKey = void 0;
    this.currentChildKey = void 0;
    var showChildCallback = GetValue225(config, "showChildCallback", void 0);
    if (showChildCallback) {
      if (IsFunction_default(showChildCallback)) {
        var showChildCallbackScope = GetValue225(config, "showChildCallbackScope", void 0);
        this.on("showchild", showChildCallback, showChildCallbackScope);
        var hideChildCallback = GetValue225(config, "hideChildCallback", void 0);
        var hideChildCallbackScope = GetValue225(config, "hideChildCallbackScope", void 0);
        this.on("hidechild", hideChildCallback, hideChildCallbackScope);
      } else {
        var defaultCallbacks = GetDefaultCallbacks_default(showChildCallback);
        this.on("showchild", defaultCallbacks.show);
        this.on("hidechild", defaultCallbacks.hide);
      }
    }
    var background = GetValue225(config, "background", void 0);
    var panel = GetValue225(config, "panel", void 0);
    var leftSide = GetValue225(config, "leftSide", void 0);
    var rightSide = GetValue225(config, "rightSide", void 0);
    var topSide = GetValue225(config, "topSide", void 0);
    var bottomSide = GetValue225(config, "bottomSide", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (panel) {
      this.add(panel, "panel", "center", 0, true);
    }
    if (leftSide) {
      var expand = GetValue225(config, "expand.left", true);
      this.add(leftSide, "leftSide", "left-top", 0, { height: expand });
    }
    if (rightSide) {
      var expand = GetValue225(config, "expand.right", true);
      this.add(rightSide, "rightSide", "right-top", 0, { height: expand });
    }
    if (topSide) {
      var expand = GetValue225(config, "expand.top", true);
      this.add(topSide, "topSide", "left-top", 0, { width: expand });
    }
    if (bottomSide) {
      var expand = GetValue225(config, "expand.bottom", true);
      this.add(bottomSide, "bottomSide", "left-bottom", 0, { width: expand });
    }
  }
  reset() {
    this.previousChildKey = void 0;
    this.currentChildKey = "panel";
    this.showChild("panel", true);
    this.hideChild("leftSide", true);
    this.hideChild("rightSide", true);
    this.hideChild("topSide", true);
    this.hideChild("bottomSide", true);
    return this;
  }
};
Object.assign(
  Sides.prototype,
  ShowChildMethods_default,
  childbehaviors_default
);
var Sides_default = Sides;

// node_modules/phaser3-rex-plugins/templates/ui/sides/Factory.js
ObjectFactory_default.register("sides", function(config) {
  var gameObject2 = new Sides_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Sides", Sides_default);

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/RegisterInputHandler.js
var RegisterInputHandler = function(config) {
  var isValidInputHandler = true;
  if (!config.hasOwnProperty("accept")) {
    isValidInputHandler = false;
    console.error(`[Tweaker] Can't register inputHandler '${config.name}', missing 'accept' callback.`);
  }
  if (!config.hasOwnProperty("build")) {
    isValidInputHandler = false;
    console.error(`[Tweaker] Can't register inputHandler '${config.name}', missing 'build' callback.`);
  }
  if (isValidInputHandler) {
    this.inputHandlers.unshift(config);
  }
  return this;
};
var RegisterInputHandler_default = RegisterInputHandler;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/RemoveInputHandler.js
var GetFirst = Phaser.Utils.Array.GetFirst;
var Remove4 = Phaser.Utils.Array.Remove;
var RemoveInputHandler = function(name2) {
  var handler = GetFirst(this.inputHandlers, "name", name2);
  if (handler) {
    Remove4(this.inputHandlers, handler);
  }
  return this;
};
var RemoveInputHandler_default = RemoveInputHandler;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/label/Title.js
var Title = class extends Label_default {
  constructor(scene, config) {
    config = BuildLabelConfig_default(scene, config);
    super(scene, config);
    this.type = "rexTweaker.Title";
  }
  setTitle(config) {
    config = config ? DeepClone_default(config) : {};
    if (config.hasOwnProperty("text")) {
    } else if (config.hasOwnProperty("title")) {
      config.text = config.title;
    } else {
      config.text = "";
    }
    this.resetDisplayContent(config);
    return this;
  }
};
var Title_default = Title;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/label/FolderTitle.js
var FolderTitle = class extends Title_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    super(scene, config);
    this.type = "rexTweaker.FolderTitle";
    var expandedIcon = new Triangle_default3(scene, config.expandedIcon);
    scene.add.existing(expandedIcon);
    this.addSpace().add(
      expandedIcon,
      { proportion: 0, expand: false, padding: 1, fitRatio: 1 }
    );
    this.addChildrenMap("expandedIcon", expandedIcon);
  }
  setExpandedState(expanded) {
    if (expanded === void 0) {
      expanded = true;
    }
    var direction = expanded ? "down" : "right";
    var expandedIcon = this.childrenMap.expandedIcon;
    expandedIcon.setDirection(direction);
    return this;
  }
};
var FolderTitle_default = FolderTitle;

// node_modules/phaser3-rex-plugins/plugins/utils/object/Merge.js
var Merge6 = function(obj1, obj2) {
  var clone = Clone_default(obj1);
  for (var key2 in obj2) {
    if (!clone.hasOwnProperty(key2)) {
      clone[key2] = obj2[key2];
    }
  }
  return clone;
};
var Merge_default2 = Merge6;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateBackground.js
var CreateBackground3 = function(scene, config, style) {
  return CreateBackground_default(scene, Merge_default2(config, style));
};
var CreateBackground_default3 = CreateBackground3;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/folder/BindingTargetMethods.js
var BindingTargetMethods_default = {
  setBindingTarget(target) {
    var child = this.childrenMap.child;
    child.setBindingTarget(target);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/folder/InputRowTitleWidthMethods.js
var InputRowTitleWidthMethods_default = {
  getMaxInputRowTitleWidth() {
    var child = this.childrenMap.child;
    var titleWidth = child.getMaxInputRowTitleWidth();
    return titleWidth + this.getInnerPadding("left");
  },
  setInputRowTitleWidth(width) {
    width -= this.getInnerPadding("left");
    var child = this.childrenMap.child;
    child.setInputRowTitleWidth(width);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/folder/Folder.js
var Folder2 = class extends Folder_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = 1;
    super(scene, config);
    this.type = "rexTweaker.Folder";
  }
  setTitle(config) {
    var title = this.childrenMap.title;
    title.setTitle(config);
    return this;
  }
};
Object.assign(
  Folder2.prototype,
  BindingTargetMethods_default,
  InputRowTitleWidthMethods_default
);
var Folder_default2 = Folder2;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateFolder.js
var GetValue226 = Phaser.Utils.Objects.GetValue;
var CreateFolder = function(parent, config, style) {
  var scene = parent.scene;
  var titleStyle = GetValue226(style, "title") || {};
  var title = new FolderTitle_default(scene, titleStyle);
  scene.add.existing(title);
  title.on("folder.expand", function() {
    title.setExpandedState(true);
  }).on("folder.collapse", function() {
    title.setExpandedState(false);
  });
  var tweakerConfig = {
    root: GetValue226(style, "root"),
    styles: GetValue226(style, "tweaker"),
    space: GetValue226(style, "space") || {}
  };
  var child = parent.createTweaker(tweakerConfig);
  var backgroundStyle = GetValue226(style, "background");
  var background = CreateBackground_default3(scene, config, backgroundStyle);
  var folder = new Folder_default2(scene, {
    title,
    child,
    background,
    transition: {
      duration: GetValue226(style, "transition.duration", 200)
    }
  });
  scene.add.existing(folder);
  return folder;
};
var CreateFolder_default = CreateFolder;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddFolder.js
var GetValue227 = Phaser.Utils.Objects.GetValue;
var AddFolder = function(config) {
  if (config === void 0) {
    config = {};
  }
  var folderStyle = GetValue227(this.styles, "folder") || {};
  folderStyle.tweaker = this.styles;
  folderStyle.root = this.root;
  var folder = CreateFolder_default(this, config, folderStyle);
  delete folderStyle.tweaker;
  delete folderStyle.root;
  this.add(
    folder,
    { expand: true }
  );
  folder.setTitle(config);
  var expanded = GetValue227(config, "expanded", true);
  if (expanded !== void 0) {
    folder.setExpandedState(expanded);
  }
  var childTweaker = folder.childrenMap.child;
  if (config.key) {
    this.root.addChildrenMap(config.key, childTweaker);
  }
  return childTweaker;
};
var AddFolder_default = AddFolder;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/tabpages/BindingTargetMethods.js
var BindingTargetMethods_default2 = {
  setBindingTarget(target) {
    var children = this.childrenMap.pages.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setBindingTarget(target);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/tabpages/InputRowTitleWidthMethods.js
var InputRowTitleWidthMethods_default2 = {
  getMaxInputRowTitleWidth() {
    var maxTitleWidth = 0;
    var children = this.childrenMap.pages.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      maxTitleWidth = Math.max(maxTitleWidth, children[i].getMaxInputRowTitleWidth());
    }
    return maxTitleWidth + this.getInnerPadding("left");
  },
  setInputRowTitleWidth(width) {
    width -= this.getInnerPadding("left");
    var children = this.childrenMap.pages.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setInputRowTitleWidth(width);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/tabpages/TabPages.js
var TabPages2 = class extends TabPages_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexTweaker.TabPages";
  }
};
Object.assign(
  TabPages2.prototype,
  BindingTargetMethods_default2,
  InputRowTitleWidthMethods_default2
);
var TabPages_default2 = TabPages2;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateTab.js
var GetValue228 = Phaser.Utils.Objects.GetValue;
var CreateTab = function(parent, config, style) {
  var scene = parent.scene;
  var tabPages = new TabPages_default2(scene, style);
  scene.add.existing(tabPages);
  var tabConfig = GetValue228(style, "tab");
  var tweakerConfig = {
    root: GetValue228(style, "root"),
    styles: GetValue228(style, "tweaker")
  };
  var pages = GetValue228(config, "pages") || [];
  for (var i = 0, cnt = pages.length; i < cnt; i++) {
    var page = pages[i];
    tabPages.addPage({
      key: page.title,
      tab: CreateLabel_default(scene, tabConfig).setActiveState(false).resetDisplayContent({ text: page.title }),
      page: parent.createTweaker(tweakerConfig)
    });
  }
  tabPages.on("tab.focus", function(tab, key2) {
    tab.setActiveState(true);
  }).on("tab.blur", function(tab, key2) {
    tab.setActiveState(false);
  });
  return tabPages;
};
var CreateTab_default = CreateTab;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddTab.js
var GetValue229 = Phaser.Utils.Objects.GetValue;
var AddTab = function(config) {
  if (config === void 0) {
    config = {};
  }
  var tabStyle = GetValue229(this.styles, "tab") || {};
  tabStyle.tweaker = this.styles;
  tabStyle.root = this.root;
  var tab = CreateTab_default(this, config, tabStyle);
  delete tabStyle.tweaker;
  delete tabStyle.root;
  this.add(
    tab,
    { expand: true }
  );
  var pagesConfig = GetValue229(config, "pages") || [];
  var pages = [];
  var shownPageIndex = 0;
  for (var i = 0, cnt = pagesConfig.length; i < cnt; i++) {
    var childTweaker = tab.getPage(i);
    var isPageShown = pagesConfig[i].show;
    if (isPageShown) {
      shownPageIndex = i;
    }
    var key2 = pagesConfig[i].key;
    if (key2) {
      this.root.addChildrenMap(key2, childTweaker);
    }
    pages.push(childTweaker);
  }
  tab.swapPage(shownPageIndex, 0);
  return pages;
};
var AddTab_default = AddTab;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/columns/BindingTargetMethods.js
var BindingTargetMethods_default3 = {
  setBindingTarget(target) {
    var children = this.childrenMap.columns;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setBindingTarget(target);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/columns/InputRowTitleWidthMethods.js
var InputRowTitleWidthMethods_default3 = {
  getMaxInputRowTitleWidth() {
    var maxTitleWidth = 0;
    var children = this.childrenMap.columns;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      maxTitleWidth = Math.max(maxTitleWidth, children[i].getMaxInputRowTitleWidth());
    }
    return maxTitleWidth + this.getInnerPadding("left");
  },
  setInputRowTitleWidth(width) {
    width -= this.getInnerPadding("left");
    var children = this.childrenMap.columns;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setInputRowTitleWidth(width);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/columns/Columns.js
var GetValue230 = Phaser.Utils.Objects.GetValue;
var Columns = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = "y";
    super(scene, config);
    this.type = "rexTweaker.Columns";
    var background = GetValue230(config, "background", void 0);
    var title = GetValue230(config, "title", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (title) {
      this.add(
        title,
        {
          expand: true,
          space: {
            bottom: GetValue230(config, "space.title", 0)
          }
        }
      );
    }
    var columnsSizer = new Sizer_default(scene, {
      orientation: "x",
      space: {
        item: GetValue230(config, "space.column", 0)
      }
    });
    scene.add.existing(columnsSizer);
    var columnConfigArray = GetValue230(config, "columns", void 0);
    var columnConfig;
    var columnChild;
    for (var i = 0, cnt = columnConfigArray.length; i < cnt; i++) {
      columnConfig = columnConfigArray[i];
      columnChild = columnConfig.child;
      columnsSizer.add(
        columnConfig.child,
        {
          proportion: columnChild.minWidth === 0 ? 1 : 0,
          expand: GetValue230(columnConfig, "expand", true)
        }
      );
    }
    this.add(
      columnsSizer,
      { expand: true }
    );
    this.addChildrenMap("title", title);
    this.addChildrenMap("columnsSizer", columnsSizer);
    this.addChildrenMap("columns", columnsSizer.childrenMap.items);
  }
  setTitle(config) {
    var title = this.childrenMap.title;
    if (config.title || config.icon) {
      title.show().setTitle(config);
    } else {
      title.hide();
    }
    return this;
  }
  getColumns() {
    return this.childrenMap.columns;
  }
  getColumn(index) {
    return this.childrenMap.columns[index];
  }
};
Object.assign(
  Columns.prototype,
  BindingTargetMethods_default3,
  InputRowTitleWidthMethods_default3
);
var Columns_default = Columns;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateColumns.js
var GetValue231 = Phaser.Utils.Objects.GetValue;
var CreateColumns = function(parent, config, style) {
  var scene = parent.scene;
  var titleStyle = GetValue231(style, "title") || {};
  var title = new Title_default(scene, titleStyle);
  scene.add.existing(title);
  var tweakerConfig = {
    root: GetValue231(style, "root"),
    styles: GetValue231(style, "tweaker")
  };
  var backgroundStyle = GetValue231(style, "background");
  if (backgroundStyle && !Array.isArray(backgroundStyle)) {
    backgroundStyle = [backgroundStyle];
  }
  var columnConfigArray = GetValue231(config, "columns", 2);
  if (typeof columnConfigArray === "number") {
    var columnCount = columnConfigArray;
    columnConfigArray = [];
    for (var i = 0, cnt = columnCount; i < cnt; i++) {
      columnConfigArray.push({});
    }
  }
  for (var i = 0, cnt = columnConfigArray.length; i < cnt; i++) {
    var columnConfig = columnConfigArray[i];
    if (backgroundStyle) {
      tweakerConfig.background = backgroundStyle[i % backgroundStyle.length];
    }
    tweakerConfig.width = GetValue231(columnConfig, "width", 0);
    var tweakerChild = parent.createTweaker(tweakerConfig);
    columnConfig.child = tweakerChild;
  }
  var columns = new Columns_default(scene, {
    title,
    columns: columnConfigArray,
    space: GetValue231(style, "space")
  });
  scene.add.existing(columns);
  return columns;
};
var CreateColumns_default = CreateColumns;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddColumns.js
var GetValue232 = Phaser.Utils.Objects.GetValue;
var AddColumns = function(config) {
  if (config === void 0) {
    config = {};
  }
  if (typeof config === "number") {
    config = {
      columns: config
    };
  }
  var columnsStyle = GetValue232(this.styles, "columns") || {};
  columnsStyle.tweaker = this.styles;
  columnsStyle.root = this.root;
  var columns = CreateColumns_default(this, config, columnsStyle);
  delete columnsStyle.tweaker;
  delete columnsStyle.root;
  this.add(
    columns,
    { expand: true }
  );
  columns.setTitle(config);
  var columnConfigArray = GetValue232(config, "columns", void 0);
  if (columnConfigArray && Array.isArray(columnConfigArray)) {
    for (var i = 0, cnt = columnConfigArray.length; i < cnt; i++) {
      var key2 = columnConfigArray[i].key;
      if (key2) {
        this.root.addChildrenMap(key2, columns.getColumn(i));
      }
    }
  }
  return columns.getColumns();
};
var AddColumns_default = AddColumns;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/wrap/BindingTargetMethods.js
var BindingTargetMethods_default4 = {
  setBindingTarget(target) {
    var children = this.childrenMap.child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setBindingTarget(target);
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/wrap/InputRowTitleWidthMethods.js
var InputRowTitleWidthMethods_default4 = {
  getMaxInputRowTitleWidth() {
    return 0;
  },
  setInputRowTitleWidth(width) {
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/wrap/Wrap.js
var GetValue233 = Phaser.Utils.Objects.GetValue;
var Wrap8 = class extends Sizer_default {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    config.orientation = "y";
    super(scene, config);
    this.type = "rexTweaker.Wrap";
    var background = GetValue233(config, "background", void 0);
    var title = GetValue233(config, "title", void 0);
    if (background) {
      this.addBackground(background);
    }
    if (title) {
      this.add(
        title,
        {
          expand: true,
          space: {
            bottom: GetValue233(config, "space.title", 0)
          }
        }
      );
    }
    var child = GetValue233(config, "child", void 0);
    this.add(
      child,
      { expand: true }
    );
    this.addChildrenMap("title", title);
    this.addChildrenMap("child", child);
  }
  setTitle(config) {
    var title = this.childrenMap.title;
    if (config.title || config.icon) {
      title.show().setTitle(config);
    } else {
      title.hide();
    }
    return this;
  }
};
Object.assign(
  Wrap8.prototype,
  BindingTargetMethods_default4,
  InputRowTitleWidthMethods_default4
);
var Wrap_default = Wrap8;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateWrap.js
var GetValue234 = Phaser.Utils.Objects.GetValue;
var CreateWrap = function(parent, config, style) {
  var scene = parent.scene;
  var titleStyle = GetValue234(style, "title") || {};
  var title = new Title_default(scene, titleStyle);
  scene.add.existing(title);
  var itemWidth = GetValue234(style, "itemWidth", 0);
  var itemHeight = GetValue234(style, "itemHeight", 0);
  var tweakerConfig = {
    root: GetValue234(style, "root"),
    styles: GetValue234(style, "tweaker"),
    space: GetValue234(style, "space"),
    align: GetValue234(style, "align", 5),
    wrap: true,
    itemWidth: GetValue234(config, "itemWidth", itemWidth),
    itemHeight: GetValue234(config, "itemHeight", itemHeight)
  };
  var backgroundStyle = GetValue234(style, "background");
  if (backgroundStyle && !Array.isArray(backgroundStyle)) {
    backgroundStyle = [backgroundStyle];
  }
  var tweakerChild = parent.createTweaker(tweakerConfig);
  var wrap = new Wrap_default(scene, {
    title,
    child: tweakerChild
  });
  scene.add.existing(wrap);
  return wrap;
};
var CreateWrap_default = CreateWrap;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddWrap.js
var GetValue235 = Phaser.Utils.Objects.GetValue;
var AddWrap = function(config) {
  if (config === void 0) {
    config = {};
  }
  var wrapStyle = GetValue235(this.styles, "wrap") || {};
  wrapStyle.tweaker = this.styles;
  wrapStyle.root = this.root;
  var wrap = CreateWrap_default(this, config, wrapStyle);
  delete wrapStyle.tweaker;
  delete wrapStyle.root;
  this.add(
    wrap,
    { expand: true }
  );
  wrap.setTitle(config);
  var childTweaker = wrap.childrenMap.child;
  if (config.key) {
    this.root.addChildrenMap(config.key, childTweaker);
  }
  return childTweaker;
};
var AddWrap_default = AddWrap;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/scrollable/BindingTargetMethods.js
var BindingTargetMethods_default5 = {
  setBindingTarget(target) {
    var child = this.childrenMap.panel;
    child.setBindingTarget(target);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/scrollable/InputRowTitleWidthMethods.js
var InputRowTitleWidthMethods_default5 = {
  getMaxInputRowTitleWidth() {
    var child = this.childrenMap.panel;
    var titleWidth = child.getMaxInputRowTitleWidth();
    return titleWidth + this.getInnerPadding("left");
  },
  setInputRowTitleWidth(width) {
    width -= this.getInnerPadding("left");
    var child = this.childrenMap.panel;
    child.setInputRowTitleWidth(width);
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/scrollable/Scrollable.js
var Scrollable2 = class extends ScrollablePanel_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexTweaker.Scrollable";
  }
  setTitle(config) {
    var title = this.childrenMap.header;
    if (config.title || config.icon) {
      title.show().setTitle(config);
    } else {
      title.hide();
    }
    return this;
  }
};
Object.assign(
  Scrollable2.prototype,
  BindingTargetMethods_default5,
  InputRowTitleWidthMethods_default5
);
var Scrollable_default2 = Scrollable2;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateScrollable.js
var GetValue236 = Phaser.Utils.Objects.GetValue;
var CreateScrollable = function(parent, config, style) {
  var scene = parent.scene;
  var titleStyle = GetValue236(style, "title") || {};
  var title = new Title_default(scene, titleStyle);
  scene.add.existing(title);
  var tweakerConfig = {
    root: GetValue236(style, "root"),
    styles: GetValue236(style, "tweaker"),
    space: GetValue236(style, "space") || {}
  };
  var child = parent.createTweaker(tweakerConfig);
  var sliderStyle = GetValue236(style, "slider");
  if (sliderStyle) {
    sliderStyle = DeepClone_default(sliderStyle);
    var trackStyle = sliderStyle.track;
    if (trackStyle) {
      sliderStyle.track = CreateBackground_default3(scene, config, trackStyle);
    }
    var thumbStyle = sliderStyle.thumb;
    if (thumbStyle) {
      sliderStyle.thumb = CreateBackground_default3(scene, config, thumbStyle);
    }
  }
  var backgroundStyle = GetValue236(style, "background");
  var background = CreateBackground_default3(scene, config, backgroundStyle);
  var scrollable = new Scrollable_default2(scene, {
    scrollMode: 0,
    header: title,
    panel: {
      child,
      mask: {
        padding: 1
      }
    },
    slider: sliderStyle,
    background,
    height: GetValue236(config, "height", 0),
    space: GetValue236(style, "space", void 0)
  });
  scene.add.existing(scrollable);
  return scrollable;
};
var CreateScrollable_default = CreateScrollable;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddScrollable.js
var GetValue237 = Phaser.Utils.Objects.GetValue;
var AddScrollable = function(config) {
  if (config === void 0) {
    config = {};
  }
  var scrollableStyle = GetValue237(this.styles, "scrollable") || {};
  scrollableStyle.tweaker = this.styles;
  scrollableStyle.root = this.root;
  var scrollable = CreateScrollable_default(this, config, scrollableStyle);
  delete scrollableStyle.tweaker;
  delete scrollableStyle.root;
  this.add(
    scrollable,
    {
      proportion: scrollable.minWidth === 0 ? 1 : 0,
      expand: true
    }
  );
  scrollable.setTitle(config);
  var childTweaker = scrollable.childrenMap.panel;
  if (config.key) {
    this.root.addChildrenMap(config.key, childTweaker);
  }
  return childTweaker;
};
var AddScrollable_default = AddScrollable;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/inputrow/BindingTargetMethods.js
var GetValue238 = Phaser.Utils.Objects.GetValue;
var BindingTargetMethods_default6 = {
  setupBinding() {
    var inputField = this.childrenMap.inputField;
    inputField.on("valuechange", function(value) {
      if (!this.autoUpdateEnable) {
        return;
      }
      this.setTargetValue(value);
    }, this);
    return this;
  },
  setAutoUpdateEnable(enable) {
    if (enable === void 0) {
      enable = true;
    }
    this.autoUpdateEnable = enable;
    return this;
  },
  setBindingTarget(target, key2) {
    this.bindingTarget = target;
    if (key2 !== void 0) {
      this.setBindingTargetKey(key2);
    }
    this.syncTargetValue();
    var inputField = this.childrenMap.inputField;
    if (inputField.onBindTarget) {
      inputField.onBindTarget(target, key2);
    }
    return this;
  },
  setBindingTargetKey(key2) {
    this.bindTargetKey = key2;
    return this;
  },
  setValueCallbacks(config) {
    this.onGetValue = GetValue238(config, "onGetValue");
    this.onSetValue = GetValue238(config, "onSetValue");
    return this;
  },
  getTargetValue() {
    if (!this.bindingTarget) {
      return void 0;
    }
    if (this.bindTargetKey != null) {
      return this.bindingTarget[this.bindTargetKey];
    }
    if (this.onGetValue) {
      return this.onGetValue(this.bindingTarget);
    }
    return void 0;
  },
  setTargetValue(value) {
    if (!this.bindingTarget) {
      return this;
    }
    if (this.bindTargetKey != null) {
      this.bindingTarget[this.bindTargetKey] = value;
      return this;
    }
    if (this.onSetValue) {
      this.onSetValue(this.bindingTarget, value);
    }
    return this;
  },
  syncTargetValue() {
    if (!this.bindingTarget) {
      return this;
    }
    var inputField = this.childrenMap.inputField;
    if (inputField.syncValue) {
      inputField.syncValue(this.getTargetValue());
    } else {
    }
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/inputrow/MonitorTargetMethods.js
var MonitorTargetMethods_default = {
  startMonitorTarget() {
    if (this.isMonitoring) {
      return this;
    }
    this.isMonitoring = true;
    this.scene.events.on("postupdate", this.onMonitorTarget, this);
    return this;
  },
  stopMonitorTarget() {
    if (!this.isMonitoring) {
      return this;
    }
    this.isMonitoring = false;
    this.scene.events.off("postupdate", this.onMonitorTarget, this);
    return this;
  },
  onMonitorTarget() {
    if (!this.bindingTarget) {
      return;
    }
    var newValue = this.getTargetValue();
    var inputField = this.childrenMap.inputField;
    if (inputField.value === newValue) {
      return;
    }
    inputField.syncValue(newValue);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/inputrow/MinTitleWidthMethods.js
var MinTitleWidthMethods_default = {
  getMinTitleWidth() {
    var title = this.childrenMap.title;
    if (!title || title.orientation !== 0) {
      return 0;
    }
    var padding = title.rexSizer.padding;
    var titleWidth = this.getChildWidth(this.childrenMap.title) + (padding.left + padding.right) * title.scaleX;
    return titleWidth + this.getInnerPadding("left");
  },
  setMinTitleWidth(width) {
    var title = this.childrenMap.title;
    if (!title || title.orientation !== 0) {
      return this;
    }
    var padding = title.rexSizer.padding;
    width -= (padding.left + padding.right) * title.scaleX;
    title.minWidth = width;
    return this;
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/inputrow/InputRow.js
var GetValue239 = Phaser.Utils.Objects.GetValue;
var InputRow = class extends Sizer_default {
  constructor(scene, config) {
    super(scene, config);
    this.type = "rexTweaker.InputRow";
    this.bindingTarget = void 0;
    this.bindTargetKey = void 0;
    this.autoUpdateEnable = true;
    var inputTitle = config.inputTitle;
    var inputField = config.inputField;
    var background = config.background;
    var proportion = GetValue239(config, "proportion.title", 0);
    var titleSpace = GetValue239(config, "space.title", 0);
    var padding;
    if (this.orientation === 0) {
      padding = { right: titleSpace };
    } else {
      padding = { bottom: titleSpace };
    }
    this.add(
      inputTitle,
      { proportion, expand: true, padding }
    );
    var defaultProportion = inputField.defaultProportion;
    if (defaultProportion === void 0) {
      defaultProportion = config.defaultExpandWidth ? 1 : 0;
    }
    var proportion = GetValue239(config, "proportion.inputField", defaultProportion);
    this.add(
      inputField,
      { proportion, expand: true }
    );
    if (background) {
      this.addBackground(background);
    }
    this.addChildrenMap("title", inputTitle);
    this.addChildrenMap("inputField", inputField);
    this.addChildrenMap("background", background);
    this.setupBinding();
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    this.stopMonitorTarget();
    super.destroy(fromScene);
  }
  setTitle(config) {
    var title = this.childrenMap.title;
    title.setTitle(config);
    return this;
  }
  preLayout() {
    var title = this.childrenMap.title;
    if (title) {
      title.minWidth = 0;
    }
    super.preLayout();
  }
};
Object.assign(
  InputRow.prototype,
  BindingTargetMethods_default6,
  MonitorTargetMethods_default,
  MinTitleWidthMethods_default
);
var InputRow_default = InputRow;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateTitleLabel.js
var CreateTitleLabel = function(scene, config, style) {
  var gameObject2 = new Title_default(scene, style);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateTitleLabel_default = CreateTitleLabel;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/inputfield/GenerateInputFieldClass.js
var GenerateInputFieldClass = function(BaseClass) {
  if (BaseClass === void 0) {
    BaseClass = Sizer_default;
  }
  class InputFiled extends BaseClass {
    get bindingTarget() {
      var inputRow = this.getParentSizer();
      return inputRow.bindingTarget;
    }
    get bindingKey() {
      var inputRow = this.getParentSizer();
      return inputRow.bindTargetKey;
    }
    get value() {
      return this._value;
    }
    get root() {
      var inputRow = this.getParentSizer();
      var tweaker = inputRow.getParentSizer();
      return tweaker.root;
    }
    onBindTarget(target, key2) {
      if (this.onBindTargetCallback) {
        this.onBindTargetCallback(this, target, key2);
      }
    }
    validate(newValue) {
      if (this.syncValueFlag || !this.validateCallback) {
        return true;
      }
      return this.validateCallback(newValue, this._value, this.bindingTarget, this.bindingKey);
    }
    getFotmatText(value) {
      if (this.textFormatCallback) {
        value = this.textFormatCallback(value);
      } else {
        value = value.toString();
      }
      return value;
    }
    set value(value) {
      if (this._value === value) {
        return;
      }
      if (!this.validate(value)) {
        value = this._value;
      }
      if (this.filterValueCallback) {
        value = this.filterValueCallback(this, value);
      }
      if (this.displayValueCallback) {
        this.displayValueCallback(this, value);
      }
      if (this._value === value) {
        return;
      }
      var oldValue = this._value;
      this._value = value;
      if (!this.syncValueFlag) {
        var bindingTarget = this.bindingTarget;
        var bindingKey = this.bindingKey;
        this.emit("valuechange", value, oldValue, bindingTarget, bindingKey);
        this.root.emit("valuechange", value, oldValue, bindingTarget, bindingKey);
      }
    }
    getValue() {
      return this.value;
    }
    setValue(value) {
      this.value = value;
      return this;
    }
    /* 
    Internal method invoked when 
    - inputRow.setBindingTarget(target), or 
    - inputRow.syncTargetValue()
    */
    syncValue(value) {
      this.syncValueFlag = true;
      this.value = value;
      this.syncValueFlag = false;
      return this;
    }
    setup(config, setDefaults) {
      if (setDefaults === void 0) {
        setDefaults = false;
      }
      if (setDefaults || config.hasOwnProperty("format")) {
        this.setTextFormatCallback(config.format);
      }
      if (setDefaults || config.hasOwnProperty("onValidate")) {
        this.setValidateCallback(config.onValidate);
      }
      if (this.setupCallback) {
        this.setupCallback(this, config, setDefaults);
      }
      return this;
    }
    setSetupCallback(callback) {
      this.setupCallback = callback;
      return this;
    }
    setFilterValueCallback(callback) {
      this.filterValueCallback = callback;
      return this;
    }
    setDisplayValueCallback(callback) {
      this.displayValueCallback = callback;
      return this;
    }
    setOnBindTargetCallback(callback) {
      this.onBindTargetCallback = callback;
      return this;
    }
    setTextFormatCallback(callback) {
      this.textFormatCallback = callback;
      return this;
    }
    setValidateCallback(callback) {
      this.validateCallback = callback;
      return this;
    }
  }
  return InputFiled;
};
var GenerateInputFieldClass_default = GenerateInputFieldClass;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateInputField.js
var CreateInputField = function(scene, config, style) {
  var inputField;
  var inputHandlers = this.inputHandlers;
  for (var i = 0, cnt = inputHandlers.length; i < cnt; i++) {
    var handler = inputHandlers[i];
    if (handler.accept(config)) {
      var InputFieldClass = GenerateInputFieldClass_default(handler.baseClass);
      inputField = new InputFieldClass(scene);
      scene.add.existing(inputField);
      inputField.setSetupCallback(handler.setup).setFilterValueCallback(handler.filterValue).setDisplayValueCallback(handler.displayValue).setOnBindTargetCallback(handler.onBindTarget);
      handler.build(inputField, style);
      break;
    }
  }
  if (inputField) {
    inputField.setup(config, true);
  } else {
  }
  return inputField;
};
var CreateInputField_default = CreateInputField;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateInputRow.js
var GetValue240 = Phaser.Utils.Objects.GetValue;
var CreateInputRow = function(scene, config, style) {
  var inputField = CreateInputField_default.call(this, scene, config, style);
  if (!inputField) {
    return null;
  }
  var titleStyle = GetValue240(style, "title") || {};
  var inputTitle = CreateTitleLabel_default(scene, config, titleStyle);
  var backgroundStyle = GetValue240(style, "background") || {};
  var background = CreateBackground_default(scene, backgroundStyle);
  var inputRow = new InputRow_default(scene, {
    ...style,
    ...config,
    // config can overwrite style
    inputTitle,
    inputField,
    background
  });
  scene.add.existing(inputRow);
  inputRow.setTitle(config);
  inputRow.setValueCallbacks(config);
  return inputRow;
};
var CreateInputRow_default = CreateInputRow;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddInput.js
var AddInput = function(object, key2, config) {
  if (arguments.length === 1) {
    config = object;
    object = config.bindingTarget;
    key2 = config.bindingKey;
  } else {
    if (config === void 0) {
      config = {};
    }
    config.bindingTarget = object;
    config.bindingKey = key2;
  }
  if (!config.title) {
    config.title = key2;
  }
  if (config.bindingTarget && config.bindingKey) {
    config.value = config.bindingTarget[config.bindingKey];
  } else {
    config.value = void 0;
  }
  var inputRowStyle = this.styles.inputRow || {};
  if (!this.isWrapMode) {
    inputRowStyle.defaultExpandWidth = this.styles.orientation === 1;
  } else {
    inputRowStyle.defaultExpandWidth = true;
  }
  var inputSizer = CreateInputRow_default.call(this, this.scene, config, inputRowStyle);
  if (!inputSizer) {
    console.error(`[Tweaker] Can't add Input
    title: ${config.title}
    view: ${config.view}
`);
    return this;
  }
  if (!this.isWrapMode) {
    var proportion;
    if (this.orientation === 1) {
      proportion = 0;
    } else {
      proportion = this.itemWidth > 0 ? 0 : 1;
      if (inputSizer.minWidth === 0) {
        inputSizer.setMinWidth(this.itemWidth);
      }
    }
    if (inputSizer.minHeight === 0) {
      inputSizer.setMinHeight(this.itemHeight);
    }
    this.add(
      inputSizer,
      { proportion, expand: true }
    );
  } else {
    inputSizer.setMinWidth(this.itemWidth);
    inputSizer.setMinHeight(this.itemHeight);
    this.add(inputSizer);
  }
  if (config.onValueChange) {
    var inputField = inputSizer.childrenMap.inputField;
    inputField.on("valuechange", config.onValueChange);
  }
  inputSizer.setAutoUpdateEnable(config.autoUpdate);
  inputSizer.setBindingTarget(object, key2);
  if (config.monitor) {
    inputSizer.startMonitorTarget();
  }
  if (config.key) {
    this.root.addChildrenMap(config.key, inputSizer);
  }
  return this;
};
var AddInput_default = AddInput;

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateRoundRectangle.js
var CreateRoundRectangle = function(scene, config) {
  var gameObject2 = new RoundRectangle_default3(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateRoundRectangle_default = CreateRoundRectangle;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/gameobjects/utils/CreateButtons.js
var GetValue241 = Phaser.Utils.Objects.GetValue;
var CreateButtons3 = function(scene, config) {
  var wrap = GetValue241(config, "wrap", false);
  var ButtonClass = wrap ? FixWidthButtons_default : Buttons_default;
  var gameObject2 = new ButtonClass(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateButtons_default2 = CreateButtons3;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateButtons.js
var GetValue242 = Phaser.Utils.Objects.GetValue;
var CreateButtons4 = function(scene, config, style) {
  var titleStyle = GetValue242(style, "title") || {};
  var title = CreateTitleLabel_default(scene, config, titleStyle);
  var buttonsConfig = config.buttons;
  var buttonStyle = GetValue242(style, "button") || {};
  var buttons = [];
  for (var i = 0, cnt = buttonsConfig.length; i < cnt; i++) {
    var button = CreateLabel_default(scene, buttonStyle);
    buttons.push(button);
    var buttonConfig = buttonsConfig[i];
    button.resetDisplayContent(buttonConfig.label);
    button.callback = buttonConfig.callback;
  }
  var buttonsSizer = CreateButtons_default2(scene, {
    buttons,
    expand: true,
    wrap: GetValue242(config, "wrap", false)
  });
  buttonsSizer.defaultProportion = 1;
  var backgroundStyle = GetValue242(style, "background") || {};
  var background = CreateRoundRectangle_default(scene, backgroundStyle);
  var inputRow = new InputRow_default(scene, {
    ...style,
    inputTitle: title,
    inputField: buttonsSizer,
    background
  });
  scene.add.existing(inputRow);
  inputRow.setTitle(config);
  buttonsSizer.on("button.click", function(button2) {
    button2.callback(inputRow.bindingTarget);
  });
  return inputRow;
};
var CreateButtons_default3 = CreateButtons4;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddButtons.js
var GetValue243 = Phaser.Utils.Objects.GetValue;
var AddButtons = function(config) {
  if (config === void 0) {
    config = {};
  }
  var scene = this.scene;
  var target = config.bindingTarget;
  delete config.bindingTarget;
  var buttonsStyle = GetValue243(this.styles, "inputRow") || {};
  var buttons = CreateButtons_default3(scene, config, buttonsStyle);
  this.add(
    buttons,
    { expand: true }
  );
  if (target) {
    buttons.setBindingTarget(target);
  }
  if (config.key) {
    this.root.addChildrenMap(config.key, buttons);
  }
  return this;
};
var AddButtons_default = AddButtons;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddButton.js
var AddButton = function(config) {
  if (config === void 0) {
    config = {};
  }
  config.buttons = [{
    label: config.label,
    callback: config.callback
  }];
  delete config.label;
  delete config.callback;
  this.addButtons(config);
  return this;
};
var AddButton_default = AddButton;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/builders/CreateSeparator.js
var CreateSeparator = function(scene, config, style) {
  return CreateBackground_default(scene, Merge_default2(config, style));
};
var CreateSeparator_default = CreateSeparator;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddSeparator.js
var GetValue244 = Phaser.Utils.Objects.GetValue;
var AddSeparator = function(config) {
  if (config === void 0) {
    config = {};
  }
  var scene = this.scene;
  var separatorStyle = GetValue244(this.styles, "separator");
  var separator = CreateSeparator_default(scene, config, separatorStyle);
  this.add(
    separator,
    { expand: true }
  );
  return this;
};
var AddSeparator_default = AddSeparator;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/AddRows.js
var AddRows = function(properties, target, monitor) {
  if (typeof target === "boolean") {
    monitor = target;
    target = void 0;
  }
  if (monitor === void 0) {
    monitor = true;
  }
  AddProperties(this, DeepClone_default(properties), target, monitor);
  return this;
};
var AddProperties = function(tweaker, properties, target, monitor) {
  if (!properties) {
    return;
  }
  for (var i = 0, cnt = properties.length; i < cnt; i++) {
    var property = properties[i];
    if (property.hasOwnProperty("$target")) {
      target = property.$target;
      delete property.$target;
    }
    var type = property.$type;
    delete property.$type;
    switch (type) {
      case "folder":
        var folder = tweaker.addFolder(property);
        AddProperties(folder, property.$properties, target, monitor);
        break;
      case "tab":
        var pages = tweaker.addTab(property);
        for (var pIdx = 0, pcnt = pages.length; pIdx < pcnt; pIdx++) {
          AddProperties(pages[pIdx], property.pages[pIdx].$properties, target, monitor);
        }
        break;
      case "columns":
        var columns = tweaker.addColumns(property);
        for (var pIdx = 0, pcnt = columns.length; pIdx < pcnt; pIdx++) {
          AddProperties(columns[pIdx], property.columns[pIdx].$properties, target, monitor);
        }
        break;
      case "scrollable":
        var scrollable = tweaker.addScrollable(property);
        AddProperties(scrollable, property.$properties, target, monitor);
        break;
      case "separator":
        tweaker.addSeparator();
        break;
      case "button":
        property.bindingTarget = target;
        tweaker.addButton(property);
        break;
      case "buttons":
        property.bindingTarget = target;
        tweaker.addButtons(property);
        break;
      default:
        var key2 = property.$key;
        delete property.$key;
        if (key2.indexOf(".") === -1) {
          property.bindingTarget = target;
          property.bindingKey = key2;
        } else {
          var keys = key2.split(".");
          property.bindingKey = keys.pop();
          var bindingTarget = target;
          for (var k = 0, kcnt = keys.length; k < kcnt; k++) {
            bindingTarget = bindingTarget[keys[k]];
            if (!target) {
              console.warn(`[Monitor] Key path '${key2}' is invalid`);
              continue;
            }
          }
          property.bindingTarget = bindingTarget;
        }
        if (!property.hasOwnProperty("monitor")) {
          property.monitor = monitor;
        }
        tweaker.addInput(property);
        break;
    }
  }
};
var AddRows_default = AddRows;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/SetBindingTarget.js
var SetBindingTarget = function(target) {
  var children = this.sizerChildren;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (!child.setBindingTarget) {
      continue;
    }
    child.setBindingTarget(target);
  }
  return this;
};
var SetBindingTarget_default = SetBindingTarget;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/GetMaxInputRowTitleWidth.js
var GetMaxInputRowTitleWidth = function() {
  var maxTitleWidth = 0;
  var children = this.sizerChildren;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (child.rexSizer.hidden) {
      continue;
    }
    if (child.getMinTitleWidth) {
      maxTitleWidth = Math.max(maxTitleWidth, child.getMinTitleWidth());
    } else if (child.getMaxInputRowTitleWidth) {
      maxTitleWidth = Math.max(maxTitleWidth, child.getMaxInputRowTitleWidth());
    }
  }
  return maxTitleWidth + this.getInnerPadding("left");
};
var GetMaxInputRowTitleWidth_default = GetMaxInputRowTitleWidth;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/SetInputRowTitleWidth.js
var SetInputRowTitleWidth = function(width) {
  if (!this.isWrapMode) {
    width -= this.getInnerPadding("left");
  }
  var children = this.sizerChildren;
  for (var i = 0, cnt = children.length; i < cnt; i++) {
    var child = children[i];
    if (child.rexSizer.hidden) {
      continue;
    }
    if (child.setMinTitleWidth) {
      child.setMinTitleWidth(width);
    } else if (child.setInputRowTitleWidth) {
      child.setInputRowTitleWidth(width);
    }
  }
  return this;
};
var SetInputRowTitleWidth_default = SetInputRowTitleWidth;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/Methods.js
var methods45 = {
  registerInputHandler: RegisterInputHandler_default,
  removeInputHandler: RemoveInputHandler_default,
  addFolder: AddFolder_default,
  addTab: AddTab_default,
  addColumns: AddColumns_default,
  addWrap: AddWrap_default,
  addScrollable: AddScrollable_default,
  addInput: AddInput_default,
  addButtons: AddButtons_default,
  addButton: AddButton_default,
  addSeparator: AddSeparator_default,
  addRows: AddRows_default,
  setBindingTarget: SetBindingTarget_default,
  getMaxInputRowTitleWidth: GetMaxInputRowTitleWidth_default,
  setInputRowTitleWidth: SetInputRowTitleWidth_default
};
var Methods_default46 = methods45;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/GenerateTweakerShellClass.js
var GetValue245 = Phaser.Utils.Objects.GetValue;
var GenerateTweakerShellClass = function(config) {
  var isWrapMode = GetValue245(config, "wrap", false);
  var BaseClass = !isWrapMode ? Sizer_default : FixWidthSizer_default;
  class TweakerShell extends BaseClass {
    constructor(scene, config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      if (config2.orientation === void 0) {
        config2.orientation = !isWrapMode ? 1 : 0;
      }
      super(scene, config2);
      this.type = "rexTweakerShell";
      this.isWrapMode = isWrapMode;
      if (!config2.root) {
        this.root = this;
        this.inputHandlers = [];
      } else {
        this.root = config2.root;
        this.inputHandlers = this.root.inputHandlers;
      }
      this.styles = GetValue245(config2, "styles") || {};
      this.styles.orientation = this.orientation;
      var itemWidth = GetValue245(config2, "itemWidth");
      if (itemWidth === void 0) {
        itemWidth = GetValue245(this.styles, "itemWidth", 0);
      }
      this.itemWidth = itemWidth;
      var itemHeight = GetValue245(config2, "itemHeight");
      if (itemHeight === void 0) {
        itemHeight = GetValue245(this.styles, "itemHeight", 0);
      }
      this.itemHeight = itemHeight;
      if (isWrapMode || this.root === this && this.orientation === 1) {
        var alignTitle = GetValue245(config2, "inputRow.alignTitle");
        if (alignTitle === void 0) {
          var titleProportion = GetValue245(this.styles, "inputRow.proportion.title");
          alignTitle = !titleProportion;
        } else {
          if (alignTitle) {
            SetValue_default(this.styles, "inputRow.proportion.title", 0);
          }
        }
        this.alignInputRowTitleStartFlag = alignTitle;
      } else {
        this.alignInputRowTitleStartFlag = false;
      }
      var background = CreateBackground_default3(scene, void 0, config2.background);
      if (background) {
        this.addBackground(background);
      }
    }
    preLayout() {
      super.preLayout();
      if (this.alignInputRowTitleStartFlag) {
        this.setInputRowTitleWidth(this.getMaxInputRowTitleWidth());
      }
    }
    createTweaker(config2, addToScene) {
      if (addToScene === void 0) {
        addToScene = true;
      }
      var TweakerShellClass = GenerateTweakerShellClass(config2);
      var gameObject2 = new TweakerShellClass(this.scene, config2);
      if (addToScene) {
        this.scene.add.existing(gameObject2);
      }
      return gameObject2;
    }
  }
  Object.assign(
    TweakerShell.prototype,
    Methods_default46
  );
  return TweakerShell;
};
var GenerateTweakerShellClass_default = GenerateTweakerShellClass;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateInputText.js
var CreateInputText_default2 = CreateInputText_default;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/TextInputHandler.js
var SetInputTextReadOnly = function(gameObject2, enable) {
  if (enable === void 0) {
    enable = true;
  }
  var inputText = gameObject2.childrenMap.inputText;
  inputText.setReadOnly(enable);
};
var TextInputHandler_default = {
  name: "TextInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "string";
    }
    return typeof config.value === "string";
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.TextInput";
    var inputTextConfig = style.inputText;
    var inputText = CreateInputText_default2(scene, inputTextConfig);
    gameObject2.add(
      inputText,
      { proportion: 1, expand: true, key: "inputText" }
    );
    inputText.on("close", function() {
      gameObject2.setValue(inputText.value);
    });
  },
  // Callback inside `setup()`
  setup(gameObject2, config, setDefaults) {
    if (setDefaults || config.hasOwnProperty("inputTextReadOnly")) {
      SetInputTextReadOnly(gameObject2, !!config.inputTextReadOnly);
    }
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var inputText = gameObject2.childrenMap.inputText;
    inputText.setText(gameObject2.getFotmatText(value));
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateInputTextArea.js
var CreateInputTextArea = function(scene, config, deepCloneConfig) {
  if (deepCloneConfig === void 0) {
    deepCloneConfig = true;
  }
  if (deepCloneConfig) {
    config = config ? DeepClone_default(config) : {};
  } else if (!config) {
    config = {};
  }
  var inputText = new TextAreaInput_default(scene, config);
  scene.add.existing(inputText);
  return inputText;
};
var CreateInputTextArea_default = CreateInputTextArea;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateInputTextArea.js
var CreateInputTextArea_default2 = CreateInputTextArea_default;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/TextAreaInputHandler.js
var SetInputTextReadOnly2 = function(gameObject2, enable) {
  if (enable === void 0) {
    enable = true;
  }
  var inputText = gameObject2.childrenMap.inputText;
  inputText.setReadOnly(enable);
};
var TextAreaInputHandler_default = {
  name: "TextAreaInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "textarea";
    }
    return false;
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    this.type = "rexTweaker.TextAreaInput";
    var inputTextAreaConfig = style.inputTextArea;
    if (inputTextAreaConfig === void 0) {
      inputTextAreaConfig = {};
    }
    if (!inputTextAreaConfig.hasOwnProperty("text")) {
      inputTextAreaConfig.text = style.inputText;
    }
    if (!inputTextAreaConfig.hasOwnProperty("slider")) {
      inputTextAreaConfig.slider = style.slider;
    }
    var inputText = CreateInputTextArea_default2(scene, inputTextAreaConfig);
    gameObject2.add(
      inputText,
      { proportion: 1, expand: true, key: "inputText" }
    );
    inputText.on("close", function() {
      gameObject2.setValue(inputText.value);
    });
  },
  // Callback inside `setup()`
  setup(gameObject2, config, setDefaults) {
    if (setDefaults || config.hasOwnProperty("inputTextReadOnly")) {
      SetInputTextReadOnly2(gameObject2, !!config.inputTextReadOnly);
    }
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var inputText = gameObject2.childrenMap.inputText;
    inputText.setText(gameObject2.getFotmatText(value));
  },
  // Callback inside `setBindingTarget()`
  onBindTarget(gameObject2) {
    var inputText = gameObject2.childrenMap.inputText;
    inputText.scrollToTop();
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/NumberInputHandler.js
var SetInputTextReadOnly3 = function(gameObject2, enable) {
  if (enable === void 0) {
    enable = true;
  }
  var inputText = gameObject2.childrenMap.inputText;
  inputText.setReadOnly(enable);
};
var NumberInputHandler_default = {
  name: "NumberInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "number";
    }
    return typeof config.value === "number";
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.NumberInput";
    var inputTextConfig = style.inputNumber || style.inputText;
    var inputText = CreateInputText_default2(scene, inputTextConfig).setNumberInput();
    gameObject2.add(
      inputText,
      { proportion: 1, expand: true, key: "inputText" }
    );
    inputText.on("close", function() {
      gameObject2.setValue(inputText.value);
    });
  },
  // Callback inside `setup()`
  setup(gameObject2, config, setDefaults) {
    if (setDefaults || config.hasOwnProperty("inputTextReadOnly")) {
      SetInputTextReadOnly3(gameObject2, !!config.inputTextReadOnly);
    }
    gameObject2.isFloatType = !config.int;
  },
  // Callback inside `setValue()`
  filterValue(gameObject2, value) {
    if (gameObject2.isFloatType) {
      return value;
    } else {
      return Math.floor(value);
    }
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var inputText = gameObject2.childrenMap.inputText;
    inputText.setText(gameObject2.getFotmatText(value));
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateSlider.js
var CreateSlider = function(scene, config) {
  var gameObject2 = new Slider_default(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateSlider_default = CreateSlider;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/RangeInputHandler.js
var GetValue246 = Phaser.Utils.Objects.GetValue;
var Linear28 = Phaser.Math.Linear;
var SnapFloor = Phaser.Math.Snap.Floor;
var SetRange = function(gameObject2, min, max, step) {
  gameObject2.minValue = min;
  gameObject2.maxValue = max;
  gameObject2.step = step;
  var slider = gameObject2.childrenMap.slider;
  slider.setGap(step, min, max);
};
var SetInputTextReadOnly4 = function(gameObject2, enable) {
  if (enable === void 0) {
    enable = true;
  }
  var inputText = gameObject2.childrenMap.inputText;
  inputText.setReadOnly(enable);
};
var RangeInputHandler_default = {
  name: "RangeInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "range";
    }
    return typeof config.value === "number" && config.hasOwnProperty("min") && config.hasOwnProperty("max");
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.RangeInput";
    var sliderConfig = style.slider;
    var trackSizeKey = gameObject2.orientation === 0 ? "track.height" : "track.width";
    var trackSize = GetValue246(sliderConfig, trackSizeKey);
    var slider = CreateSlider_default(scene, sliderConfig);
    var defaultProportion = style.defaultExpandWidth ? 2 : 0;
    var proportion = GetValue246(style, "proportion.range.slider", defaultProportion);
    var expand = trackSize === void 0;
    gameObject2.add(
      slider,
      { proportion, expand, key: "slider" }
    );
    var inputTextConfig = style.inputNumber || style.inputText;
    var inputText = CreateInputText_default2(scene, inputTextConfig).setNumberInput();
    var defaultProportion = style.defaultExpandWidth ? 1 : 0;
    var proportion = GetValue246(style, "proportion.range.inputText", defaultProportion);
    gameObject2.add(
      inputText,
      { proportion, expand: true, key: "inputText" }
    );
    inputText.on("close", function() {
      gameObject2.setValue(inputText.value);
    });
    slider.on("valuechange", function() {
      var value = Linear28(gameObject2.minValue, gameObject2.maxValue, slider.value);
      if (gameObject2.step) {
        value = SnapFloor(value, gameObject2.step, gameObject2.minValue);
      }
      gameObject2.setValue(value);
    });
  },
  // Callback inside `setup()`
  setup(gameObject2, config, setDefaults) {
    if (setDefaults || config.hasOwnProperty("max")) {
      SetRange(gameObject2, config.min, config.max, config.step);
    }
    if (setDefaults || config.hasOwnProperty("inputTextReadOnly")) {
      SetInputTextReadOnly4(gameObject2, !!config.inputTextReadOnly);
    }
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var slider = gameObject2.childrenMap.slider;
    slider.setValue(value, gameObject2.minValue, gameObject2.maxValue);
    var inputText = gameObject2.childrenMap.inputText;
    inputText.setText("").setText(gameObject2.getFotmatText(value));
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateButtons.js
var CreateButtons5 = function(scene, config) {
  var gameObject2 = new Buttons_default(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateButtons_default4 = CreateButtons5;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateLabel.js
var CreateLabel_default2 = CreateLabel_default;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/IncDecInputHandler.js
var GetValue247 = Phaser.Utils.Objects.GetValue;
var SetInputTextReadOnly5 = function(gameObject2, enable) {
  if (enable === void 0) {
    enable = true;
  }
  var inputText = gameObject2.childrenMap.inputText;
  inputText.setReadOnly(enable);
};
var IncDecInputHandler_default = {
  name: "RangeInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "incdec";
    }
    return false;
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.IncDecInput";
    var incDecConfig = GetValue247(style, "incDec") || {};
    var buttonConfigBase = { text: null, action: null };
    var buttons = CreateButtons_default4(scene, {
      expand: false
    });
    var proportion = style.defaultExpandWidth ? 1 : 0;
    gameObject2.add(
      buttons,
      { proportion, expand: true }
    );
    var inputTextConfig = style.inputNumber || style.inputText;
    var inputText = CreateInputText_default2(scene, inputTextConfig).setNumberInput();
    inputText.on("close", function() {
      gameObject2.setValue(inputText.value);
    });
    var incButtonConfig = Object.assign(DeepClone_default(buttonConfigBase), incDecConfig.incButton || {});
    var incButton = CreateLabel_default2(scene, incButtonConfig);
    var decButtonConfig = Object.assign(DeepClone_default(buttonConfigBase), incDecConfig.decButton || {});
    var decButton = CreateLabel_default2(scene, decButtonConfig);
    buttons.addButton(incButton);
    buttons.addButton(decButton);
    var inputTextIndex = incDecConfig.inputTextIndex || 0;
    buttons.insert(
      inputTextIndex,
      inputText,
      { proportion: 1, expand: true }
    );
    gameObject2.step = 1;
    gameObject2.minValue = void 0;
    gameObject2.maxValue = void 0;
    buttons.on("button.click", function(button, index, pointer, event) {
      var value = gameObject2.value;
      if (index === 0) {
        value += gameObject2.step;
      } else {
        value -= gameObject2.step;
      }
      if (gameObject2.maxValue !== void 0 && value > gameObject2.maxValue) {
        value = gameObject2.maxValue;
      }
      if (gameObject2.minValue !== void 0 && value < gameObject2.minValue) {
        value = gameObject2.minValue;
      }
      gameObject2.setValue(value);
    });
    gameObject2.addChildrenMap("incButton", incButton);
    gameObject2.addChildrenMap("decButton", decButton);
    gameObject2.addChildrenMap("inputText", inputText);
  },
  // Callback inside `setup()`
  setup(gameObject2, config, setDefaults) {
    if (setDefaults || config.hasOwnProperty("inputTextReadOnly")) {
      SetInputTextReadOnly5(gameObject2, !!config.inputTextReadOnly);
    }
    if (setDefaults || config.hasOwnProperty("step")) {
      gameObject2.step = config.hasOwnProperty("step") ? config.step : 1;
    }
    if (setDefaults || config.hasOwnProperty("min")) {
      gameObject2.minValue = config.min;
    }
    if (setDefaults || config.hasOwnProperty("max")) {
      gameObject2.maxValue = config.max;
    }
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var inputText = gameObject2.childrenMap.inputText;
    inputText.setText("").setText(gameObject2.getFotmatText(value));
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateColorInput.js
var CreateColorInput = function(scene, config, deepCloneConfig) {
  if (deepCloneConfig === void 0) {
    deepCloneConfig = true;
  }
  if (deepCloneConfig) {
    config = config ? DeepClone_default(config) : {};
  } else if (!config) {
    config = {};
  }
  var inputText = new ColorInput_default(scene, config);
  scene.add.existing(inputText);
  return inputText;
};
var CreateColorInput_default = CreateColorInput;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateColorInput.js
var CreateColorInput_default2 = CreateColorInput_default;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/ColorInputHandler.js
var ColorInputHandler_default = {
  name: "ColorInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "color";
    }
    return false;
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.ColorInput";
    var colorInputConfig = style.colorInput;
    if (colorInputConfig === void 0) {
      colorInputConfig = {};
    }
    if (!colorInputConfig.hasOwnProperty("inputText")) {
      colorInputConfig.inputText = style.inputText;
    }
    var colorInput = CreateColorInput_default2(scene, colorInputConfig);
    gameObject2.add(
      colorInput,
      { proportion: 1, expand: true, key: "colorInput" }
    );
    colorInput.on("valuechange", function(value) {
      gameObject2.setValue(value);
    });
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var colorInput = gameObject2.childrenMap.colorInput;
    colorInput.setValue(value);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateCheckbox.js
var CreateCheckbox = function(scene, config) {
  var gameObject2 = new Checkbox_default2(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateCheckbox_default = CreateCheckbox;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/CheckboxInputHandler.js
var CheckboxInputHandler_default = {
  name: "CheckboxInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "boolean";
    }
    return typeof config.value === "boolean";
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.CheckboxInput";
    var checkboxConfig = style.checkbox;
    var checkbox = CreateCheckbox_default(scene, checkboxConfig);
    var size = checkboxConfig.size;
    if (size !== void 0) {
      checkbox.setSize(size, size);
    }
    var fitRatio = size !== void 0 ? 0 : 1;
    gameObject2.add(
      checkbox,
      { proportion: 0, expand: false, fitRatio, key: "checkbox" }
    );
    checkbox.on("valuechange", function(value) {
      gameObject2.setValue(value);
    });
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var checkbox = gameObject2.childrenMap.checkbox;
    checkbox.setValue(value);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateToggleSwitch.js
var CreateToggleSwitch = function(scene, config) {
  var gameObject2 = new ToggleSwitch_default2(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateToggleSwitch_default = CreateToggleSwitch;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/ToggleSwitchInputHandler.js
var ToggleSwitchInputHandler_default = {
  name: "ToggleSwitchInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "toggleSwitch";
    }
    return false;
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.ToggleSwitchInput";
    var toggleSwitchConfig = style.toggleSwitch;
    var toggleSwitch = CreateToggleSwitch_default(scene, toggleSwitchConfig);
    var size = toggleSwitchConfig.size;
    if (size !== void 0) {
      toggleSwitch.setSize(size, size);
    }
    var fitRatio = size !== void 0 ? 0 : 1;
    gameObject2.addSpace().add(
      toggleSwitch,
      { proportion: 0, expand: false, fitRatio, key: "toggleSwitch" }
    );
    toggleSwitch.on("valuechange", function(value) {
      gameObject2.setValue(value);
    });
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var toggleSwitch = gameObject2.childrenMap.toggleSwitch;
    toggleSwitch.setValue(value);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/utils/build/CreateDropDownList.js
var CreateDropDownList = function(scene, config) {
  config = BuildListConfig_default(scene, config);
  var gameObject2 = new DropDownList_default(scene, config);
  scene.add.existing(gameObject2);
  return gameObject2;
};
var CreateDropDownList_default = CreateDropDownList;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/CreateDropDownList.js
var CreateDropDownList_default2 = CreateDropDownList_default;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/OptionsMethods.js
var GetOptionIndex = function(options, value) {
  for (var i = 0, cnt = options.length; i < cnt; i++) {
    var option = options[i];
    if (option.value === value) {
      return i;
    }
  }
  return void 0;
};
var GetOption = function(options, value) {
  var index = GetOptionIndex(options, value);
  if (index == null) {
    return void 0;
  }
  return options[index];
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/ListInputHandler.js
var SetOptions = function(gameObject2, options) {
  var list = gameObject2.childrenMap.list;
  list.setOptions(options);
};
var ListInputHandler_default = {
  name: "ListInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "list";
    }
    return config.hasOwnProperty("options");
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.ListInput";
    var list = CreateDropDownList_default2(scene, style.list);
    gameObject2.add(
      list,
      { proportion: 1, expand: true, key: "list" }
    );
    list.on("button.click", function(dropDownList, listPanel, button, index, pointer, event) {
      gameObject2.setValue(button.value);
    });
  },
  // Callback inside `setup()`
  setup(gameObject2, config, setDefaults) {
    if (setDefaults || config.hasOwnProperty("options")) {
      SetOptions(gameObject2, config.options);
    }
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var list = gameObject2.childrenMap.list;
    var option = GetOption(list.options, value);
    list.resetDisplayContent(option).setMinSize(list.width, list.height).layout().setMinSize(0, 0);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/utils/SetButtonsActiveState.js
var SetButtonsActiveStateByIndex = function(buttons, index) {
  for (var i = 0, cnt = buttons.length; i < cnt; i++) {
    var button = buttons[i];
    if (!button) {
      continue;
    }
    button.setActiveState(i === index);
  }
};
var SetButtonsActiveState_default = SetButtonsActiveStateByIndex;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/inputhandlers/ButtonsInputHandler.js
var GetValue248 = Phaser.Utils.Objects.GetValue;
var SetOptions2 = function(gameObject2, options) {
  var list = gameObject2.childrenMap.list;
  list.options = options;
  var scene = gameObject2.scene;
  var buttonConfig = list.buttonConfig;
  list.clearButtons(true);
  for (var i = 0, cnt = options.length; i < cnt; i++) {
    var option = options[i];
    var button = CreateLabel_default2(scene, buttonConfig).setActiveState(false).resetDisplayContent({ text: option.text });
    list.addButton(button);
  }
};
var ButtonsInputHandler_default = {
  name: "ButtonsInput",
  accept(config) {
    if (config.hasOwnProperty("view")) {
      return config.view === "buttons";
    }
    return false;
  },
  // Callback after `constructor()`
  build(gameObject2, style) {
    var scene = gameObject2.scene;
    gameObject2.type = "rexTweaker.ButtonsInput";
    var buttonConfig = style.button ? DeepClone_default(style.button) : {};
    var buttonExpand = GetValue248(buttonConfig, "expand", true);
    if (buttonExpand) {
      buttonConfig.align = "center";
    }
    delete buttonConfig.expand;
    var list = CreateButtons_default4(scene, {
      expand: buttonExpand
    });
    list.buttonConfig = buttonConfig;
    gameObject2.add(
      list,
      { proportion: 1, expand: true, key: "list" }
    );
    list.on("button.click", function(button, index, pointer, event) {
      var option = list.options[index];
      if (!option) {
        return;
      }
      gameObject2._selectedIndex = index;
      gameObject2.setValue(option.value);
      gameObject2._selectedIndex = void 0;
    });
  },
  // Callback inside `setup()`
  setup(gameObject2, config, setDefaults) {
    if (setDefaults || config.hasOwnProperty("options")) {
      SetOptions2(gameObject2, config.options);
    }
  },
  // Callback inside `setValue()`
  displayValue(gameObject2, value) {
    var list = gameObject2.childrenMap.list;
    var index = gameObject2._selectedIndex;
    if (index === void 0) {
      index = GetOptionIndex(list.options, value);
    }
    SetButtonsActiveState_default(list.childrenMap.buttons, index);
  }
};

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/methods/RegisterDefaultInputHandlers.js
var RegisterDefaultInputHandlers = function() {
  this.registerInputHandler(TextInputHandler_default).registerInputHandler(TextAreaInputHandler_default).registerInputHandler(NumberInputHandler_default).registerInputHandler(RangeInputHandler_default).registerInputHandler(IncDecInputHandler_default).registerInputHandler(ColorInputHandler_default).registerInputHandler(CheckboxInputHandler_default).registerInputHandler(ToggleSwitchInputHandler_default).registerInputHandler(ListInputHandler_default).registerInputHandler(ButtonsInputHandler_default);
};
var RegisterDefaultInputHandlers_default = RegisterDefaultInputHandlers;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/Tweaker.js
var Tweaker = class extends GenerateTweakerShellClass_default() {
  constructor(scene, config) {
    if (config === void 0) {
      config = {};
    }
    if (config.hasOwnProperty("style")) {
      config.styles = config.style;
    }
    if (config.styles === void 0) {
      config.styles = {};
    }
    config.background = config.styles.background || {};
    config.space = config.styles.space || {};
    super(scene, config);
    this.type = "rexTweaker";
    RegisterDefaultInputHandlers_default.call(this);
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    this.inputHandlers = void 0;
  }
};
var Tweaker_default = Tweaker;

// node_modules/phaser3-rex-plugins/templates/ui/tweaker/Factory.js
ObjectFactory_default.register("tweaker", function(config) {
  var gameObject2 = new Tweaker_default(this.scene, config);
  this.scene.add.existing(gameObject2);
  return gameObject2;
});
SetValue_default(window, "RexPlugins.UI.Tweaker", Tweaker_default);

// node_modules/phaser3-rex-plugins/templates/ui/click/Factory.js
ObjectFactory_default.register("click", function(gameObject2, config) {
  return new Click_default(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Click", Click_default);

// node_modules/phaser3-rex-plugins/templates/ui/clickoutside/Factory.js
ObjectFactory_default.register("clickOutside", function(gameObject2, config) {
  return new ClickOutside_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.ClickOutside", ClickOutside_default2);

// node_modules/phaser3-rex-plugins/templates/ui/intouching/Factory.js
ObjectFactory_default.register("inTouching", function(gameObject2, config) {
  return new InTouching_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.InTouching", InTouching_default2);

// node_modules/phaser3-rex-plugins/templates/ui/tap/Factory.js
ObjectFactory_default.register("tap", function(gameObject2, config) {
  if (!IsGameObject_default(gameObject2)) {
    config = gameObject2;
    gameObject2 = this.scene;
  }
  return new Tap_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Tap", Tap_default2);

// node_modules/phaser3-rex-plugins/templates/ui/press/Factory.js
ObjectFactory_default.register("press", function(gameObject2, config) {
  if (!IsGameObject_default(gameObject2)) {
    config = gameObject2;
    gameObject2 = this.scene;
  }
  return new Press_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Press", Press_default2);

// node_modules/phaser3-rex-plugins/templates/ui/swipe/Factory.js
ObjectFactory_default.register("swipe", function(gameObject2, config) {
  if (!IsGameObject_default(gameObject2)) {
    config = gameObject2;
    gameObject2 = this.scene;
  }
  return new Swipe_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Swipe", Swipe_default2);

// node_modules/phaser3-rex-plugins/templates/ui/pan/Pan.js
var Pan_default2 = Pan_default;

// node_modules/phaser3-rex-plugins/templates/ui/pan/Factory.js
ObjectFactory_default.register("pan", function(gameObject2, config) {
  if (!IsGameObject_default(gameObject2)) {
    config = gameObject2;
    gameObject2 = this.scene;
  }
  return new Pan_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Pan", Pan_default2);

// node_modules/phaser3-rex-plugins/plugins/drag.js
var drag_default = Drag_default;

// node_modules/phaser3-rex-plugins/templates/ui/drag/Drag.js
var Drag_default2 = drag_default;

// node_modules/phaser3-rex-plugins/templates/ui/drag/Factory.js
ObjectFactory_default.register("drag", function(gameObject2, config) {
  return new Drag_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Drag", Drag_default2);

// node_modules/phaser3-rex-plugins/templates/ui/pinch/Pinch.js
var Pinch_default2 = Pinch_default;

// node_modules/phaser3-rex-plugins/templates/ui/pinch/Factory.js
ObjectFactory_default.register("pinch", function(config) {
  return new Pinch_default2(this.scene, config);
});
SetValue_default(window, "RexPlugins.UI.Pinch", Pinch_default2);

// node_modules/phaser3-rex-plugins/templates/ui/rotate/Rotate.js
var Rotate_default2 = Rotate_default;

// node_modules/phaser3-rex-plugins/templates/ui/rotate/Factory.js
ObjectFactory_default.register("rotate", function(config) {
  return new Rotate_default2(this.scene, config);
});
SetValue_default(window, "RexPlugins.UI.Rotate", Rotate_default2);

// node_modules/phaser3-rex-plugins/plugins/behaviors/flip/GetFaceUpdatingCallback.js
var IsPlainObject58 = Phaser.Utils.Objects.IsPlainObject;
var GetValue249 = Phaser.Utils.Objects.GetValue;
var GetFrameUpdatingCallback = function(key2, frame, gameObject2) {
  var callback;
  if (key2 === void 0) {
    key2 = gameObject2.texture.key;
    frame = gameObject2.frame.name;
  } else if (IsPlainObject58(key2)) {
    var config = key2;
    key2 = GetValue249(config, "key", gameObject2.texture.key);
    frame = GetValue249(config, "frame", gameObject2.frame.name);
  } else if (typeof key2 === "string") {
  } else {
    callback = key2;
  }
  if (callback === void 0) {
    callback = function(gameObject3) {
      gameObject3.setTexture(key2, frame);
    };
  }
  return callback;
};
var GetFaceUpdatingCallback_default = GetFrameUpdatingCallback;

// node_modules/phaser3-rex-plugins/plugins/behaviors/flip/Flip.js
var GetValue250 = Phaser.Utils.Objects.GetValue;
var GetAdvancedValue7 = Phaser.Utils.Objects.GetAdvancedValue;
var Linear29 = Phaser.Math.Linear;
var Flip2 = class extends EaseValueTaskBase_default {
  constructor(gameObject2, config) {
    super(gameObject2, config);
    this.resetFromJSON(config);
    this.boot();
  }
  resetFromJSON(o) {
    super.resetFromJSON(o);
    this.setDuration(GetAdvancedValue7(o, "duration", 500));
    this.setEase(GetValue250(o, "ease", "Sine"));
    this.setOrientation(GetValue250(o, "orientation", 0));
    this.setFrontFace(GetValue250(o, "front", void 0));
    this.setBackFace(GetValue250(o, "back", void 0));
    this.setFace(GetValue250(o, "face", 0));
    return this;
  }
  setOrientation(orientation) {
    if (typeof orientation === "string") {
      orientation = ORIENTATIONMODE3[orientation];
    }
    this.orientation = orientation;
    return this;
  }
  get face() {
    return this._face;
  }
  set face(face2) {
    if (typeof face2 === "string") {
      face2 = FACEMODE2[face2];
    }
    this._face = face2;
    if (face2 === 0 && this.frontFaceCallback) {
      this.frontFaceCallback(this.parent);
    } else if (face2 === 1 && this.backFaceCallback) {
      this.backFaceCallback(this.parent);
    }
  }
  setFace(face2) {
    this.face = face2;
    return this;
  }
  toggleFace() {
    var newFace = this.face === 0 ? 1 : 0;
    this.setFace(newFace);
    return this;
  }
  setFrontFace(key2, frame) {
    this.frontFaceCallback = GetFaceUpdatingCallback_default(key2, frame, this.parent);
    return this;
  }
  setBackFace(key2, frame) {
    this.backFaceCallback = GetFaceUpdatingCallback_default(key2, frame, this.parent);
    return this;
  }
  start() {
    if (this.timer.isRunning) {
      return this;
    }
    var gameObject2 = this.parent;
    if (this.orientation === 0) {
      this.scale0 = gameObject2.scaleX;
    } else {
      this.scale0 = gameObject2.scaleY;
    }
    this.timer.setDelay(this.delay).setDuration(this.duration / 2).setRepeat(1);
    super.start();
    return this;
  }
  flip(duration) {
    if (this.isRunning) {
      return this;
    }
    if (duration !== void 0) {
      this.setDuration(duration);
    }
    this.start();
    return this;
  }
  updateTarget(gameObject2, timer) {
    if (timer.justRestart) {
      this.toggleFace();
    }
    var t = timer.t;
    if (timer.isOddIteration) {
      t = 1 - t;
    }
    t = this.easeFn(t);
    var value = Linear29(this.scale0, 0, t);
    if (this.orientation === 0) {
      gameObject2.scaleX = value;
    } else {
      gameObject2.scaleY = value;
    }
  }
};
var ORIENTATIONMODE3 = {
  x: 0,
  horizontal: 0,
  y: 1,
  vertical: 1
};
var FACEMODE2 = {
  front: 0,
  back: 1
};
var Flip_default2 = Flip2;

// node_modules/phaser3-rex-plugins/plugins/flip.js
var flip_default = Flip_default2;

// node_modules/phaser3-rex-plugins/templates/ui/flip/Flip.js
var Flip_default3 = flip_default;

// node_modules/phaser3-rex-plugins/templates/ui/flip/Factory.js
ObjectFactory_default.register("flip", function(gameObject2, config) {
  return new Flip_default3(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Flip", Flip_default3);

// node_modules/phaser3-rex-plugins/templates/ui/shake/Factory.js
ObjectFactory_default.register("shake", function(gameObject2, config) {
  return new Shake_default(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Shake", Shake_default);

// node_modules/phaser3-rex-plugins/templates/ui/toucheventstop/Factory.js
ObjectFactory_default.register("touchEventStop", function(gameObject2, config) {
  return new TouchEventStop_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.TouchEventStop", TouchEventStop_default2);

// node_modules/phaser3-rex-plugins/templates/ui/perspective/Perspective.js
var Perspective_default = ContainerPerspective_default;

// node_modules/phaser3-rex-plugins/templates/ui/perspective/Factory.js
ObjectFactory_default.register("perspective", function(gameObject2, config) {
  return new Perspective_default(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Perspective", Perspective_default);

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/utils/LocalXY.js
var RotateAround9 = Phaser.Math.RotateAround;
var LocalXYToWorldXY = function(gameObject2, localX, localY) {
  var ox = gameObject2.width / 2;
  var oy = gameObject2.height / 2;
  out.x = localX - ox;
  out.y = localY - oy;
  RotateAround9(out, 0, 0, gameObject2.rotation);
  out.x *= gameObject2.scaleX;
  out.y *= gameObject2.scaleY;
  out.x += gameObject2.x;
  out.y += gameObject2.y;
  return out;
};
var WorldXYToLocalXY = function(gameObject2, worldX, worldY) {
  var ox = gameObject2.width / 2;
  var oy = gameObject2.height / 2;
  out.x = worldX - gameObject2.x;
  out.y = worldY - gameObject2.y;
  out.x /= gameObject2.scaleX;
  out.y /= gameObject2.scaleY;
  RotateAround9(out, 0, 0, -gameObject2.rotation);
  out.x += ox;
  out.y += oy;
  return out;
};
var out = { x: 0, y: 0 };

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/image/methods/ControlPoint.js
var ControlPoint = class {
  constructor(parent, vertex) {
    this.parent = parent;
    this.vertex = vertex;
    this._localX = void 0;
    this._localY = void 0;
  }
  destroy() {
    this.parent = void 0;
    this.vertex = void 0;
  }
  updateVertexPosition(x, y) {
    var gameObject2 = this.parent;
    var srcHeight = gameObject2.height;
    var vHalfWidth = gameObject2.frame.cutWidth / srcHeight / 2;
    var vHalfHeight = gameObject2.frame.cutHeight / srcHeight / 2;
    var vx = x / srcHeight - vHalfWidth;
    var vy = y / srcHeight - vHalfHeight;
    var vertex = this.vertex;
    vertex.x = vx;
    vertex.y = -vy;
    gameObject2.forceUpdate();
    return this;
  }
  get localX() {
    return this._localX;
  }
  set localX(x) {
    this.setLocalXY(x, this._localY);
  }
  get localY() {
    return this._localY;
  }
  set localY(y) {
    this.setLocalXY(this._localX, y);
  }
  get localXOrigin() {
    return this._localXOrigin;
  }
  get localYOrigin() {
    return this._localYOrigin;
  }
  resetLocalXY(x, y) {
    this._localXOrigin = x;
    this._localYOrigin = y;
    this._localX = x;
    this._localY = y;
    return this;
  }
  setLocalXY(x, y, ignoreUpdateVertex) {
    if (this._localX === x && this._localY === y) {
      return this;
    }
    this._localX = x;
    this._localY = y;
    if (!ignoreUpdateVertex) {
      this.updateVertexPosition(x, y);
    }
    return this;
  }
  setWorldXY(x, y) {
    if (this._worldX === x && this._worldY === y) {
      return this;
    }
    var localXY = WorldXYToLocalXY(this.parent, x, y);
    this.setLocalXY(localXY.x, localXY.y);
    return this;
  }
  setPosition(x, y) {
    this.setWorldXY(x, y);
    return this;
  }
  getWorldXY() {
    return LocalXYToWorldXY(this.parent, this._localX, this._localY);
  }
  get x() {
    var worldXY = LocalXYToWorldXY(this.parent, this._localX, this._localY);
    return worldXY.x;
  }
  set x(x) {
    this.setWorldXY(x, this.y);
  }
  get y() {
    var worldXY = LocalXYToWorldXY(this.parent, this._localX, this._localY);
    return worldXY.y;
  }
  set y(y) {
    this.setWorldXY(this.x, y);
  }
};
var ControlPoint_default = ControlPoint;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/image/methods/InitFaces.js
var Vertex = Phaser.Geom.Mesh.Vertex;
var Face = Phaser.Geom.Mesh.Face;
var InitFaces = function(quad) {
  var isNinePointMode = quad.isNinePointMode;
  var pointCount = isNinePointMode ? 9 : 4;
  var vertices = quad.vertices;
  var faces = quad.faces;
  var controlPoints = quad.controlPoints;
  for (var i = 0; i < pointCount; i++) {
    var vertex = new Vertex();
    vertices.push(vertex);
    controlPoints.push(new ControlPoint_default(quad, vertex));
  }
  var indices;
  if (isNinePointMode) {
    indices = NinePointsIndices;
  } else {
    if (!quad.fourPointsModeRTL) {
      indices = FourPointsIndices;
    } else {
      indices = FourPointsIndicesRTL;
    }
  }
  for (var i = 0, cnt = indices.length; i < cnt; i += 3) {
    var vert1 = vertices[indices[i + 0]];
    var vert2 = vertices[indices[i + 1]];
    var vert3 = vertices[indices[i + 2]];
    faces.push(new Face(vert1, vert2, vert3));
  }
  if (isNinePointMode) {
    quad.topLeft = controlPoints[0];
    quad.topCenter = controlPoints[1];
    quad.topRight = controlPoints[2];
    quad.centerLeft = controlPoints[3];
    quad.center = controlPoints[4];
    quad.centerRight = controlPoints[5];
    quad.bottomLeft = controlPoints[6];
    quad.bottomCenter = controlPoints[7];
    quad.bottomRight = controlPoints[8];
  } else {
    quad.topLeft = controlPoints[0];
    quad.topRight = controlPoints[1];
    quad.bottomLeft = controlPoints[2];
    quad.bottomRight = controlPoints[3];
  }
};
var FourPointsIndices = [
  0,
  2,
  3,
  0,
  3,
  1
];
var FourPointsIndicesRTL = [
  1,
  3,
  2,
  1,
  2,
  0
];
var NinePointsIndices = [
  0,
  3,
  4,
  0,
  4,
  1,
  1,
  4,
  2,
  4,
  5,
  2,
  3,
  6,
  4,
  6,
  7,
  4,
  4,
  7,
  8,
  4,
  8,
  5
];
var InitFaces_default = InitFaces;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/image/methods/GetPointPosition.js
var GetPointPosition = function(quad) {
  var points;
  var top = 0, bottom = quad.height, left = 0, right = quad.width;
  if (quad.isNinePointMode) {
    var centerX = (left + right) / 2;
    var centerY = (top + bottom) / 2;
    points = [
      left,
      top,
      // top-left
      centerX,
      top,
      // top-center
      right,
      top,
      // top-right
      left,
      centerY,
      // center-left
      centerX,
      centerY,
      // center-center
      right,
      centerY,
      // top-right
      left,
      bottom,
      // center-left
      centerX,
      bottom,
      // bottom-center
      right,
      bottom
      // bottom-right
    ];
  } else {
    points = [
      left,
      top,
      // top-left
      right,
      top,
      // top-right
      left,
      bottom,
      // bottom-left
      right,
      bottom
      // bottom-right
    ];
  }
  return points;
};
var GetPointPosition_default = GetPointPosition;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/image/Image.js
var IsPlainObject59 = Phaser.Utils.Objects.IsPlainObject;
var GetValue251 = Phaser.Utils.Objects.GetValue;
var Image3 = class extends MeshBase_default {
  constructor(scene, x, y, key2, frame, config) {
    if (IsPlainObject59(x)) {
      config = x;
      x = GetValue251(config, "x", 0);
      y = GetValue251(config, "y", 0);
      key2 = GetValue251(config, "key", null);
      frame = GetValue251(config, "frame", null);
    }
    super(scene, x, y, key2, frame);
    this.type = "rexQuadImage";
    this.isNinePointMode = GetValue251(config, "ninePointMode", false);
    this.fourPointsModeRTL = GetValue251(config, "rtl", false);
    this.controlPoints = [];
    InitFaces_default(this);
    this.hideCCW = false;
    this.syncSize();
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    for (var i = 0, cnt = this.controlPoints.length; i < cnt; i++) {
      this.controlPoints[i].destroy();
    }
    this.controlPoints = void 0;
  }
  resetVerts() {
    this.dirtyCache[9] = -1;
    var points = GetPointPosition_default(this);
    var srcWidth = this.width;
    var srcHeight = this.height;
    var vHalfWidth = this.frame.cutWidth / srcHeight / 2;
    var vHalfHeight = this.frame.cutHeight / srcHeight / 2;
    var frameU0 = this.frame.u0;
    var frameU1 = this.frame.u1;
    var frameV0 = this.frame.v0;
    var frameV1 = this.frame.v1;
    var frameU = frameU1 - frameU0;
    var frameV = frameV1 - frameV0;
    var controlPoints = this.controlPoints;
    for (var i = 0, cnt = points.length; i < cnt; i += 2) {
      var px = points[i + 0];
      var py = points[i + 1];
      var vertexIndex = i / 2;
      var x = px / srcHeight - vHalfWidth;
      var y = py / srcHeight - vHalfHeight;
      var u = frameU0 + frameU * (px / srcWidth);
      var v = frameV0 + frameV * (py / srcHeight);
      this.vertices[vertexIndex].set(x, -y, 0).setUVs(u, v);
      controlPoints[vertexIndex].resetLocalXY(px, py);
    }
    return this;
  }
  syncSize() {
    this.setSizeToFrame();
    this.setOrtho(this.width / this.height, 1);
    this.resetVerts();
    return this;
  }
};
var Image_default2 = Image3;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/rendertexture/RenderTexture.js
var IsPlainObject60 = Phaser.Utils.Objects.IsPlainObject;
var GetValue252 = Phaser.Utils.Objects.GetValue;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/skewimage/Skew.js
var Skew = function(gameObject2, skewX, skewY) {
  if (skewX === void 0) {
    skewX = 0;
  }
  if (skewY === void 0) {
    skewY = 0;
  }
  var width = gameObject2.width, height = gameObject2.height;
  var ox = width * 0.5;
  var oy = height * 0.5;
  var xOffset = Math.tan(skewX) * oy;
  var yOffset = Math.tan(skewY) * ox;
  var controlPoints = gameObject2.controlPoints;
  for (var i = 0, cnt = controlPoints.length; i < cnt; i++) {
    var controlPoint = controlPoints[i];
    var x = controlPoint.localXOrigin;
    var y = controlPoint.localYOrigin;
    controlPoint.localX = x + (y > oy ? xOffset : -xOffset);
    controlPoint.localY = y + (x > ox ? yOffset : -yOffset);
  }
};
var Skew_default = Skew;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/skewimage/SkewImage.js
var IsPlainObject61 = Phaser.Utils.Objects.IsPlainObject;
var GetValue253 = Phaser.Utils.Objects.GetValue;
var DegToRad22 = Phaser.Math.DegToRad;
var RadToDeg17 = Phaser.Math.RadToDeg;
var SkewImage = class extends Image_default2 {
  constructor(scene, x, y, key2, frame) {
    if (IsPlainObject61(x)) {
      var config = x;
      x = GetValue253(config, "x", 0);
      y = GetValue253(config, "y", 0);
      key2 = GetValue253(config, "key", null);
      frame = GetValue253(config, "frame", null);
    }
    super(scene, x, y, key2, frame);
    this.type = "rexSkewmage";
    this._skewX = 0;
    this._skewY = 0;
  }
  get skewX() {
    return this._skewX;
  }
  set skewX(value) {
    this._skewX = value;
    Skew_default(this, this._skewX, this._skewY);
  }
  get skewXDeg() {
    return RadToDeg17(this._skewX);
  }
  set skewXDeg(value) {
    this.skewX = DegToRad22(value);
  }
  get skewY() {
    return this._skewY;
  }
  set skewY(value) {
    this._skewY = value;
    Skew_default(this, this._skewX, this._skewY);
  }
  get skewYDeg() {
    return RadToDeg17(this._skewY);
  }
  set skewYDeg(value) {
    this.skewY = DegToRad22(value);
  }
  setSkewX(skewX) {
    this.skewX = skewX;
    return this;
  }
  setSkewY(skewY) {
    this.skewY = skewY;
    return this;
  }
  setSkew(skewX, skewY) {
    if (skewY === void 0) {
      skewY = skewX;
    }
    this.skewX = skewX;
    this.skewY = skewY;
    return this;
  }
  setSkewXDeg(skewX) {
    this.skewXDeg = skewX;
    return this;
  }
  setSkewYDeg(skewY) {
    this.skewYDeg = skewY;
    return this;
  }
  setSkewDeg(skewX, skewY) {
    if (skewY === void 0) {
      skewY = skewX;
    }
    this.skewXDeg = skewX;
    this.skewYDeg = skewY;
    return this;
  }
};
var SkewImage_default = SkewImage;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/mesh/quad/skewrendertexture/SkewRenderTexture.js
var IsPlainObject62 = Phaser.Utils.Objects.IsPlainObject;
var GetValue254 = Phaser.Utils.Objects.GetValue;
var SkewRenderTexture = class extends SkewImage_default {
  constructor(scene, x, y, width, height) {
    if (IsPlainObject62(x)) {
      var config = x;
      x = GetValue254(config, "x", 0);
      y = GetValue254(config, "y", 0);
      width = GetValue254(config, "width", 32);
      height = GetValue254(config, "height", 32);
    }
    var texture = CreateDynamicTexture_default(scene, width, height);
    super(scene, x, y, texture, null);
    this.type = "rexSkewRenderTexture";
    this.rt = this.texture;
  }
  destroy(fromScene) {
    if (!this.scene || this.ignoreDestroy) {
      return;
    }
    super.destroy(fromScene);
    this.rt.destroy();
    this.rt = null;
  }
};
var SkewRenderTexture_default = SkewRenderTexture;

// node_modules/phaser3-rex-plugins/plugins/behaviors/containerskew/ContainerSkew.js
var ContainerSkew = class extends MeshRenderTextureBase_default(SkewRenderTexture_default) {
  get skewState() {
    return this.isRunning;
  }
};
var ContainerSkew_default = ContainerSkew;

// node_modules/phaser3-rex-plugins/templates/ui/skew/Skew.js
var Skew_default2 = ContainerSkew_default;

// node_modules/phaser3-rex-plugins/templates/ui/skew/Factory.js
ObjectFactory_default.register("skew", function(gameObject2, config) {
  return new Skew_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Skew", Skew_default2);

// node_modules/phaser3-rex-plugins/templates/ui/anchor/Factory.js
ObjectFactory_default.register("anchor", function(gameObject2, config) {
  return new Anchor_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.Anchor", Anchor_default2);

// node_modules/phaser3-rex-plugins/templates/ui/texttyping/Factory.js
ObjectFactory_default.register("textTyping", function(gameObject2, config) {
  return new TextTyping_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.TextTyping", TextTyping_default2);

// node_modules/phaser3-rex-plugins/templates/ui/textpage/Factory.js
ObjectFactory_default.register("textPage", function(gameObject2, config) {
  return new TextPage_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.TextPage", TextPage_default2);

// node_modules/phaser3-rex-plugins/plugins/behaviors/textedit/methods/LastOpenedEditor.js
var LastOpenedEditor2 = void 0;
var SetLastOpenedEditor2 = function(editor) {
  if (editor === LastOpenedEditor2) {
    return;
  }
  if (LastOpenedEditor2 !== void 0) {
    LastOpenedEditor2.close();
  }
  LastOpenedEditor2 = editor;
};
var CloseLastOpenEditor2 = function(editor) {
  if (editor !== LastOpenedEditor2) {
    return;
  }
  LastOpenedEditor2 = void 0;
};

// node_modules/phaser3-rex-plugins/plugins/behaviors/textedit/methods/CreateInputText.js
var GetValue255 = Phaser.Utils.Objects.GetValue;
var Clone3 = Phaser.Utils.Objects.Clone;
var CreateInputText2 = function(text, config) {
  if (config === void 0) {
    config = {};
  }
  config = Clone3(config);
  var scene = text.scene;
  var style = text.style;
  var backgroundColor = GetValue255(config, "backgroundColor", style.backgroundColor);
  if (backgroundColor === null) {
    backgroundColor = "transparent";
  }
  config.text = GetValue255(config, "text", text.text);
  config.fontFamily = GetValue255(config, "fontFamily", style.fontFamily);
  config.fontSize = GetValue255(config, "fontSize", style.fontSize);
  config.color = GetValue255(config, "color", style.color);
  config.backgroundColor = backgroundColor;
  config.direction = GetValue255(config, "rtl", style.rtl) ? "rtl" : "ltr";
  config.align = GetValue255(config, "align", GetHAlign(style));
  if (config.direction === "rtl" && IsTextGameObject_default(text)) {
    config.align = "right";
  }
  var padding = text.padding;
  if (padding.left > 0) {
    config.paddingLeft = `${padding.left}px`;
  }
  if (padding.right > 0) {
    config.paddingRight = `${padding.right}px`;
  }
  if (style.backgroundCornerRadius) {
    config.borderRadius = GetValue255(config, "borderRadius", `${style.backgroundCornerRadius}px`);
  }
  var inputText = new InputText_default(
    scene,
    text.x,
    text.y,
    GetValue255(config, "width", text.width),
    GetValue255(config, "height", text.height),
    config
  );
  inputText.setScale(text.scaleX, text.scaleY).setOrigin(text.originX, text.originY).setScrollFactor(text.scrollFactorX, text.scrollFactorY);
  var textParentContainer = text.parentContainer;
  if (!textParentContainer) {
    scene.add.existing(inputText);
  } else {
    textParentContainer.add(inputText);
  }
  return inputText;
};
var GetHAlign = function(style) {
  if (style.hasOwnProperty("align")) {
    return style.align;
  } else if (style.hasOwnProperty("halign")) {
    return style.halign;
  } else {
    return "left";
  }
};
var CreateInputText_default3 = CreateInputText2;

// node_modules/phaser3-rex-plugins/plugins/utils/time/NextTick.js
var NextTick = function(scene, callback, scope) {
  return scene.time.delayedCall(0, callback, [], scope);
};
var NextTick_default = NextTick;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textedit/methods/Open.js
var GetValue256 = Phaser.Utils.Objects.GetValue;
var Merge7 = Phaser.Utils.Objects.Merge;
var Open3 = function(config, onCloseCallback) {
  if (config === void 0) {
    config = {};
  }
  config = Merge7(config, this.openConfig);
  SetLastOpenedEditor2(this);
  if (IsFunction_default(config)) {
    onCloseCallback = config;
    config = void 0;
  }
  var textType = GetValue256(config, "inputType", void 0);
  if (textType === void 0) {
    textType = GetValue256(config, "type", "text");
  }
  if (onCloseCallback === void 0) {
    onCloseCallback = GetValue256(config, "onClose", void 0);
  }
  var onCreateInputTextCallback = GetValue256(config, "onCreate", void 0);
  var onOpenCallback = GetValue256(config, "onOpen", void 0);
  var customOnTextChanged = GetValue256(config, "onTextChanged", void 0);
  this.inputText = CreateInputText_default3(this.parent, config);
  if (onCreateInputTextCallback) {
    onCreateInputTextCallback(this.parent, this.inputText);
  }
  this.inputText.on("textchange", function(inputText) {
    var text = inputText.text;
    if (customOnTextChanged) {
      customOnTextChanged(this.parent, text);
    } else {
      this.parent.text = text;
    }
  }, this).setFocus();
  this.parent.setVisible(false);
  this.onClose = onCloseCallback;
  if (GetValue256(config, "enterClose", textType !== "textarea")) {
    this.scene.input.keyboard.once("keydown-ENTER", this.close, this);
  }
  this.delayCall = NextTick_default(this.scene, function() {
    this.scene.input.once("pointerdown", this.close, this);
    if (onOpenCallback) {
      onOpenCallback(this.parent, this.inputText);
    }
    this.emit("open", this.parent, this.inputText);
  }, this);
  return this;
};
var Open_default3 = Open3;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textedit/methods/Close.js
var Close2 = function() {
  CloseLastOpenEditor2(this);
  this.parent.setVisible(true);
  if (this.inputText) {
    this.inputText.destroy();
    this.inputText = void 0;
  }
  if (this.delayCall) {
    this.delayCall.remove();
    this.delayCall = void 0;
  }
  this.scene.input.keyboard.off("keydown-ENTER", this.close, this);
  this.scene.input.off("pointerdown", this.close, this);
  if (this.onClose) {
    this.onClose(this.parent);
  }
  this.emit("close", this.parent);
  return this;
};
var Close_default2 = Close2;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textedit/methods/Methods.js
var Methods21 = {
  open: Open_default3,
  close: Close_default2
};
var Methods_default47 = Methods21;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textedit/TextEdit.js
var GetValue257 = Phaser.Utils.Objects.GetValue;
var TextEdit = class extends ComponentBase_default {
  constructor(gameObject2, config) {
    super(gameObject2);
    this.inputText = void 0;
    this.onClose = void 0;
    this.delayCall = void 0;
    this.setOpenConfig(config);
    var clickEnable = GetValue257(config, "clickEnable", true);
    if (clickEnable) {
      gameObject2.on("pointerdown", function() {
        this.open();
      }, this).setInteractive();
    }
  }
  shutdown(fromScene) {
    if (this.isShutdown) {
      return;
    }
    this.close();
    super.shutdown(fromScene);
  }
  setOpenConfig(config) {
    if (config === void 0) {
      config = {};
    }
    this.openConfig = config;
    return this;
  }
  get isOpened() {
    return this.inputText !== void 0;
  }
  get text() {
    return this.isOpened ? this.inputText.text : this.parent.text;
  }
};
Object.assign(
  TextEdit.prototype,
  Methods_default47
);
var TextEdit_default = TextEdit;

// node_modules/phaser3-rex-plugins/plugins/behaviors/textedit/Edit.js
var Edit = function(gameObject2, config, onCloseCallback) {
  if (!gameObject2._edit) {
    gameObject2._edit = new TextEdit_default(gameObject2, {
      clickEnable: false
    });
  }
  gameObject2._edit.open(config, onCloseCallback);
  return gameObject2._edit;
};
var Edit_default = Edit;

// node_modules/phaser3-rex-plugins/templates/ui/textedit/TextEdit.js
var TextEdit_default2 = TextEdit_default;

// node_modules/phaser3-rex-plugins/templates/ui/textedit/Factory.js
ObjectFactory_default.register("textEdit", function(gameObject2, config) {
  return new TextEdit_default2(gameObject2, config);
});
SetValue_default(window, "RexPlugins.UI.TextEdit", TextEdit_default2);

// node_modules/phaser3-rex-plugins/plugins/layermanager.js
var layermanager_default = LayerManager_default;

// node_modules/phaser3-rex-plugins/templates/ui/layermanager/LayerManager.js
var LayerManager_default2 = layermanager_default;

// node_modules/phaser3-rex-plugins/templates/ui/layermanager/Factory.js
ObjectFactory_default.register("layerManager", function(config) {
  return new LayerManager_default2(this.scene, config);
});
SetValue_default(window, "RexPlugins.UI.LayerManager", LayerManager_default2);

// node_modules/phaser3-rex-plugins/templates/ui/textedit/Edit.js
var Edit_default2 = Edit_default;

// node_modules/phaser3-rex-plugins/templates/ui/ui-plugin.js
var UIPlugin = class extends Phaser.Plugins.ScenePlugin {
  constructor(scene, pluginManager) {
    super(scene, pluginManager);
    this.add = new ObjectFactory_default(scene);
  }
  boot() {
    var eventEmitter = this.scene.events;
    eventEmitter.on("destroy", this.destroy, this);
  }
  destroy() {
    this.add.destroy();
    super.destroy();
  }
  isInTouching(gameObject2, pointer, preTest, postTest) {
    if (!gameObject2.visible) {
      return false;
    }
    return IsPointerInBounds_default(gameObject2, pointer, preTest, postTest);
  }
  get viewport() {
    return GetViewport_default(this.scene, this.scene.cameras.main, true);
  }
};
var methods46 = {
  getParentSizer: GetParent,
  getTopmostSizer: GetTopmostParent,
  removeFromParent: RemoveFromParent_default,
  hide: Hide,
  show: Show,
  isShown: IsShown,
  confirmAction: ConfirmAction_default,
  edit: Edit_default2,
  wrapExpandText: WrapExpandText_default,
  fontSizeExpandText: FontSizeExpandText_default,
  fontSizeResize: FontSizeFit_default,
  // Backward compatibility
  setFontSizeToFitWidth: FontSizeFit_default,
  waitEvent: WaitEvent2,
  waitComplete: WaitComplete,
  delayPromise: Delay_default,
  setChildrenInteractive: SetChildrenInteractive_default2,
  fadeIn: fade_in_default,
  fadeOutDestroy: fade_out_destroy_default,
  easeMoveTo: EaseMoveTo_default,
  easeMoveFrom: EaseMoveFrom_default,
  modal: Modal2,
  modalPromise: ModalPromise,
  modalClose: ModalClose,
  requestDrag: RequestDrag_default,
  openFileChooser: Open_default2
};
Object.assign(
  UIPlugin.prototype,
  methods46
);
var ui_plugin_default = UIPlugin;
export {
  ui_plugin_default as default
};
/*! Bundled license information:

phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/MeasureText.js:
  (**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   *)

phaser3-rex-plugins/plugins/utils/math/Linear.js:
  (**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   *)

phaser3-rex-plugins/plugins/utils/object/Merge.js:
  (**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://opensource.org/licenses/MIT|MIT License}
   *)
*/
//# sourceMappingURL=phaser3-rex-plugins_templates_ui_ui-plugin__js.js.map
